From f58c470cb9e6c8eb735e83f13c832dab7ef09a53 Mon Sep 17 00:00:00 2001
From: John Scipione <jscipione@gmail.com>
Date: Sun, 17 Jan 2021 14:57:07 -0500
Subject: BTextView: Fix scrolling in text view

Prevent scrolling out of bounds horizontally. The algorithm to keep
cursor in text view bounds was taken from _PerformAutoScrolling()
(mouse scrolling method) and was fixed to account for the left
margin which is not always 0.

Fix left and top margin scrolling not always 0 in
_PerformAutoScrolling() as well, this fixes a similar bug that
was present when scrolling the text with the mouse instead.

Remove extraSpace variable, no longer needed.

This makes text views behave properly when overflow occurs i.e. when
you type text off the end of the text view. Instead of scrolling an
entire page over, it nudges the text over as you'd expect.

Replace xDiff and yDiff float variables with a single scrollTo BPoint
in ScrollToOffset(). This was also copied from _PerformAutoScrolling().

Remove floorf() calls, we know that we are dealing with integers.

Take top and bottom margins into account when scrolling with keyboard
in ScrollToOffset(). This allows you to scroll past the margins all the
way to the top and bottom using the up and down arrow keys (1 more px.)

Fixes #16642, #16476

Change-Id: I2d32d6039944d2dc3218ce4de71f2966cc98c866
---
 src/kits/interface/TextView.cpp | 53 +++++++++++++++++++--------------
 1 file changed, 31 insertions(+), 22 deletions(-)

diff --git a/src/kits/interface/TextView.cpp b/src/kits/interface/TextView.cpp
index 695688c411..b51c4b7796 100644
--- a/src/kits/interface/TextView.cpp
+++ b/src/kits/interface/TextView.cpp
@@ -2164,30 +2164,38 @@ BTextView::ScrollToOffset(int32 offset)
 {
 	BRect bounds = Bounds();
 	float lineHeight = 0.0;
-	float xDiff = 0.0;
-	float yDiff = 0.0;
 	BPoint point = PointAt(offset, &lineHeight);
+	BPoint scrollBy(B_ORIGIN);
 
 	// horizontal
-	float extraSpace = ceilf(bounds.IntegerWidth() / 2);
 	if (point.x < bounds.left)
-		xDiff = point.x - bounds.right + extraSpace;
+		scrollBy.x = point.x - bounds.right;
 	else if (point.x > bounds.right)
-		xDiff = point.x - bounds.left - extraSpace;
+		scrollBy.x = point.x - bounds.left;
 
-	// vertical
-	if (point.y < bounds.top)
-		yDiff = point.y - bounds.top;
-	else if (point.y + lineHeight > bounds.bottom
-		&& point.y - lineHeight > bounds.top) {
-		yDiff = point.y + lineHeight - bounds.bottom;
+	// prevent from scrolling out of view
+	if (scrollBy.x != 0.0) {
+		float rightMax = fTextRect.right + fLayoutData->rightInset;
+		if (bounds.right + scrollBy.x > rightMax)
+			scrollBy.x = rightMax - bounds.right;
+		float leftMin = fTextRect.left - fLayoutData->leftInset;
+		if (bounds.left + scrollBy.x < leftMin)
+			scrollBy.x = leftMin - bounds.left;
 	}
 
-	// prevent negative scroll offset in y
-	if (bounds.top + yDiff < 0.0)
-		yDiff = -bounds.top;
+	// vertical
+	if (CountLines() > 1) {
+		// scroll in Y only if multiple lines!
+		if (point.y < bounds.top - fLayoutData->topInset)
+			scrollBy.y = point.y - bounds.top - fLayoutData->topInset;
+		else if (point.y + lineHeight > bounds.bottom
+				+ fLayoutData->bottomInset) {
+			scrollBy.y = point.y + lineHeight - bounds.bottom
+				+ fLayoutData->bottomInset;
+		}
+	}
 
-	ScrollBy(xDiff, yDiff);
+	ScrollBy(scrollBy.x, scrollBy.y);
 }
 
 
@@ -4939,11 +4947,12 @@ BTextView::_PerformAutoScrolling()
 
 	// prevent from scrolling out of view
 	if (scrollBy.x != 0.0) {
-		float rightMax = floorf(fTextRect.right + fLayoutData->rightInset);
+		float rightMax = fTextRect.right + fLayoutData->rightInset;
 		if (bounds.right + scrollBy.x > rightMax)
 			scrollBy.x = rightMax - bounds.right;
-		if (bounds.left + scrollBy.x < 0)
-			scrollBy.x = -bounds.left;
+		float leftMin = fTextRect.left - fLayoutData->leftInset;
+		if (bounds.left + scrollBy.x < leftMin)
+			scrollBy.x = leftMin - bounds.left;
 	}
 
 	if (CountLines() > 1) {
@@ -4955,12 +4964,12 @@ BTextView::_PerformAutoScrolling()
 
 		// prevent from scrolling out of view
 		if (scrollBy.y != 0.0) {
-			float bottomMax = floorf(fTextRect.bottom
-				+ fLayoutData->bottomInset);
+			float bottomMax = fTextRect.bottom + fLayoutData->bottomInset;
 			if (bounds.bottom + scrollBy.y > bottomMax)
 				scrollBy.y = bottomMax - bounds.bottom;
-			if (bounds.top + scrollBy.y < 0)
-				scrollBy.y = -bounds.top;
+			float topMin = fTextRect.top - fLayoutData->topInset;
+			if (bounds.top + scrollBy.y < topMin)
+				scrollBy.y = topMin - bounds.top;
 		}
 	}
 
-- 
2.30.2

