From 0b3e9e5ddb161c3a236f2106e38fc82acb9b3d9e Mon Sep 17 00:00:00 2001
From: John Scipione <jscipione@gmail.com>
Date: Sun, 17 Jan 2021 14:57:07 -0500
Subject: BTextView: Fix Tracker edit name

Don't resize text view in FrameResized() if resizable, this is done
in _AutoResize() instead. Scroll to 0 after resizing in _AutoResize().

Set TextRect width to max line width when word-wrap is off.
Make _ValidateTextRect() method and call it to ensure fTextRect
does not reach 0 width. This change means that the text rect width is
always the width of the text inside matching BeOS R5 behavior. It is
necessary to allow the Edit Name text view to shrink as text is
deleted.

TODO highlighting only goes to edge of text, it should go to the edge
of text view when wrap is off (e.g. in StyledEdit).

Prevent scrolling out of bounds horizontally with the keyboard.
The algorithm to keep cursor in text view bounds was taken from
_PerformAutoScrolling() (mouse scrolling method) and was updated
to account for the left margin which is not always 0.

Make left and top margin not always 0 when scrolling in
_PerformAutoScrolling() as well, this fixes the same bug when
scrolling the text with the mouse.

Remove extraSpace variable, no longer needed. This means that we
always scroll according to the text width without any extra space.

The above makes text views behave properly when overflow occurs i.e.
when you type text off the end of the text view. Instead of scrolling
an entire page of text over, it nudges the text over slightly as
you'd expect it to.

Take top and bottom margins into account when scrolling with keyboard
in ScrollToOffset(). This allows you to scroll past the margins all the
way to the top and bottom using the up and down arrow keys (1 more px.)

Fix drawing issues when typing off the edge:

When word-wrap is turned on for a multi-line text view and you insert,
backspace or delete the position of text rect changes as you type off
the end of the BTextView area. Call FrameResized() in ScrollToOffset()
to reposition the text rect and redraw. This can also happen as a result
of the word-wrap setting changing too so call FrameResized() in that
case too.

Use Window()->DisableUpdates() and Window()->EnableUpdates() and
remove a call to Window()->UpdateIfNeeded() to prevent the text
from flashing when it draw then the text rect position is moved
and it draws again. This coalesces multiple consecutive draw calls.

Replace xDiff and yDiff float variables with a single scrollTo BPoint
in ScrollToOffset(). This was also copied from _PerformAutoScrolling().
(no functional change intended here)

Remove floorf() calls, we know that we are dealing with integers.
(no functional change intended here)

Fixes #16642, #16476

Change-Id: I2d32d6039944d2dc3218ce4de71f2966cc98c866
---
 headers/os/interface/TextView.h |   1 +
 src/kits/interface/TextView.cpp | 125 +++++++++++++++++++++-----------
 src/kits/tracker/TextWidget.cpp |  44 +++++------
 3 files changed, 102 insertions(+), 68 deletions(-)

diff --git a/headers/os/interface/TextView.h b/headers/os/interface/TextView.h
index 3757bb1862..951948a092 100644
--- a/headers/os/interface/TextView.h
+++ b/headers/os/interface/TextView.h
@@ -302,6 +302,7 @@ private:
 									int32 scrollTo = INT32_MIN);
 			void				_RecalculateLineBreaks(int32* startLine,
 									int32* endLine);
+			void				_ValidateTextRect();
 			int32				_FindLineBreak(int32 fromOffset,
 									float* _ascent, float* _descent,
 									float* inOutWidth);
diff --git a/src/kits/interface/TextView.cpp b/src/kits/interface/TextView.cpp
index b51c4b7796..fde4b1174a 100644
--- a/src/kits/interface/TextView.cpp
+++ b/src/kits/interface/TextView.cpp
@@ -509,12 +509,7 @@ BTextView::AttachedToWindow()
 	fDragOffset = -1;
 	fActive = false;
 
-	// text rect right must be greater than left
-	if (fTextRect.right <= fTextRect.left)
-		fTextRect.right = fTextRect.left + 1;
-	// text rect bottom must be greater than top
-	if (fTextRect.bottom <= fTextRect.top)
-		fTextRect.bottom = fTextRect.top + 1;
+	_ValidateTextRect();
 
 	_AutoResize(true);
 
@@ -808,8 +803,13 @@ BTextView::FrameResized(float newWidth, float newHeight)
 {
 	BView::FrameResized(newWidth, newHeight);
 
+	// frame resized in _AutoResize() instead
+	if (fResizable)
+		return;
+
 	if (fWrap) {
 		// recalculate line breaks
+		// will update scroll bars if text rect changes
 		_ResetTextRect();
 	} else {
 		// don't recalculate line breaks,
@@ -852,9 +852,9 @@ BTextView::FrameResized(float newWidth, float newHeight)
 			BRegion dirty(oldTextRect | fTextRect);
 			Invalidate(&dirty);
 		}
-	}
 
-	_UpdateScrollbars();
+		_UpdateScrollbars();
+	}
 }
 
 
@@ -2196,6 +2196,10 @@ BTextView::ScrollToOffset(int32 offset)
 	}
 
 	ScrollBy(scrollBy.x, scrollBy.y);
+
+	// Update text rect position and scroll bars
+	if (CountLines() > 1 && !fWrap)
+		FrameResized(Bounds().Width(), Bounds().Height());
 }
 
 
@@ -2417,6 +2421,8 @@ BTextView::SetWordWrap(bool wrap)
 			_HideCaret();
 	}
 
+	BRect savedBounds = Bounds();
+
 	fWrap = wrap;
 	if (wrap)
 		_ResetTextRect(); // calls _Refresh
@@ -2426,6 +2432,10 @@ BTextView::SetWordWrap(bool wrap)
 	if (fEditable)
 		ScrollToOffset(fCaretOffset);
 
+	// redraw text rect and update scroll bars if bounds have changed
+	if (Bounds() != savedBounds)
+		FrameResized(Bounds().Width(), Bounds().Height());
+
 	if (updateOnScreen) {
 		// show the caret, hilite the selection
 		if (fSelStart != fSelEnd) {
@@ -2565,7 +2575,7 @@ BTextView::MakeResizable(bool resize, BView* resizeView)
 		}
 		// We need to reset the right inset, as otherwise the auto-resize would
 		// get confused about just how wide the textview needs to be.
-		// This seems to be an artefact of how Tracker creates the textview
+		// This seems to be an artifact of how Tracker creates the textview
 		// during a rename action.
 		fLayoutData->rightInset = fLayoutData->leftInset;
 	} else {
@@ -3193,10 +3203,8 @@ BTextView::_InitObject(BRect textRect, const BFont* initialFont,
 	// if needed.
 	fTextRect = textRect;
 		// NOTE: The only places where text rect is changed:
-		// * width is possibly adjusted in _AutoResize(),
-		// * height is adjusted in _RecalculateLineBreaks().
-		// When used within the layout management framework, the
-		// text rect is changed to maintain constant insets.
+		// * width and height are adjusted in _RecalculateLineBreaks(),
+		// text rect maintains constant insets, use SetInsets() to change.
 	fMinTextRectWidth = fTextRect.Width();
 		// see SetTextRect()
 	fSelStart = fSelEnd = 0;
@@ -3266,6 +3274,10 @@ BTextView::_HandleBackspace(int32 modifiers)
 		undoBuffer->BackwardErase();
 	}
 
+	// we may draw twice, so turn updates off for now
+	if (Window() != NULL)
+		Window()->DisableUpdates();
+
 	if (fSelStart == fSelEnd) {
 		if (fSelStart == 0)
 			return;
@@ -3278,6 +3290,10 @@ BTextView::_HandleBackspace(int32 modifiers)
 	fCaretOffset = fSelEnd = fSelStart;
 
 	_Refresh(fSelStart, fSelEnd, fCaretOffset);
+
+	// turn drawing back on
+	if (Window() != NULL)
+		Window()->EnableUpdates();
 }
 
 
@@ -3487,6 +3503,10 @@ BTextView::_HandleDelete(int32 modifiers)
 		undoBuffer->ForwardErase();
 	}
 
+	// we may draw twice, so turn updates off for now
+	if (Window() != NULL)
+		Window()->DisableUpdates();
+
 	if (fSelStart == fSelEnd) {
 		if (fSelEnd == fText->Length())
 			return;
@@ -3499,6 +3519,10 @@ BTextView::_HandleDelete(int32 modifiers)
 	fCaretOffset = fSelEnd = fSelStart;
 
 	_Refresh(fSelStart, fSelEnd, fCaretOffset);
+
+	// turn updates back on
+	if (Window() != NULL)
+		Window()->EnableUpdates();
 }
 
 
@@ -3702,6 +3726,10 @@ BTextView::_HandleAlphaKey(const char* bytes, int32 numBytes)
 		DeleteText(fSelStart, fSelEnd);
 	}
 
+	// we may draw twice, so turn updates off for now
+	if (Window() != NULL)
+		Window()->DisableUpdates();
+
 	if (fAutoindent && numBytes == 1 && *bytes == B_ENTER) {
 		int32 start, offset;
 		start = offset = OffsetAt(_LineAt(fSelStart));
@@ -3718,8 +3746,11 @@ BTextView::_HandleAlphaKey(const char* bytes, int32 numBytes)
 		_DoInsertText(bytes, numBytes, fSelStart, NULL);
 
 	fCaretOffset = fSelEnd;
-
 	ScrollToOffset(fCaretOffset);
+
+	// turn update back on to draw
+	if (Window() != NULL)
+		Window()->EnableUpdates();
 }
 
 
@@ -3891,25 +3922,23 @@ BTextView::_RecalculateLineBreaks(int32* startLine, int32* endLine)
 		switch (fAlignment) {
 			default:
 			case B_ALIGN_LEFT:
-				// grow right
-				fTextRect.right = std::max(fTextRect.right,
-					fTextRect.left + fMinTextRectWidth);
+				// move right edge
+				fTextRect.right = fTextRect.left + fMinTextRectWidth;
 				break;
 
 			case B_ALIGN_RIGHT:
-				// grow left
-				fTextRect.left = std::min(fTextRect.left,
-					fTextRect.right - fMinTextRectWidth);
+				// move left edge
+				fTextRect.left = fTextRect.right - fMinTextRectWidth;
 				break;
 
 			case B_ALIGN_CENTER:
-				// grow out
-				if (fMinTextRectWidth > fTextRect.Width()) {
-					fTextRect.InsetBy(ceilf((fTextRect.Width()
-						- fMinTextRectWidth) / 2.0f), 0);
-				}
+				// move both edges
+				fTextRect.InsetBy(roundf((fTextRect.Width()
+					- fMinTextRectWidth) / 2), 0);
 				break;
 		}
+
+		_ValidateTextRect();
 	}
 
 	*endLine = lineIndex - 1;
@@ -3917,6 +3946,18 @@ BTextView::_RecalculateLineBreaks(int32* startLine, int32* endLine)
 }
 
 
+void
+BTextView::_ValidateTextRect()
+{
+	// text rect right must be greater than left
+	if (fTextRect.right <= fTextRect.left)
+		fTextRect.right = fTextRect.left + 1;
+	// text rect bottom must be greater than top
+	if (fTextRect.bottom <= fTextRect.top)
+		fTextRect.bottom = fTextRect.top + 1;
+}
+
+
 int32
 BTextView::_FindLineBreak(int32 fromOffset, float* _ascent, float* _descent,
 	float* inOutWidth)
@@ -4598,7 +4639,6 @@ BTextView::_RequestDrawLines(int32 startLine, int32 endLine)
 		Bounds().right,
 		to != NULL ? to->origin + fTextRect.top : fTextRect.bottom);
 	Invalidate(invalidRect);
-	Window()->UpdateIfNeeded();
 }
 
 
@@ -5055,28 +5095,29 @@ BTextView::_ScrollTo(float x, float y)
 void
 BTextView::_AutoResize(bool redraw)
 {
-	if (!fResizable)
+	if (!fResizable || fContainerView == NULL)
 		return;
 
 	BRect bounds = Bounds();
 
-	if (fContainerView != NULL) {
-		// NOTE: This container view thing is only used by Tracker.
-		// move container view if not left aligned
-		float oldWidth = bounds.Width();
-		float newWidth = ceilf(fLayoutData->leftInset
-			+ fTextRect.Width() + fLayoutData->rightInset);
-		if (fAlignment == B_ALIGN_CENTER) {
-			if (fmod(ceilf(newWidth - oldWidth), 2.0) != 0.0)
-				newWidth += 1;
+	// NOTE: This container view thing is only used by Tracker.
+	// move container view if not left aligned
+	float oldWidth = bounds.Width();
+	float newWidth = ceilf(fLayoutData->leftInset
+		+ fTextRect.Width() + fLayoutData->rightInset);
+	float right = oldWidth - newWidth;
 
-			fContainerView->MoveBy(ceilf(oldWidth - newWidth) / 2, 0);
-		} else if (fAlignment == B_ALIGN_RIGHT)
-			fContainerView->MoveBy(ceilf(oldWidth - newWidth), 0);
+	if (fAlignment == B_ALIGN_CENTER)
+		fContainerView->MoveBy(roundf(right / 2), 0);
+	else if (fAlignment == B_ALIGN_RIGHT)
+		fContainerView->MoveBy(right, 0);
 
-		// resize container view
-		fContainerView->ResizeBy(ceilf(newWidth - oldWidth), 0);
-	}
+	// resize container view
+	float grow = newWidth - oldWidth;
+	fContainerView->ResizeBy(grow, 0);
+
+	// scroll rect to start, there is room for full text
+	ScrollToOffset(0);
 
 	if (redraw)
 		_RequestDrawLines(0, 0);
diff --git a/src/kits/tracker/TextWidget.cpp b/src/kits/tracker/TextWidget.cpp
index 5211e771fb..b6dddce8cc 100644
--- a/src/kits/tracker/TextWidget.cpp
+++ b/src/kits/tracker/TextWidget.cpp
@@ -334,18 +334,12 @@ TextViewFilter(BMessage* message, BHandler**, BMessageFilter* filter)
 		BTextView* textView = dynamic_cast<BTextView*>(
 			scrollView->FindView("WidgetTextView"));
 		if (textView != NULL) {
-			BRect textRect = textView->TextRect();
-			BRect rect = scrollView->Frame();
-
-			if (rect.right + 5 > poseView->Bounds().right
-				|| rect.left - 5 < 0)
-				textView->MakeResizable(true, NULL);
-
-			if (textRect.Width() + 10 < rect.Width()) {
+			// limit max width to 30em
+			float maxWidth = textView->StringWidth("M") * 30;
+			if (textView->TextRect().Width() > maxWidth)
+				textView->MakeResizable(false, NULL);
+			else
 				textView->MakeResizable(true, scrollView);
-				// make sure no empty white space stays on the right
-				textView->ScrollToOffset(0);
-			}
 		}
 	}
 
@@ -398,23 +392,11 @@ BTextWidget::StartEdit(BRect bounds, BPoseView* view, BPose* pose)
 
 	textView->SetTextRect(textRect);
 
-	BPoint origin = view->LeftTop();
-	textRect = view->Bounds();
-
-	bool hitBorder = false;
-	if (rect.left <= origin.x)
-		rect.left = origin.x + 1, hitBorder = true;
-	if (rect.right >= textRect.right)
-		rect.right = textRect.right - 1, hitBorder = true;
-
+	// resize textView
 	textView->MoveTo(rect.LeftTop());
 	textView->ResizeTo(rect.Width(), rect.Height());
 
-	BScrollView* scrollView = new BScrollView("BorderView", textView, 0, 0,
-		false, false, B_PLAIN_BORDER);
-	view->AddChild(scrollView);
-
-	// configure text view
+	// set alignment before adding textView so it doesn't redraw
 	switch (view->ViewMode()) {
 		case kIconMode:
 			textView->SetAlignment(B_ALIGN_CENTER);
@@ -428,7 +410,17 @@ BTextWidget::StartEdit(BRect bounds, BPoseView* view, BPose* pose)
 			textView->SetAlignment(fAlignment);
 			break;
 	}
-	textView->MakeResizable(true, hitBorder ? NULL : scrollView);
+
+	BScrollView* scrollView = new BScrollView("BorderView", textView, 0, 0,
+		false, false, B_PLAIN_BORDER);
+	view->AddChild(scrollView);
+
+	// limit max width to 30em
+	float maxWidth = textView->StringWidth("M") * 30;
+	if (textView->TextRect().Width() > maxWidth)
+		textView->MakeResizable(false, NULL);
+	else
+		textView->MakeResizable(true, scrollView);
 
 	view->SetActivePose(pose);
 		// tell view about pose
-- 
2.30.2

