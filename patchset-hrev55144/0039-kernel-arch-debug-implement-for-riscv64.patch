From 83245d47dd84e3dee213f4bd2d3f3308f5820728 Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Sun, 6 Jun 2021 22:26:13 +0900
Subject: kernel/arch/debug: implement for riscv64

Change-Id: Iab5cc9ef4059f968bca03683592d1ec1818a26a2
---
 .../private/kernel/arch/riscv64/arch_debug.h  |   9 +
 src/system/kernel/arch/riscv64/arch_debug.cpp | 230 +++++++++++++++++-
 .../arch/riscv64/arch_debug_console.cpp       |   4 +-
 3 files changed, 239 insertions(+), 4 deletions(-)

diff --git a/headers/private/kernel/arch/riscv64/arch_debug.h b/headers/private/kernel/arch/riscv64/arch_debug.h
index 57bd5b8e45..69830bfd65 100644
--- a/headers/private/kernel/arch/riscv64/arch_debug.h
+++ b/headers/private/kernel/arch/riscv64/arch_debug.h
@@ -9,8 +9,17 @@
 #include <SupportDefs.h>
 
 
+struct kernel_args;
+
 struct arch_debug_registers {
 };
 
 
+void WritePC(addr_t pc);
+void DoStackTrace(addr_t fp, addr_t pc);
+void WriteTrapInfo();
+
+status_t arch_debug_init_early(kernel_args *args);
+
+
 #endif	// _KERNEL_ARCH_RISCV64_DEBUG_H
diff --git a/src/system/kernel/arch/riscv64/arch_debug.cpp b/src/system/kernel/arch/riscv64/arch_debug.cpp
index 07a48ef0da..880fd93851 100644
--- a/src/system/kernel/arch/riscv64/arch_debug.cpp
+++ b/src/system/kernel/arch/riscv64/arch_debug.cpp
@@ -8,11 +8,224 @@
 
 
 #include <arch/debug.h>
+#include <vm/VMAddressSpace.h>
+#include <vm/VMArea.h>
+#include <elf.h>
+#include <kimage.h>
+#include <arch/generic/user_memory.h>
+#include <AutoDeleterDrivers.h>
+
+
+kernel_args *sKernelArgs;
+bool sInitCalled = false;
+
+
+static void
+WriteImage(preloaded_image* _image)
+{
+	preloaded_elf64_image* image = (preloaded_elf64_image*)_image;
+	dprintf("image \"%s\"\n", (char*)image->name);
+	dprintf(
+		"  text: 0x%" B_PRIxADDR " - 0x%" B_PRIxADDR ", %" B_PRIdSSIZE "\n",
+		image->text_region.start,
+		image->text_region.start + image->text_region.size,
+		image->text_region.delta
+	);
+	dprintf(
+		"  data: 0x%" B_PRIxADDR " - 0x%" B_PRIxADDR ", %" B_PRIdSSIZE "\n",
+		image->data_region.start,
+		image->data_region.start + image->data_region.size,
+		image->data_region.delta
+	);
+}
+
+
+static void
+WriteImages()
+{
+	WriteImage(sKernelArgs->kernel_image);
+	for (preloaded_image* image = sKernelArgs->preloaded_images; image != NULL;
+		image = image->next)
+		WriteImage(image);
+}
+
+
+static bool
+AddressInImage(preloaded_image* _image, addr_t adr)
+{
+	preloaded_elf64_image* image = (preloaded_elf64_image*)_image;
+	if (
+		adr >= image->text_region.start &&
+		adr < image->text_region.start + image->text_region.size
+	) return true;
+	if (
+		adr >= image->data_region.start &&
+		adr < image->data_region.start + image->data_region.size
+	) return true;
+	return false;
+}
+
+
+static bool
+SymbolAt(preloaded_image* _image, addr_t adr, const char **name, ssize_t *ofs)
+{
+	preloaded_elf64_image* image = (preloaded_elf64_image*)_image;
+	adr -= image->text_region.delta;
+	for (uint32 i = 0; i < image->num_debug_symbols; i++) {
+		Elf64_Sym& sym = image->debug_symbols[i];
+		if (sym.st_shndx != STN_UNDEF && adr >= sym.st_value
+			&& adr < sym.st_value + sym.st_size) {
+			if (name != NULL)
+				*name = &image->debug_string_table[sym.st_name];
+			if (ofs != NULL)
+				*ofs = adr - sym.st_value;
+			return true;
+		}
+	}
+	return false;
+}
+
+
+static preloaded_image*
+FindImage(addr_t adr)
+{
+	if (AddressInImage(sKernelArgs->kernel_image, adr))
+		return sKernelArgs->kernel_image;
+
+	for (preloaded_image* image = sKernelArgs->preloaded_images; image != NULL;
+		image = image->next)
+		if (AddressInImage(image, adr))
+			return image;
+
+	return NULL;
+}
+
+
+static VMArea*
+FindArea(addr_t adr)
+{
+	VMAddressSpacePutter addrSpace;
+	addrSpace.SetTo(VMAddressSpace::GetCurrent());
+	return addrSpace->LookupArea(adr);
+}
+
+
+static status_t
+lookup_symbol(Thread* thread, addr_t address, addr_t* _baseAddress,
+	const char** _symbolName, const char** _imageName, bool* _exactMatch)
+{
+	status_t status = B_ENTRY_NOT_FOUND;
+
+	if (IS_KERNEL_ADDRESS(address)) {
+		// a kernel symbol
+		status = elf_debug_lookup_symbol_address(address, _baseAddress,
+			_symbolName, _imageName, _exactMatch);
+	} else if (thread != NULL && thread->team != NULL) {
+		// try a lookup using the userland runtime loader structures
+		status = elf_debug_lookup_user_symbol_address(thread->team, address,
+			_baseAddress, _symbolName, _imageName, _exactMatch);
+
+		if (status != B_OK) {
+			// try to locate the image in the images loaded into user space
+			status = image_debug_lookup_user_symbol_address(thread->team,
+				address, _baseAddress, _symbolName, _imageName, _exactMatch);
+		}
+	}
+
+	return status;
+}
+
+
+void
+WritePCBoot(addr_t pc)
+{
+	preloaded_image* image = FindImage(pc);
+	if (image != NULL) {
+		const char *name;
+		ssize_t ofs;
+		if (SymbolAt(image, pc, &name, &ofs)) {
+			dprintf("<%s> %s + %" B_PRIdSSIZE, (char*)image->name, name, ofs);
+			return;
+		}
+		dprintf("<%s> 0x%" B_PRIxADDR, (char*)image->name,
+			pc - ((preloaded_elf64_image*)image)->text_region.delta);
+		return;
+	}
+/*
+	VMArea* area = FindArea(pc);
+	if (area != NULL) {
+		dprintf("<%s> 0x%" B_PRIxADDR, area->name, pc - area->Base());
+		return;
+	}
+*/
+	dprintf("0x%" B_PRIxADDR, pc);
+}
+
+
+void
+WritePC(addr_t pc)
+{
+	// dprintf("0x%" B_PRIxADDR " ", pc);
+	if (!sInitCalled) {
+		WritePCBoot(pc); return;
+	}
+
+	addr_t baseAddress;
+	const char* symbolName;
+	const char* imageName;
+	bool exactMatch;
+	if (lookup_symbol(thread_get_current_thread(), pc, &baseAddress,
+		&symbolName, &imageName, &exactMatch) >= B_OK) {
+		if (symbolName != NULL) {
+			dprintf("<%s> %s + %" B_PRIdSSIZE, imageName, symbolName,
+				pc - baseAddress);
+			return;
+		}
+		dprintf("<%s> 0x%" B_PRIxADDR, imageName, pc - baseAddress);
+		return;
+	}
+
+	VMArea* area = FindArea(pc);
+	if (area != NULL) {
+		dprintf("<%s> 0x%" B_PRIxADDR, area->name, pc - area->Base());
+		return;
+	}
+
+	dprintf("0x%" B_PRIxADDR, pc);
+}
+
+
+void
+DoStackTrace(addr_t fp, addr_t pc)
+{
+	dprintf("Stack:\n");
+	dprintf("FP: 0x%" B_PRIxADDR, fp);
+	if (pc != 0) {
+		dprintf(", PC: "); WritePC(pc);
+	}
+	dprintf("\n");
+	while (fp != 0) {
+		if (user_memcpy(&pc, (uint64*)fp - 1, sizeof(pc)) < B_OK) break;
+		if (user_memcpy(&fp, (uint64*)fp - 2, sizeof(pc)) < B_OK) break;
+		dprintf("FP: 0x%" B_PRIxADDR, fp);
+		dprintf(", PC: "); WritePC(pc - 1);
+		dprintf("\n");
+	}
+}
+
+
+static int
+stack_trace(int argc, char **argv)
+{
+	DoStackTrace(Fp(), 0);
+	return 0;
+}
 
 
 void
 arch_debug_stack_trace(void)
 {
+	DoStackTrace(Fp(), 0);
 }
 
 
@@ -41,6 +254,7 @@ void
 arch_debug_call_with_fault_handler(cpu_ent* cpu, jmp_buf jumpBuffer,
 	void (*function)(void*), void* parameter)
 {
+	function(parameter);
 }
 
 
@@ -99,14 +313,24 @@ arch_debug_unset_current_thread(void)
 }
 
 
+status_t
+arch_debug_init_early(kernel_args *args)
+{
+	dprintf("arch_debug_init_early()\n");
+	sKernelArgs = args;
+	WriteImages();
+	return B_OK;
+}
+
+
 status_t
 arch_debug_init(kernel_args *args)
 {
-#if 0
+	sInitCalled = true;
+
 	add_debugger_command("where", &stack_trace, "Same as \"sc\"");
 	add_debugger_command("bt", &stack_trace, "Same as \"sc\" (as in gdb)");
 	add_debugger_command("sc", &stack_trace, "Stack crawl for current thread");
-#endif
 
-	return B_NO_ERROR;
+	return B_OK;
 }
diff --git a/src/system/kernel/arch/riscv64/arch_debug_console.cpp b/src/system/kernel/arch/riscv64/arch_debug_console.cpp
index 32eaa295fe..6f82d72773 100644
--- a/src/system/kernel/arch/riscv64/arch_debug_console.cpp
+++ b/src/system/kernel/arch/riscv64/arch_debug_console.cpp
@@ -11,6 +11,7 @@
 #include <boot/kernel_args.h>
 #include <kernel.h>
 #include <vm/vm.h>
+#include <Htif.h>
 
 #include <string.h>
 
@@ -59,6 +60,7 @@ arch_debug_serial_getchar(void)
 void
 arch_debug_serial_putchar(const char c)
 {
+	HtifOutChar(c);
 }
 
 
@@ -75,7 +77,7 @@ arch_debug_serial_puts(const char *s)
 void
 arch_debug_serial_early_boot_message(const char *string)
 {
-	// this function will only be called in fatal situations
+	arch_debug_serial_puts(string);
 }
 
 
-- 
2.30.2

