From 42bc1ffdc7741a1a1ff41cd0dcb9a960f0a6f4a0 Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Mon, 26 Jul 2021 02:27:06 +0900
Subject: boot_loader.efi: update for riscv64

* Added MMU page table generation.

* Added FDT device detection and passin to kernel.

Change-Id: I89257c93c84404fd988f621b29f927ed0df3c3b1
---
 src/system/boot/loader/Jamfile                |   1 +
 src/system/boot/loader/elf.cpp                |   8 +-
 src/system/boot/loader/kernel_args.cpp        |   4 +-
 src/system/boot/loader/main.cpp               |   8 +-
 src/system/boot/loader/vfs.cpp                |   4 +-
 src/system/boot/platform/efi/Jamfile          |   5 +-
 .../boot/platform/efi/arch/riscv64/Jamfile    |   2 +
 .../platform/efi/arch/riscv64/arch_mmu.cpp    | 447 +++++++++++++++++-
 .../platform/efi/arch/riscv64/arch_smp.cpp    |  95 +++-
 .../platform/efi/arch/riscv64/arch_start.cpp  | 109 ++++-
 .../platform/efi/arch/riscv64/arch_traps.cpp  | 176 +++++++
 .../platform/efi/arch/riscv64/arch_traps.h    |  55 +++
 .../efi/arch/riscv64/arch_traps_asm.S         |  26 +
 .../boot/platform/efi/arch/riscv64/entry.S    |  24 +-
 src/system/boot/platform/efi/console.cpp      |   1 +
 src/system/boot/platform/efi/debug.cpp        |   5 +-
 src/system/boot/platform/efi/dtb.cpp          | 433 ++++++++++++++++-
 src/system/boot/platform/efi/mmu.cpp          |  25 +-
 src/system/boot/platform/efi/mmu.h            |   2 +
 src/system/boot/platform/efi/serial.cpp       |  23 +-
 src/system/boot/platform/efi/serial.h         |   4 +
 src/system/boot/platform/efi/start.cpp        |  51 +-
 src/system/boot/platform/efi/video.cpp        |   1 +
 23 files changed, 1444 insertions(+), 65 deletions(-)
 create mode 100644 src/system/boot/platform/efi/arch/riscv64/arch_traps.cpp
 create mode 100644 src/system/boot/platform/efi/arch/riscv64/arch_traps.h
 create mode 100644 src/system/boot/platform/efi/arch/riscv64/arch_traps_asm.S

diff --git a/src/system/boot/loader/Jamfile b/src/system/boot/loader/Jamfile
index a1bc9e7651..9cf9de3671 100644
--- a/src/system/boot/loader/Jamfile
+++ b/src/system/boot/loader/Jamfile
@@ -74,6 +74,7 @@ for platform in [ MultiBootSubDirSetup ] {
 				{
 					DEFINES +=
 						BOOT_SUPPORT_ELF64
+						BOOT_SUPPORT_PARTITION_EFI
 					;
 					if $(TARGET_BOOT_PLATFORM) = efi {
 						DEFINES +=
diff --git a/src/system/boot/loader/elf.cpp b/src/system/boot/loader/elf.cpp
index 99495aaf93..450e3ec2dc 100644
--- a/src/system/boot/loader/elf.cpp
+++ b/src/system/boot/loader/elf.cpp
@@ -299,7 +299,8 @@ ELFLoader<Class>::Load(int fd, preloaded_image* _image)
 	{
 		AddrType address = firstRegion->start;
 		if (Class::AllocateRegion(&address, totalSize,
-				B_READ_AREA | B_WRITE_AREA, &mappedRegion) != B_OK) {
+				B_READ_AREA | B_WRITE_AREA | B_EXECUTE_AREA, &mappedRegion)
+				!= B_OK) {
 			status = B_NO_MEMORY;
 			goto error1;
 		}
@@ -727,13 +728,12 @@ elf_relocate_image(preloaded_image* image)
 #ifdef BOOT_SUPPORT_ELF64
 	if (image->elf_class == ELFCLASS64)
 		return ELF64Loader::Relocate(image);
-	else
 #endif
 #ifdef BOOT_SUPPORT_ELF32
+	if (image->elf_class == ELFCLASS32)
 		return ELF32Loader::Relocate(image);
-#else
-		return B_ERROR;
 #endif
+	return B_ERROR;
 }
 
 
diff --git a/src/system/boot/loader/kernel_args.cpp b/src/system/boot/loader/kernel_args.cpp
index b114b9eebf..5d32c3b136 100644
--- a/src/system/boot/loader/kernel_args.cpp
+++ b/src/system/boot/loader/kernel_args.cpp
@@ -397,7 +397,7 @@ kernel_args_malloc(size_t size)
 			return NULL;
 		}
 
-#ifdef _BOOT_PLATFORM_EFI
+#if defined(_BOOT_PLATFORM_EFI) || defined(__riscv)
 		addr_t translated_block;
 		platform_bootloader_address_to_kernel_address(block, &translated_block);
 		if (add_kernel_args_range((void *)translated_block, size) != B_OK)
@@ -418,7 +418,7 @@ kernel_args_malloc(size_t size)
 	sFirstFree = (void*)((addr_t)block + size);
 	sLast = block;
 	sFree = kChunkSize - size;
-#ifdef _BOOT_PLATFORM_EFI
+#if defined(_BOOT_PLATFORM_EFI) || defined(__riscv)
 	addr_t translated_block;
 	platform_bootloader_address_to_kernel_address(block, &translated_block);
 	if (add_kernel_args_range((void *)translated_block, kChunkSize) != B_OK)
diff --git a/src/system/boot/loader/main.cpp b/src/system/boot/loader/main.cpp
index 85c5466a26..d6b81182f9 100644
--- a/src/system/boot/loader/main.cpp
+++ b/src/system/boot/loader/main.cpp
@@ -87,8 +87,11 @@ main(stage2_args *args)
 
 	if (bootVolume.IsValid()) {
 		// we got a volume to boot from!
-		load_driver_settings(args, bootVolume.RootDirectory());
 
+		// TODO: fix for riscv64
+#ifndef __riscv
+		load_driver_settings(args, bootVolume.RootDirectory());
+#endif
 		status_t status;
 		while ((status = load_kernel(args, bootVolume)) < B_OK) {
 			// loading the kernel failed, so let the user choose another
@@ -130,8 +133,11 @@ main(stage2_args *args)
 			gKernelArgs.ucode_data_size = 0;
 			platform_load_ucode(bootVolume);
 
+			// TODO: fix for riscv64
+#ifndef __riscv
 			// apply boot settings
 			apply_boot_settings();
+#endif
 
 			// set up kernel args version info
 			gKernelArgs.kernel_args_size = sizeof(kernel_args);
diff --git a/src/system/boot/loader/vfs.cpp b/src/system/boot/loader/vfs.cpp
index 403878b063..cab1e85f51 100644
--- a/src/system/boot/loader/vfs.cpp
+++ b/src/system/boot/loader/vfs.cpp
@@ -167,7 +167,7 @@ status_t
 Node::Acquire()
 {
 	fRefCount++;
-	TRACE(("%p::Acquire(), fRefCount = %ld\n", this, fRefCount));
+	TRACE(("%p::Acquire(), fRefCount = %" B_PRId32 "\n", this, fRefCount));
 	return B_OK;
 }
 
@@ -175,7 +175,7 @@ Node::Acquire()
 status_t
 Node::Release()
 {
-	TRACE(("%p::Release(), fRefCount = %ld\n", this, fRefCount));
+	TRACE(("%p::Release(), fRefCount = %" B_PRId32 "\n", this, fRefCount));
 	if (--fRefCount == 0) {
 		TRACE(("delete node: %p\n", this));
 		delete this;
diff --git a/src/system/boot/platform/efi/Jamfile b/src/system/boot/platform/efi/Jamfile
index b9581b9c4c..1c615192a1 100644
--- a/src/system/boot/platform/efi/Jamfile
+++ b/src/system/boot/platform/efi/Jamfile
@@ -4,6 +4,7 @@ UsePrivateHeaders [ FDirName kernel boot ] ;
 UsePrivateHeaders [ FDirName kernel platform ] ;
 UsePrivateHeaders [ FDirName kernel boot platform efi ] ;
 UsePrivateHeaders [ FDirName kernel boot arch $(TARGET_KERNEL_ARCH) ] ;
+UseLibraryHeaders [ FDirName libfdt ] ;
 
 SubDirHdrs $(HAIKU_TOP) src add-ons kernel partitioning_systems gpt ;
 
@@ -32,7 +33,9 @@ local platform_src =
 	serial.cpp
 	;
 
-local support_libs ;
+local support_libs =
+	boot_fdt.a
+;
 
 local platform ;
 for platform in [ MultiBootSubDirSetup efi ] {
diff --git a/src/system/boot/platform/efi/arch/riscv64/Jamfile b/src/system/boot/platform/efi/arch/riscv64/Jamfile
index 464c7e47ae..f98215fb58 100644
--- a/src/system/boot/platform/efi/arch/riscv64/Jamfile
+++ b/src/system/boot/platform/efi/arch/riscv64/Jamfile
@@ -17,6 +17,8 @@ for platform in [ MultiBootSubDirSetup efi ] {
 		arch_smp.cpp
 		arch_mmu.cpp
 		arch_timer.cpp
+		arch_traps.cpp
+		arch_traps_asm.S
 		;
 
 	BootMergeObject boot_platform_efi_riscv64.o :
diff --git a/src/system/boot/platform/efi/arch/riscv64/arch_mmu.cpp b/src/system/boot/platform/efi/arch/riscv64/arch_mmu.cpp
index 9a86a8590b..91a0b4a21c 100644
--- a/src/system/boot/platform/efi/arch/riscv64/arch_mmu.cpp
+++ b/src/system/boot/platform/efi/arch/riscv64/arch_mmu.cpp
@@ -3,8 +3,453 @@
  * Released under the terms of the MIT License.
  */
 
+
+#include <algorithm>
+
+#include <kernel.h>
+#include <arch_kernel.h>
+#include <boot/platform.h>
+#include <boot/stage2.h>
+
+#include <efi/types.h>
+#include <efi/boot-services.h>
+
+#include "mmu.h"
+#include "efi_platform.h"
+
+
+extern addr_t gStackBase;
+
+phys_addr_t sPageTable = 0;
+
+
+static inline
+void *VirtFromPhys(uint64_t physAdr)
+{
+	return (void*)physAdr;
+}
+
+
+static uint64_t
+SignExtendVirtAdr(uint64_t virtAdr)
+{
+	if (((uint64_t)1 << 38) & virtAdr)
+		return virtAdr | 0xFFFFFF8000000000;
+	return virtAdr;
+}
+
+
+static void
+WritePteFlags(uint32 flags)
+{
+	bool first = true;
+	dprintf("{");
+	for (uint32 i = 0; i < 32; i++) {
+		if ((1 << i) & flags) {
+			if (first) first = false; else dprintf(", ");
+			switch (i) {
+			case pteValid:    dprintf("valid"); break;
+			case pteRead:     dprintf("read"); break;
+			case pteWrite:    dprintf("write"); break;
+			case pteExec:     dprintf("exec"); break;
+			case pteUser:     dprintf("user"); break;
+			case pteGlobal:   dprintf("global"); break;
+			case pteAccessed: dprintf("accessed"); break;
+			case pteDirty:    dprintf("dirty"); break;
+			default:          dprintf("%" B_PRIu32, i);
+			}
+		}
+	}
+	dprintf("}");
+}
+
+
+static void
+DumpPageWrite(uint64_t virtAdr, uint64_t physAdr, size_t size, uint64 flags, uint64& firstVirt, uint64& firstPhys, uint64& firstFlags, uint64& len)
+{
+	if (virtAdr == firstVirt + len && physAdr == firstPhys + len && flags == firstFlags) {
+		len += size;
+	} else {
+		if (len != 0) {
+			dprintf("  0x%08" B_PRIxADDR " - 0x%08" B_PRIxADDR,
+				firstVirt, firstVirt + (len - 1));
+			dprintf(": 0x%08" B_PRIxADDR " - 0x%08" B_PRIxADDR ", %#" B_PRIxADDR ", ", firstPhys, firstPhys + (len - 1), len);
+			WritePteFlags(firstFlags); dprintf("\n");
+		}
+		firstVirt = virtAdr;
+		firstPhys = physAdr;
+		firstFlags = flags;
+		len = size;
+	}
+}
+
+
+static void
+DumpPageTableInt(Pte* pte, uint64_t virtAdr, uint32_t level, uint64& firstVirt, uint64& firstPhys, uint64& firstFlags, uint64& len)
+{
+	for (uint32 i = 0; i < pteCount; i++) {
+		if (((1 << pteValid) & pte[i].flags) != 0) {
+			if ((((1 << pteRead) | (1 << pteWrite) | (1 << pteExec)) & pte[i].flags) == 0) {
+				if (level == 0)
+					panic("internal page table on level 0");
+
+				DumpPageTableInt((Pte*)VirtFromPhys(pageSize*pte[i].ppn),
+					virtAdr + ((uint64_t)i << (pageBits + pteIdxBits*level)),
+					level - 1, firstVirt, firstPhys, firstFlags, len);
+			} else {
+				DumpPageWrite(
+					SignExtendVirtAdr(virtAdr + ((uint64_t)i << (pageBits + pteIdxBits*level))),
+					pte[i].ppn * B_PAGE_SIZE,
+					1 << (pageBits + pteIdxBits*level),
+					pte[i].flags,
+					firstVirt, firstPhys, firstFlags, len);
+			}
+		}
+	}
+}
+
+
+static int
+DumpPageTable(uint64 satp)
+{
+	SatpReg satpReg(satp);
+	Pte* root = (Pte*)VirtFromPhys(satpReg.ppn * B_PAGE_SIZE);
+
+	dprintf("PageTable:\n");
+	uint64 firstVirt = 0;
+	uint64 firstPhys = 0;
+	uint64 firstFlags = 0;
+	uint64 len = 0;
+	DumpPageTableInt(root, 0, 2, firstVirt, firstPhys, firstFlags, len);
+	DumpPageWrite(0, 0, 0, 0, firstVirt, firstPhys, firstFlags, len);
+
+	return 0;
+}
+
+
+static Pte*
+LookupPte(addr_t virtAdr, bool alloc)
+{
+	Pte *pte = (Pte*)VirtFromPhys(sPageTable);
+	for (int level = 2; level > 0; level --) {
+		pte += VirtAdrPte(virtAdr, level);
+		if (((1 << pteValid) & pte->flags) == 0) {
+			if (!alloc)
+				return NULL;
+			pte->ppn = mmu_allocate_page() / B_PAGE_SIZE;
+			if (pte->ppn == 0)
+				return NULL;
+			memset((Pte*)VirtFromPhys(B_PAGE_SIZE * pte->ppn), 0, B_PAGE_SIZE);
+			pte->flags |= (1 << pteValid);
+		}
+		pte = (Pte*)VirtFromPhys(B_PAGE_SIZE * pte->ppn);
+	}
+	pte += VirtAdrPte(virtAdr, 0);
+	return pte;
+}
+
+
+static void
+Map(addr_t virtAdr, phys_addr_t physAdr, uint64 flags)
+{
+	// dprintf("Map(%#" B_PRIxADDR ", %#" B_PRIxADDR ")\n", virtAdr, physAdr);
+	Pte* pte = LookupPte(virtAdr, true);
+	if (pte == NULL) panic("can't allocate page table");
+
+	pte->ppn = physAdr / B_PAGE_SIZE;
+	pte->flags = (1 << pteValid) | (1 << pteAccessed) | (1 << pteDirty) | flags;
+}
+
+
+static void
+MapRange(addr_t virtAdr, phys_addr_t physAdr, size_t size, uint64 flags)
+{
+	dprintf("MapRange(%#" B_PRIxADDR " - %#" B_PRIxADDR ", %#" B_PRIxADDR " - %#" B_PRIxADDR ", %#"
+		B_PRIxADDR ")\n", virtAdr, virtAdr + (size - 1), physAdr, physAdr + (size - 1), size);
+	for (size_t i = 0; i < size; i += B_PAGE_SIZE)
+		Map(virtAdr + i, physAdr + i, flags);
+
+	ASSERT_ALWAYS(insert_virtual_allocated_range(virtAdr, size) >= B_OK);
+}
+
+
+static void
+MapAddrRange(addr_range& range, uint64 flags)
+{
+	if (range.size == 0) {
+		range.start = 0;
+		return;
+	}
+
+	phys_addr_t physAdr = range.start;
+	range.start = get_next_virtual_address(range.size);
+
+	MapRange(range.start, physAdr, range.size, flags);
+
+	if (gKernelArgs.arch_args.num_virtual_ranges_to_keep
+		>= MAX_VIRTUAL_RANGES_TO_KEEP)
+		panic("too many virtual ranges to keep");
+
+	gKernelArgs.arch_args.virtual_ranges_to_keep[
+		gKernelArgs.arch_args.num_virtual_ranges_to_keep++] = range;
+}
+
+
+static void
+PreallocKernelRange()
+{
+	Pte* root = (Pte*)VirtFromPhys(sPageTable);
+	for (uint64 i = VirtAdrPte(KERNEL_BASE, 2); i <= VirtAdrPte(KERNEL_TOP, 2);
+		i++) {
+		Pte *pte = &root[i];
+		pte->ppn = mmu_allocate_page() / B_PAGE_SIZE;
+		if (pte->ppn == 0) panic("can't alloc early physical page");
+		memset(VirtFromPhys(B_PAGE_SIZE * pte->ppn), 0, B_PAGE_SIZE);
+		pte->flags |= (1 << pteValid);
+	}
+}
+
+
+uint64
+GetSatp()
+{
+	SatpReg satp;
+	satp.ppn = sPageTable / B_PAGE_SIZE;
+	satp.asid = 0;
+	satp.mode = satpModeSv39;
+	return satp.val;
+}
+
+
+static void
+GetPhysMemRange(addr_range& range)
+{
+	phys_addr_t beg = (phys_addr_t)(-1), end = 0;
+	if (gKernelArgs.num_physical_memory_ranges <= 0)
+		beg = 0;
+	else {
+		for (size_t i = 0; i < gKernelArgs.num_physical_memory_ranges; i++) {
+			beg = std::min(beg, gKernelArgs.physical_memory_range[i].start);
+			end = std::max(end, gKernelArgs.physical_memory_range[i].start + gKernelArgs.physical_memory_range[i].size);
+		}
+	}
+	range.start = beg;
+	range.size = end - beg;
+}
+
+
+static void
+FillPhysicalMemoryMap(size_t memory_map_size,
+	efi_memory_descriptor *memory_map, size_t descriptor_size,
+	uint32_t descriptor_version)
+{
+	// Add physical memory to the kernel args and update virtual addresses for
+	// EFI regions.
+	gKernelArgs.num_physical_memory_ranges = 0;
+
+	// First scan: Add all usable ranges
+	for (size_t i = 0; i < memory_map_size / descriptor_size; ++i) {
+		efi_memory_descriptor* entry = &memory_map[i];
+		switch (entry->Type) {
+		case EfiLoaderCode:
+		case EfiLoaderData:
+		case EfiBootServicesCode:
+		case EfiBootServicesData:
+		case EfiConventionalMemory: {
+			// Usable memory.
+			uint64_t base = entry->PhysicalStart;
+			uint64_t end = entry->PhysicalStart + entry->NumberOfPages * 4096;
+			uint64_t originalSize = end - base;
+
+			// PMP protected memory, unusable
+			if (base == 0x80000000)
+				break;
+
+			gKernelArgs.ignored_physical_memory
+				+= originalSize - (std::max(end, base) - base);
+
+			if (base >= end)
+				break;
+			uint64_t size = end - base;
+
+			insert_physical_memory_range(base, size);
+			break;
+		}
+		case EfiACPIReclaimMemory:
+			// ACPI reclaim -- physical memory we could actually use later
+			break;
+		case EfiRuntimeServicesCode:
+		case EfiRuntimeServicesData:
+			entry->VirtualStart = entry->PhysicalStart;
+			break;
+		}
+	}
+
+	uint64_t initialPhysicalMemory = total_physical_memory();
+
+	// Second scan: Remove everything reserved that may overlap
+	for (size_t i = 0; i < memory_map_size / descriptor_size; ++i) {
+		efi_memory_descriptor* entry = &memory_map[i];
+		switch (entry->Type) {
+		case EfiLoaderCode:
+		case EfiLoaderData:
+		case EfiBootServicesCode:
+		case EfiBootServicesData:
+		case EfiConventionalMemory:
+			break;
+		default:
+			uint64_t base = entry->PhysicalStart;
+			uint64_t end = entry->PhysicalStart + entry->NumberOfPages * 4096;
+			remove_physical_memory_range(base, end - base);
+		}
+	}
+
+	gKernelArgs.ignored_physical_memory
+		+= initialPhysicalMemory - total_physical_memory();
+
+	sort_address_ranges(gKernelArgs.physical_memory_range,
+		gKernelArgs.num_physical_memory_ranges);
+}
+
+
+static void
+FillPhysicalAllocatedMemoryMap(size_t memory_map_size,
+	efi_memory_descriptor *memory_map, size_t descriptor_size,
+	uint32_t descriptor_version)
+{
+	for (size_t i = 0; i < memory_map_size / descriptor_size; ++i) {
+		efi_memory_descriptor* entry = &memory_map[i];
+		switch (entry->Type) {
+		case EfiLoaderData:
+			insert_physical_allocated_range(entry->PhysicalStart, entry->NumberOfPages * B_PAGE_SIZE);
+			break;
+		default:
+			;
+		}
+	}
+	sort_address_ranges(gKernelArgs.physical_allocated_range,
+		gKernelArgs.num_physical_allocated_ranges);
+}
+
+
+static void
+IdentityMap()
+{
+	Pte* pte = (Pte*)VirtFromPhys(sPageTable);
+	for (size_t i = 0; i < pteCount / 2; i++) {
+		pte[i].flags = (1 << pteValid) | (1 << pteRead) | (1 << pteWrite) | (1 << pteWrite) | (1 << pteExec);
+		pte[i].ppn = i * (pteCount * pteCount);
+	}
+}
+
+
+//#pragma mark -
+
 void
 arch_mmu_init()
 {
-	// Stub
+}
+
+
+void
+arch_mmu_post_efi_setup(size_t memory_map_size,
+	efi_memory_descriptor *memory_map, size_t descriptor_size,
+	uint32_t descriptor_version)
+{
+	FillPhysicalAllocatedMemoryMap(memory_map_size, memory_map, descriptor_size, descriptor_version);
+
+	// Switch EFI to virtual mode, using the kernel pmap.
+	// Something involving ConvertPointer might need to be done after this?
+	// http://wiki.phoenix.com/wiki/index.php/EFI_RUNTIME_SERVICES
+	kRuntimeServices->SetVirtualAddressMap(memory_map_size, descriptor_size,
+		descriptor_version, memory_map);
+}
+
+
+uint64
+arch_mmu_generate_post_efi_page_tables(size_t memory_map_size,
+	efi_memory_descriptor *memory_map, size_t descriptor_size,
+	uint32_t descriptor_version)
+{
+	sPageTable = mmu_allocate_page();
+	memset(VirtFromPhys(sPageTable), 0, B_PAGE_SIZE);
+	dprintf("sPageTable: %#" B_PRIxADDR "\n", sPageTable);
+
+	if (false) {
+		IdentityMap();
+		DumpPageTable(GetSatp());
+		return GetSatp();
+	}
+
+	PreallocKernelRange();
+
+	gKernelArgs.num_virtual_allocated_ranges = 0;
+	gKernelArgs.arch_args.num_virtual_ranges_to_keep = 0;
+	FillPhysicalMemoryMap(memory_map_size, memory_map, descriptor_size, descriptor_version);
+
+	addr_range physMemRange;
+	GetPhysMemRange(physMemRange);
+	dprintf("physMemRange: %#" B_PRIxADDR ", %#" B_PRIxSIZE "\n", physMemRange.start, physMemRange.size);
+
+	// Physical memory mapping
+	gKernelArgs.arch_args.physMap.start = KERNEL_TOP + 1 - physMemRange.size;
+	gKernelArgs.arch_args.physMap.size = physMemRange.size;
+	MapRange(gKernelArgs.arch_args.physMap.start, physMemRange.start, physMemRange.size, (1 << pteRead) | (1 << pteWrite));
+
+	// Boot loader
+	dprintf("Boot loader:\n");
+	for (size_t i = 0; i < memory_map_size / descriptor_size; ++i) {
+		efi_memory_descriptor* entry = &memory_map[i];
+		switch (entry->Type) {
+		case EfiLoaderCode:
+		case EfiLoaderData:
+			MapRange(entry->VirtualStart, entry->PhysicalStart, entry->NumberOfPages * B_PAGE_SIZE, (1 << pteRead) | (1 << pteWrite) | (1 << pteExec));
+			break;
+		default:
+			;
+		}
+	}
+	dprintf("Boot loader stack\n");
+	addr_t sp = Sp();
+	addr_t stackTop = ROUNDDOWN(sp - 1024*64, B_PAGE_SIZE);
+	dprintf("  SP: %#" B_PRIxADDR "\n", sp);
+	dprintf("  gStackBase: %#" B_PRIxADDR "\n", gStackBase);
+	// MapRange(stackTop, stackTop, ROUNDUP(gStackBase, B_PAGE_SIZE) - stackTop, (1 << pteRead) | (1 << pteWrite));
+
+	// EFI runtime services
+	dprintf("EFI runtime services:\n");
+	for (size_t i = 0; i < memory_map_size / descriptor_size; ++i) {
+		efi_memory_descriptor* entry = &memory_map[i];
+		if ((entry->Attribute & EFI_MEMORY_RUNTIME) != 0)
+			MapRange(entry->VirtualStart, entry->PhysicalStart, entry->NumberOfPages * B_PAGE_SIZE, (1 << pteRead) | (1 << pteWrite) | (1 << pteExec));
+	}
+
+	// Memory regions
+	dprintf("Regions:\n");
+	void* cookie = NULL;
+	addr_t virtAdr;
+	phys_addr_t physAdr;
+	size_t size;
+	while (mmu_next_region(&cookie, &virtAdr, &physAdr, &size)) {
+		MapRange(virtAdr, physAdr, size, (1 << pteRead) | (1 << pteWrite) | (1 << pteExec));
+	}
+
+	// Devices
+	dprintf("Devices:\n");
+	MapAddrRange(gKernelArgs.arch_args.clint, (1 << pteRead) | (1 << pteWrite));
+	MapAddrRange(gKernelArgs.arch_args.htif, (1 << pteRead) | (1 << pteWrite));
+	MapAddrRange(gKernelArgs.arch_args.plic, (1 << pteRead) | (1 << pteWrite));
+	if (gKernelArgs.arch_args.uart.kind != kUartKindNone) {
+		// !!!
+		MapRange(gKernelArgs.arch_args.uart.regs.start, gKernelArgs.arch_args.uart.regs.start, gKernelArgs.arch_args.uart.regs.size, (1 << pteRead) | (1 << pteWrite));
+
+		MapAddrRange(gKernelArgs.arch_args.uart.regs,
+			(1 << pteRead) | (1 << pteWrite));
+	}
+
+	sort_address_ranges(gKernelArgs.virtual_allocated_range, gKernelArgs.num_virtual_allocated_ranges);
+
+	DumpPageTable(GetSatp());
+
+	return GetSatp();
 }
diff --git a/src/system/boot/platform/efi/arch/riscv64/arch_smp.cpp b/src/system/boot/platform/efi/arch/riscv64/arch_smp.cpp
index 84e25b57ac..f35ec105d7 100644
--- a/src/system/boot/platform/efi/arch/riscv64/arch_smp.cpp
+++ b/src/system/boot/platform/efi/arch/riscv64/arch_smp.cpp
@@ -15,6 +15,9 @@
 #include <boot/platform.h>
 #include <boot/stage2.h>
 #include <boot/menu.h>
+#include <platform/sbi/sbi_syscalls.h>
+
+#include "mmu.h"
 
 
 //#define TRACE_SMP
@@ -25,27 +28,108 @@
 #endif
 
 
+extern "C" void arch_enter_kernel(uint64 satp, struct kernel_args *kernelArgs,
+        addr_t kernelEntry, addr_t kernelStackTop);
+
+
+struct CpuEntryInfo {
+	uint64 satp;
+	uint64 kernelEntry;
+};
+
+
+static CpuInfo sCpus[SMP_MAX_CPUS];
+uint32 sCpuCount = 0;
+
+
+static void
+CpuEntry(int hartId, CpuEntryInfo* info)
+{
+	arch_enter_kernel(info->satp, &gKernelArgs, info->kernelEntry,
+		gKernelArgs.cpu_kstack[hartId].start
+		+ gKernelArgs.cpu_kstack[hartId].size);
+}
+
+
+void
+arch_smp_register_cpu(CpuInfo** cpu)
+{
+	dprintf("arch_smp_register_cpu()\n");
+	uint32 newCount = sCpuCount + 1;
+	if (newCount > SMP_MAX_CPUS) {
+		*cpu = NULL;
+		return;
+	}
+	*cpu = &sCpus[sCpuCount];
+	sCpuCount = newCount;
+}
+
+
 int
 arch_smp_get_current_cpu(void)
 {
-	// One cpu for now.
-	return 0;
+	return Mhartid();
 }
 
 
 void
 arch_smp_init_other_cpus(void)
 {
-	// One cpu for now.
 	gKernelArgs.num_cpus = 1;
 	return;
+
+	if (get_safemode_boolean(B_SAFEMODE_DISABLE_SMP, false)) {
+		// SMP has been disabled!
+		TRACE(("smp disabled per safemode setting\n"));
+		gKernelArgs.num_cpus = 1;
+	}
+
+	gKernelArgs.num_cpus = sCpuCount;
+
+	if (gKernelArgs.num_cpus < 2)
+		return;
+
+	for (uint32 i = 1; i < gKernelArgs.num_cpus; i++) {
+		// create a final stack the trampoline code will put the ap processor on
+		void * stack = NULL;
+		const size_t size = KERNEL_STACK_SIZE + KERNEL_STACK_GUARD_PAGES * B_PAGE_SIZE;
+		if (platform_allocate_region(&stack, size, 0, false) != B_OK) {
+			panic("Unable to allocate AP stack");
+		}
+		memset(stack, 0, size);
+		gKernelArgs.cpu_kstack[i].start = fix_address((uint64_t)stack);
+		gKernelArgs.cpu_kstack[i].size = size;
+	}
 }
 
 
 void
-arch_smp_boot_other_cpus(uint32 pml4, uint64 kernel_entry)
+arch_smp_boot_other_cpus(uint64 satp, uint64 kernel_entry)
 {
-	// One cpu for now.
+	return;
+
+	dprintf("arch_smp_boot_other_cpus()\n");
+	for (uint32 i = 0; i < sCpuCount; i++) {
+		if (0 != sCpus[i].id) {
+			sbiret res;
+			dprintf("starting CPU %" B_PRIu32 "\n", sCpus[i].id);
+
+			res = sbi_hart_get_status(sCpus[i].id);
+			dprintf("[PRE] sbi_hart_get_status() -> (%ld, %ld)\n", res.error, res.value);
+
+			CpuEntryInfo info = {.satp = satp, .kernelEntry = kernel_entry};
+			res = sbi_hart_start(sCpus[i].id, (addr_t)&CpuEntry, (addr_t)&info);
+			dprintf("sbi_hart_start() -> (%ld, %ld)\n", res.error, res.value);
+
+			for (;;) {
+				res = sbi_hart_get_status(sCpus[i].id);
+				if (res.error < 0 || res.value == SBI_HART_STATE_STARTED)
+					break;
+			}
+
+			dprintf("[POST] sbi_hart_get_status() -> (%ld, %ld)\n", res.error, res.value);
+		}
+	}
 }
 
 
@@ -68,5 +152,4 @@ arch_smp_add_safemode_menus(Menu *menu)
 void
 arch_smp_init(void)
 {
-	// One cpu for now.
 }
diff --git a/src/system/boot/platform/efi/arch/riscv64/arch_start.cpp b/src/system/boot/platform/efi/arch/riscv64/arch_start.cpp
index 17a25044f7..4b654752c2 100644
--- a/src/system/boot/platform/efi/arch/riscv64/arch_start.cpp
+++ b/src/system/boot/platform/efi/arch/riscv64/arch_start.cpp
@@ -8,11 +8,60 @@
 #include <boot/stage2.h>
 #include <boot/stdio.h>
 
+#include <arch_cpu_defs.h>
+
+#include "mmu.h"
+#include "serial.h"
+#include "smp.h"
 #include "efi_platform.h"
+#include "arch_traps.h"
+
+
+// From entry.S
+extern "C" void arch_enter_kernel(uint64 satp, struct kernel_args *kernelArgs,
+        addr_t kernelEntry, addr_t kernelStackTop);
+
+// From arch_mmu.cpp
+extern void arch_mmu_post_efi_setup(size_t memory_map_size,
+    efi_memory_descriptor *memory_map, size_t descriptor_size,
+    uint32_t descriptor_version);
+
+extern uint64_t arch_mmu_generate_post_efi_page_tables(size_t memory_map_size,
+    efi_memory_descriptor *memory_map, size_t descriptor_size,
+    uint32_t descriptor_version);
+
+
+#include <arch/riscv64/arch_uart_sifive.h>
 
 
-extern "C" void arch_enter_kernel(struct kernel_args *kernelArgs,
-	addr_t kernelEntry, addr_t kernelStackTop);
+static void UartWriteChar(volatile UARTSifiveRegs* uart, const char ch)
+{
+	while (uart->txdata.isFull) {}
+	uart->txdata.val = ch;
+}
+
+
+static void UartWrite(volatile UARTSifiveRegs* uart, const char* str)
+{
+	for (; *str != '\0'; str++)
+		UartWriteChar(uart, *str);
+}
+
+
+void
+MmuTest(volatile UARTSifiveRegs* uart, uint64 satp)
+{
+	UartWrite(uart, "MmuTest()\n");
+
+	UartWriteChar(uart, '1'); UartWriteChar(uart, '\n');
+	SetSatp(satp);
+	UartWriteChar(uart, '2'); UartWriteChar(uart, '\n');
+	FlushTlbAll();
+	UartWriteChar(uart, '3'); UartWriteChar(uart, '\n');
+
+	for (;;) Wfi();
+}
+
 
 void
 arch_start_kernel(addr_t kernelEntry)
@@ -27,7 +76,7 @@ arch_start_kernel(addr_t kernelEntry)
 	size_t descriptor_size;
 	uint32_t descriptor_version;
 	if (kBootServices->GetMemoryMap(&memory_map_size, &dummy, &map_key,
-			&descriptor_size, &descriptor_version) != EFI_BUFFER_TOO_SMALL) {
+		&descriptor_size, &descriptor_version) != EFI_BUFFER_TOO_SMALL) {
 		panic("Unable to determine size of system memory map");
 	}
 
@@ -43,7 +92,7 @@ arch_start_kernel(addr_t kernelEntry)
 	// Read (and print) the memory map.
 	memory_map_size = actual_memory_map_size;
 	if (kBootServices->GetMemoryMap(&memory_map_size, memory_map, &map_key,
-			&descriptor_size, &descriptor_version) != EFI_SUCCESS) {
+		&descriptor_size, &descriptor_version) != EFI_SUCCESS) {
 		panic("Unable to fetch system memory map.");
 	}
 
@@ -52,11 +101,29 @@ arch_start_kernel(addr_t kernelEntry)
 	for (size_t i = 0; i < memory_map_size / descriptor_size; ++i) {
 		efi_memory_descriptor *entry
 			= (efi_memory_descriptor *)(addr + i * descriptor_size);
-		dprintf("  %#lx-%#lx  %#lx %#x %#lx\n", entry->PhysicalStart,
-			entry->PhysicalStart + entry->NumberOfPages * B_PAGE_SIZE,
-			entry->VirtualStart, entry->Type, entry->Attribute);
+		dprintf("  phys: %#lx, virt: %#lx, size: %#lx, ",
+			entry->PhysicalStart, entry->VirtualStart,
+			entry->NumberOfPages * B_PAGE_SIZE);
+		switch (entry->Type) {
+		case EfiReservedMemoryType:  dprintf("reservedMemoryType"); break;
+		case EfiLoaderCode:          dprintf("loaderCode"); break;
+		case EfiLoaderData:          dprintf("loaderData"); break;
+		case EfiBootServicesCode:    dprintf("bootServicesCode"); break;
+		case EfiBootServicesData:    dprintf("bootServicesData"); break;
+		case EfiConventionalMemory:  dprintf("conventionalMemory"); break;
+		case EfiACPIReclaimMemory:   dprintf("ACPIReclaimMemory"); break;
+		case EfiRuntimeServicesCode: dprintf("runtimeServicesCode"); break;
+		case EfiRuntimeServicesData: dprintf("runtimeServicesData"); break;
+		default: dprintf("?(%d)", entry->Type);
+		}
+		dprintf(", attrs: %#lx\n", entry->Attribute);
 	}
 
+	// Generate page tables for use after ExitBootServices.
+	uint64_t satp = arch_mmu_generate_post_efi_page_tables(
+		memory_map_size, memory_map, descriptor_size, descriptor_version);
+	dprintf("SATP: 0x%016" B_PRIx64 "\n", satp);
+
 	// Attempt to fetch the memory map and exit boot services.
 	// This needs to be done in a loop, as ExitBootServices can change the
 	// memory map.
@@ -67,14 +134,17 @@ arch_start_kernel(addr_t kernelEntry)
 	// A changing memory map shouldn't affect the generated page tables, as
 	// they only needed to know about the maximum address, not any specific
 	// entry.
+#if 1
 	dprintf("Calling ExitBootServices. So long, EFI!\n");
 	while (true) {
 		if (kBootServices->ExitBootServices(kImage, map_key) == EFI_SUCCESS) {
 			// The console was provided by boot services, disable it.
 			stdout = NULL;
 			stderr = NULL;
-			// Can we adjust gKernelArgs.platform_args.serial_base_ports[0]
-			// to something fixed in qemu for debugging?
+			// Also switch to legacy serial output
+			// (may not work on all systems)
+			serial_switch_to_legacy();
+			dprintf("Switched to legacy serial output\n");
 			break;
 		}
 
@@ -84,14 +154,27 @@ arch_start_kernel(addr_t kernelEntry)
 			panic("Unable to fetch system memory map.");
 		}
 	}
+#endif
+	arch_traps_init();
 
 	// Update EFI, generate final kernel physical memory map, etc.
-	//arch_mmu_post_efi_setup(memory_map_size, memory_map,
-	//		descriptor_size, descriptor_version);
+	arch_mmu_post_efi_setup(memory_map_size, memory_map,
+			descriptor_size, descriptor_version);
+
+	if (false)
+		MmuTest((volatile UARTSifiveRegs*)gKernelArgs.arch_args.uart.regs.start, satp);
+
+	dprintf("[PRE] SetSatp()\n");
+	SetSatp(satp);
+	dprintf("[POST] SetSatp()\n");
+	FlushTlbAll();
+	dprintf("[POST] FlushTlbAll()\n");
 
-	//smp_boot_other_cpus(final_pml4, kernelEntry);
+	smp_boot_other_cpus(satp, kernelEntry);
 
 	// Enter the kernel!
-	arch_enter_kernel(&gKernelArgs, kernelEntry,
+	dprintf("arch_enter_kernel(satp: %#" B_PRIxADDR ", kernelArgs: %#" B_PRIxADDR ", kernelEntry: %#" B_PRIxADDR ", sp: %#" B_PRIxADDR ")\n",
+		satp, (addr_t)&gKernelArgs, (addr_t)kernelEntry, gKernelArgs.cpu_kstack[0].start + gKernelArgs.cpu_kstack[0].size);
+	arch_enter_kernel(satp, &gKernelArgs, kernelEntry,
 		gKernelArgs.cpu_kstack[0].start + gKernelArgs.cpu_kstack[0].size);
 }
diff --git a/src/system/boot/platform/efi/arch/riscv64/arch_traps.cpp b/src/system/boot/platform/efi/arch/riscv64/arch_traps.cpp
new file mode 100644
index 0000000000..2ffeed09ff
--- /dev/null
+++ b/src/system/boot/platform/efi/arch/riscv64/arch_traps.cpp
@@ -0,0 +1,176 @@
+#include "arch_traps.h"
+
+#include <KernelExport.h>
+#include <arch_cpu_defs.h>
+
+
+void
+WriteMode(int mode)
+{
+	switch (mode) {
+		case modeU: dprintf("u"); break;
+		case modeS: dprintf("s"); break;
+		case modeM: dprintf("m"); break;
+		default: dprintf("%d", mode);
+	}
+}
+
+
+void
+WriteModeSet(uint32_t val)
+{
+	bool first = true;
+	dprintf("{");
+	for (int i = 0; i < 32; i++) {
+		if (((1LL << i) & val) != 0) {
+			if (first) first = false; else dprintf(", ");
+			WriteMode(i);
+		}
+	}
+	dprintf("}");
+}
+
+
+void
+WriteExt(uint64_t val)
+{
+	switch (val) {
+		case 0: dprintf("off"); break;
+		case 1: dprintf("initial"); break;
+		case 2: dprintf("clean"); break;
+		case 3: dprintf("dirty"); break;
+		default: dprintf("%" B_PRId64, val);
+	}
+}
+
+
+void
+WriteSstatus(uint64_t val)
+{
+	SstatusReg status(val);
+	dprintf("%#" B_PRIx64, val);
+	dprintf(" (");
+	dprintf("ie: "); WriteModeSet(status.ie);
+	dprintf(", pie: "); WriteModeSet(status.pie);
+	dprintf(", spp: "); WriteMode(status.spp);
+	dprintf(", fs: "); WriteExt(status.fs);
+	dprintf(", xs: "); WriteExt(status.xs);
+	dprintf(", sum: %d", (int)status.sum);
+	dprintf(", mxr: %d", (int)status.mxr);
+	dprintf(", uxl: %d", (int)status.uxl);
+	dprintf(", sd: %d", (int)status.sd);
+	dprintf(")");
+}
+
+
+void
+WriteInterrupt(uint64_t val)
+{
+	switch (val) {
+		case 0 + modeU: dprintf("uSoft"); break;
+		case 0 + modeS: dprintf("sSoft"); break;
+		case 0 + modeM: dprintf("mSoft"); break;
+		case 4 + modeU: dprintf("uTimer"); break;
+		case 4 + modeS: dprintf("sTimer"); break;
+		case 4 + modeM: dprintf("mTimer"); break;
+		case 8 + modeU: dprintf("uExtern"); break;
+		case 8 + modeS: dprintf("sExtern"); break;
+		case 8 + modeM: dprintf("mExtern"); break;
+		default: dprintf("%" B_PRId64, val);
+	}
+}
+
+
+void
+WriteInterruptSet(uint64_t val)
+{
+	bool first = true;
+	dprintf("{");
+	for (int i = 0; i < 64; i++) {
+		if (((1LL << i) & val) != 0) {
+			if (first) first = false; else dprintf(", ");
+			WriteInterrupt(i);
+		}
+	}
+	dprintf("}");
+}
+
+
+void
+WriteCause(uint64_t cause)
+{
+	if ((cause & causeInterrupt) == 0) {
+		dprintf("exception ");
+		switch (cause) {
+			case causeExecMisalign: dprintf("execMisalign"); break;
+			case causeExecAccessFault: dprintf("execAccessFault"); break;
+			case causeIllegalInst: dprintf("illegalInst"); break;
+			case causeBreakpoint: dprintf("breakpoint"); break;
+			case causeLoadMisalign: dprintf("loadMisalign"); break;
+			case causeLoadAccessFault: dprintf("loadAccessFault"); break;
+			case causeStoreMisalign: dprintf("storeMisalign"); break;
+			case causeStoreAccessFault: dprintf("storeAccessFault"); break;
+			case causeUEcall: dprintf("uEcall"); break;
+			case causeSEcall: dprintf("sEcall"); break;
+			case causeMEcall: dprintf("mEcall"); break;
+			case causeExecPageFault: dprintf("execPageFault"); break;
+			case causeLoadPageFault: dprintf("loadPageFault"); break;
+			case causeStorePageFault: dprintf("storePageFault"); break;
+			default: dprintf("%" B_PRId64, cause);
+			}
+	} else {
+		dprintf("interrupt "); WriteInterrupt(cause & ~causeInterrupt);
+	}
+}
+
+
+void
+WritePC(addr_t pc)
+{
+	dprintf("0x%" B_PRIxADDR, pc);
+}
+
+
+void
+DoStackTrace(addr_t fp, addr_t pc)
+{
+	dprintf("Stack:\n");
+	dprintf("FP: 0x%" B_PRIxADDR, fp);
+	if (pc != 0) {
+		dprintf(", PC: "); WritePC(pc);
+	}
+	dprintf("\n");
+	while (fp != 0) {
+		pc = *((uint64*)fp - 1);
+		fp = *((uint64*)fp - 2);
+		dprintf("FP: 0x%" B_PRIxADDR, fp);
+		dprintf(", PC: "); WritePC(pc);
+		dprintf("\n");
+		if (pc == 0) break;
+	}
+}
+
+
+void
+STrap(iframe* frame)
+{
+	uint64 cause = Scause();
+
+	dprintf("STrap("); WriteCause(Scause()); dprintf(")\n");
+	dprintf("  sstatus: "); WriteSstatus(Sstatus()); dprintf("\n");
+	dprintf("  sie: "); WriteInterruptSet(Sie()); dprintf("\n");
+	dprintf("  sip: "); WriteInterruptSet(Sip()); dprintf("\n");
+	dprintf("  sepc: 0x%" B_PRIxADDR "\n", Sepc());
+	dprintf("  stval: 0x%" B_PRIxADDR "\n", Stval());
+	dprintf("  sscratch: 0x%" B_PRIxADDR "\n", Sscratch());
+	DoStackTrace(Fp(), Sepc());
+	for (;;) Wfi();
+}
+
+
+void
+arch_traps_init()
+{
+	dprintf("init_arch_traps()\n");
+	SetStvec((uint64)SVec);
+}
diff --git a/src/system/boot/platform/efi/arch/riscv64/arch_traps.h b/src/system/boot/platform/efi/arch/riscv64/arch_traps.h
new file mode 100644
index 0000000000..20d253c749
--- /dev/null
+++ b/src/system/boot/platform/efi/arch/riscv64/arch_traps.h
@@ -0,0 +1,55 @@
+#ifndef _ARCH_TRAPS_H_
+#define _ARCH_TRAPS_H_
+
+
+#include <SupportDefs.h>
+
+
+struct iframe {
+	uint64 ra;
+	uint64 t6;
+	uint64 sp;
+	uint64 gp;
+	uint64 tp;
+	uint64 t0;
+	uint64 t1;
+	uint64 t2;
+	uint64 t5;
+	uint64 s1;
+	uint64 a0;
+	uint64 a1;
+	uint64 a2;
+	uint64 a3;
+	uint64 a4;
+	uint64 a5;
+	uint64 a6;
+	uint64 a7;
+	uint64 s2;
+	uint64 s3;
+	uint64 s4;
+	uint64 s5;
+	uint64 s6;
+	uint64 s7;
+	uint64 s8;
+	uint64 s9;
+	uint64 s10;
+	uint64 s11;
+	uint64 t3;
+	uint64 t4;
+	uint64 fp;
+	uint64 epc;
+};
+
+
+extern "C" {
+
+void SVec();
+void STrap(iframe* frame);
+
+};
+
+
+void arch_traps_init();
+
+
+#endif	// _ARCH_TRAPS_H_
diff --git a/src/system/boot/platform/efi/arch/riscv64/arch_traps_asm.S b/src/system/boot/platform/efi/arch/riscv64/arch_traps_asm.S
new file mode 100644
index 0000000000..aecd1987d6
--- /dev/null
+++ b/src/system/boot/platform/efi/arch/riscv64/arch_traps_asm.S
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2021, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <arch_traps.h>
+
+
+.globl SVec
+.type  SVec, @function
+.align 4
+SVec:
+	PushTrapFrame
+	sd fp, 2*8(sp)
+	csrr t0, sepc
+	sd   t0, 31*8(sp)
+
+	mv a0, sp
+	call STrap
+
+	ld t0, 31*8(sp)
+	csrw sepc, t0
+	PopTrapFrame
+	sret
+.size	SVec, .-SVec
diff --git a/src/system/boot/platform/efi/arch/riscv64/entry.S b/src/system/boot/platform/efi/arch/riscv64/entry.S
index 7ae5221a49..f847b77d85 100644
--- a/src/system/boot/platform/efi/arch/riscv64/entry.S
+++ b/src/system/boot/platform/efi/arch/riscv64/entry.S
@@ -7,24 +7,30 @@
 
     .text
 
-/*  status_t arch_enter_kernel(struct kernel_args *kernelArgs,
+/*  status_t arch_enter_kernel(addr_t satp, struct kernel_args *kernelArgs,
         addr_t kernelEntry, addr_t kernelStackTop);
 
-    a0  - kernelArgs
-    a1  - kernelEntry
-    a2  - kernelStackTop
+    a0  - SATP register value
+    a1  - kernelArgs
+    a2  - kernelEntry
+    a3  - kernelStackTop
 */
 FUNCTION(arch_enter_kernel):
+	csrw satp, a0
+	sfence.vma
+
 	// set the kernel stack
-	mv	sp,a2
+	mv	sp, a3
+	li	fp, 0
+	li  ra, 0
 
 	// Setup kernel args
-	//mv	a0,a0	// kernelArgs
-	mv	a4,a1
-	li	a1,0	// currentCPU=0
+	mv	a0, a1	// kernelArgs
+	mv	t0, a2
+	li	a1, 0	// currentCPU=0
 
 	// call the kernel
-	jr	a4
+	jr	t0
 
 	// return
 	li	a0,-1  // B_ERROR
diff --git a/src/system/boot/platform/efi/console.cpp b/src/system/boot/platform/efi/console.cpp
index 1c0fea642f..b81dbadd88 100644
--- a/src/system/boot/platform/efi/console.cpp
+++ b/src/system/boot/platform/efi/console.cpp
@@ -165,6 +165,7 @@ console_wait_for_key(void)
 		kBootServices->WaitForEvent(1, &event, &index);
 		status = kSystemTable->ConIn->ReadKeyStroke(kSystemTable->ConIn, &key);
 	} while (status == EFI_NOT_READY);
+	// printf("key: (char: %d, code: %d)\n", key.UnicodeChar, key.ScanCode);
 
 	if (key.UnicodeChar > 0)
 		return (int) key.UnicodeChar;
diff --git a/src/system/boot/platform/efi/debug.cpp b/src/system/boot/platform/efi/debug.cpp
index 48724ad3ce..ac84fb8b75 100644
--- a/src/system/boot/platform/efi/debug.cpp
+++ b/src/system/boot/platform/efi/debug.cpp
@@ -47,7 +47,10 @@ dprintf(const char *format, ...)
 	va_list args;
 
 	va_start(args, format);
-	dprintf_args(format, args);
+	if (true)
+		dprintf_args(format, args);
+	else
+		vprintf(format, args);
 	va_end(args);
 }
 
diff --git a/src/system/boot/platform/efi/dtb.cpp b/src/system/boot/platform/efi/dtb.cpp
index 1c8744523a..4df865413d 100644
--- a/src/system/boot/platform/efi/dtb.cpp
+++ b/src/system/boot/platform/efi/dtb.cpp
@@ -11,10 +11,18 @@
 #include <boot/platform.h>
 #include <boot/stage2.h>
 #include <kernel/kernel.h>
+#include <arch_smp.h>
+#include <arch/generic/debug_uart_8250.h>
+#include <arch/riscv64/arch_uart_sifive.h>
 
 #include <ByteOrder.h>
 
+extern "C" {
+#include <libfdt.h>
+}
+
 #include "efi_platform.h"
+#include "serial.h"
 
 
 #define INFO(x...) dprintf("efi/fdt: " x)
@@ -24,23 +32,377 @@
 static void* sDtbTable = NULL;
 static uint32 sDtbSize = 0;
 
+static uint32 sBootHart = 0;
+static uint64 sTimerFrequrency = 10000000;
+
+static addr_range sPlic = {0};
+static addr_range sClint = {0};
+static ArchUart sUart = {.kind = kUartKindNone};
+
+
+DebugUART8250*
+arch_get_uart_8250(addr_t base, int64 clock)
+{
+	static char buffer[sizeof(DebugUART8250)];
+	DebugUART8250* uart = new(buffer) DebugUART8250(base, clock);
+	return uart;
+}
+
+
+ArchUARTSifive*
+arch_get_uart_sifive(addr_t base, int64 clock)
+{
+	static char buffer[sizeof(ArchUARTSifive)];
+	ArchUARTSifive* uart = new(buffer) ArchUARTSifive(base, clock);
+	return uart;
+}
+
+
+static void WriteString(const char *str) {dprintf("%s", str);}
+static void WriteLn() {dprintf("\n");}
+static void WriteHex(uint64_t val, int n) {dprintf("%08" B_PRIx64, val);}
+static void WriteInt(int64_t val) {dprintf("%" B_PRId64, val);}
+
+
+static void WriteStringList(const char* prop, size_t size)
+{
+	bool first = true;
+	const char* propEnd = prop + size;
+	while (propEnd - prop > 0) {
+		if (first) first = false; else WriteString(", ");
+		int curLen = strlen(prop);
+		WriteString("'");
+		WriteString(prop);
+		WriteString("'");
+		prop += curLen + 1;
+	}
+}
+
+
+static void DumpFdt(const void *fdt)
+{
+	if (!fdt)
+		return;
+
+	int err = fdt_check_header(fdt);
+	if (err) {
+		WriteString("fdt error: ");
+		WriteString(fdt_strerror(err));
+		WriteLn();
+		return;
+	}
+
+	WriteString("fdt tree:"); WriteLn();
+
+	int node = -1;
+	int depth = -1;
+	while ((node = fdt_next_node(fdt, node, &depth)) >= 0 && depth >= 0) {
+		for (int i = 0; i < depth; i++) WriteString("  ");
+		// WriteInt(node); WriteString(", "); WriteInt(depth); WriteString(": ");
+		WriteString("node('");
+		WriteString(fdt_get_name(fdt, node, NULL));
+		WriteString("')"); WriteLn();
+		depth++;
+		for (int prop = fdt_first_property_offset(fdt, node); prop >= 0; prop = fdt_next_property_offset(fdt, prop)) {
+			int len;
+			const struct fdt_property *property = fdt_get_property_by_offset(fdt, prop, &len);
+			if (property == NULL) {
+				for (int i = 0; i < depth; i++) WriteString("  ");
+				WriteString("getting prop at ");
+				WriteInt(prop);
+				WriteString(": ");
+				WriteString(fdt_strerror(len));
+				WriteLn();
+				break;
+			}
+			for (int i = 0; i < depth; i++) WriteString("  ");
+			WriteString("prop('");
+			WriteString(fdt_string(fdt, fdt32_to_cpu(property->nameoff)));
+			WriteString("'): ");
+			if (
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "compatible") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "model") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "serial-number") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "status") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "device_type") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "riscv,isa") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "mmu-type") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "format") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "bootargs") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "stdout-path") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "reg-names") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "reset-names") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "clock-names") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "clock-output-names") == 0
+			) {
+				WriteStringList((const char*)property->data, fdt32_to_cpu(property->len));
+			} else if (strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "reg") == 0) {
+				for (uint64_t *it = (uint64_t*)property->data; (uint8_t*)it - (uint8_t*)property->data < fdt32_to_cpu(property->len); it += 2) {
+					if (it != (uint64_t*)property->data) WriteString(", ");
+					WriteString("(0x");
+					WriteHex(fdt64_to_cpu(*it), 8);
+					WriteString(", 0x");
+					WriteHex(fdt64_to_cpu(*(it + 1)), 8);
+					WriteString(")");
+				}
+			} else if (
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "phandle") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "clock-frequency") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "timebase-frequency") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "#address-cells") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "#size-cells") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "#interrupt-cells") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "interrupts") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "interrupt-parent") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "boot-hartid") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "riscv,ndev") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "value") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "offset") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "regmap") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "bank-width") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "width") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "height") == 0 ||
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "stride") == 0
+			) {
+				WriteInt(fdt32_to_cpu(*(uint32_t*)property->data));
+			} else if (
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "interrupts-extended") == 0
+			) {
+				for (uint32_t *it = (uint32_t*)property->data; (uint8_t*)it - (uint8_t*)property->data < fdt32_to_cpu(property->len); it += 2) {
+					if (it != (uint32_t*)property->data) WriteString(", ");
+					WriteString("(");
+					WriteInt(fdt32_to_cpu(*it));
+					WriteString(", ");
+					WriteInt(fdt32_to_cpu(*(it + 1)));
+					WriteString(")");
+				}
+			} else if (
+				strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "ranges") == 0
+			) {
+				WriteLn();
+				depth++;
+				// kind
+				// child address
+				// parent address
+				// size
+				for (uint32_t *it = (uint32_t*)property->data; (uint8_t*)it - (uint8_t*)property->data < fdt32_to_cpu(property->len); it += 7) {
+					for (int i = 0; i < depth; i++) WriteString("  ");
+					uint32_t kind = fdt32_to_cpu(*(it + 0));
+					switch (kind & 0x03000000) {
+					case 0x00000000: WriteString("CONFIG"); break;
+					case 0x01000000: WriteString("IOPORT"); break;
+					case 0x02000000: WriteString("MMIO"); break;
+					case 0x03000000: WriteString("MMIO_64BIT"); break;
+					}
+					WriteString(" (0x"); WriteHex(kind, 8);
+					WriteString("), ");
+					WriteString("child: 0x"); WriteHex(fdt64_to_cpu(*(uint64_t*)(it + 1)), 8);
+					WriteString(", ");
+					WriteString("parent: 0x"); WriteHex(fdt64_to_cpu(*(uint64_t*)(it + 3)), 8);
+					WriteString(", ");
+					WriteString("len: 0x"); WriteHex(fdt64_to_cpu(*(uint64_t*)(it + 5)), 8);
+					WriteLn();
+				}
+				for (int i = 0; i < depth; i++) WriteString("  ");
+				depth--;
+			} else if (strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "bus-range") == 0) {
+				uint32_t *it = (uint32_t*)property->data;
+				WriteInt(fdt32_to_cpu(*it));
+				WriteString(", ");
+				WriteInt(fdt32_to_cpu(*(it + 1)));
+			} else if (strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "interrupt-map-mask") == 0) {
+				WriteLn();
+				depth++;
+				for (uint32_t *it = (uint32_t*)property->data; (uint8_t*)it - (uint8_t*)property->data < fdt32_to_cpu(property->len); it++) {
+					for (int i = 0; i < depth; i++) WriteString("  ");
+					WriteString("0x"); WriteHex(fdt32_to_cpu(*(uint32_t*)it), 8);
+					WriteLn();
+				}
+				for (int i = 0; i < depth; i++) WriteString("  ");
+				depth--;
+			} else if (strcmp(fdt_string(fdt, fdt32_to_cpu(property->nameoff)), "interrupt-map") == 0) {
+				WriteLn();
+				depth++;
+				for (uint32_t *it = (uint32_t*)property->data; (uint8_t*)it - (uint8_t*)property->data < fdt32_to_cpu(property->len); it += 6) {
+					for (int i = 0; i < depth; i++) WriteString("  ");
+					// child unit address
+					WriteString("0x"); WriteHex(fdt32_to_cpu(*(it + 0)), 8);
+					WriteString(", ");
+					WriteString("0x"); WriteHex(fdt32_to_cpu(*(it + 1)), 8);
+					WriteString(", ");
+					WriteString("0x"); WriteHex(fdt32_to_cpu(*(it + 2)), 8);
+					WriteString(", ");
+					WriteString("0x"); WriteHex(fdt32_to_cpu(*(it + 3)), 8);
+
+					WriteString(", bus: "); WriteInt(fdt32_to_cpu(*(it + 0)) / (1 << 16) % (1 << 8));
+					WriteString(", dev: "); WriteInt(fdt32_to_cpu(*(it + 0)) / (1 << 11) % (1 << 5));
+					WriteString(", fn: "); WriteInt(fdt32_to_cpu(*(it + 0)) % (1 << 3));
+
+					WriteString(", childIrq: ");
+					// child interrupt specifier
+					WriteInt(fdt32_to_cpu(*(it + 3)));
+					WriteString(", parentIrq: (");
+					// interrupt-parent
+					WriteInt(fdt32_to_cpu(*(it + 4)));
+					WriteString(", ");
+					WriteInt(fdt32_to_cpu(*(it + 5)));
+					WriteString(")");
+					WriteLn();
+					if (((it - (uint32_t*)property->data) / 6) % 4 == 3 && ((uint8_t*)(it + 6) - (uint8_t*)property->data < fdt32_to_cpu(property->len)))
+						WriteLn();
+				}
+				for (int i = 0; i < depth; i++) WriteString("  ");
+				depth--;
+			} else {
+				WriteString("?");
+			}
+			WriteString(" (len ");
+			WriteInt(fdt32_to_cpu(property->len));
+			WriteString(")"); WriteLn();
+/*
+			dump_hex(property->data, fdt32_to_cpu(property->len), depth);
+*/
+		}
+		depth--;
+	}
+}
+
+
 
 static bool
-fdt_valid(void* fdt, uint32* size)
+HasFdtString(const char* prop, int size, const char* pattern)
 {
-	if (fdt == NULL)
-		return false;
-	uint32* words = (uint32*)fdt;
-	if (B_BENDIAN_TO_HOST_INT32(words[0]) != 0xd00dfeed)
+	int patternLen = strlen(pattern);
+	const char* propEnd = prop + size;
+	while (propEnd - prop > 0) {
+		int curLen = strlen(prop);
+		if (curLen == patternLen && memcmp(prop, pattern, curLen + 1) == 0)
+			return true;
+		prop += curLen + 1;
+	}
+	return false;
+}
+
+
+static bool
+GetReg(const void* fdt, int node, uint32 addressCells, uint32 sizeCells, size_t idx, addr_range& range)
+{
+	int propSize;
+	const uint8* prop = (const uint8*)fdt_getprop(fdt, node, "reg", &propSize);
+	if (prop == NULL)
 		return false;
-	*size = B_BENDIAN_TO_HOST_INT32(words[1]);
-	if (size == 0)
+
+	size_t entrySize = 4*(addressCells + sizeCells);
+	if ((idx + 1)*entrySize > (size_t)propSize)
 		return false;
 
+	prop += idx*entrySize;
+
+	switch (addressCells) {
+		case 1: range.start = fdt32_to_cpu(*(uint32*)prop); prop += 4; break;
+		case 2: range.start = fdt64_to_cpu(*(uint64*)prop); prop += 8; break;
+		default: panic("unsupported addressCells");
+	}
+	switch (sizeCells) {
+		case 1: range.size = fdt32_to_cpu(*(uint32*)prop); prop += 4; break;
+		case 2: range.size = fdt64_to_cpu(*(uint64*)prop); prop += 8; break;
+		default: panic("unsupported sizeCells");
+	}
 	return true;
 }
 
 
+static uint32
+GetInterrupt(const void* fdt, int node, uint32 interruptCells)
+{
+	if (uint32* prop = (uint32*)fdt_getprop(fdt, node, "interrupts-extended", NULL)) {
+		return fdt32_to_cpu(*(prop + 1));
+	}
+	if (uint32* prop = (uint32*)fdt_getprop(fdt, node, "interrupts", NULL)) {
+		return fdt32_to_cpu(*prop);
+	}
+	dprintf("[!] no interrupt field\n");
+	return 0;
+}
+
+
+static void
+HandleFdt(const void* fdt, int node, uint32 addressCells, uint32 sizeCells,
+	uint32 interruptCells /* from parent node */)
+{
+	// TODO: handle different field sizes
+
+	const char* name = fdt_get_name(fdt, node, NULL);
+	if (strcmp(name, "chosen") == 0) {
+		if (uint32* prop = (uint32*)fdt_getprop(fdt, node, "boot-hartid", NULL))
+			sBootHart = fdt32_to_cpu(*prop);
+	} else if (strcmp(name, "cpus") == 0) {
+		if (uint32* prop = (uint32*)fdt_getprop(fdt, node, "timebase-frequency", NULL))
+			sTimerFrequrency = fdt32_to_cpu(*prop);
+	}
+
+	const char* deviceType = (const char*)fdt_getprop(fdt, node,
+		"device_type", NULL);
+
+	if (deviceType != NULL) {
+		if (strcmp(deviceType, "cpu") == 0) {
+			CpuInfo* info;
+			arch_smp_register_cpu(&info);
+			if (info == NULL)
+				return;
+			info->id = fdt32_to_cpu(*(uint32*)fdt_getprop(fdt, node, "reg", NULL));
+			dprintf("cpu\n");
+			dprintf("  id: %" B_PRIu32 "\n", info->id);
+		}
+	}
+
+	int compatibleLen;
+	const char* compatible = (const char*)fdt_getprop(fdt, node,
+		"compatible", &compatibleLen);
+	if (compatible == NULL) return;
+	if (HasFdtString(compatible, compatibleLen, "riscv,clint0")) {
+		GetReg(fdt, node, addressCells, sizeCells, 0, sClint);
+	} else if (
+		HasFdtString(compatible, compatibleLen, "riscv,plic0") ||
+		HasFdtString(compatible, compatibleLen, "sifive,plic-1.0.0")
+	) {
+		GetReg(fdt, node, addressCells, sizeCells, 0, sPlic);
+	} else if (
+		sUart.kind == kUartKindNone && (
+			HasFdtString(compatible, compatibleLen, "ns16550a") ||
+			HasFdtString(compatible, compatibleLen, "sifive,uart0") ||
+			HasFdtString(compatible, compatibleLen, "arm,pl011")
+		)
+	) {
+		if (HasFdtString(compatible, compatibleLen, "ns16550a"))
+			sUart.kind = kUartKind8250;
+		else if (HasFdtString(compatible, compatibleLen, "sifive,uart0"))
+			sUart.kind = kUartKindSifive;
+		else if (HasFdtString(compatible, compatibleLen, "arm,pl011"))
+			sUart.kind = kUartKindPl011;
+
+		GetReg(fdt, node, addressCells, sizeCells, 0, sUart.regs);
+		sUart.irq = GetInterrupt(fdt, node, interruptCells);
+		const void* prop = fdt_getprop(fdt, node, "clock-frequency", NULL);
+		sUart.clock = (prop == NULL) ? 0 : fdt32_to_cpu(*(uint32*)prop);
+
+		switch (sUart.kind) {
+			case kUartKind8250:
+				gUART = arch_get_uart_8250(sUart.regs.start, sUart.clock);
+				break;
+			case kUartKindSifive:
+				gUART = arch_get_uart_sifive(sUart.regs.start, sUart.clock);
+				break;
+			default:
+				;
+		}
+	
+		if (gUART != NULL)
+			gUART->InitEarly();
+	}
+}
+
+
 void
 dtb_init()
 {
@@ -56,17 +418,26 @@ dtb_init()
 
 		void* dtbPtr = (void*)(table[i].VendorTable);
 
-		uint32 fdtSize = 0;
-		if (!fdt_valid(dtbPtr, &fdtSize)) {
-			ERROR("Invalid FDT from UEFI table %d\n", i);
-			break;
-		} else {
-			INFO("Valid FDT from UEFI table %d (%d)\n", i, fdtSize);
+		int res = fdt_check_header(dtbPtr);
+		if (res != 0) {
+			ERROR("Invalid FDT from UEFI table %d: %s\n", i, fdt_strerror(res));
+			continue;
+		}
+
+		sDtbTable = dtbPtr;
+		sDtbSize = fdt_totalsize(dtbPtr);
+	
+		INFO("Valid FDT from UEFI table %d, size: %" B_PRIu32 "\n", i, sDtbSize);
 
-			sDtbTable = dtbPtr;
-			sDtbSize = fdtSize;
-			break;
+		if (false)
+			DumpFdt(sDtbTable);
+
+		int node = -1;
+		int depth = -1;
+		while ((node = fdt_next_node(sDtbTable, node, &depth)) >= 0 && depth >= 0) {
+			HandleFdt(sDtbTable, node, 2, 2, 1);
 		}
+		break;
 	}
 }
 
@@ -76,7 +447,7 @@ dtb_set_kernel_args()
 {
 	// pack into proper location if the architecture cares
 	if (sDtbTable != NULL) {
-		#ifdef __ARM__
+		#if defined(__ARM__) || defined(__riscv)
 		gKernelArgs.arch_args.fdt = kernel_args_malloc(sDtbSize);
 		if (gKernelArgs.arch_args.fdt != NULL)
 			memcpy(gKernelArgs.arch_args.fdt, sDtbTable, sDtbSize);
@@ -84,4 +455,32 @@ dtb_set_kernel_args()
 			ERROR("unable to malloc for fdt!\n");
 		#endif
 	}
+
+#ifdef __riscv
+	dprintf("bootHart: %" B_PRIu32 "\n", sBootHart);
+	gKernelArgs.arch_args.bootHart = sBootHart;
+	dprintf("timerFrequrency: %" B_PRIu64 "\n", sTimerFrequrency);
+	gKernelArgs.arch_args.timerFrequrency = sTimerFrequrency;
+
+//	gKernelArgs.arch_args.htif  = {.start = 0x40008000, .size = 0x10};
+	gKernelArgs.arch_args.htif  = {.start = 0, .size = 0};
+	gKernelArgs.arch_args.plic  = sPlic;
+	gKernelArgs.arch_args.clint = sClint;
+#endif
+#if defined(__ARM__) || defined(__riscv)
+	gKernelArgs.arch_args.uart  = sUart;
+	dprintf("UART:\n");
+	dprintf("  kind: ");
+	switch (sUart.kind) {
+		case kUartKindNone: dprintf("none"); break;
+		case kUartKind8250: dprintf("8250"); break;
+		case kUartKindSifive: dprintf("sifive"); break;
+		case kUartKindPl011: dprintf("pl011"); break;
+		default: ;
+	}
+	dprintf("\n");
+	dprintf("  regs: %#" B_PRIx64 ", %#" B_PRIx64 "\n", sUart.regs.start, sUart.regs.size);
+	dprintf("  irq: %" B_PRIu32 "\n", sUart.irq);
+	dprintf("  clock: %" B_PRIu64 "\n", sUart.clock);
+#endif
 }
diff --git a/src/system/boot/platform/efi/mmu.cpp b/src/system/boot/platform/efi/mmu.cpp
index 60461b6b89..f40a5f2770 100644
--- a/src/system/boot/platform/efi/mmu.cpp
+++ b/src/system/boot/platform/efi/mmu.cpp
@@ -124,7 +124,7 @@ platform_allocate_region(void **_address, size_t size, uint8 /* protection */,
 
 	memory_region *region = new(std::nothrow) memory_region {
 		next: allocated_regions,
-		vaddr: *_address == NULL ? 0 : (addr_t)*_address,
+		vaddr: 0 /* *_address == NULL ? 0 : (addr_t)*_address */,
 		paddr: (phys_addr_t)addr,
 		size: size
 	};
@@ -133,6 +133,7 @@ platform_allocate_region(void **_address, size_t size, uint8 /* protection */,
 		kBootServices->FreePages(addr, pages);
 		return B_NO_MEMORY;
 	}
+
 	//region->dprint("Allocated");
 	allocated_regions = region;
 	*_address = (void *)region->paddr;
@@ -269,3 +270,25 @@ platform_free_region(void *address, size_t size)
 	panic("platform_free_region: Unknown region to free??");
 	return B_ERROR; // NOT Reached
 }
+
+
+bool
+mmu_next_region(void** cookie, addr_t* vaddr, phys_addr_t* paddr, size_t* size)
+{
+	if (*cookie == NULL)
+		*cookie = &allocated_regions;
+	else
+		*cookie = ((memory_region*)*cookie)->next;
+
+	memory_region* region = (memory_region*)*cookie;
+	if (region == NULL)
+		return false;
+
+	if (region->vaddr == 0)
+		region->vaddr = get_next_virtual_address(region->size);
+
+	*vaddr = region->vaddr;
+	*paddr = region->paddr;
+	*size = region->size;
+	return true;
+}
diff --git a/src/system/boot/platform/efi/mmu.h b/src/system/boot/platform/efi/mmu.h
index afb237dd3f..bc56fdcca6 100644
--- a/src/system/boot/platform/efi/mmu.h
+++ b/src/system/boot/platform/efi/mmu.h
@@ -36,6 +36,8 @@ extern void mmu_init();
 
 extern phys_addr_t mmu_allocate_page();
 
+bool mmu_next_region(void** cookie, addr_t* vaddr, phys_addr_t* paddr, size_t* size);
+
 extern addr_t mmu_map_physical_memory(addr_t physicalAddress, size_t size,
 	uint32 flags);
 
diff --git a/src/system/boot/platform/efi/serial.cpp b/src/system/boot/platform/efi/serial.cpp
index 54f40ace57..f1deecf81d 100644
--- a/src/system/boot/platform/efi/serial.cpp
+++ b/src/system/boot/platform/efi/serial.cpp
@@ -12,6 +12,7 @@
 
 #include <boot/platform.h>
 #include <arch/cpu.h>
+#include <arch/generic/debug_uart.h>
 #include <boot/stage2.h>
 #include <boot/stdio.h>
 
@@ -41,18 +42,34 @@ enum serial_register_offsets {
 static uint16 sSerialBasePort = 0x3f8;
 
 
+DebugUART* gUART = NULL;
+
+
 static void
 serial_putc(char ch)
 {
 	if (!sSerialEnabled)
 		return;
 
+	if (sSerialUsesEFI) {
+		char16_t ucsBuffer[2];
+		ucsBuffer[0] = ch;
+		ucsBuffer[1] = 0;
+		kSystemTable->ConOut->OutputString(kSystemTable->ConOut, ucsBuffer);
+		return;
+	}
+
 	if (sSerialUsesEFI) {
 		size_t bufSize = 1;
 		sSerial->Write(sSerial, &bufSize, &ch);
 		return;
 	}
 
+	if (gUART != NULL) {
+		gUART->PutChar(ch);
+		return;
+	}
+
 	#if defined(__x86__) || defined(__x86_64__)
 	while ((in8(sSerialBasePort + SERIAL_LINE_STATUS) & 0x20) == 0)
 		asm volatile ("pause;");
@@ -65,7 +82,7 @@ serial_putc(char ch)
 extern "C" void
 serial_puts(const char* string, size_t size)
 {
-	if (!sSerialEnabled || (sSerial == NULL && sSerialUsesEFI))
+	if (!sSerialEnabled /*|| (sSerial == NULL && sSerialUsesEFI)*/)
 		return;
 
 	while (size-- != 0) {
@@ -118,13 +135,13 @@ serial_init(void)
 }
 
 
-#if defined(__x86__) || defined(__x86_64__)
 extern "C" void
 serial_switch_to_legacy(void)
 {
 	sSerial = NULL;
 	sSerialUsesEFI = false;
 
+#if defined(__x86__) || defined(__x86_64__)
 	memset(gKernelArgs.platform_args.serial_base_ports, 0,
 		sizeof(uint16) * MAX_SERIAL_PORTS);
 
@@ -138,5 +155,5 @@ serial_switch_to_legacy(void)
 	out8(divisor >> 8, sSerialBasePort + SERIAL_DIVISOR_LATCH_HIGH);
 	out8(3, sSerialBasePort + SERIAL_LINE_CONTROL);
 		// 8N1
-}
 #endif
+}
diff --git a/src/system/boot/platform/efi/serial.h b/src/system/boot/platform/efi/serial.h
index 14fd158428..3b5be8a36d 100644
--- a/src/system/boot/platform/efi/serial.h
+++ b/src/system/boot/platform/efi/serial.h
@@ -9,6 +9,10 @@
 #include <SupportDefs.h>
 
 
+class DebugUART;
+extern DebugUART* gUART;
+
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/src/system/boot/platform/efi/start.cpp b/src/system/boot/platform/efi/start.cpp
index 11659feb3d..406e99583d 100644
--- a/src/system/boot/platform/efi/start.cpp
+++ b/src/system/boot/platform/efi/start.cpp
@@ -12,6 +12,7 @@
 #include <KernelExport.h>
 
 #include <arch/cpu.h>
+#include <arch_cpu_defs.h>
 #include <kernel.h>
 
 #include <boot/kernel_args.h>
@@ -50,6 +51,11 @@ extern "C" void _start(void);
 extern "C" void efi_enter_kernel(uint64 pml4, uint64 entry_point, uint64 stack);
 
 
+#ifdef __riscv
+addr_t gStackBase;
+#endif
+
+
 static void
 call_ctors(void)
 {
@@ -142,20 +148,53 @@ get_kernel_entry(void)
 }
 
 
+static void
+get_kernel_regions(addr_range& text, addr_range& data)
+{
+	if (gKernelArgs.kernel_image->elf_class == ELFCLASS64) {
+		preloaded_elf64_image *image = static_cast<preloaded_elf64_image *>(
+			gKernelArgs.kernel_image.Pointer());
+		text.start = image->text_region.start;
+		text.size = image->text_region.size;
+		data.start = image->data_region.start;
+		data.size = image->data_region.size;
+		return;
+	} else if (gKernelArgs.kernel_image->elf_class == ELFCLASS32) {
+		preloaded_elf32_image *image = static_cast<preloaded_elf32_image *>(
+			gKernelArgs.kernel_image.Pointer());
+		text.start = image->text_region.start;
+		text.size = image->text_region.size;
+		data.start = image->data_region.start;
+		data.size = image->data_region.size;
+		return;
+	}
+	panic("Unknown kernel format! Not 32-bit or 64-bit!");
+}
+
+
 extern "C" void
 platform_start_kernel(void)
 {
+#ifdef __riscv
+	gKernelArgs.arch_args.platform1 = kPlatform1Sbi;
+	gKernelArgs.arch_args.platform2 = kPlatform2Efi;
+#endif
+
 	smp_init_other_cpus();
 	dtb_set_kernel_args();
 
 	addr_t kernelEntry = get_kernel_entry();
 
+	addr_range textRegion = {.start = 0, .size = 0}, dataRegion = {.start = 0, .size = 0};
+	get_kernel_regions(textRegion, dataRegion);
+	dprintf("kernel:\n");
+	dprintf("  text: %#" B_PRIx64 ", %#" B_PRIx64 "\n", textRegion.start, textRegion.size);
+	dprintf("  data: %#" B_PRIx64 ", %#" B_PRIx64 "\n", dataRegion.start, dataRegion.size);
+	dprintf("  entry: %#lx\n", kernelEntry);
+
 	arch_mmu_init();
 	convert_kernel_args();
 
-	// Save the kernel entry point address.
-	dprintf("kernel entry at %#lx\n", kernelEntry);
-
 	// map in a kernel stack
 	void *stack_address = NULL;
 	if (platform_allocate_region(&stack_address,
@@ -166,7 +205,7 @@ platform_start_kernel(void)
 	gKernelArgs.cpu_kstack[0].start = fix_address((addr_t)stack_address);
 	gKernelArgs.cpu_kstack[0].size = KERNEL_STACK_SIZE
 		+ KERNEL_STACK_GUARD_PAGES * B_PAGE_SIZE;
-	dprintf("Kernel stack at %#lx\n", gKernelArgs.cpu_kstack[0].start);
+	dprintf("Kernel stack at %#" B_PRIx64 "\n", gKernelArgs.cpu_kstack[0].start);
 
 	// Apply any weird EFI quirks
 	quirks_init();
@@ -194,6 +233,10 @@ platform_exit(void)
 extern "C" efi_status
 efi_main(efi_handle image, efi_system_table *systemTable)
 {
+#ifdef __riscv
+	gStackBase = Sp();
+#endif
+	
 	stage2_args args;
 
 	memset(&args, 0, sizeof(stage2_args));
diff --git a/src/system/boot/platform/efi/video.cpp b/src/system/boot/platform/efi/video.cpp
index 3c89b570f0..168dd825d8 100644
--- a/src/system/boot/platform/efi/video.cpp
+++ b/src/system/boot/platform/efi/video.cpp
@@ -161,6 +161,7 @@ platform_init_video(void)
 	efi_status status = kBootServices->LocateProtocol(&sGraphicsOutputGuid,
 		NULL, (void **)&sGraphicsOutput);
 	if (sGraphicsOutput == NULL || status != EFI_SUCCESS) {
+		dprintf("GOP protocol not found\n");
 		gKernelArgs.frame_buffer.enabled = false;
 		sGraphicsOutput = NULL;
 		return B_ERROR;
-- 
2.30.2

