From a030f5da0aec3efc442d12c7c78112e53c072a07 Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Mon, 26 Jul 2021 02:58:57 +0900
Subject: kernel/arch/thread: implement for riscv64 (2)

Change-Id: I2f3a3604d8eb8ea6ac481d985485d9e5b5a1820b
---
 .../kernel/arch/riscv64/arch_thread.cpp       | 39 ++++++++++++-------
 1 file changed, 25 insertions(+), 14 deletions(-)

diff --git a/src/system/kernel/arch/riscv64/arch_thread.cpp b/src/system/kernel/arch/riscv64/arch_thread.cpp
index 2a17506e9e..fc9ea69ba6 100644
--- a/src/system/kernel/arch/riscv64/arch_thread.cpp
+++ b/src/system/kernel/arch/riscv64/arch_thread.cpp
@@ -55,20 +55,29 @@ arch_thread_init_thread_struct(Thread *thread)
 }
 
 
+static inline VMAddressSpace*
+GetThreadAddressSpace(Thread* thread)
+{
+/*
+	if (thread->team == team_get_kernel_team())
+		return VMAddressSpace::Kernel();
+*/
+	return thread->team->address_space;
+}
+
+
 void
 arch_thread_init_kthread_stack(Thread* thread, void* _stack, void* _stackTop,
 	void (*function)(void*), const void* data)
 {
-	dprintf("arch_thread_init_kthread_stack(%p(%s))\n", thread, thread->name);
+	// dprintf("arch_thread_init_kthread_stack(%p(%s))\n", thread, thread->name);
 	memset(&thread->arch_info.context, 0, sizeof(arch_context));
 	thread->arch_info.context.sp = (addr_t)_stackTop;
 	thread->arch_info.context.s[0] = 0; // fp
 	thread->arch_info.context.s[1] = (addr_t)function;
 	thread->arch_info.context.s[2] = (addr_t)data;
 	thread->arch_info.context.ra = (addr_t)arch_thread_entry;
-	VMTranslationMap* map = (thread->team == team_get_kernel_team())
-		? VMAddressSpace::Kernel()->TranslationMap()
-		: thread->team->address_space->TranslationMap();
+	VMTranslationMap* map = GetThreadAddressSpace(thread)->TranslationMap();
 	thread->arch_info.context.satp = ((RISCV64VMTranslationMap*)map)->Satp();
 }
 
@@ -98,9 +107,9 @@ arch_thread_context_switch(Thread *from, Thread *to)
 	dprintf("arch_thread_context_switch(%p(%s), %p(%s))\n", from, from->name,
 		to, to->name);
 	*/
+	// TODO: save/restore FPU only if needed
+	save_fpu(&from->arch_info.fpuContext);
 	if (arch_setjmp(&from->arch_info.context) == 0) {
-		// TODO: save/restore FPU only if needed
-		save_fpu(&from->arch_info.fpuContext);
 		arch_longjmp(&to->arch_info.context, 1);
 	} else {
 		restore_fpu(&from->arch_info.fpuContext);
@@ -118,7 +127,7 @@ status_t
 arch_thread_enter_userspace(Thread *thread, addr_t entry, void *arg1,
 	void *arg2)
 {
-	dprintf("arch_thread_enter_uspace()\n");
+	// dprintf("arch_thread_enter_uspace()\n");
 
 	disable_interrupts();
 	if (arch_setjmp(&thread->arch_info.context) == 0) {
@@ -177,7 +186,7 @@ status_t
 arch_setup_signal_frame(Thread *thread, struct sigaction *sa,
 	struct signal_frame_data *signalFrameData)
 {
-	dprintf("arch_setup_signal_frame()\n");
+	// dprintf("arch_setup_signal_frame()\n");
 	iframe* frame = thread->arch_info.userFrame;
 
 	// fill signal context
@@ -218,7 +227,7 @@ arch_setup_signal_frame(Thread *thread, struct sigaction *sa,
 	// end of fill signal context
 
 	signal_get_user_stack(frame->sp, &signalFrameData->context.uc_stack);
-
+/*
 	dprintf("  thread->signal_stack_enabled: %d\n",
 		thread->signal_stack_enabled);
 	if (thread->signal_stack_enabled) {
@@ -227,17 +236,17 @@ arch_setup_signal_frame(Thread *thread, struct sigaction *sa,
 			thread->signal_stack_base + thread->signal_stack_size
 		);
 	}
-
+*/
 	uint8* userStack = get_signal_stack(thread, frame, sa,
 		sizeof(*signalFrameData));
-	dprintf("  user stack: 0x%" B_PRIxADDR "\n", (addr_t)userStack);
+	// dprintf("  user stack: 0x%" B_PRIxADDR "\n", (addr_t)userStack);
 	status_t res = user_memcpy(userStack, signalFrameData,
 		sizeof(*signalFrameData));
 	if (res < B_OK)
 		return res;
 
 	addr_t commpageAdr = (addr_t)thread->team->commpage_address;
-	dprintf("  commpageAdr: 0x%" B_PRIxADDR "\n", commpageAdr);
+	// dprintf("  commpageAdr: 0x%" B_PRIxADDR "\n", commpageAdr);
 	addr_t signalHandlerAddr;
 	ASSERT(user_memcpy(&signalHandlerAddr,
 		&((addr_t*)commpageAdr)[COMMPAGE_ENTRY_RISCV64_SIGNAL_HANDLER],
@@ -258,7 +267,7 @@ arch_setup_signal_frame(Thread *thread, struct sigaction *sa,
 int64
 arch_restore_signal_frame(struct signal_frame_data* signalFrameData)
 {
-	dprintf("arch_restore_signal_frame()\n");
+	// dprintf("arch_restore_signal_frame()\n");
 	iframe* frame = thread_get_current_thread()->arch_info.userFrame;
 
 	frame->ra  = signalFrameData->context.uc_mcontext.x[ 0];
@@ -314,10 +323,12 @@ arch_check_syscall_restart(Thread *thread)
 void
 arch_store_fork_frame(struct arch_fork_arg *arg)
 {
+/*
 	dprintf("arch_store_fork_frame()\n");
 	dprintf("  arg: %p\n", arg);
 	dprintf("  userFrame: %p\n",
 		thread_get_current_thread()->arch_info.userFrame);
+*/
 	memcpy(&arg->frame, thread_get_current_thread()->arch_info.userFrame,
 		sizeof(iframe));
 	arg->frame.a0 = 0; // fork return value
@@ -335,7 +346,7 @@ arch_store_fork_frame(struct arch_fork_arg *arg)
 void
 arch_restore_fork_frame(struct arch_fork_arg *arg)
 {
-	dprintf("arch_restore_fork_frame(%p)\n", arg);
+	// dprintf("arch_restore_fork_frame(%p)\n", arg);
 	disable_interrupts();
 	if (arch_setjmp(&thread_get_current_thread()->arch_info.context) == 0) {
 		SstatusReg status(Sstatus());
-- 
2.30.2

