From 96a452e4815255c08711a9926da89626e8d6f927 Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Fri, 24 Jan 2020 08:30:48 +0900
Subject: Interface kit: rewrite menu logic by using input events

WIP, DON'T MERGE

Keyboard navigation is implemented:
* Alt+Esc opens menu.
* Arrow keys are used to move to previous/next item and enter/leave submenu.
* Character key invoke or enter item with underlined character.
* Enter invoke menu, Esc leave current menu.

TODO:
* Fix freeze when dymanically building submenu.
* Implement navigation area timeout.
* Menu is still sometimes displayed when not ready.

Fixes #1621, #3259, #4335, #7182.

Change-Id: Ia693570e9bf4cbea33cd7d71bd5e7249c089959f
---
 headers/os/interface/Menu.h             |  27 +-
 headers/private/interface/MenuPrivate.h |  35 +-
 headers/private/interface/MenuWindow.h  |   2 -
 src/kits/interface/BMCPrivate.cpp       |   6 +
 src/kits/interface/Menu.cpp             | 929 +++++++++++++-----------
 src/kits/interface/MenuBar.cpp          | 140 +---
 src/kits/interface/MenuField.cpp        |   7 +-
 src/kits/interface/MenuPrivate.cpp      |   6 +-
 src/kits/interface/MenuWindow.cpp       | 137 ++--
 src/kits/interface/PopUpMenu.cpp        |  10 -
 10 files changed, 677 insertions(+), 622 deletions(-)

diff --git a/headers/os/interface/Menu.h b/headers/os/interface/Menu.h
index 017cbe0242..625287701f 100644
--- a/headers/os/interface/Menu.h
+++ b/headers/os/interface/Menu.h
@@ -17,6 +17,7 @@ class BMenuItem;
 
 
 namespace BPrivate {
+	class MenuTrackState;
 	class BMenuWindow;
 	class ExtraMenuData;
 	class TriggerList;
@@ -188,10 +189,9 @@ private:
 			BMenu&				operator=(const BMenu& other);
 
 			void				_InitData(BMessage* archive);
-			bool				_Show(bool selectFirstItem = false,
-									bool keyDown = false);
+			bool				_Show(bool selectFirstItem = false);
 			void				_Hide();
-			BMenuItem*			_Track(int* action, long start = -1);
+			BMenuItem*			_Track(int32* action, int32 start = -1);
 			void				_ScriptReceived(BMessage* message);
 			void				_ItemScriptReceived(BMessage* message,
 									BMenuItem* item);
@@ -206,14 +206,12 @@ private:
 									BRect& navAreaRectAbove,
 									BRect& navAreaBelow);
 
+			bool				_HitNavigationArea(BPoint position, BMenuItem* item);
+
 			void				_UpdateStateOpenSelect(BMenuItem* item,
 									BPoint position, BRect& navAreaRectAbove,
 									BRect& navAreaBelow,
-									bigtime_t& selectedTime,
-									bigtime_t& navigationAreaTime);
-			void				_UpdateStateClose(BMenuItem* item,
-									const BPoint& where,
-									const uint32& buttons);
+									bool isTimeout);
 
 			bool				_AddItem(BMenuItem* item, int32 index);
 			bool				_RemoveItems(int32 index, int32 count,
@@ -250,8 +248,7 @@ private:
 			void				_Uninstall();
 			void				_SelectItem(BMenuItem* item,
 									bool showSubmenu = true,
-									bool selectFirstItem = false,
-									bool keyDown = false);
+									bool selectFirstItem = false);
 			bool				_SelectNextItem(BMenuItem* item, bool forward);
 			BMenuItem*			_NextItem(BMenuItem* item, bool forward) const;
 			void				_SetIgnoreHidden(bool ignoreHidden)
@@ -271,13 +268,11 @@ private:
 									uint32& trigger,
 									BPrivate::TriggerList& triggers);
 			void				_UpdateWindowViewSize(const bool &updatePosition);
-			bool				_AddDynamicItems(bool keyDown = false);
-			bool				_OkToProceed(BMenuItem* item,
-									bool keyDown = false);
+			bool				_AddDynamicItems();
+			bool				_OkToProceed(BMenuItem* item);
 
-			bool				_CustomTrackingWantsToQuit();
+			void				_CallTrackingHook();
 
-			int					_State(BMenuItem** _item = NULL) const;
 			void				_InvokeItem(BMenuItem* item, bool now = false);
 			void				_QuitTracking(bool onlyThis = true);
 
@@ -291,7 +286,7 @@ private:
 	static	uint32				sCommandKey;
 	static	uint32				sMenuKey;
 
-			BMenuItem*			fChosenItem;
+			BPrivate::MenuTrackState* fTrackState;
 			BList				fItems;
 			BRect				fPad;
 			BMenuItem*			fSelected;
diff --git a/headers/private/interface/MenuPrivate.h b/headers/private/interface/MenuPrivate.h
index 4627b701ed..64bf3f2359 100644
--- a/headers/private/interface/MenuPrivate.h
+++ b/headers/private/interface/MenuPrivate.h
@@ -11,14 +11,18 @@
 
 
 #include <Menu.h>
+#include <MessageRunner.h>
+#include <Locker.h>
 
+#include <AutoDeleter.h>
 
-enum menu_states {
-	MENU_STATE_TRACKING = 0,
-	MENU_STATE_TRACKING_SUBMENU = 1,
-	MENU_STATE_KEY_TO_SUBMENU = 2,
-	MENU_STATE_KEY_LEAVE_SUBMENU = 3,
-	MENU_STATE_CLOSED = 5
+
+enum menu_track_command {
+	MENU_TRACK_CMD_DONE
+};
+
+enum {
+	navigationAreaTimeoutMsg = 'nvat',
 };
 
 
@@ -48,7 +52,7 @@ public:
 									const;
 			void				SetItemMargins(float, float, float, float);
 
-			int					State(BMenuItem** item = NULL) const;
+			bool				IsTracking() const;
 
 			void				Install(BWindow* window);
 			void				Uninstall();
@@ -78,6 +82,23 @@ private:
 
 };
 
+struct MenuTrackState {
+	thread_id trackThread;
+	BLocker locker;
+	bool quit;
+	BMenu* rootMenu;
+	BMenu* curMenu;
+	BMenu* cursorMenu; // menu that holding pointer event mask
+	BMenuItem* invokedItem;
+	bool cursorInside, cursorObscured;
+	BPoint clickPoint, enterPoint;
+	BRect navAreaRectAbove;
+	BRect navAreaRectBelow;
+	bigtime_t selectedTime;
+	bigtime_t navigationAreaTime;
+	ObjectDeleter<BMessageRunner> navigationAreaTimer;
+};
+
 };	// namespace BPrivate
 
 
diff --git a/headers/private/interface/MenuWindow.h b/headers/private/interface/MenuWindow.h
index eb1b943c9d..c409bd4c54 100644
--- a/headers/private/interface/MenuWindow.h
+++ b/headers/private/interface/MenuWindow.h
@@ -38,12 +38,10 @@ public:
 			void			SetSmallStep(float step);
 			void			GetSteps(float* _smallStep, float* _largeStep) const;
 			bool			HasScrollers() const;
-			bool			CheckForScrolling(const BPoint& cursor);
 			bool			TryScrollBy(const float& step);
 			bool			TryScrollTo(const float& where);
 
 private:
-			bool			_Scroll(const BPoint& cursor);
 			void			_ScrollBy(const float& step);
 
 			BMenu*			fMenu;
diff --git a/src/kits/interface/BMCPrivate.cpp b/src/kits/interface/BMCPrivate.cpp
index 6e6ca327e4..537cb00c33 100644
--- a/src/kits/interface/BMCPrivate.cpp
+++ b/src/kits/interface/BMCPrivate.cpp
@@ -21,6 +21,8 @@
 #include <MessageRunner.h>
 #include <Window.h>
 
+#include <MenuPrivate.h>
+
 
 static const float kPopUpIndicatorWidth = 13.0f;
 
@@ -76,6 +78,10 @@ _BMCFilter_::~_BMCFilter_()
 filter_result
 _BMCFilter_::Filter(BMessage* message, BHandler** handler)
 {
+	BPrivate::MenuPrivate menuPrivate(fMenuField->MenuBar());
+	if (menuPrivate.IsTracking())
+		return B_DISPATCH_MESSAGE;
+
 	if (message->what == B_MOUSE_DOWN) {
 		if (BView* view = dynamic_cast<BView*>(*handler)) {
 			BPoint point;
diff --git a/src/kits/interface/Menu.cpp b/src/kits/interface/Menu.cpp
index 81ce64624d..1ddc385aed 100644
--- a/src/kits/interface/Menu.cpp
+++ b/src/kits/interface/Menu.cpp
@@ -39,6 +39,7 @@
 #include <SystemCatalog.h>
 #include <UnicodeChar.h>
 #include <Window.h>
+#include <AutoLocker.h>
 
 #include <AppServerLink.h>
 #include <AutoDeleter.h>
@@ -53,6 +54,8 @@
 
 #define USE_CACHED_MENUWINDOW 1
 
+#define SHOW_NAVIGATION_AREA 0
+
 using BPrivate::gSystemCatalog;
 
 #undef B_TRANSLATION_CONTEXT
@@ -227,7 +230,7 @@ struct BMenu::LayoutData {
 BMenu::BMenu(const char* name, menu_layout layout)
 	:
 	BView(BRect(0, 0, 0, 0), name, 0, B_WILL_DRAW),
-	fChosenItem(NULL),
+	fTrackState(NULL),
 	fSelected(NULL),
 	fCachedMenuWindow(NULL),
 	fSuper(NULL),
@@ -235,7 +238,6 @@ BMenu::BMenu(const char* name, menu_layout layout)
 	fAscent(-1.0f),
 	fDescent(-1.0f),
 	fFontHeight(-1.0f),
-	fState(MENU_STATE_CLOSED),
 	fLayout(layout),
 	fExtraRect(NULL),
 	fMaxContentWidth(0.0f),
@@ -264,7 +266,7 @@ BMenu::BMenu(const char* name, menu_layout layout)
 BMenu::BMenu(const char* name, float width, float height)
 	:
 	BView(BRect(0.0f, 0.0f, 0.0f, 0.0f), name, 0, B_WILL_DRAW),
-	fChosenItem(NULL),
+	fTrackState(NULL),
 	fPad(14.0f, 2.0f, 20.0f, 0.0f),
 	fSelected(NULL),
 	fCachedMenuWindow(NULL),
@@ -273,7 +275,6 @@ BMenu::BMenu(const char* name, float width, float height)
 	fAscent(-1.0f),
 	fDescent(-1.0f),
 	fFontHeight(-1.0f),
-	fState(0),
 	fLayout(B_ITEMS_IN_MATRIX),
 	fExtraRect(NULL),
 	fMaxContentWidth(0.0f),
@@ -299,7 +300,7 @@ BMenu::BMenu(const char* name, float width, float height)
 BMenu::BMenu(BMessage* archive)
 	:
 	BView(archive),
-	fChosenItem(NULL),
+	fTrackState(NULL),
 	fPad(14.0f, 2.0f, 20.0f, 0.0f),
 	fSelected(NULL),
 	fCachedMenuWindow(NULL),
@@ -308,7 +309,6 @@ BMenu::BMenu(BMessage* archive)
 	fAscent(-1.0f),
 	fDescent(-1.0f),
 	fFontHeight(-1.0f),
-	fState(MENU_STATE_CLOSED),
 	fLayout(B_ITEMS_IN_ROW),
 	fExtraRect(NULL),
 	fMaxContentWidth(0.0f),
@@ -402,14 +402,7 @@ BMenu::AttachedToWindow()
 	_GetOptionKey(sOptionKey);
 	_GetMenuKey(sMenuKey);
 
-	// The menu should be added to the menu hierarchy and made visible if:
-	// * the mouse is over the menu,
-	// * the user has requested the menu via the keyboard.
-	// So if we don't pass keydown in here, keyboard navigation breaks since
-	// fAttachAborted will return false if the mouse isn't over the menu
-	bool keyDown = Supermenu() != NULL
-		? Supermenu()->fState == MENU_STATE_KEY_TO_SUBMENU : false;
-	fAttachAborted = _AddDynamicItems(keyDown);
+	fAttachAborted = _AddDynamicItems();
 
 	if (!fAttachAborted) {
 		_CacheFontInfo();
@@ -450,15 +443,43 @@ BMenu::Draw(BRect updateRect)
 
 	DrawBackground(updateRect);
 	DrawItems(updateRect);
+
+	#if SHOW_NAVIGATION_AREA
+	if (fTrackState != NULL) {
+		BRect above, below;
+		{
+			AutoLocker<BLocker> locker(fTrackState->locker);
+			above = ConvertFromScreen(fTrackState->navAreaRectAbove);
+			below = ConvertFromScreen(fTrackState->navAreaRectBelow);
+		}
+		bool isLeft = above.left == 0;
+		PushState();
+		SetDrawingMode(B_OP_ALPHA);
+		SetHighColor(0xff, 0, 0, 0x66);
+		if (!isLeft) {
+			FillTriangle(above.LeftBottom(), above.RightTop(), above.RightBottom());
+			FillTriangle(below.LeftTop(), below.RightBottom(), above.RightTop());
+		} else {
+			FillTriangle(above.RightBottom(), above.LeftTop(), above.LeftBottom());
+			FillTriangle(below.RightTop(), below.LeftBottom(), above.LeftTop());
+		}
+		PopState();
+	}
+	#endif
 }
 
 
+const static bigtime_t kNavigationAreaTimeout = 1000000;
+
 void
 BMenu::MessageReceived(BMessage* message)
 {
 	if (message->HasSpecifiers())
 		return _ScriptReceived(message);
 
+	if (fTrackState == NULL)
+		return BView::MessageReceived(message);
+
 	switch (message->what) {
 		case B_MOUSE_WHEEL_CHANGED:
 		{
@@ -485,6 +506,159 @@ BMenu::MessageReceived(BMessage* message)
 			break;
 		}
 
+		case B_MOUSE_DOWN: {
+			printf("B_MOUSE_DOWN, _IsStickyMode: %d\n", _IsStickyMode());
+			BPoint where = B_ORIGIN;
+			message->FindPoint("be:view_where", &where);
+			{
+				AutoLocker<BLocker> locker(fTrackState->locker);
+				if (!fTrackState->cursorInside) {
+					_QuitTracking(false);
+					BView::MessageReceived(message);
+					return;
+				}
+			}
+			if (_IsStickyMode())
+				_SetStickyMode(false);
+
+			_CallTrackingHook();
+
+			BView::MessageReceived(message);
+			break;
+		}
+
+		case B_MOUSE_UP: {
+			printf("B_MOUSE_UP, _IsStickyMode: %d\n", _IsStickyMode());
+			BPoint where = B_ORIGIN;
+			message->FindPoint("be:view_where", &where);
+			BMenuItem* item = _HitTestItems(where, B_ORIGIN);
+			if (
+				!_IsStickyMode() || (
+					!(fExtraRect != NULL && fExtraRect->Contains(where)) &&
+					dynamic_cast<BMenuWindow*>(Window()) == NULL &&
+					(item == NULL || item->Submenu() == NULL)
+				)
+			) {
+				if (item != NULL) _InvokeItem(item);
+				_QuitTracking(false);
+			}
+			_CallTrackingHook();
+			BView::MessageReceived(message);
+			break;
+		}
+
+		case B_MOUSE_MOVED: {
+			BPoint where = B_ORIGIN;
+			int32 buttons = 0;
+			int32 transit = B_OUTSIDE_VIEW;
+
+			message->FindPoint("be:view_where", &where);
+			message->FindInt32("buttons", &buttons);
+			message->FindInt32("be:transit", &transit);
+
+			if (fTrackState == NULL) {
+				BView::MessageReceived(message);
+				return;
+			}
+
+			{
+				AutoLocker<BLocker> locker(fTrackState->locker);
+
+				BRect checkRect(-8, -8, 8, 8);
+				checkRect.OffsetBy(fTrackState->clickPoint);
+
+				if (_IsStickyMode() && !checkRect.Contains(ConvertToScreen(where))) {
+					printf("outside of checkRect\n");
+					_SetStickyMode(false);
+				}
+
+				switch (transit) {
+					case B_ENTERED_VIEW:
+						fTrackState->cursorMenu = this;
+						fTrackState->cursorMenu->SetEventMask(B_POINTER_EVENTS, 0);
+						fTrackState->cursorInside = true;
+						break;
+					case B_EXITED_VIEW:
+						if (fTrackState->cursorMenu == this)
+							fTrackState->cursorInside = false;
+
+						if ((fSelected != NULL) && (fSelected->Submenu() == NULL))
+							_SelectItem(NULL);
+
+						break;
+				}
+
+				if (fTrackState->cursorMenu != this)
+					SetEventMask(0, 0);
+			}
+
+			switch (transit) {
+				case B_ENTERED_VIEW:
+				case B_INSIDE_VIEW: {
+					{
+						AutoLocker<BLocker> locker(fTrackState->locker);
+						if (fTrackState->cursorObscured) {
+							if (transit == B_ENTERED_VIEW) {
+								fTrackState->enterPoint = where;
+								break;
+							}
+							if (fTrackState->enterPoint == where)
+								break;
+
+							fTrackState->cursorObscured = false;
+						}
+					}
+					BMenuItem* oldSelected = fSelected;
+					BMenuItem* item = _HitTestItems(where, B_ORIGIN);
+					if (item == NULL) {
+						if ((fSelected != NULL) && (fSelected->Submenu() == NULL))
+							_SelectItem(NULL);
+					} else if (fSelected != item) {
+						if (!_HitNavigationArea(where, item)) {
+							fTrackState->navigationAreaTimer.Unset();
+							_SelectItem(item, true);
+						} else {
+							if (fTrackState->navigationAreaTimer.Get() != NULL)
+								fTrackState->navigationAreaTimer.SetTo(new(std::nothrow) BMessageRunner(BMessenger(this), BMessage(navigationAreaTimeoutMsg), kNavigationAreaTimeout, 1));
+						}
+					}
+					{
+						AutoLocker<BLocker> locker(fTrackState->locker);
+						if (oldSelected != fSelected)
+							fTrackState->curMenu = this;
+					}
+					break;
+				}
+			}
+
+			_CallTrackingHook();
+
+			BView::MessageReceived(message);
+			break;
+		}
+		
+		case navigationAreaTimeoutMsg: {
+			if (fTrackState->navigationAreaTimer.Get() != NULL) {
+				fTrackState->navigationAreaTimer.Unset();
+				BPoint where;
+				GetMouse(&where, NULL);
+				BMenuItem* oldSelected = fSelected;
+				BMenuItem* item = _HitTestItems(where, B_ORIGIN);
+				if (item == NULL) {
+					if ((fSelected != NULL) && (fSelected->Submenu() == NULL))
+						_SelectItem(NULL);
+				} else
+					_SelectItem(item, true);
+
+				{
+					AutoLocker<BLocker> locker(fTrackState->locker);
+					if (oldSelected != fSelected)
+						fTrackState->curMenu = this;
+				}
+			}
+			break;
+		}
+
 		default:
 			BView::MessageReceived(message);
 			break;
@@ -495,64 +669,63 @@ BMenu::MessageReceived(BMessage* message)
 void
 BMenu::KeyDown(const char* bytes, int32 numBytes)
 {
-	// TODO: Test how it works on BeOS R5 and implement this correctly
+	if (fTrackState == NULL)
+		return;
+
+	AutoLocker<BLocker> locker(fTrackState->locker);
+
+	if (fTrackState->curMenu != this) {
+		BMessenger messenger(fTrackState->curMenu);
+		messenger.SendMessage(Window()->CurrentMessage());
+		return;
+	}
+
+	fTrackState->cursorObscured = true;
+	be_app->ObscureCursor();
+
 	switch (bytes[0]) {
 		case B_UP_ARROW:
-			if (fLayout == B_ITEMS_IN_COLUMN)
+			if (fLayout == B_ITEMS_IN_COLUMN) {
 				_SelectNextItem(fSelected, false);
+			} else if (fLayout == B_ITEMS_IN_ROW || fLayout == B_ITEMS_IN_MATRIX) {
+				_QuitTracking(true);
+			}
 			break;
 
 		case B_DOWN_ARROW:
-		{
-			BMenuBar* bar = dynamic_cast<BMenuBar*>(Supermenu());
-			if (bar != NULL && fState == MENU_STATE_CLOSED) {
-				// tell MenuBar's _Track:
-				bar->fState = MENU_STATE_KEY_TO_SUBMENU;
-			}
-			if (fLayout == B_ITEMS_IN_COLUMN)
+			if (fLayout == B_ITEMS_IN_COLUMN) {
 				_SelectNextItem(fSelected, true);
+			} else if (fLayout == B_ITEMS_IN_ROW || fLayout == B_ITEMS_IN_MATRIX) {
+				if (fSelected != NULL) {
+					BMenu* subMenu = fSelected->Submenu();
+					if (subMenu != NULL && subMenu->LockLooper()) {
+						subMenu->_SelectNextItem(subMenu->fSelected, true);
+						subMenu->UnlockLooper();
+						fTrackState->curMenu = subMenu;
+					}
+				}
+			}
 			break;
-		}
 
 		case B_LEFT_ARROW:
-			if (fLayout == B_ITEMS_IN_ROW)
+			if (fLayout == B_ITEMS_IN_ROW || fLayout == B_ITEMS_IN_MATRIX) {
 				_SelectNextItem(fSelected, false);
-			else {
-				// this case has to be handled a bit specially.
-				BMenuItem* item = Superitem();
-				if (item) {
-					if (dynamic_cast<BMenuBar*>(Supermenu())) {
-						// If we're at the top menu below the menu bar, pass
-						// the keypress to the menu bar so we can move to
-						// another top level menu.
-						BMessenger messenger(Supermenu());
-						messenger.SendMessage(Window()->CurrentMessage());
-					} else {
-						// tell _Track
-						fState = MENU_STATE_KEY_LEAVE_SUBMENU;
-					}
-				}
+			} else if (fLayout == B_ITEMS_IN_COLUMN) {
+				_QuitTracking(true);
 			}
 			break;
 
 		case B_RIGHT_ARROW:
-			if (fLayout == B_ITEMS_IN_ROW)
+			if (fLayout == B_ITEMS_IN_ROW || fLayout == B_ITEMS_IN_MATRIX) {
 				_SelectNextItem(fSelected, true);
-			else {
-				if (fSelected != NULL && fSelected->Submenu() != NULL) {
-					fSelected->Submenu()->_SetStickyMode(true);
-						// fix me: this shouldn't be needed but dynamic menus
-						// aren't getting it set correctly when keyboard
-						// navigating, which aborts the attach
-					fState = MENU_STATE_KEY_TO_SUBMENU;
-					_SelectItem(fSelected, true, true, true);
-				} else if (dynamic_cast<BMenuBar*>(Supermenu())) {
-					// if we have no submenu and we're an
-					// item in the top menu below the menubar,
-					// pass the keypress to the menubar
-					// so you can use the keypress to switch menus.
-					BMessenger messenger(Supermenu());
-					messenger.SendMessage(Window()->CurrentMessage());
+			} else if (fLayout == B_ITEMS_IN_COLUMN) {
+				if (fSelected != NULL) {
+					BMenu* subMenu = fSelected->Submenu();
+					if (subMenu != NULL && subMenu->LockLooper()) {
+						subMenu->_SelectNextItem(subMenu->fSelected, true);
+						subMenu->UnlockLooper();
+						fTrackState->curMenu = subMenu;
+					}
 				}
 			}
 			break;
@@ -575,21 +748,13 @@ BMenu::KeyDown(const char* bytes, int32 numBytes)
 		case B_ENTER:
 		case B_SPACE:
 			if (fSelected != NULL) {
-				fChosenItem = fSelected;
-					// preserve for exit handling
+				_InvokeItem(fSelected);
 				_QuitTracking(false);
 			}
 			break;
 
 		case B_ESCAPE:
-			_SelectItem(NULL);
-			if (fState == MENU_STATE_CLOSED
-				&& dynamic_cast<BMenuBar*>(Supermenu())) {
-				// Keyboard may show menu without tracking it
-				BMessenger messenger(Supermenu());
-				messenger.SendMessage(Window()->CurrentMessage());
-			} else
-				_QuitTracking(false);
+			_QuitTracking(false);
 			break;
 
 		default:
@@ -601,8 +766,18 @@ BMenu::KeyDown(const char* bytes, int32 numBytes)
 				if (item->fTriggerIndex < 0 || item->fTrigger != trigger)
 					continue;
 
-				_InvokeItem(item);
-				_QuitTracking(false);
+				if (item->Submenu()) {
+					_SelectItem(item, true, false);
+					BMenu* subMenu = fSelected->Submenu();
+					if (subMenu != NULL && subMenu->LockLooper()) {
+						subMenu->_SelectNextItem(subMenu->fSelected, true);
+						subMenu->UnlockLooper();
+						fTrackState->curMenu = subMenu;
+					}
+				} else {
+					_InvokeItem(item);
+					_QuitTracking(false);
+				}
 				break;
 			}
 			break;
@@ -1279,7 +1454,7 @@ BMenu::BMenu(BRect frame, const char* name, uint32 resizingMode, uint32 flags,
 	menu_layout layout, bool resizeToFit)
 	:
 	BView(frame, name, resizingMode, flags),
-	fChosenItem(NULL),
+	fTrackState(NULL),
 	fSelected(NULL),
 	fCachedMenuWindow(NULL),
 	fSuper(NULL),
@@ -1287,7 +1462,6 @@ BMenu::BMenu(BRect frame, const char* name, uint32 resizingMode, uint32 flags,
 	fAscent(-1.0f),
 	fDescent(-1.0f),
 	fFontHeight(-1.0f),
-	fState(MENU_STATE_CLOSED),
 	fLayout(layout),
 	fExtraRect(NULL),
 	fMaxContentWidth(0.0f),
@@ -1382,7 +1556,7 @@ BMenu::Track(bool sticky, BRect* clickToOpenRect)
 
 	_SetStickyMode(sticky);
 
-	int action;
+	int32 action;
 	BMenuItem* menuItem = _Track(&action);
 
 	fExtraRect = NULL;
@@ -1498,7 +1672,7 @@ BMenu::_InitData(BMessage* archive)
 
 
 bool
-BMenu::_Show(bool selectFirstItem, bool keyDown)
+BMenu::_Show(bool selectFirstItem)
 {
 	if (Window() != NULL)
 		return false;
@@ -1525,17 +1699,6 @@ BMenu::_Show(bool selectFirstItem, bool keyDown)
 		return false;
 
 	if (window->Lock()) {
-		bool addAborted = false;
-		if (keyDown)
-			addAborted = _AddDynamicItems(keyDown);
-
-		if (addAborted) {
-			if (ourWindow)
-				window->Quit();
-			else
-				window->Unlock();
-			return false;
-		}
 		fAttachAborted = false;
 
 		window->AttachMenu(this);
@@ -1549,6 +1712,7 @@ BMenu::_Show(bool selectFirstItem, bool keyDown)
 
 		// Menu didn't have the time to add its items: aborting...
 		if (fAttachAborted) {
+			printf("fAttachAborted\n");
 			window->DetachMenu();
 			// TODO: Probably not needed, we can just let _hide() quit the
 			// window.
@@ -1562,6 +1726,11 @@ BMenu::_Show(bool selectFirstItem, bool keyDown)
 		_UpdateWindowViewSize(true);
 		window->Show();
 
+		if (Supermenu() != NULL) {
+			fTrackState = Supermenu()->fTrackState;
+			fTriggerEnabled = Supermenu()->fTriggerEnabled;
+		}
+
 		if (selectFirstItem)
 			_SelectItem(ItemAt(0), false);
 
@@ -1582,6 +1751,22 @@ BMenu::_Hide()
 	if (fSelected != NULL)
 		_SelectItem(NULL);
 
+	BMenu *rootMenu = NULL;
+	if (fTrackState != NULL) {
+		AutoLocker<BLocker> locker(fTrackState->locker);
+		if (fTrackState->cursorMenu == this) {
+			SetEventMask(0, 0);
+			rootMenu = fTrackState->rootMenu;
+			fTrackState->cursorMenu = rootMenu;
+		}
+	}
+	if (rootMenu != NULL && rootMenu->LockLooper()) {
+		rootMenu->SetEventMask(B_POINTER_EVENTS, 0);
+		rootMenu->UnlockLooper();
+	}
+
+	fTrackState = NULL;
+
 	window->Hide();
 	window->DetachMenu();
 		// we don't want to be deleted when the window is removed
@@ -1934,189 +2119,92 @@ status_t BMenu::_InsertItemAtSpecifier(const BMessage& specifier, int32 what,
 // #pragma mark - mouse tracking
 
 
-const static bigtime_t kOpenSubmenuDelay = 0;
-const static bigtime_t kNavigationAreaTimeout = 1000000;
-
-
 BMenuItem*
-BMenu::_Track(int* action, long start)
+BMenu::_Track(int32* action, int32 start)
 {
-	// TODO: cleanup
+	if (fTrackState != NULL) {
+		printf("Track: already entered\n");
+		return NULL;
+	}
+	printf("+Track\n");
+	printf("sticky: %d\n", fStickyMode);
+	if (fExtraRect != NULL) {
+		printf("extraRect: "); fExtraRect->PrintToStream();
+	}
+	if (sMenuInfo.click_to_open)
+		_SetStickyMode(true);
+	BPrivate::MenuTrackState trackState;
 	BMenuItem* item = NULL;
-	BRect navAreaRectAbove;
-	BRect navAreaRectBelow;
-	bigtime_t selectedTime = system_time();
-	bigtime_t navigationAreaTime = 0;
+	BMenuItem* startItem = ItemAt(start);
+	bool oldTriggerEnabled = fTriggerEnabled;
+	thread_id senderThread;
+	bool run = true;
+
+	fTrackState = &trackState;
+	fTrackState->trackThread = find_thread(NULL);
+	fTrackState->quit = false;
+	fTrackState->rootMenu = this;
+	fTrackState->curMenu = this;
+	fTrackState->cursorMenu = this;
+	fTrackState->invokedItem = NULL;
+	fTrackState->cursorInside = false;
+	fTrackState->cursorObscured = false;
+	fTrackState->navAreaRectAbove = BRect();
+	fTrackState->navAreaRectBelow = BRect();
+	//fTrackState->navigationAreaTimer = NULL;
 
-	fState = MENU_STATE_TRACKING;
-	fChosenItem = NULL;
-		// we will use this for keyboard selection
-
-	BPoint location;
-	uint32 buttons = 0;
 	if (LockLooper()) {
-		GetMouse(&location, &buttons);
-		UnlockLooper();
-	}
-
-	bool releasedOnce = buttons == 0;
-	while (fState != MENU_STATE_CLOSED) {
-		if (_CustomTrackingWantsToQuit())
-			break;
-
-		if (!LockLooper())
-			break;
-
-		BMenuWindow* window = static_cast<BMenuWindow*>(Window());
-		BPoint screenLocation = ConvertToScreen(location);
-		if (window->CheckForScrolling(screenLocation)) {
-			UnlockLooper();
-			continue;
+		SetEventMask(B_POINTER_EVENTS, 0);
+		BPoint where;
+		uint32 btns;
+		GetMouse(&where, &btns);
+		fTrackState->cursorInside = Bounds().Contains(where);
+		fTrackState->clickPoint = ConvertToScreen(where);
+		if (startItem == NULL) {
+			startItem = _HitTestItems(where, B_ORIGIN);
 		}
-
-		// The order of the checks is important
-		// to be able to handle overlapping menus:
-		// first we check if mouse is inside a submenu,
-		// then if the mouse is inside this menu,
-		// then if it's over a super menu.
-		if (_OverSubmenu(fSelected, screenLocation)
-			|| fState == MENU_STATE_KEY_TO_SUBMENU) {
-			if (fState == MENU_STATE_TRACKING) {
-				// not if from R.Arrow
-				fState = MENU_STATE_TRACKING_SUBMENU;
-			}
-			navAreaRectAbove = BRect();
-			navAreaRectBelow = BRect();
-
-			// Since the submenu has its own looper,
-			// we can unlock ours. Doing so also make sure
-			// that our window gets any update message to
-			// redraw itself
-			UnlockLooper();
-
-			// To prevent NULL access violation, ensure a menu has actually
-			// been selected and that it has a submenu. Because keyboard and
-			// mouse interactions set selected items differently, the menu
-			// tracking thread needs to be careful in triggering the navigation
-			// to the submenu.
-			if (fSelected != NULL) {
-				BMenu* submenu = fSelected->Submenu();
-				int submenuAction = MENU_STATE_TRACKING;
-				if (submenu != NULL) {
-					submenu->_SetStickyMode(_IsStickyMode());
-
-					// The following call blocks until the submenu
-					// gives control back to us, either because the mouse
-					// pointer goes out of the submenu's bounds, or because
-					// the user closes the menu
-					BMenuItem* submenuItem = submenu->_Track(&submenuAction);
-					if (submenuAction == MENU_STATE_CLOSED) {
-						item = submenuItem;
-						fState = MENU_STATE_CLOSED;
-					} else if (submenuAction == MENU_STATE_KEY_LEAVE_SUBMENU) {
-						if (LockLooper()) {
-							BMenuItem* temp = fSelected;
-							// close the submenu:
-							_SelectItem(NULL);
-							// but reselect the item itself for user:
-							_SelectItem(temp, false);
-							UnlockLooper();
-						}
-						// cancel  key-nav state
-						fState = MENU_STATE_TRACKING;
-					} else
-						fState = MENU_STATE_TRACKING;
-				}
-			}
-			if (!LockLooper())
-				break;
-		} else if ((item = _HitTestItems(location, B_ORIGIN)) != NULL) {
-			_UpdateStateOpenSelect(item, location, navAreaRectAbove,
-				navAreaRectBelow, selectedTime, navigationAreaTime);
-			releasedOnce = true;
-		} else if (_OverSuper(screenLocation)
-			&& fSuper->fState != MENU_STATE_KEY_TO_SUBMENU) {
-			fState = MENU_STATE_TRACKING;
-			UnlockLooper();
-			break;
-		} else if (fState == MENU_STATE_KEY_LEAVE_SUBMENU) {
-			UnlockLooper();
-			break;
-		} else if (fSuper == NULL
-			|| fSuper->fState != MENU_STATE_KEY_TO_SUBMENU) {
-			// Mouse pointer outside menu:
-			// If there's no other submenu opened,
-			// deselect the current selected item
-			if (fSelected != NULL
-				&& (fSelected->Submenu() == NULL
-					|| fSelected->Submenu()->Window() == NULL)) {
-				_SelectItem(NULL);
-				fState = MENU_STATE_TRACKING;
-			}
-
-			if (fSuper != NULL) {
-				// Give supermenu the chance to continue tracking
-				*action = fState;
-				UnlockLooper();
-				return NULL;
-			}
+		if (!oldTriggerEnabled && btns == 0) {
+			fTrackState->cursorObscured = true;
+			be_app->ObscureCursor();
+			fTriggerEnabled = true;
+			Invalidate();
 		}
-
+		_SelectItem(startItem, true, false);
 		UnlockLooper();
-
-		if (releasedOnce)
-			_UpdateStateClose(item, location, buttons);
-
-		if (fState != MENU_STATE_CLOSED) {
-			bigtime_t snoozeAmount = 50000;
-
-			BPoint newLocation = location;
-			uint32 newButtons = buttons;
-
-			// If user doesn't move the mouse, loop here,
-			// so we don't interfere with keyboard menu navigation
-			do {
-				snooze(snoozeAmount);
-				if (!LockLooper())
-					break;
-				GetMouse(&newLocation, &newButtons, true);
-				UnlockLooper();
-			} while (newLocation == location && newButtons == buttons
-				&& !(item != NULL && item->Submenu() != NULL
-					&& item->Submenu()->Window() == NULL)
-				&& fState == MENU_STATE_TRACKING);
-
-			if (newLocation != location || newButtons != buttons) {
-				if (!releasedOnce && newButtons == 0 && buttons != 0)
-					releasedOnce = true;
-				location = newLocation;
-				buttons = newButtons;
-			}
-
-			if (releasedOnce)
-				_UpdateStateClose(item, location, buttons);
+	}
+	while (run) {
+		int32 cmd = receive_data(&senderThread, NULL, 0);
+		switch (cmd) {
+			case MENU_TRACK_CMD_DONE:
+				run = false;
+				break;
 		}
 	}
 
-	if (action != NULL)
-		*action = fState;
-
-	// keyboard Enter will set this
-	if (fChosenItem != NULL)
-		item = fChosenItem;
-	else if (fSelected == NULL) {
-		// needed to cover (rare) mouse/ESC combination
-		item = NULL;
-	}
+	item = fTrackState->invokedItem;
 
-	if (fSelected != NULL && LockLooper()) {
+	if (LockLooper()) {
+		// hide submenus
 		_SelectItem(NULL);
+		SetEventMask(0, 0);
+		if (fTriggerEnabled != oldTriggerEnabled) {
+			fTriggerEnabled = oldTriggerEnabled;
+			Invalidate();
+		}
+/*
+		if (fTrackState->navigationAreaTimer != NULL) {
+			delete fTrackState->navigationAreaTimer;
+			fTrackState->navigationAreaTimer = NULL;
+		}
+*/
+		fTrackState = NULL;
 		UnlockLooper();
 	}
 
 	// delete the menu window recycled for all the child menus
 	_DeleteMenuWindow();
 
+	printf("-Track\n");
 	return item;
 }
 
@@ -2162,16 +2250,15 @@ BMenu::_UpdateNavigationArea(BPoint position, BRect& navAreaRectAbove,
 	if (fSelected == NULL)
 		return;
 
-	BMenu* submenu = fSelected->Submenu();
+	BView* submenu = fSelected->Submenu()->Parent();
 
 	if (submenu != NULL) {
 		BRect menuBounds = ConvertToScreen(Bounds());
 
 		BRect submenuBounds;
-		if (fSelected->Submenu()->LockLooper()) {
-			submenuBounds = fSelected->Submenu()->ConvertToScreen(
-				fSelected->Submenu()->Bounds());
-			fSelected->Submenu()->UnlockLooper();
+		if (submenu->LockLooper()) {
+			submenuBounds = submenu->ConvertToScreen(submenu->Bounds());
+			submenu->UnlockLooper();
 		}
 
 		if (menuBounds.left < submenuBounds.left) {
@@ -2193,21 +2280,95 @@ BMenu::_UpdateNavigationArea(BPoint position, BRect& navAreaRectAbove,
 		navAreaRectAbove = BRect();
 		navAreaRectBelow = BRect();
 	}
+
+	#if SHOW_NAVIGATION_AREA
+	Invalidate();
+	#endif
+}
+
+
+bool
+BMenu::_HitNavigationArea(BPoint position, BMenuItem* item)
+{
+	if (fLayout != B_ITEMS_IN_COLUMN)
+		return false;
+
+	BRect navAreaRectAbove, navAreaRectBelow;
+	{
+		AutoLocker<BLocker> locker(fTrackState->locker);
+		navAreaRectAbove = fTrackState->navAreaRectAbove;
+		navAreaRectBelow = fTrackState->navAreaRectBelow;
+	}
+
+	position = ConvertToScreen(position);
+	printf("position: "); position.PrintToStream();
+
+	if (!navAreaRectAbove.IsValid() && !navAreaRectBelow.IsValid() && fSelected != NULL && fSelected->Submenu() != NULL) {
+		printf("_UpdateNavigationArea\n");
+		_UpdateNavigationArea(position, navAreaRectAbove,
+			navAreaRectBelow);
+	}
+	
+	printf("navAreaRectAbove: "); navAreaRectAbove.PrintToStream();
+	printf("navAreaRectBelow: "); navAreaRectBelow.PrintToStream();
+
+	bool inNavArea = false;
+	bool inNavAreaRectAbove = navAreaRectAbove.Contains(position);
+	bool inNavAreaRectBelow = navAreaRectBelow.Contains(position);
+
+	if (inNavAreaRectAbove || inNavAreaRectBelow) {
+		bool isLeft = ConvertFromScreen(navAreaRectAbove).left == 0;
+		BPoint p1, p2;
+
+		if (inNavAreaRectAbove) {
+			if (!isLeft) {
+				p1 = navAreaRectAbove.LeftBottom();
+				p2 = navAreaRectAbove.RightTop();
+			} else {
+				p2 = navAreaRectAbove.RightBottom();
+				p1 = navAreaRectAbove.LeftTop();
+			}
+		} else {
+			if (!isLeft) {
+				p2 = navAreaRectBelow.LeftTop();
+				p1 = navAreaRectBelow.RightBottom();
+			} else {
+				p1 = navAreaRectBelow.RightTop();
+				p2 = navAreaRectBelow.LeftBottom();
+			}
+		}
+		inNavArea =
+			  (p1.y - p2.y) * position.x + (p2.x - p1.x) * position.y
+			+ (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x >= 0;
+	}
+	
+	printf("inNavArea: %d\n", inNavArea);
+
+	if (!inNavArea && !(item != NULL && item->Frame().Contains(ConvertFromScreen(position)))) {
+		printf("reset nav area\n");
+		navAreaRectAbove = BRect();
+		navAreaRectBelow = BRect();
+	}
+
+	{
+		AutoLocker<BLocker> locker(fTrackState->locker);
+		navAreaRectAbove = fTrackState->navAreaRectAbove = navAreaRectAbove;
+		navAreaRectBelow = fTrackState->navAreaRectBelow = navAreaRectBelow;
+	}
+
+	return inNavArea;
 }
 
 
 void
 BMenu::_UpdateStateOpenSelect(BMenuItem* item, BPoint position,
-	BRect& navAreaRectAbove, BRect& navAreaRectBelow, bigtime_t& selectedTime,
-	bigtime_t& navigationAreaTime)
+	BRect& navAreaRectAbove, BRect& navAreaRectBelow, bool isTimeout)
 {
-	if (fState == MENU_STATE_CLOSED)
+	if (fLayout != B_ITEMS_IN_COLUMN) {
+		_SelectItem(item, true);
 		return;
-
+	}
 	if (item != fSelected) {
-		if (navigationAreaTime == 0)
-			navigationAreaTime = system_time();
-
 		position = ConvertToScreen(position);
 
 		bool inNavAreaRectAbove = navAreaRectAbove.Contains(position);
@@ -2215,11 +2376,13 @@ BMenu::_UpdateStateOpenSelect(BMenuItem* item, BPoint position,
 
 		if (fSelected == NULL
 			|| (!inNavAreaRectAbove && !inNavAreaRectBelow)) {
-			_SelectItem(item, false);
+			_SelectItem(item, true);
 			navAreaRectAbove = BRect();
 			navAreaRectBelow = BRect();
-			selectedTime = system_time();
-			navigationAreaTime = 0;
+			{
+				AutoLocker<BLocker> locker(fTrackState->locker);
+				fTrackState->navigationAreaTimer.Unset();
+			}
 			return;
 		}
 
@@ -2247,13 +2410,8 @@ BMenu::_UpdateStateOpenSelect(BMenuItem* item, BPoint position,
 			  (p1.y - p2.y) * position.x + (p2.x - p1.x) * position.y
 			+ (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x >= 0;
 
-		bigtime_t systime = system_time();
-
-		if (!inNavArea || (navigationAreaTime > 0 && systime -
-			navigationAreaTime > kNavigationAreaTimeout)) {
-			// Don't delay opening of submenu if the user had
-			// to wait for the navigation area timeout anyway
-			_SelectItem(item, inNavArea);
+		if (!inNavArea || isTimeout) {
+			_SelectItem(item, true);
 
 			if (inNavArea) {
 				_UpdateNavigationArea(position, navAreaRectAbove,
@@ -2263,11 +2421,18 @@ BMenu::_UpdateStateOpenSelect(BMenuItem* item, BPoint position,
 				navAreaRectBelow = BRect();
 			}
 
-			selectedTime = system_time();
-			navigationAreaTime = 0;
+			{
+				AutoLocker<BLocker> locker(fTrackState->locker);
+				fTrackState->navigationAreaTimer.Unset();
+			}
+		}
+	} else if (fSelected->Submenu() != NULL) {
+		{
+			AutoLocker<BLocker> locker(fTrackState->locker);
+			BMessage message(navigationAreaTimeoutMsg);
+			fTrackState->navigationAreaTimer.SetTo(new(std::nothrow) BMessageRunner(BMessenger(this), BMessage(navigationAreaTimeoutMsg), kNavigationAreaTimeout, 1));
 		}
-	} else if (fSelected->Submenu() != NULL &&
-		system_time() - selectedTime > kOpenSubmenuDelay) {
+		
 		_SelectItem(fSelected, true);
 
 		if (!navAreaRectAbove.IsValid() && !navAreaRectBelow.IsValid()) {
@@ -2276,42 +2441,6 @@ BMenu::_UpdateStateOpenSelect(BMenuItem* item, BPoint position,
 				navAreaRectBelow);
 		}
 	}
-
-	if (fState != MENU_STATE_TRACKING)
-		fState = MENU_STATE_TRACKING;
-}
-
-
-void
-BMenu::_UpdateStateClose(BMenuItem* item, const BPoint& where,
-	const uint32& buttons)
-{
-	if (fState == MENU_STATE_CLOSED)
-		return;
-
-	if (buttons != 0 && _IsStickyMode()) {
-		if (item == NULL) {
-			if (item != fSelected && LockLooper()) {
-				_SelectItem(item, false);
-				UnlockLooper();
-			}
-			fState = MENU_STATE_CLOSED;
-		} else
-			_SetStickyMode(false);
-	} else if (buttons == 0 && !_IsStickyMode()) {
-		if (fExtraRect != NULL && fExtraRect->Contains(where)) {
-			_SetStickyMode(true);
-			fExtraRect = NULL;
-				// Setting this to NULL will prevent this code
-				// to be executed next time
-		} else {
-			if (item != fSelected && LockLooper()) {
-				_SelectItem(item, false);
-				UnlockLooper();
-			}
-			fState = MENU_STATE_CLOSED;
-		}
-	}
 }
 
 
@@ -2691,7 +2820,7 @@ BMenu::ScreenLocation()
 
 	BPoint point;
 	if (superMenu->Layout() == B_ITEMS_IN_COLUMN)
-		point = superItem->Frame().RightTop() + BPoint(1.0f, 1.0f);
+		point = superItem->Frame().RightTop() + BPoint(1.0f, 0.0f);
 	else
 		point = superItem->Frame().LeftBottom() + BPoint(1.0f, 1.0f);
 
@@ -2793,29 +2922,41 @@ BMenu::DrawItems(BRect updateRect)
 }
 
 
-int
-BMenu::_State(BMenuItem** item) const
-{
-	if (fState == MENU_STATE_TRACKING || fState == MENU_STATE_CLOSED)
-		return fState;
-
-	if (fSelected != NULL && fSelected->Submenu() != NULL)
-		return fSelected->Submenu()->_State(item);
-
-	return fState;
-}
-
-
 void
 BMenu::_InvokeItem(BMenuItem* item, bool now)
 {
 	if (!item->IsEnabled())
 		return;
 
+	// called from BWindow for shortcut handling
+	if (now) {
+		// Lock the root menu window before calling BMenuItem::Invoke()
+		BMenu* parent = this;
+		BMenu* rootMenu = NULL;
+		do {
+			rootMenu = parent;
+			parent = rootMenu->Supermenu();
+		} while (parent != NULL);
+
+		if (rootMenu->LockLooper()) {
+			item->Invoke();
+			rootMenu->UnlockLooper();
+		}
+		return;
+	}
+
+	{
+		if (fTrackState == NULL)
+			return;
+		AutoLocker<BLocker> locker(fTrackState->locker);
+		if (fTrackState->invokedItem != NULL)
+			return;
+		fTrackState->invokedItem = item;
+	}
+
 	// Do the "selected" animation
-	// TODO: Doesn't work. This is supposed to highlight
-	// and dehighlight the item, works on beos but not on haiku.
-	if (!item->Submenu() && LockLooper()) {
+	#if 0
+	if (LockLooper()) {
 		snooze(50000);
 		item->Select(true);
 		Window()->UpdateIfNeeded();
@@ -2830,19 +2971,7 @@ BMenu::_InvokeItem(BMenuItem* item, bool now)
 		Window()->UpdateIfNeeded();
 		UnlockLooper();
 	}
-
-	// Lock the root menu window before calling BMenuItem::Invoke()
-	BMenu* parent = this;
-	BMenu* rootMenu = NULL;
-	do {
-		rootMenu = parent;
-		parent = rootMenu->Supermenu();
-	} while (parent != NULL);
-
-	if (rootMenu->LockLooper()) {
-		item->Invoke();
-		rootMenu->UnlockLooper();
-	}
+	#endif
 }
 
 
@@ -2972,8 +3101,7 @@ BMenu::_Uninstall()
 
 
 void
-BMenu::_SelectItem(BMenuItem* item, bool showSubmenu, bool selectFirstItem,
-	bool keyDown)
+BMenu::_SelectItem(BMenuItem* item, bool showSubmenu, bool selectFirstItem)
 {
 	// Avoid deselecting and then reselecting the same item
 	// which would cause flickering
@@ -2986,15 +3114,27 @@ BMenu::_SelectItem(BMenuItem* item, bool showSubmenu, bool selectFirstItem,
 		}
 
 		fSelected = item;
-		if (fSelected != NULL)
+		if (fSelected != NULL) {
+			BMenuWindow* window = dynamic_cast<BMenuWindow*>(Window());
+			if (window != NULL && window->LockLooper()) {
+				BRect frame = ConvertToParent(fSelected->Frame());
+				float height = Parent()->Bounds().Height();
+				if (frame.top < 0)
+					window->TryScrollBy(frame.top);
+				else if (frame.bottom > height)
+					window->TryScrollBy(frame.bottom - height);
+				window->UnlockLooper();
+			}
 			fSelected->Select(true);
+		}
 	}
 
 	if (fSelected != NULL && showSubmenu) {
 		BMenu* subMenu = fSelected->Submenu();
 		if (subMenu != NULL && subMenu->Window() == NULL) {
-			if (!subMenu->_Show(selectFirstItem, keyDown)) {
+			if (!subMenu->_Show(selectFirstItem)) {
 				// something went wrong, deselect the item
+				printf("_SelectItem: can't show submenu\n");
 				fSelected->Select(false);
 				fSelected = NULL;
 			}
@@ -3013,7 +3153,7 @@ BMenu::_SelectNextItem(BMenuItem* item, bool forward)
 	if (nextItem == NULL)
 		return false;
 
-	_SelectItem(nextItem, dynamic_cast<BMenuBar*>(this) != NULL);
+	_SelectItem(nextItem, true, false);
 
 	if (LockLooper()) {
 		be_app->ObscureCursor();
@@ -3033,7 +3173,7 @@ BMenu::_NextItem(BMenuItem* item, bool forward) const
 
 	int32 index = fItems.IndexOf(item);
 	int32 loopCount = numItems;
-	while (--loopCount) {
+	while (loopCount--) {
 		// Cycle through menu items in the given direction...
 		if (forward)
 			index++;
@@ -3060,32 +3200,23 @@ BMenu::_NextItem(BMenuItem* item, bool forward) const
 void
 BMenu::_SetStickyMode(bool sticky)
 {
-	if (fStickyMode == sticky)
+	if (fTrackState == NULL) {
+		fStickyMode = sticky;
 		return;
-
-	fStickyMode = sticky;
-
-	if (fSuper != NULL) {
-		// propagate the status to the super menu
-		fSuper->_SetStickyMode(sticky);
-	} else {
-		// TODO: Ugly hack, but it needs to be done in this method
-		BMenuBar* menuBar = dynamic_cast<BMenuBar*>(this);
-		if (sticky && menuBar != NULL && menuBar->LockLooper()) {
-			// If we are switching to sticky mode,
-			// steal the focus from the current focus view
-			// (needed to handle keyboard navigation)
-			menuBar->_StealFocus();
-			menuBar->UnlockLooper();
-		}
 	}
+	AutoLocker<BLocker> locker(fTrackState->locker);
+	fTrackState->rootMenu->fStickyMode = sticky;
 }
 
 
 bool
 BMenu::_IsStickyMode() const
 {
-	return fStickyMode;
+	if (fTrackState == NULL) {
+		return fStickyMode;
+	}
+	AutoLocker<BLocker> locker(fTrackState->locker);
+	return fTrackState->rootMenu->fStickyMode;
 }
 
 
@@ -3228,13 +3359,10 @@ BMenu::_ChooseTrigger(const char* title, int32& index, uint32& trigger,
 void
 BMenu::_UpdateWindowViewSize(const bool &move)
 {
-	BMenuWindow* window = static_cast<BMenuWindow*>(Window());
+	BMenuWindow* window = dynamic_cast<BMenuWindow*>(Window());
 	if (window == NULL)
 		return;
 
-	if (dynamic_cast<BMenuBar*>(this) != NULL)
-		return;
-
 	if (!fResizeToFit)
 		return;
 
@@ -3290,15 +3418,17 @@ BMenu::_UpdateWindowViewSize(const bool &move)
 
 
 bool
-BMenu::_AddDynamicItems(bool keyDown)
+BMenu::_AddDynamicItems()
 {
+	printf("_AddDynamicItems(%p)\n", this);
 	bool addAborted = false;
 	if (AddDynamicItem(B_INITIAL_ADD)) {
 		BMenuItem* superItem = Superitem();
 		BMenu* superMenu = Supermenu();
 		do {
+			//printf("_AddDynamicItems: step\n");
 			if (superMenu != NULL
-				&& !superMenu->_OkToProceed(superItem, keyDown)) {
+				&& !superMenu->_OkToProceed(superItem)) {
 				AddDynamicItem(B_ABORT);
 				addAborted = true;
 				break;
@@ -3311,66 +3441,41 @@ BMenu::_AddDynamicItems(bool keyDown)
 
 
 bool
-BMenu::_OkToProceed(BMenuItem* item, bool keyDown)
-{
-	BPoint where;
-	uint32 buttons;
-	GetMouse(&where, &buttons, false);
-	bool stickyMode = _IsStickyMode();
-	// Quit if user clicks the mouse button in sticky mode
-	// or releases the mouse button in nonsticky mode
-	// or moves the pointer over another item
-	// TODO: I added the check for BMenuBar to solve a problem with Deskbar.
-	// BeOS seems to do something similar. This could also be a bug in
-	// Deskbar, though.
-	if ((buttons != 0 && stickyMode)
-		|| ((dynamic_cast<BMenuBar*>(this) == NULL
-			&& (buttons == 0 && !stickyMode))
-		|| ((_HitTestItems(where) != item) && !keyDown))) {
-		return false;
-	}
-
-	return true;
+BMenu::_OkToProceed(BMenuItem* item)
+{
+	return true; /* !!! */
 }
 
 
-bool
-BMenu::_CustomTrackingWantsToQuit()
+void
+BMenu::_CallTrackingHook()
 {
 	if (fExtraMenuData != NULL && fExtraMenuData->trackingHook != NULL
 		&& fExtraMenuData->trackingState != NULL) {
-		return fExtraMenuData->trackingHook(this,
-			fExtraMenuData->trackingState);
+		if (fExtraMenuData->trackingHook(this, fExtraMenuData->trackingState))
+			_QuitTracking(true);
 	}
-
-	return false;
 }
 
 
 void
 BMenu::_QuitTracking(bool onlyThis)
 {
-	_SelectItem(NULL);
-	if (BMenuBar* menuBar = dynamic_cast<BMenuBar*>(this))
-		menuBar->_RestoreFocus();
-
-	fState = MENU_STATE_CLOSED;
-
-	if (!onlyThis) {
-		// Close the whole menu hierarchy
-		if (Supermenu() != NULL)
-			Supermenu()->fState = MENU_STATE_CLOSED;
+	if (fTrackState == NULL)
+		return;
 
-		if (_IsStickyMode())
-			_SetStickyMode(false);
+	AutoLocker<BLocker> locker(fTrackState->locker);
 
-		if (LockLooper()) {
-			be_app->ShowCursor();
-			UnlockLooper();
-		}
+	if (onlyThis && Supermenu() != NULL) {
+		_SelectItem(NULL);
+		fTrackState->curMenu = Supermenu();
+		return;
 	}
 
-	_Hide();
+	if (!fTrackState->quit) {
+		fTrackState->quit = true;
+		send_data(fTrackState->trackThread, MENU_TRACK_CMD_DONE, NULL, 0);
+	}
 }
 
 
diff --git a/src/kits/interface/MenuBar.cpp b/src/kits/interface/MenuBar.cpp
index 6a07dd23c4..91442206f2 100644
--- a/src/kits/interface/MenuBar.cpp
+++ b/src/kits/interface/MenuBar.cpp
@@ -173,6 +173,9 @@ BMenuBar::AllDetached()
 void
 BMenuBar::WindowActivated(bool state)
 {
+	if (!state) {
+		BPrivate::MenuPrivate(this).QuitTracking(false);
+	}
 	BView::WindowActivated(state);
 }
 
@@ -550,152 +553,32 @@ BMenuBar::_TrackTask(void* arg)
 BMenuItem*
 BMenuBar::_Track(int32* action, int32 startIndex, bool showMenu)
 {
-	// TODO: Cleanup, merge some "if" blocks if possible
 	BMenuItem* item = NULL;
-	fState = MENU_STATE_TRACKING;
-	fChosenItem = NULL;
-		// we will use this for keyboard selection
 
-	BPoint where;
-	uint32 buttons;
+	if (startIndex == -1 && showMenu)
+		startIndex = 0;
+
 	if (LockLooper()) {
-		if (startIndex != -1) {
-			be_app->ObscureCursor();
-			_SelectItem(ItemAt(startIndex), true, false);
-		}
-		GetMouse(&where, &buttons);
+		_StealFocus();
 		UnlockLooper();
 	}
 
-	while (fState != MENU_STATE_CLOSED) {
-		bigtime_t snoozeAmount = 40000;
-		if (!LockLooper())
-			break;
-
-		item = dynamic_cast<_BMCMenuBar_*>(this) != NULL ? ItemAt(0)
-			: _HitTestItems(where, B_ORIGIN);
-
-		if (_OverSubmenu(fSelected, ConvertToScreen(where))
-			|| fState == MENU_STATE_KEY_TO_SUBMENU) {
-			// call _Track() from the selected sub-menu when the mouse cursor
-			// is over its window
-			BMenu* submenu = fSelected->Submenu();
-			UnlockLooper();
-			snoozeAmount = 30000;
-			submenu->_SetStickyMode(_IsStickyMode());
-			int localAction;
-			fChosenItem = submenu->_Track(&localAction);
-
-			// The mouse could have meen moved since the last time we
-			// checked its position, or buttons might have been pressed.
-			// Unfortunately our child menus don't tell
-			// us the new position.
-			// TODO: Maybe have a shared struct between all menus
-			// where to store the current mouse position ?
-			// (Or just use the BView mouse hooks)
-			BPoint newWhere;
-			if (LockLooper()) {
-				GetMouse(&newWhere, &buttons);
-				UnlockLooper();
-			}
-
-			// Needed to make BMenuField child menus "sticky"
-			// (see ticket #953)
-			if (localAction == MENU_STATE_CLOSED) {
-				if (fExtraRect != NULL && fExtraRect->Contains(where)
-					&& point_distance(newWhere, where) < 9) {
-					// 9 = 3 pixels ^ 2 (since point_distance() returns the
-					// square of the distance)
-					_SetStickyMode(true);
-					fExtraRect = NULL;
-				} else
-					fState = MENU_STATE_CLOSED;
-			}
-			if (!LockLooper())
-				break;
-		} else if (item != NULL) {
-			if (item->Submenu() != NULL && item != fSelected) {
-				if (item->Submenu()->Window() == NULL) {
-					// open the menu if it's not opened yet
-					_SelectItem(item);
-				} else {
-					// Menu was already opened, close it and bail
-					_SelectItem(NULL);
-					fState = MENU_STATE_CLOSED;
-					fChosenItem = NULL;
-				}
-			} else {
-				// No submenu, just select the item
-				_SelectItem(item);
-			}
-		} else if (item == NULL && fSelected != NULL
-			&& !_IsStickyMode() && Bounds().Contains(where)) {
-			_SelectItem(NULL);
-			fState = MENU_STATE_TRACKING;
-		}
-
-		UnlockLooper();
-
-		if (fState != MENU_STATE_CLOSED) {
-			BPoint newWhere = where;
-			uint32 newButtons = buttons;
-
-			do {
-				// If user doesn't move the mouse or change buttons loop
-				// here so that we don't interfere with keyboard menu
-				// navigation
-				snooze(snoozeAmount);
-				if (!LockLooper())
-					break;
-
-				GetMouse(&newWhere, &newButtons);
-				UnlockLooper();
-			} while (newWhere == where && newButtons == buttons
-				&& fState == MENU_STATE_TRACKING);
-
-			if (newButtons != 0 && _IsStickyMode()) {
-				if (item == NULL || (item->Submenu() != NULL
-						&& item->Submenu()->Window() != NULL)) {
-					// clicked outside the menu bar or on item with already
-					// open sub menu
-					fState = MENU_STATE_CLOSED;
-				} else
-					_SetStickyMode(false);
-			} else if (newButtons == 0 && !_IsStickyMode()) {
-				if ((fSelected != NULL && fSelected->Submenu() == NULL)
-					|| item == NULL) {
-					// clicked on an item without a submenu or clicked and
-					// released the mouse button outside the menu bar
-					fChosenItem = fSelected;
-					fState = MENU_STATE_CLOSED;
-				} else
-					_SetStickyMode(true);
-			}
-			where = newWhere;
-			buttons = newButtons;
-		}
-	}
+	item = BMenu::_Track(action, startIndex);
 
 	if (LockLooper()) {
 		if (fSelected != NULL)
 			_SelectItem(NULL);
 
-		if (fChosenItem != NULL)
-			fChosenItem->Invoke();
+		if (item != NULL)
+			item->Invoke();
 
 		_RestoreFocus();
 		UnlockLooper();
 	}
 
-	if (_IsStickyMode())
-		_SetStickyMode(false);
-
 	_DeleteMenuWindow();
 
-	if (action != NULL)
-		*action = fState;
-
-	return fChosenItem;
+	return item;
 }
 
 
@@ -747,7 +630,6 @@ BMenuBar::_InitData(menu_layout layout)
 
 	fBorders = BControlLook::B_ALL_BORDERS;
 	fLastBounds = new BRect(Bounds());
-	_SetIgnoreHidden(true);
 	SetLowUIColor(B_MENU_BACKGROUND_COLOR);
 	SetViewColor(B_TRANSPARENT_COLOR);
 }
diff --git a/src/kits/interface/MenuField.cpp b/src/kits/interface/MenuField.cpp
index 8bf6193010..588ef6818f 100644
--- a/src/kits/interface/MenuField.cpp
+++ b/src/kits/interface/MenuField.cpp
@@ -507,6 +507,11 @@ BMenuField::KeyDown(const char* bytes, int32 numBytes)
 
 			fMenuBar->StartMenuBar(0, true, true, &bounds);
 
+			fMenuTaskID = spawn_thread((thread_func)_thread_entry,
+				"_m_task_", B_NORMAL_PRIORITY, this);
+			if (fMenuTaskID >= 0)
+				resume_thread(fMenuTaskID);
+
 			bounds = Bounds();
 			bounds.right = fDivider;
 
@@ -1087,7 +1092,7 @@ BMenuField::_DrawLabel(BRect updateRect)
 	rgb_color textColor;
 
 	BPrivate::MenuPrivate menuPrivate(fMenuBar);
-	if (menuPrivate.State() != MENU_STATE_CLOSED) {
+	if (menuPrivate.IsTracking()) {
 		// highlight the background of the label grey (like BeOS R5)
 		SetLowColor(ui_color(B_MENU_SELECTED_BACKGROUND_COLOR));
 		BRect fillRect(rect.InsetByCopy(0, kVMargin));
diff --git a/src/kits/interface/MenuPrivate.cpp b/src/kits/interface/MenuPrivate.cpp
index 4339654f77..73ea8d70e5 100644
--- a/src/kits/interface/MenuPrivate.cpp
+++ b/src/kits/interface/MenuPrivate.cpp
@@ -168,10 +168,10 @@ MenuPrivate::SetItemMargins(float left, float top, float right, float bottom)
 }
 
 
-int
-MenuPrivate::State(BMenuItem** item) const
+bool
+MenuPrivate::IsTracking() const
 {
-	return fMenu->_State(item);
+	return fMenu->fTrackState != NULL;
 }
 
 
diff --git a/src/kits/interface/MenuWindow.cpp b/src/kits/interface/MenuWindow.cpp
index f1b373c087..2a1b735292 100644
--- a/src/kits/interface/MenuWindow.cpp
+++ b/src/kits/interface/MenuWindow.cpp
@@ -15,6 +15,7 @@
 #include <Debug.h>
 #include <Menu.h>
 #include <MenuItem.h>
+#include <MessageRunner.h>
 
 #include <MenuPrivate.h>
 #include <WindowPrivate.h>
@@ -25,12 +26,24 @@ namespace BPrivate {
 class BMenuScroller : public BView {
 public:
 							BMenuScroller(BRect frame);
+							~BMenuScroller();
 
 			bool			IsEnabled() const;
 			void			SetEnabled(bool enabled);
 
+			void			MouseMoved(BPoint where, uint32 transit,
+								const BMessage* dragMessage);
+			void			MessageReceived(BMessage* msg);
+
+protected:
+	virtual	void			DoScroll() = 0;
+
 private:
+			void			_StartScrolling(bool doStart);
+
 			bool			fEnabled;
+			bool			fMouseInside;
+			BMessageRunner*	fScrollRunner;
 };
 
 
@@ -53,7 +66,8 @@ class UpperScroller : public BMenuScroller {
 public:
 							UpperScroller(BRect frame);
 
-	virtual	void			Draw(BRect updateRect);
+			void			DoScroll();
+			void			Draw(BRect updateRect);
 };
 
 
@@ -61,7 +75,8 @@ class LowerScroller : public BMenuScroller {
 public:
 							LowerScroller(BRect frame);
 
-	virtual	void			Draw(BRect updateRect);
+			void			DoScroll();
+			void			Draw(BRect updateRect);
 };
 
 
@@ -73,17 +88,29 @@ using namespace BPrivate;
 
 const int kScrollerHeight = 12;
 
+enum {
+	scrollMsg = 'scrl'
+};
+
 
 BMenuScroller::BMenuScroller(BRect frame)
 	:
 	BView(frame, "menu scroller", 0, B_WILL_DRAW | B_FRAME_EVENTS
 		| B_FULL_UPDATE_ON_RESIZE),
-	fEnabled(false)
+	fEnabled(false),
+	fMouseInside(false),
+	fScrollRunner(NULL)
 {
 	SetViewUIColor(B_MENU_BACKGROUND_COLOR);
 }
 
 
+BMenuScroller::~BMenuScroller()
+{
+	_StartScrolling(false);
+}
+
+
 bool
 BMenuScroller::IsEnabled() const
 {
@@ -95,6 +122,51 @@ void
 BMenuScroller::SetEnabled(bool enabled)
 {
 	fEnabled = enabled;
+	_StartScrolling(fEnabled && fMouseInside);
+}
+
+
+void
+BMenuScroller::MouseMoved(BPoint where, uint32 transit,
+	const BMessage* dragMessage)
+{
+	switch (transit) {
+		case B_ENTERED_VIEW:
+			fMouseInside = true;
+			if (fEnabled) _StartScrolling(true);
+			break;
+		case B_EXITED_VIEW:
+			fMouseInside = false;
+			if (fEnabled) _StartScrolling(false);
+			break;
+	}
+}
+
+
+void
+BMenuScroller::MessageReceived(BMessage* msg)
+{
+	switch (msg->what) {
+		case scrollMsg:
+			DoScroll();
+			break;
+		default:
+			BView::MessageReceived(msg);
+	}
+}
+
+
+void
+BMenuScroller::_StartScrolling(bool doStart)
+{
+	if (doStart) {
+		if (fScrollRunner == NULL)
+			fScrollRunner = new (std::nothrow) BMessageRunner(BMessenger(this), new BMessage(scrollMsg), 5000, -1);
+	} else {
+		if (fScrollRunner != NULL) {
+			delete fScrollRunner; fScrollRunner = NULL;
+		}
+	}
 }
 
 
@@ -108,6 +180,16 @@ UpperScroller::UpperScroller(BRect frame)
 }
 
 
+void
+UpperScroller::DoScroll()
+{
+	BMenuWindow* window = dynamic_cast<BMenuWindow*>(Window());
+	float smallStep;
+	window->GetSteps(&smallStep, NULL);
+	window->TryScrollBy(-smallStep);
+}
+
+
 void
 UpperScroller::Draw(BRect updateRect)
 {
@@ -140,6 +222,16 @@ LowerScroller::LowerScroller(BRect frame)
 }
 
 
+void
+LowerScroller::DoScroll()
+{
+	BMenuWindow* window = dynamic_cast<BMenuWindow*>(Window());
+	float smallStep;
+	window->GetSteps(&smallStep, NULL);
+	window->TryScrollBy(smallStep);
+}
+
+
 void
 LowerScroller::Draw(BRect updateRect)
 {
@@ -391,16 +483,6 @@ BMenuWindow::HasScrollers() const
 }
 
 
-bool
-BMenuWindow::CheckForScrolling(const BPoint &cursor)
-{
-	if (!fMenuFrame || !fUpperScroller || !fLowerScroller)
-		return false;
-
-	return _Scroll(cursor);
-}
-
-
 bool
 BMenuWindow::TryScrollBy(const float& step)
 {
@@ -423,35 +505,6 @@ BMenuWindow::TryScrollTo(const float& where)
 }
 
 
-bool
-BMenuWindow::_Scroll(const BPoint& where)
-{
-	ASSERT((fLowerScroller != NULL));
-	ASSERT((fUpperScroller != NULL));
-
-	const BPoint cursor = ConvertFromScreen(where);
-	const BRect &lowerFrame = fLowerScroller->Frame();
-	const BRect &upperFrame = fUpperScroller->Frame();
-
-	int32 delta = 0;
-	if (fLowerScroller->IsEnabled() && lowerFrame.Contains(cursor))
-		delta = 1;
-	else if (fUpperScroller->IsEnabled() && upperFrame.Contains(cursor))
-		delta = -1;
-
-	if (delta == 0)
-		return false;
-
-	float smallStep;
-	GetSteps(&smallStep, NULL);
-	_ScrollBy(smallStep * delta);
-
-	snooze(5000);
-
-	return true;
-}
-
-
 void
 BMenuWindow::_ScrollBy(const float& step)
 {
diff --git a/src/kits/interface/PopUpMenu.cpp b/src/kits/interface/PopUpMenu.cpp
index 7b94b380ab..892d938c9b 100644
--- a/src/kits/interface/PopUpMenu.cpp
+++ b/src/kits/interface/PopUpMenu.cpp
@@ -429,20 +429,10 @@ BPopUpMenu::_StartTrack(BPoint where, bool autoInvoke, bool startOpened,
 	fWhere = where;
 	fUseWhere = true;
 
-	// Determine when mouse-down-up will be taken as a 'press',
-	// rather than a 'click'
-	bigtime_t clickMaxTime = 0;
-	get_click_speed(&clickMaxTime);
-	clickMaxTime += system_time();
-
 	// Show the menu's window
 	Show();
-	snooze(50000);
 	BMenuItem* result = Track(startOpened, _specialRect);
 
-	// If it was a click, keep the menu open and tracking
-	if (system_time() <= clickMaxTime)
-		result = Track(true, _specialRect);
 	if (result != NULL && autoInvoke)
 		result->Invoke();
 
-- 
2.30.2

