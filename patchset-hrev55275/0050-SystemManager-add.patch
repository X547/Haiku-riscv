From 2daf6f5aa4ee65d796702da4b70bdc5469d6ccea Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Mon, 24 May 2021 04:08:45 +0900
Subject: SystemManager: add

Change-Id: Ie23c73a1518e7fec4c0b6347c1a7aa9d916b11dd
---
 src/apps/Jamfile                          |   1 +
 src/apps/systemmanager/Errors.cpp         |  26 +
 src/apps/systemmanager/Errors.h           |  39 +
 src/apps/systemmanager/Jamfile            |  15 +
 src/apps/systemmanager/Old.cpp            | 121 +++
 src/apps/systemmanager/StackWindow.cpp    | 286 +++++++
 src/apps/systemmanager/StackWindow.h      |  28 +
 src/apps/systemmanager/SystemManager.cpp  | 796 ++++++++++++++++++
 src/apps/systemmanager/SystemManager.rdef |  41 +
 src/apps/systemmanager/TeamWindow.cpp     | 930 ++++++++++++++++++++++
 src/apps/systemmanager/TeamWindow.h       |  54 ++
 src/apps/systemmanager/UIUtils.cpp        |  95 +++
 src/apps/systemmanager/UIUtils.h          |  59 ++
 src/apps/systemmanager/Utils.cpp          | 164 ++++
 src/apps/systemmanager/Utils.h            |  29 +
 15 files changed, 2684 insertions(+)
 create mode 100644 src/apps/systemmanager/Errors.cpp
 create mode 100644 src/apps/systemmanager/Errors.h
 create mode 100644 src/apps/systemmanager/Jamfile
 create mode 100644 src/apps/systemmanager/Old.cpp
 create mode 100644 src/apps/systemmanager/StackWindow.cpp
 create mode 100644 src/apps/systemmanager/StackWindow.h
 create mode 100644 src/apps/systemmanager/SystemManager.cpp
 create mode 100644 src/apps/systemmanager/SystemManager.rdef
 create mode 100644 src/apps/systemmanager/TeamWindow.cpp
 create mode 100644 src/apps/systemmanager/TeamWindow.h
 create mode 100644 src/apps/systemmanager/UIUtils.cpp
 create mode 100644 src/apps/systemmanager/UIUtils.h
 create mode 100644 src/apps/systemmanager/Utils.cpp
 create mode 100644 src/apps/systemmanager/Utils.h

diff --git a/src/apps/Jamfile b/src/apps/Jamfile
index c883cf7b07..232451f675 100644
--- a/src/apps/Jamfile
+++ b/src/apps/Jamfile
@@ -60,3 +60,4 @@ HaikuSubInclude tracker ;
 HaikuSubInclude tv ;
 HaikuSubInclude webpositive ;
 HaikuSubInclude workspaces ;
+HaikuSubInclude systemmanager ;
diff --git a/src/apps/systemmanager/Errors.cpp b/src/apps/systemmanager/Errors.cpp
new file mode 100644
index 0000000000..2168fc0895
--- /dev/null
+++ b/src/apps/systemmanager/Errors.cpp
@@ -0,0 +1,26 @@
+#include "Errors.h"
+
+#include <errno.h>
+
+#include <Alert.h>
+#include <String.h>
+
+
+StatusError::StatusError(status_t res, const char *msg):
+	res(res), msg(msg)
+{}
+
+void ShowError(const StatusError &err)
+{
+	BString msg, buf;
+
+	if (err.msg != NULL) {
+		buf.SetToFormat("%s\n\n", err.msg);
+		msg += buf;
+	}
+	buf.SetToFormat("Error code: 0x%08" B_PRIx32 " (%s).", err.res, strerror(err.res));
+	msg += buf;
+
+	BAlert *alert = new BAlert("Error", msg, "OK", NULL, NULL, B_WIDTH_AS_USUAL, B_STOP_ALERT);
+	alert->Go(NULL);
+}
diff --git a/src/apps/systemmanager/Errors.h b/src/apps/systemmanager/Errors.h
new file mode 100644
index 0000000000..769bd588c8
--- /dev/null
+++ b/src/apps/systemmanager/Errors.h
@@ -0,0 +1,39 @@
+#ifndef _ERRORS_H_
+#define _ERRORS_H_
+
+#include <SupportDefs.h>
+
+#include <errno.h>
+
+
+class StatusError
+{
+public:
+	status_t res;
+	const char *msg;
+
+	StatusError(status_t res, const char *msg);
+};
+
+void ShowError(const StatusError &err);
+
+static inline status_t Check(status_t res, const char *msg = NULL, bool fatal = true)
+{
+	if ((res < B_OK) && fatal)
+		throw StatusError(res, msg);
+	return res;
+}
+
+static inline status_t CheckErrno(status_t res, const char *msg = NULL, bool fatal = true)
+{
+	if ((res < 0) && fatal)
+		throw StatusError(errno, msg);
+	return res;
+}
+
+#define CheckRet(err) {status_t _err = (err); if (_err < B_OK) return _err;}
+
+#define CheckRetVoid(err) {status_t _err = (err); if (_err < B_OK) return;}
+
+
+#endif	// _ERRORS_H_
diff --git a/src/apps/systemmanager/Jamfile b/src/apps/systemmanager/Jamfile
new file mode 100644
index 0000000000..439e0bd2d9
--- /dev/null
+++ b/src/apps/systemmanager/Jamfile
@@ -0,0 +1,15 @@
+SubDir HAIKU_TOP src apps systemmanager ;
+
+UsePrivateHeaders interface shared ;
+UsePrivateKernelHeaders ;
+
+Application SystemManager :
+	SystemManager.cpp
+	TeamWindow.cpp
+	StackWindow.cpp
+	Errors.cpp
+	Utils.cpp
+	UIUtils.cpp
+	: be [ TargetLibstdc++ ] debug libcolumnlistview.a
+	: SystemManager.rdef
+;
diff --git a/src/apps/systemmanager/Old.cpp b/src/apps/systemmanager/Old.cpp
new file mode 100644
index 0000000000..18d3f206b9
--- /dev/null
+++ b/src/apps/systemmanager/Old.cpp
@@ -0,0 +1,121 @@
+BLayoutItem *CreateTextControlLayoutItem(BTextControl *view)
+{
+	BGroupLayout *layout;
+		BLayoutBuilder::Group<>(B_VERTICAL, 0)
+			.GetLayout(&layout)
+			.AddGroup(B_HORIZONTAL, 0)
+				.Add(view->CreateLabelLayoutItem())
+				.AddGlue()
+				.End()
+			.Add(view->CreateTextViewLayoutItem())
+			.End();
+	return layout;
+}
+
+BLayoutItem *CreateMenuFieldLayoutItem(BMenuField *view)
+{
+	BGroupLayout *layout;
+		BLayoutBuilder::Group<>(B_VERTICAL, 0)
+			.GetLayout(&layout)
+			.AddGroup(B_HORIZONTAL, 0)
+				.Add(view->CreateLabelLayoutItem())
+				.AddGlue()
+				.End()
+			.AddStrut(16)
+			.Add(view->CreateMenuBarLayoutItem())
+			.End();
+	return layout;
+}
+
+BBox *NewLabelBox(const char *name, const char *label, BView *content)
+{
+	BBox *box = new BBox(name);
+	if (label != NULL)
+		box->SetLabel(label);
+	if (content != NULL)
+		box->AddChild(content);
+	return box;
+}
+
+static BView *NewColorView(const char *name, rgb_color color)
+{
+	BView *view = new BView(name, B_SUPPORTS_LAYOUT);
+	view->SetViewColor(color);
+	if (color == B_TRANSPARENT_COLOR)
+		view->SetFlags(view->Flags() | B_TRANSPARENT_BACKGROUND);
+	return view;
+}
+
+static BView *NewInfoView(TeamWindow *wnd)
+{
+	BView *view = new BView("Info", B_TRANSPARENT_BACKGROUND);
+	view->SetViewColor(B_TRANSPARENT_COLOR);
+
+	BTextControl *fTeam, *fPort, *fToken;
+	BTextControl *fLeftView, *fTopView, *fRightView, *fBottomView;
+	BMenuField *fMenuField;
+
+	fTeam = new BTextControl("team", "Team:", "0", NULL); fTeam->SetEnabled(false);
+	fPort = new BTextControl("port", "Port:", "0", NULL); fPort->SetEnabled(false);
+	fToken = new BTextControl("token", "Token:", "0", NULL); fToken->SetEnabled(false);
+
+	fLeftView = new BTextControl("left", "User:", "0", NULL);
+	fTopView = new BTextControl("top", "Group:", "0", NULL);
+	fRightView = new BTextControl("right", "Right:", "255", NULL);
+	fBottomView = new BTextControl("bottom", "Bottom:", "255", NULL);
+
+	BMenu *menu = new BPopUpMenu("menu");
+	menu->AddItem(new BMenuItem("Item 1", NULL));
+	menu->AddItem(new BMenuItem("Item 2", NULL));
+	menu->AddItem(new BMenuItem("Item 3", NULL));
+	menu->AddItem(new BMenuItem("Item 4", NULL));
+	fMenuField = new BMenuField("menuField", "Menu field:", menu);
+
+	BLayoutBuilder::Group<>(view, B_VERTICAL, B_USE_SMALL_SPACING)
+		.SetInsets(B_USE_SMALL_SPACING)
+/*
+		.Add(
+			BLayoutBuilder::Group<>(NewLabelBox("frame", "Frame", NULL), B_HORIZONTAL, B_USE_SMALL_SPACING)
+				.SetInsets(padding, 2*padding, padding, padding)
+				.Add(CreateTextControlLayoutItem(fLeftView))
+				.Add(CreateTextControlLayoutItem(fTopView))
+				.Add(CreateTextControlLayoutItem(fRightView))
+				.Add(CreateTextControlLayoutItem(fBottomView))
+				.View()
+		)
+*/
+		.Add(
+			NewLabelBox("box1", NULL,
+				BLayoutBuilder::Group<>(NewColorView("content", B_TRANSPARENT_COLOR), B_HORIZONTAL, B_USE_SMALL_SPACING)
+					.SetInsets(B_USE_SMALL_SPACING)
+					.Add(CreateTextControlLayoutItem(fTeam))
+					.Add(CreateTextControlLayoutItem(fPort))
+					.Add(CreateTextControlLayoutItem(fToken))
+					.View()
+			)
+		)
+
+		.Add(
+			NewLabelBox("frame", "Effective",
+				BLayoutBuilder::Group<>(NewColorView("content", B_TRANSPARENT_COLOR), B_HORIZONTAL, B_USE_SMALL_SPACING)
+					.SetInsets(B_USE_SMALL_SPACING, 0, B_USE_SMALL_SPACING, B_USE_SMALL_SPACING)
+					.Add(CreateTextControlLayoutItem(new BTextControl("euid", "User:", "0", NULL)))
+					.Add(CreateTextControlLayoutItem(new BTextControl("egid", "Group:", "0", NULL)))
+					.View()
+			)
+		)
+		.Add(
+			NewLabelBox("frame", "Actual",
+				BLayoutBuilder::Group<>(NewColorView("content", B_TRANSPARENT_COLOR), B_HORIZONTAL, B_USE_SMALL_SPACING)
+					.SetInsets(B_USE_SMALL_SPACING, 0, B_USE_SMALL_SPACING, B_USE_SMALL_SPACING)
+					.Add(CreateTextControlLayoutItem(new BTextControl("uid", "User:", "0", NULL)))
+					.Add(CreateTextControlLayoutItem(new BTextControl("gid", "Group:", "0", NULL)))
+					.View()
+			)
+		)
+		.Add(CreateMenuFieldLayoutItem(fMenuField))
+		.AddGlue()
+		.End();
+
+	return view;
+}
diff --git a/src/apps/systemmanager/StackWindow.cpp b/src/apps/systemmanager/StackWindow.cpp
new file mode 100644
index 0000000000..930d3fd926
--- /dev/null
+++ b/src/apps/systemmanager/StackWindow.cpp
@@ -0,0 +1,286 @@
+#include "StackWindow.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <libgen.h>
+
+#include <Application.h>
+#include <View.h>
+#include <TabView.h>
+#include <Rect.h>
+#include <Menu.h>
+#include <MenuBar.h>
+#include <MenuItem.h>
+#include <LayoutBuilder.h>
+#include <private/interface/ColumnListView.h>
+#include <private/interface/ColumnTypes.h>
+#include <private/shared/AutoLocker.h>
+#include <String.h>
+#include <image.h>
+#include <drivers/KernelExport.h>
+
+#include <private/debug/debug_support.h>
+
+#include <cxxabi.h>
+#include <map>
+
+#include "Errors.h"
+#include "UIUtils.h"
+
+
+enum {
+	frameFpCol = 0,
+	frameIpCol,
+	frameImageCol,
+	frameFunctionCol,
+};
+
+
+static char *CppDemangle(const char *abiName)
+{
+  int status;
+  char *ret = abi::__cxa_demangle(abiName, 0, 0, &status);
+  return ret;
+}
+
+static void LookupSymbolAddress(
+	StackWindow *wnd,
+	debug_symbol_lookup_context *lookupContext, const void *address,
+	BString &imageStr, BString &symbolStr)
+{
+	// lookup the symbol
+	void *baseAddress;
+	char symbolName[1024];
+	char imagePath[B_PATH_NAME_LENGTH], imageNameBuf[B_PATH_NAME_LENGTH], *imageName;
+	bool exactMatch;
+	bool lookupSucceeded = false;
+	if (lookupContext) {
+		status_t error = debug_lookup_symbol_address(lookupContext, address,
+			&baseAddress, symbolName, sizeof(symbolName), imagePath,
+			sizeof(imagePath), &exactMatch);
+		lookupSucceeded = (error == B_OK);
+	}
+
+	if (lookupSucceeded) {
+		strcpy(imageNameBuf, imagePath);
+		imageName = basename(imageNameBuf);
+
+		// we were able to look something up
+		if (strlen(symbolName) > 0) {
+			char *demangledName = CppDemangle(symbolName);
+			if (demangledName != NULL) {
+				strcpy(symbolName, demangledName);
+				free(demangledName);
+			}
+
+			// we even got a symbol
+			imageStr.SetTo(imageName);
+			symbolStr.SetToFormat("%s + %ld%s",
+				symbolName,
+				(addr_t)address - (addr_t)baseAddress,
+				exactMatch ? "" : " (closest symbol)"
+			);
+		} else {
+			// no symbol: image relative address
+			imageStr.SetTo(imageName);
+			symbolStr.SetToFormat("%ld", (addr_t)address - (addr_t)baseAddress);
+		}
+
+	} else {
+		// lookup failed: find area containing the IP
+		bool useAreaInfo = false;
+		area_info info;
+		ssize_t cookie = 0;
+		while (get_next_area_info(wnd->fTeam, &cookie, &info) == B_OK) {
+			if ((addr_t)info.address <= (addr_t)address &&
+				(addr_t)info.address + info.size > (addr_t)address
+			) {
+				useAreaInfo = true;
+				break;
+			}
+		}
+
+		if (useAreaInfo) {
+			imageStr.SetToFormat("<area: %s>", info.name);
+			symbolStr.SetToFormat("%#lx", (addr_t)address - (addr_t)info.address);
+		} else {
+			imageStr.SetTo("");
+			symbolStr.SetTo("");
+		}
+	}
+}
+
+static void WriteStackTrace(StackWindow *wnd)
+{
+	status_t error;
+	void *ip = NULL, *fp = NULL;
+
+	error = debug_get_instruction_pointer(&wnd->fDebugContext, wnd->fId, &ip, &fp);
+
+	debug_symbol_lookup_context *lookupContext = NULL;
+	Check(debug_create_symbol_lookup_context(wnd->fTeam, -1, &lookupContext), "can't create symbol lookup context", false);
+
+	BString imageStr, symbolStr;
+	LookupSymbolAddress(wnd, lookupContext, ip, imageStr, symbolStr);
+
+	BRow *row;
+	BString str;
+
+	row = new BRow();
+	row->SetField(new Int64Field((addr_t)fp), frameFpCol);
+	row->SetField(new Int64Field((addr_t)ip), frameIpCol);
+	row->SetField(new BStringField(imageStr), frameImageCol);
+	row->SetField(new BStringField(symbolStr), frameFunctionCol);
+	wnd->fView->AddRow(row);
+
+	for (int32 i = 0; i < 400; i++) {
+		debug_stack_frame_info stackFrameInfo;
+
+		error = debug_get_stack_frame(&wnd->fDebugContext, fp, &stackFrameInfo);
+		if (error < B_OK)
+			break;
+
+		ip = stackFrameInfo.return_address;
+		fp = stackFrameInfo.parent_frame;
+
+		LookupSymbolAddress(wnd, lookupContext, ip, imageStr, symbolStr);
+
+		row = new BRow();
+		row->SetField(new Int64Field((addr_t)fp), frameFpCol);
+		row->SetField(new Int64Field((addr_t)ip), frameIpCol);
+		row->SetField(new BStringField(imageStr), frameImageCol);
+		row->SetField(new BStringField(symbolStr), frameFunctionCol);
+		wnd->fView->AddRow(row);
+
+		if (fp == NULL)
+			break;
+	}
+
+	if (lookupContext)
+		debug_delete_symbol_lookup_context(lookupContext);
+}
+
+static status_t DebugThread(void *arg)
+{
+	StackWindow *wnd = (StackWindow*)arg;
+	status_t res;
+	bool run = true;
+	try {
+		while (run) {
+			int32 code;
+			debug_debugger_message_data message;
+			res = read_port(wnd->fDebuggerPort, &code, &message, sizeof(message));
+			if (res == B_INTERRUPTED) continue;
+			Check(res, "read port failed");
+			// printf("debug msg: %d\n", code);
+			switch (code) {
+			case B_DEBUGGER_MESSAGE_THREAD_DEBUGGED: {
+				run = false;
+				break;
+			}
+			}
+		}
+	} catch (StatusError &err) {
+		ShowError(err);
+		return err.res;
+	}
+	return B_OK;
+}
+
+
+static void ListFrames(StackWindow *wnd, BColumnListView *view)
+{
+	thread_info threadInfo;
+	status_t res;
+
+	Check(get_thread_info(wnd->fId, &threadInfo), "thread not found");
+	wnd->fTeam = threadInfo.team;
+
+	wnd->fDebuggerPort = Check(create_port(10, "debugger port"));
+	HandleDeleter<port_id, status_t, delete_port> portDeleter(wnd->fDebuggerPort);
+
+	wnd->fNubPort = Check(install_team_debugger(wnd->fTeam, wnd->fDebuggerPort), "can't install debugger");
+	HandleDeleter<team_id, status_t, remove_team_debugger> teamDebuggerDeleter(wnd->fTeam);
+
+	Check(init_debug_context(&wnd->fDebugContext, wnd->fTeam, wnd->fNubPort));
+	CObjectDeleter<debug_context, void, destroy_debug_context> debugContextDeleter(&wnd->fDebugContext);
+
+	Check(debug_thread(wnd->fId));
+
+	thread_id debugThread = spawn_thread(DebugThread, "debug thread", B_NORMAL_PRIORITY, wnd);
+	wait_for_thread(debugThread, &res); Check(res);
+
+	WriteStackTrace(wnd);
+}
+
+static void NewFramesView(StackWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Frames", B_NAVIGABLE);
+	view->AddColumn(new HexIntegerColumn("FP", 128, 50, 500, B_ALIGN_RIGHT), frameFpCol);
+	view->AddColumn(new HexIntegerColumn("IP", 128, 50, 500, B_ALIGN_RIGHT), frameIpCol);
+	view->AddColumn(new BStringColumn("Image", 150, 50, 500, B_TRUNCATE_END), frameImageCol);
+	view->AddColumn(new BStringColumn("Function", 512, 50, 1024, B_TRUNCATE_END), frameFunctionCol);
+	wnd->fView = view;
+	ListFrames(wnd, view);
+}
+
+
+std::map<team_id, StackWindow*> stacks;
+BLocker stacksLocker;
+
+void OpenStackWindow(team_id id, BPoint center)
+{
+	AutoLocker<BLocker> locker(stacksLocker);
+	auto it = stacks.find(id);
+	if (it != stacks.end()) {
+		it->second->Activate();
+	} else {
+		StackWindow *wnd = new StackWindow(id);
+		stacks[id] = wnd;
+		BRect frame = wnd->Frame();
+		wnd->MoveTo(center.x - frame.Width()/2, center.y - frame.Height()/2);
+		wnd->Show();
+	}
+}
+
+StackWindow::StackWindow(thread_id id): BWindow(BRect(0, 0, 800, 480), "Thread", B_DOCUMENT_WINDOW, B_ASYNCHRONOUS_CONTROLS | B_AUTO_UPDATE_SIZE_LIMITS),
+	fId(id)
+{
+	BMenuBar *menuBar;
+
+	BString title;
+	title.SetToFormat("Thread %" B_PRId32, fId);
+	SetTitle(title.String());
+
+	menuBar = new BMenuBar("menu", B_ITEMS_IN_ROW, true);
+	BLayoutBuilder::Menu<>(menuBar)
+		.AddMenu(new BMenu("File"))
+			.AddItem(new BMenuItem("Close", new BMessage(B_QUIT_REQUESTED), 'W'))
+			.End()
+		.End()
+	;
+
+	try {
+		NewFramesView(this);
+	} catch (StatusError &err) {
+		ShowError(err);
+		PostMessage(B_QUIT_REQUESTED);
+	}
+
+	BLayoutBuilder::Group<>(this, B_VERTICAL, 0)
+		.Add(menuBar)
+		.AddGroup(B_VERTICAL, 0)
+			.Add(fView)
+			.SetInsets(-1)
+			.End()
+		.End()
+	;
+}
+
+StackWindow::~StackWindow()
+{
+	printf("-StackWindow\n");
+	AutoLocker<BLocker> locker(stacksLocker);
+	stacks.erase(fId);
+}
diff --git a/src/apps/systemmanager/StackWindow.h b/src/apps/systemmanager/StackWindow.h
new file mode 100644
index 0000000000..853c1072dd
--- /dev/null
+++ b/src/apps/systemmanager/StackWindow.h
@@ -0,0 +1,28 @@
+#ifndef _STACKWINDOW_H_
+#define _STACKWINDOW_H_
+
+#include <Window.h>
+#include <OS.h>
+#include <private/debug/debug_support.h>
+#include <private/shared/AutoDeleter.h>
+
+class BColumnListView;
+
+class StackWindow: public BWindow
+{
+public:
+	BColumnListView *fView;
+
+
+	thread_id fId;
+	team_id fTeam;
+	port_id fDebuggerPort, fNubPort;
+	debug_context fDebugContext;
+
+	StackWindow(thread_id id);
+	~StackWindow();
+};
+
+void OpenStackWindow(thread_id id, BPoint center);
+
+#endif	// _STACKWINDOW_H_
diff --git a/src/apps/systemmanager/SystemManager.cpp b/src/apps/systemmanager/SystemManager.cpp
new file mode 100644
index 0000000000..1111ca42ff
--- /dev/null
+++ b/src/apps/systemmanager/SystemManager.cpp
@@ -0,0 +1,796 @@
+#include <stdio.h>
+#include <time.h>
+
+#include <OS.h>
+#include <image.h>
+#include <private/kernel/util/KMessage.h>
+#include <private/system/extended_system_info_defs.h>
+#include <private/libroot/extended_system_info.h>
+#include <private/system/syscall_process_info.h>
+#include <private/system/syscalls.h>
+#include <Application.h>
+#include <PropertyInfo.h>
+#include <Window.h>
+#include <Alert.h>
+#include <View.h>
+#include <TabView.h>
+#include <Rect.h>
+#include <Menu.h>
+#include <MenuBar.h>
+#include <MenuItem.h>
+#include <IconUtils.h>
+#include <LayoutBuilder.h>
+#include <private/interface/ColumnListView.h>
+#include <private/interface/ColumnTypes.h>
+#include <private/shared/AutoDeleter.h>
+
+#include <Entry.h>
+#include <Path.h>
+#include <NodeInfo.h>
+#include <FindDirectory.h>
+
+#include "TeamWindow.h"
+#include "Errors.h"
+#include "Utils.h"
+#include "UIUtils.h"
+
+enum {
+	invokeMsg = 1,
+	selectMsg,
+	updateMsg,
+
+	setLayoutMsg,
+
+	terminateMsg,
+	suspendMsg,
+	resumeMsg,
+	sendSignalMsg,
+	debugMsg,
+
+	showLocationMsg,
+};
+
+enum {
+	nameCol = 0,
+	idCol,
+	parentIdCol,
+	sidCol,
+	gidCol,
+	memSizeCol,
+	memAllocCol,
+	userCol,
+	pathCol,
+};
+
+enum {
+	statNameCol = 0,
+	statValueCol,
+};
+
+enum ViewLayout {
+	flatLayout = 0,
+	treeLayout = 1,
+	sessionsLayout = 2,
+};
+
+
+struct RowTree
+{
+	ObjectDeleter<RowTree> next, down;
+	ObjectDeleter<BRow> row;
+};
+
+
+static void BuildRowTree(ObjectDeleter<RowTree> &tree, BColumnListView *view, BRow *row)
+{
+	tree.SetTo(new RowTree());
+	tree->row.SetTo(row);
+	RowTree *last = NULL;
+	ObjectDeleter<RowTree> newNode;
+	int32 count = view->CountRows(row);
+	for (int32 i = 0; i < count; i++) {
+		BuildRowTree(newNode, view, view->RowAt(i, row));
+		if (last == NULL) {
+			tree->down.SetTo(newNode.Detach());
+			last = tree->down.Get();
+		} else {
+			last->next.SetTo(newNode.Detach());
+			last = last->next.Get();
+		}
+	}
+}
+
+static void RemoveRow(BColumnListView *view, BRow *row, ObjectDeleter<RowTree> &tree)
+{
+	BuildRowTree(tree, view, row);
+	view->RemoveRow(row);
+}
+
+static void InsertRow(BColumnListView *view, BRow *parent, ObjectDeleter<RowTree> &tree)
+{
+	if (tree.Get() == NULL) return;
+
+	BRow *row = tree->row.Detach();
+	view->AddRow(row, parent);
+	if (parent != NULL)
+		view->ExpandOrCollapse(parent, true);
+	ObjectDeleter<RowTree> list(tree->down.Detach());
+	while (list.Get() != NULL) {
+		ObjectDeleter<RowTree> next(list->next.Detach());
+		InsertRow(view, row, list);
+		list.SetTo(next.Detach());
+	}
+	tree.Unset();
+}
+
+static void SetRowParent(BColumnListView *view, BRow *row, BRow *newParent)
+{
+	BRow *oldParent;
+	view->FindParent(row, &oldParent, NULL);
+	if (newParent != oldParent) {
+		ObjectDeleter<RowTree> tree;
+		RemoveRow(view, row, tree);
+		InsertRow(view, newParent, tree);
+	}
+}
+
+static BRow *FindIntRow(BColumnListView *view, BRow *parent, int32 val)
+{
+	BRow *row, *row2;
+	BString name;
+	for (int32 i = 0; i < view->CountRows(parent); i++) {
+		row = view->RowAt(i, parent);
+		if (((BIntegerField*)row->GetField(idCol))->Value() == val)
+			return row;
+		row2 = FindIntRow(view, row, val);
+		if (row2 != NULL)
+			return row2;
+	}
+	return NULL;
+}
+
+static BRow *FindIntRowList(BList &list, int32 val)
+{
+	for (int32 i = 0; i < list.CountItems(); i++) {
+		BRow *row = (BRow*)list.ItemAt(i);
+		if (((BIntegerField*)row->GetField(idCol))->Value() == val)
+			return row;
+	}
+	return NULL;
+}
+
+static void CollectRowList(BList &list, BColumnListView *view, BRow *parent = NULL)
+{
+	for (int32 i = 0; i < view->CountRows(parent); i++) {
+		BRow *row = view->RowAt(i, parent);
+		list.AddItem(row);
+		CollectRowList(list, view, row);
+	}
+}
+
+static void RelayoutTeams(BColumnListView *view, ViewLayout layout)
+{
+	BList list;
+	CollectRowList(list, view);
+
+	switch (layout) {
+	case flatLayout: {
+		for (int32 i = 0; i < list.CountItems(); i++) {
+			BRow *row = (BRow*)list.ItemAt(i);
+			SetRowParent(view, row, NULL);
+		}
+		break;
+	}
+	case treeLayout: {
+		for (int32 i = 0; i < list.CountItems(); i++) {
+			BRow *row = (BRow*)list.ItemAt(i);
+			BRow *parent = FindIntRowList(list, ((BIntegerField*)row->GetField(parentIdCol))->Value());
+			SetRowParent(view, row, parent);
+		}
+		break;
+	}
+	case sessionsLayout: {
+		break;
+	}
+	}
+
+}
+
+static void GetTeamMemory(size_t &size, size_t &alloc, team_id team)
+{
+	area_info info;
+	ssize_t cookie = 0;
+
+	// TODO: limit max enumerated area count to prevent freezes
+	size = 0; alloc = 0;
+	while (get_next_area_info(team, &cookie, &info) >= B_OK) {
+		size += info.size;
+		alloc += info.ram_size;
+	}
+}
+
+static void ListTeams(BColumnListView *view, ViewLayout layout) {
+	status_t status;
+	team_info info;
+	int32 cookie;
+	BRow *row;
+	cookie = 0;
+	BList prevRows;
+	BString str;
+
+	CollectRowList(prevRows, view);
+
+	while (get_next_team_info(&cookie, &info) == B_OK) {
+		int32 uid = -1, gid = -1;
+		KMessage extInfo;
+		if (get_extended_team_info(info.team, B_TEAM_INFO_BASIC, extInfo) >= B_OK) {
+			if (extInfo.FindInt32("uid", &uid) < B_OK) uid = -1;
+			if (extInfo.FindInt32("gid", &gid) < B_OK) gid = -1;
+		}
+
+		int32 imageCookie = 0;
+		image_info imageInfo;
+		status = get_next_image_info(info.team, &imageCookie, &imageInfo);
+		if (status < B_OK) strcpy(imageInfo.name, "");
+		BPath path(imageInfo.name);
+
+		BBitmap* icon = new BBitmap(BRect(0, 0, B_MINI_ICON - 1, B_MINI_ICON - 1), B_RGBA32);
+		BEntry entry;
+		entry_ref ref;
+		if (status == B_OK) {
+			entry.SetTo(imageInfo.name);
+			status = entry.GetRef(&ref);
+		}
+		if (status == B_OK)
+			status = BNodeInfo::GetTrackerIcon(&ref, icon, B_MINI_ICON);
+		if (status != B_OK) {
+			BMimeType genericAppType(B_APP_MIME_TYPE);
+			status = genericAppType.GetIcon(icon, B_MINI_ICON);
+		}
+
+		row = FindIntRowList(prevRows, info.team);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		} else {
+			prevRows.RemoveItem(row);
+		}
+		row->SetField(new IconStringField(icon, path.Leaf()), nameCol);
+		row->SetField(new BIntegerField(info.team), idCol);
+		row->SetField(new BIntegerField(_kern_process_info(info.team, PARENT_ID)), parentIdCol);
+		row->SetField(new BIntegerField(_kern_process_info(info.team, SESSION_ID)), sidCol);
+		row->SetField(new BIntegerField(_kern_process_info(info.team, GROUP_ID)), gidCol);
+		size_t memSize, memAlloc;
+		GetTeamMemory(memSize, memAlloc, info.team);
+		GetSizeString(str, memSize); row->SetField(new BStringField(str), memSizeCol);
+		GetSizeString(str, memAlloc); row->SetField(new BStringField(str), memAllocCol);
+		GetUserGroupString(str, uid, gid);
+		row->SetField(new BStringField(str), userCol);
+		row->SetField(new BStringField(imageInfo.name), pathCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = (BRow*)prevRows.ItemAt(i);
+		view->RemoveRow(row);
+		delete row;
+	}
+
+	RelayoutTeams(view, layout);
+
+#if 0
+	switch (treeLayout) {
+	case flatLayout:
+		break;
+	case treeLayout: {
+		int32 count = view->CountRows(), i = 0;
+		while (i < count) {
+			row = view->RowAt(i);
+			BRow *parent = FindIntRow(view, NULL, ((BIntegerField*)row->GetField(parentIdCol))->Value());
+			if (parent != NULL) {
+				SetRowParent(view, row, parent);
+				i = 0; count = view->CountRows();
+			} else {
+				i++;
+			}
+		}
+		break;
+	}
+	case sessionsLayout: {
+		{
+			int32 count = view->CountRows(), i = 0;
+			while (i < count) {
+				row = view->RowAt(i);
+				int32 gid = ((BIntegerField*)row->GetField(gidCol))->Value();
+				BRow *parent = FindIntRow(view, NULL, gid);
+				if ((parent != NULL) && (parent != row)) {
+					SetRowParent(view, row, parent);
+					i = 0; count = view->CountRows();
+				} else {
+					i++;
+				}
+			}
+		}
+		{
+			int32 count = view->CountRows(), i = 0;
+			while (i < count) {
+				row = view->RowAt(i);
+				int32 sid = ((BIntegerField*)row->GetField(sidCol))->Value();
+				BRow *parent = FindIntRow(view, NULL, sid);
+				if ((parent != NULL) && (parent != row)) {
+					SetRowParent(view, row, parent);
+					i = 0; count = view->CountRows();
+				} else {
+					i++;
+				}
+			}
+		}
+		break;
+	}
+	}
+#endif
+}
+
+static BColumnListView* NewTeamsView()
+{
+	BColumnListView *view;
+	view = new BColumnListView("Teams", B_NAVIGABLE);
+	view->SetInvocationMessage(new BMessage(invokeMsg));
+	view->AddColumn(new IconStringColumn("Name", 256 - 32, 50, 500, B_TRUNCATE_MIDDLE), nameCol);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), idCol);
+	view->AddColumn(new BIntegerColumn("Parent", 64, 32, 128, B_ALIGN_RIGHT), parentIdCol);
+	view->AddColumn(new BIntegerColumn("Session", 64, 32, 128, B_ALIGN_RIGHT), sidCol);
+	view->AddColumn(new BIntegerColumn("Group", 64, 32, 128, B_ALIGN_RIGHT), gidCol);
+	view->AddColumn(new BStringColumn("Mapped", 64 + 16, 32, 256, B_TRUNCATE_END), memSizeCol);
+	view->AddColumn(new BStringColumn("Alloc", 64 + 16, 32, 256, B_TRUNCATE_END), memAllocCol);
+	view->AddColumn(new BStringColumn("User", 64 + 16, 32, 128, B_TRUNCATE_END), userCol);
+	view->AddColumn(new BStringColumn("Path", 512, 50, 1024, B_TRUNCATE_MIDDLE), pathCol);
+	view->SetColumnVisible(parentIdCol, false);
+	return view;
+}
+
+
+static void ListStats(BColumnListView *view)
+{
+	int32 rowId = 0;
+	BString str;
+
+	system_info info;
+
+	if (get_system_info(&info) >= B_OK) {
+		time_t unixTime = info.boot_time/1000000;
+		struct tm *tm = localtime(&unixTime);
+		str.SetToFormat("%04d.%02d.%02d %02d:%02d:%02d.%06d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, (int)(info.boot_time%1000000));
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		str.SetToFormat("%" B_PRIu32, info.cpu_count);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetUsedMaxSize(str, info.used_pages * B_PAGE_SIZE, info.max_pages * B_PAGE_SIZE);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetSizeString(str, info.cached_pages * B_PAGE_SIZE);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetSizeString(str, info.block_cache_pages * B_PAGE_SIZE);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetSizeString(str, info.ignored_pages * B_PAGE_SIZE);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetSizeString(str, info.needed_memory);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		uint64 totalMemory = info.max_pages * B_PAGE_SIZE;
+		GetUsedMaxSize(str, totalMemory - info.free_memory, totalMemory);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetUsedMaxSize(str, (info.max_swap_pages - info.free_swap_pages) * B_PAGE_SIZE, info.max_swap_pages * B_PAGE_SIZE);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		str.SetToFormat("%" B_PRIu32, info.page_faults);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetUsedMax(str, info.used_sems, info.max_sems);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetUsedMax(str, info.used_ports, info.max_ports);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetUsedMax(str, info.used_threads, info.max_threads);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		GetUsedMax(str, info.used_teams, info.max_teams);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+
+		view->RowAt(rowId++)->SetField(new BStringField(info.kernel_name), statValueCol);
+
+		str.SetToFormat("%s %s", info.kernel_build_date, info.kernel_build_time);
+		view->RowAt(rowId++)->SetField(new BStringField(str), statValueCol);
+	}
+}
+
+static void NewInfoRow(BColumnListView *view, const char *name)
+{
+	BRow *row = new BRow();
+	row->SetField(new BStringField(name), statNameCol);
+	view->AddRow(row);
+}
+
+static BColumnListView *NewStatsView()
+{
+	BColumnListView *view;
+	view = new BColumnListView("Stats", B_NAVIGABLE);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), statNameCol);
+	view->AddColumn(new BStringColumn("Value", 256, 50, 1024, B_TRUNCATE_END, B_ALIGN_RIGHT), statValueCol);
+
+	NewInfoRow(view, "Boot time");
+	NewInfoRow(view, "CPU count");
+	NewInfoRow(view, "Pages");
+	NewInfoRow(view, "Cached pages");
+	NewInfoRow(view, "Block cache pages");
+	NewInfoRow(view, "Ignored pages");
+	NewInfoRow(view, "Needed memory");
+	NewInfoRow(view, "Memory");
+	NewInfoRow(view, "Swap pages");
+	NewInfoRow(view, "Page faults");
+	NewInfoRow(view, "Semaphores");
+	NewInfoRow(view, "Ports");
+	NewInfoRow(view, "Threads");
+	NewInfoRow(view, "Teams");
+	NewInfoRow(view, "Kernel name");
+	NewInfoRow(view, "Kernel build timestamp");
+
+	ListStats(view);
+	return view;
+}
+
+
+static BMessage *NewSetLayoutMsg(int32 layout)
+{
+	BMessage *msg = new BMessage(setLayoutMsg);
+	msg->SetInt32("val", layout);
+	return msg;
+}
+
+class TestWindow: public BWindow
+{
+private:
+	BTabView *fTabView;
+	BColumnListView *fTeamsView;
+	BColumnListView *fStatsView;
+	ViewLayout fLayout;
+	BMessageRunner fListUpdater;
+
+public:
+	TestWindow(BRect frame): BWindow(frame, "SystemManager", B_DOCUMENT_WINDOW, B_ASYNCHRONOUS_CONTROLS | B_AUTO_UPDATE_SIZE_LIMITS),
+		fLayout(treeLayout),
+		fListUpdater(BMessenger(this), BMessage(updateMsg), 1000000)
+	{
+		BMenuBar *menuBar;
+		BMenu *signalMenu;
+		BTab *tab;
+
+		menuBar = new BMenuBar("menu", B_ITEMS_IN_ROW, true);
+		BLayoutBuilder::Menu<>(menuBar)
+/*
+			.AddMenu(new BMenu("File"))
+				.AddItem(new BMenuItem("New", new BMessage('item'), 'N'))
+				.AddItem(new BMenuItem("Open...", new BMessage('item'), 'O'))
+				.AddItem(new BMenuItem("Close", new BMessage(B_QUIT_REQUESTED), 'W'))
+				.AddSeparator()
+				.AddItem(new BMenuItem("Save", new BMessage('item'), 'S'))
+				.AddItem(new BMenuItem("Save as...", new BMessage('item'), 'S', B_SHIFT_KEY))
+				.AddSeparator()
+				.AddItem(new BMenuItem("Quit", new BMessage(B_QUIT_REQUESTED), 'Q'))
+				.End()
+*/
+			.AddMenu(new BMenu("View"))
+				.AddMenu(new BMenu("Layout"))
+					.AddItem(new BMenuItem("Flat", NewSetLayoutMsg(flatLayout)))
+					.AddItem(new BMenuItem("Tree", NewSetLayoutMsg(treeLayout)))
+					.AddItem(new BMenuItem("Sessions and groups", NewSetLayoutMsg(sessionsLayout)))
+					.End()
+				.End()
+			.AddMenu(new BMenu("Action"))
+/*
+				.AddItem(new BMenuItem("Update", new BMessage(updateMsg), 'R'))
+				.AddSeparator()
+*/
+				.AddItem(new BMenuItem("Terminate", new BMessage(terminateMsg), 'T'))
+				.AddItem(new BMenuItem("Suspend", new BMessage(suspendMsg)))
+				.AddItem(new BMenuItem("Resume", new BMessage(resumeMsg)))
+				.AddMenu(signalMenu = new BMenu("Send signal"))
+					.End()
+				.AddItem(new BMenuItem("Debug" B_UTF8_ELLIPSIS, new BMessage(debugMsg)))
+				.AddSeparator()
+				.AddItem(new BMenuItem("Show location", new BMessage(showLocationMsg)))
+				.End()
+			.End()
+		;
+
+		for (size_t i = 0; i < sizeof(signals)/sizeof(signals[0]); i++) {
+			BMessage *msg = new BMessage(sendSignalMsg);
+			msg->AddInt32("val", signals[i].val);
+			signalMenu->AddItem(new BMenuItem(signals[i].name, msg));
+		}
+
+		fTabView = new BTabView("tab_view", B_WIDTH_FROM_LABEL);
+		fTabView->SetBorder(B_NO_BORDER);
+
+		//tab = new BTab(); fTabView->AddTab(NewTeamsView("Apps"), tab);
+		tab = new BTab(); fTabView->AddTab(fTeamsView = NewTeamsView(), tab);
+		//tab = new BTab(); fTabView->AddTab(new TestView(BRect(0, 0, -1, -1), "Services", B_FOLLOW_NONE), tab);
+		//tab = new BTab(); fTabView->AddTab(new TestView(BRect(0, 0, -1, -1), "Sockets", B_FOLLOW_NONE), tab);
+		tab = new BTab(); fTabView->AddTab(fStatsView = NewStatsView(), tab);
+
+		ListTeams(fTeamsView, fLayout);
+
+		BLayoutBuilder::Group<>(this, B_VERTICAL, 0)
+			.Add(menuBar)
+			.AddGroup(B_VERTICAL, 0)
+				.Add(fTabView)
+				.SetInsets(-1, 0, -1, -1)
+				.End()
+			.End()
+		;
+	}
+
+	team_id SelectedTeam(const char **name = NULL)
+	{
+		BRow *row = fTeamsView->CurrentSelection(NULL);
+		if (row == NULL) return -1;
+		if (name != NULL) *name = ((IconStringField*)row->GetField(nameCol))->String();
+		return ((BIntegerField*)row->GetField(idCol))->Value();
+	}
+
+	void MessageReceived(BMessage *msg)
+	{
+		try {
+			switch (msg->what) {
+			case invokeMsg: {
+				team_id team = SelectedTeam();
+				if (team < B_OK) return;
+				BPoint center((Frame().left + Frame().right)/2, (Frame().top + Frame().bottom)/2);
+				OpenTeamWindow(team, center);
+				return;
+			}
+			case updateMsg: {
+				BTab *tab = fTabView->TabAt(fTabView->Selection());
+				if (tab == NULL) return;
+				BView *view = tab->View();
+				if (view == fTeamsView)
+					ListTeams(fTeamsView, fLayout);
+				else if (view == fStatsView)
+					ListStats(fStatsView);
+				return;
+			}
+			case setLayoutMsg: {
+				int32 layout;
+				CheckRetVoid(msg->FindInt32("val", &layout));
+				fLayout = (ViewLayout)layout;
+				RelayoutTeams(fTeamsView, fLayout);
+				return;
+			}
+			case terminateMsg: {
+				team_id team;
+				int32 which;
+				BInvoker *invoker = NULL;
+				if (msg->FindInt32("which", &which) < B_OK) {
+					const char *name;
+					team = SelectedTeam(&name);
+					if (team < B_OK) return;
+					Check(msg->AddInt32("team", team));
+					BString str;
+					str.SetToFormat("Are you sure you want to terminate team \"%s\" (%" B_PRId32 ")?", name, team);
+					BAlert *alert = new BAlert("SystemManager", str, "No", "Yes", NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);
+					invoker = new BInvoker(new BMessage(*msg), this);
+					invoker->Message()->SetPointer("invoker", invoker);
+					alert->Go(invoker);
+					return;
+				}
+				if (msg->FindPointer("invoker", &(void*&)invoker) >= B_OK) {
+					delete invoker; invoker = NULL;
+				}
+				if (which != 1) return;
+				CheckRetVoid(msg->FindInt32("team", &team));
+				if (team < B_OK) return;
+				Check(kill_team(team), "Can't terminate team.");
+				return;
+			}
+			case suspendMsg: {
+				team_id team = SelectedTeam();
+				if (team < B_OK) return;
+				CheckErrno(kill(team, SIGSTOP), "Can't suspend team.");
+				return;
+			}
+			case resumeMsg: {
+				team_id team = SelectedTeam();
+				if (team < B_OK) return;
+				CheckErrno(kill(team, SIGCONT), "Can't resume team.");
+				return;
+			}
+			case sendSignalMsg: {
+				int32 signal;
+				CheckRetVoid(msg->FindInt32("val", &signal));
+				team_id team = SelectedTeam();
+				if (team < B_OK) return;
+				CheckErrno(kill(team, signal), "Can't send signal.");
+				return;
+			}
+			case debugMsg: {
+				team_id team = SelectedTeam();
+				if (team < B_OK) return;
+				BPath debuggerPath;
+				BString teamStr;
+				Check(find_directory(B_SYSTEM_APPS_DIRECTORY, &debuggerPath), "(1)");
+				Check(debuggerPath.Append("Debugger"), "(2)");
+				teamStr.SetToFormat("%" B_PRId32, team);
+				int argc = 0;
+				const char *argv[4];
+				argv[argc++] = debuggerPath.Path();
+				argv[argc++] = "--team";
+				argv[argc++] = teamStr.String();
+				argv[argc] = NULL;
+				thread_id thread = Check(load_image(argc, argv, (const char**)environ), "(3)");
+				resume_thread(thread);
+				return;
+			}
+			case showLocationMsg: {
+				BRow *row = fTeamsView->CurrentSelection(NULL);
+				if (row == NULL) return;
+				ShowLocation(((BStringField*)row->GetField(pathCol))->String());
+			}
+			}
+		} catch (StatusError &err) {
+			ShowError(err);
+		}
+		BWindow::MessageReceived(msg);
+	}
+};
+
+
+static property_info gProperties[] = {
+	{"Team", {B_EXECUTE_PROPERTY, 0}, {B_INDEX_SPECIFIER, 0}},
+	{"Image", {B_EXECUTE_PROPERTY, 0}, {B_INDEX_SPECIFIER, 0}},
+	{"Thread", {B_EXECUTE_PROPERTY, 0}, {B_INDEX_SPECIFIER, 0}},
+	{"Area", {B_EXECUTE_PROPERTY, 0}, {B_INDEX_SPECIFIER, 0}},
+	{"Port", {B_EXECUTE_PROPERTY, 0}, {B_INDEX_SPECIFIER, 0}},
+	{"Sem", {B_EXECUTE_PROPERTY, 0}, {B_INDEX_SPECIFIER, 0}},
+	{0}
+};
+
+class TestApplication: public BApplication
+{
+private:
+	BWindow *fWnd;
+
+public:
+	TestApplication(): BApplication("application/x-vnd.Test-SystemManager")
+	{
+		fWnd = new TestWindow(BRect(0, 0, 640, 480));
+		fWnd->SetFlags(fWnd->Flags() | B_QUIT_ON_WINDOW_CLOSE);
+		fWnd->CenterOnScreen();
+		fWnd->Show();
+	}
+
+	BHandler *ResolveSpecifier(BMessage* message, int32 index, BMessage* specifier, int32 what, const char* property)
+	{
+		printf("TestApplication::ResolveSpecifier()\n");
+		BPropertyInfo propInfo(gProperties);
+		printf("specifier: "); specifier->PrintToStream();
+		if (propInfo.FindMatch(message, 0, specifier, what, property) >= 0)
+			return this;
+		return BApplication::ResolveSpecifier(message, index, specifier, what, property);
+	}
+
+	status_t GetSupportedSuites(BMessage *data)
+	{
+		printf("TestApplication::GetSupportedSuites()\n");
+		if (data == NULL) return B_BAD_VALUE;
+		CheckRet(data->AddString("suites", "suite/vnd.Test-SystemMangager"));
+		BPropertyInfo propertyInfo(gProperties);
+		CheckRet(data->AddFlat("messages", &propertyInfo));
+		return BApplication::GetSupportedSuites(data);
+	}
+
+	status_t HandleScript(BMessage &message, BMessage &reply, int32 index, BMessage &specifier, int32 what, const char* property)
+	{
+		BPropertyInfo propInfo(gProperties);
+		int32 propIdx = propInfo.FindMatch(&message, index, &specifier, what, property);
+		switch (propIdx) {
+		case 0: // Team: Execute
+		case 1: // Image: Execute
+		case 2: // Thread: Execute
+		case 3: // Area: Execute
+		case 4: // Port: Execute
+		case 5: // Sem: Execute
+			switch (what) {
+			case B_INDEX_SPECIFIER: {
+				CheckRet(specifier.FindInt32("index", &index));
+				BRect frame = fWnd->Frame();
+				BPoint center((frame.left + frame.right)/2, (frame.top + frame.bottom)/2);
+				switch (propIdx) {
+				case 0: {
+					OpenTeamWindow(index, center);
+					return B_OK;
+				}
+				case 2: {
+					thread_info info;
+					CheckRet(get_thread_info(index, &info));
+					BWindow *wnd = OpenTeamWindow(info.team, center);
+					BMessage wndMsg(teamWindowShowThreadMsg);
+					wndMsg.AddInt32("val", index);
+					BMessenger(wnd).SendMessage(&wndMsg);
+					return B_OK;
+				}
+				case 3: {
+					area_info info;
+					CheckRet(get_area_info(index, &info));
+					BWindow *wnd = OpenTeamWindow(info.team, center);
+					BMessage wndMsg(teamWindowShowAreaMsg);
+					wndMsg.AddInt32("val", index);
+					BMessenger(wnd).SendMessage(&wndMsg);
+					return B_OK;
+				}
+				case 4: {
+					port_info info;
+					CheckRet(get_port_info(index, &info));
+					BWindow *wnd = OpenTeamWindow(info.team, center);
+					BMessage wndMsg(teamWindowShowPortMsg);
+					wndMsg.AddInt32("val", index);
+					BMessenger(wnd).SendMessage(&wndMsg);
+					return B_OK;
+				}
+				case 5: {
+					sem_info info;
+					CheckRet(get_sem_info(index, &info));
+					BWindow *wnd = OpenTeamWindow(info.team, center);
+					BMessage wndMsg(teamWindowShowSemMsg);
+					wndMsg.AddInt32("val", index);
+					BMessenger(wnd).SendMessage(&wndMsg);
+					return B_OK;
+				}
+				}
+			}
+			}
+			break;
+		}
+		return B_BAD_SCRIPT_SYNTAX;
+	}
+
+	void MessageReceived(BMessage *msg)
+	{
+		int32 index;
+		BMessage specifier;
+		int32 what;
+		const char* property;
+
+		if (msg->HasSpecifiers() && msg->GetCurrentSpecifier(&index, &specifier, &what, &property) >= B_OK) {
+			BMessage reply(B_REPLY);
+			status_t res = HandleScript(*msg, reply, index, specifier, what, property);
+			if (res != B_OK) {
+				reply.what = B_MESSAGE_NOT_UNDERSTOOD;
+				reply.AddString("message", strerror(res));
+			}
+			reply.AddInt32("error", res);
+			msg->SendReply(&reply);
+			return;
+		}
+
+		switch (msg->what) {
+		case B_SILENT_RELAUNCH:
+			fWnd->Activate();
+			return;
+		}
+
+		BApplication::MessageReceived(msg);
+	}
+
+};
+
+
+int main()
+{
+	(new TestApplication())->Run();
+	return 0;
+}
diff --git a/src/apps/systemmanager/SystemManager.rdef b/src/apps/systemmanager/SystemManager.rdef
new file mode 100644
index 0000000000..df71d766f9
--- /dev/null
+++ b/src/apps/systemmanager/SystemManager.rdef
@@ -0,0 +1,41 @@
+resource app_signature "application/x-vnd.Test-SystemManager";
+
+resource app_flags B_SINGLE_LAUNCH;
+
+resource app_version {
+	major  = 0,
+	middle = 0,
+	minor  = 0,
+
+	variety = B_APPV_DEVELOPMENT,
+	internal = 0,
+
+	short_info = "SystemManager",
+	long_info = "List running teams and its objects."
+};
+
+resource vector_icon {
+	$"6E6369660E03010000020002023980000000000000004000004BE00008908100"
+	$"010000FFFF01000000020016023CC7EE389BC0BA16573E39B04977C842ADC700"
+	$"FFFFD3020006023C529D3753A2B8966F3D9D084B6044496AAF00474747FFA5A0"
+	$"A002001602BC4E76BC411B3C90DABCA00D47587D4ABA850090FFD40200160238"
+	$"313C3B5CF0BFCD963C7AAC4C13943FCAF901ECFFC3054B04017E020006033E2F"
+	$"99387F17BA42DB3FF5B94A0E32482C90001D1E2C3D454658FF01010102000602"
+	$"3879063B8224BE2CC83B10DB4A1F6F49B894FF9A9A9A00242222020006033C69"
+	$"A60000000000003E186148800049800058F3F3F300D4CECEFFD9D9D902000603"
+	$"3C1F1A33E78CB7ACC03FFE4F48BB3EBD7B6C0078D905818CFF05FF7ADD050200"
+	$"1602349C2E37B5FABA1F6036FC624A3E004B320001D3FF910200160235777837"
+	$"0A67B7E8CE363A844A1D684B45D800F3FF2E0D0A04486050605C51544E04033E"
+	$"5349594856475C49604B5C4E604B0A06262A264C485E5252523030240A04262A"
+	$"4838523030240A044838485E525252300A04262A264C485E48380A04453A4553"
+	$"2844282E0A04B6F9C0F42845282EB701B8EC0A044550455328452AC0F30A0445"
+	$"3A45502A43B701B8EC0408AEBAB6BCBCC32FBD4F2E3930BDA8B9ACC0A5BA9EBC"
+	$"03BB1EBFD937BF0DBD4FC072BCC3C019BDDBC0CB46460204BF23C726BF91C70D"
+	$"BEB5C73FBE9FC87EBE7AC7D9BEC5C922BFAAC97BBF3CC994C018C962C02DC823"
+	$"C053C8C8C008C77F0204BFCEC6FBC042C6E0BF5BC715BF48C85ABF1FC7B3BF71"
+	$"C902C063C95ABFF0C974C0D7C93FC0EAC7FAC113C8A2C0C1C7530E0A07010000"
+	$"0A0101011001178300040A0001021001178400040A020103000A080109000A0B"
+	$"010A1001178120040A030104000A04020506000A090107000A0A0108000A0D01"
+	$"0C0815FF0A0C010B0815FF0A0D010C0A3FEAF70000000000003FEAF7C573B4C2"
+	$"770615FF0A0C010B0A3FEAF70000000000003FEAF7C573B4C2770615FF"
+};
diff --git a/src/apps/systemmanager/TeamWindow.cpp b/src/apps/systemmanager/TeamWindow.cpp
new file mode 100644
index 0000000000..d96d4a555c
--- /dev/null
+++ b/src/apps/systemmanager/TeamWindow.cpp
@@ -0,0 +1,930 @@
+#include "TeamWindow.h"
+
+#include <Application.h>
+#include <View.h>
+#include <TabView.h>
+#include <Rect.h>
+#include <Menu.h>
+#include <MenuBar.h>
+#include <MenuItem.h>
+#include <PopUpMenu.h>
+#include <Box.h>
+#include <LayoutBuilder.h>
+#include <private/interface/ColumnListView.h>
+#include <private/interface/ColumnTypes.h>
+#include <private/shared/AutoLocker.h>
+#include <String.h>
+#include <image.h>
+#include <private/kernel/util/KMessage.h>
+#include <private/system/extended_system_info_defs.h>
+#include <private/libroot/extended_system_info.h>
+#include <drivers/KernelExport.h>
+#include <fs_info.h>
+#include <private/system/syscalls.h>
+#include <private/system/vfs_defs.h>
+
+#include <Entry.h>
+#include <Path.h>
+
+#include <map>
+
+#include "StackWindow.h"
+#include "Errors.h"
+#include "Utils.h"
+#include "UIUtils.h"
+
+
+enum {
+	imageIdCol = 0,
+	imageTextCol,
+	imageDataCol,
+	imageNameCol,
+	imagePathCol,
+};
+
+enum {
+	threadIdCol = 0,
+	threadNameCol,
+	threadStateCol,
+	threadPriorityCol,
+	threadSemCol,
+	threadUserTimeCol,
+	threadKernelTimeCol,
+	threadStackBaseCol,
+	threadStackEndCol,
+};
+
+enum {
+	areaIdCol = 0,
+	areaNameCol,
+	areaAdrCol,
+	areaSizeCol,
+	areaAllocCol,
+	areaProtCol,
+	areaLockCol,
+};
+
+enum {
+	portIdCol = 0,
+	portNameCol,
+	portCapacityCol,
+	portQueuedCol,
+	portTotalCol,
+};
+
+enum {
+	semIdCol = 0,
+	semNameCol,
+	semCountCol,
+	semLatestHolderCol,
+};
+
+enum {
+	fileNameCol,
+	fileIdCol,
+	fileModeCol,
+	fileDevCol,
+	fileNodeCol,
+	fileDevNameCol,
+	fileVolNameCol,
+	fileFsNameCol
+};
+
+enum {
+	infoNameCol = 0,
+	infoValueCol,
+};
+
+enum {
+	updateMsg = teamWindowPrivateMsgBase,
+	infoShowWorkDirMsg,
+	imagesShowLocationMsg,
+	threadsInvokeMsg,
+	threadsTerminateMsg,
+	threadsSendSignalMsg,
+	threadsShowSemMsg,
+	threadsShowStackAreaMsg,
+	semsShowThreadMsg,
+};
+
+
+static const char *GetFileName(const char *path)
+{
+	const char *name = path;
+	for (const char *it = name; *it != '\0'; it++) {
+		if (*it == '/') name = it + 1;
+	}
+	return name;
+}
+
+static BRow *FindIntRow(BColumnListView *view, int32 col, BRow *parent, int32 val)
+{
+	BRow *row;
+	BString name;
+	for (int32 i = 0; i < view->CountRows(parent); i++) {
+		row = view->RowAt(i, parent);
+		if (((BIntegerField*)row->GetField(col))->Value() == val)
+			return row;
+	}
+	return NULL;
+}
+
+
+//#pragma mark Lists
+
+static void ListInfo(TeamWindow *wnd, BColumnListView *view)
+{
+	int32 rowId = 0;
+	int32 int32Val = -1;
+	BString str;
+	const char *strPtr;
+	int32 uid = -1, gid = -1;
+
+	KMessage extInfo;
+
+	if (get_extended_team_info(wnd->fId, B_TEAM_INFO_BASIC, extInfo) >= B_OK) {
+		if (extInfo.FindInt32("id", &int32Val) >= B_OK) {
+			str.SetToFormat("%" B_PRId32, int32Val);
+			view->RowAt(rowId++)->SetField(new BStringField(str), infoValueCol);
+		}
+		if (extInfo.FindString("name", &strPtr) >= B_OK) {
+			view->RowAt(rowId++)->SetField(new BStringField(strPtr), infoValueCol);
+		}
+
+		if (extInfo.FindInt32("process group", &int32Val) >= B_OK) {
+			str.SetToFormat("%" B_PRId32, int32Val);
+			view->RowAt(rowId++)->SetField(new BStringField(str), infoValueCol);
+		}
+
+		if (extInfo.FindInt32("session", &int32Val) >= B_OK) {
+			str.SetToFormat("%" B_PRId32, int32Val);
+			view->RowAt(rowId++)->SetField(new BStringField(str), infoValueCol);
+		}
+
+		if (extInfo.FindInt32("uid", &uid) < B_OK) uid = -1;
+		if (extInfo.FindInt32("gid", &gid) < B_OK) gid = -1;
+		GetUserGroupString(str, uid, gid, true);
+		view->RowAt(rowId++)->SetField(new BStringField(str), infoValueCol);
+
+		if (extInfo.FindInt32("euid", &uid) < B_OK) uid = -1;
+		if (extInfo.FindInt32("egid", &gid) < B_OK) gid = -1;
+		GetUserGroupString(str, uid, gid, true);
+		view->RowAt(rowId++)->SetField(new BStringField(str), infoValueCol);
+
+		entry_ref ref;
+		if (
+			extInfo.FindInt32("cwd device", &ref.device) >= B_OK &&
+			extInfo.FindInt64("cwd directory", &ref.directory) >= B_OK
+		) {
+			ref.set_name(".");
+			BPath path(&ref);
+			view->RowAt(rowId++)->SetField(new BStringField(path.Path()), infoValueCol);
+		}
+	}
+}
+
+static void NewInfoRow(BColumnListView *view, const char *name)
+{
+	BRow *row = new BRow();
+	row->SetField(new BStringField(name), infoNameCol);
+	view->AddRow(row);
+}
+
+static BColumnListView *NewInfoView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Info", B_NAVIGABLE);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), infoNameCol);
+	view->AddColumn(new BStringColumn("Value", 512, 50, 1024, B_TRUNCATE_END), infoValueCol);
+
+	NewInfoRow(view, "ID");
+	NewInfoRow(view, "Name");
+	NewInfoRow(view, "Process group");
+	NewInfoRow(view, "Session");
+	NewInfoRow(view, "User");
+	NewInfoRow(view, "Effective user");
+	NewInfoRow(view, "Working directory");
+
+	ListInfo(wnd, view);
+	return view;
+}
+
+
+static void ListImages(TeamWindow *wnd, BColumnListView *view)
+{
+	int32 cookie = 0;
+	image_info info;
+	BString str;
+	BRow *row;
+	BList prevRows;
+
+	for (int32 i = 0; i < view->CountRows(); i++) {
+		row = view->RowAt(i);
+		prevRows.AddItem((void*)(addr_t)(((BIntegerField*)row->GetField(imageIdCol))->Value()));
+	}
+
+	while (get_next_image_info(wnd->fId, &cookie, &info) >= B_OK) {
+		prevRows.RemoveItem((void*)(addr_t)info.id);
+		row = FindIntRow(view, imageIdCol, NULL, info.id);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		}
+
+		row->SetField(new BIntegerField(info.id), imageIdCol);
+		row->SetField(new Int64Field((uintptr_t)info.text), imageTextCol);
+		row->SetField(new Int64Field((uintptr_t)info.data), imageDataCol);
+		row->SetField(new BStringField(GetFileName(info.name)), imageNameCol);
+		row->SetField(new BStringField(info.name), imagePathCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = FindIntRow(view, imageIdCol, NULL, (int32)(addr_t)prevRows.ItemAt(i));
+		view->RemoveRow(row);
+		delete row;
+	}
+}
+
+static BColumnListView *NewImagesView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Images", B_NAVIGABLE);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), imageIdCol);
+	view->AddColumn(new HexIntegerColumn("Text", 128, 50, 500, B_ALIGN_RIGHT), imageTextCol);
+	view->AddColumn(new HexIntegerColumn("Data", 128, 50, 500, B_ALIGN_RIGHT), imageDataCol);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), imageNameCol);
+	view->AddColumn(new BStringColumn("Path", 500, 50, 1000, B_TRUNCATE_MIDDLE), imagePathCol);
+	ListImages(wnd, view);
+	return view;
+}
+
+static void ListThreads(TeamWindow *wnd, BColumnListView *view)
+{
+	int32 cookie = 0;
+	thread_info info;
+	BString str;
+	BRow *row;
+	BList prevRows;
+
+	for (int32 i = 0; i < view->CountRows(); i++) {
+		row = view->RowAt(i);
+		prevRows.AddItem((void*)(addr_t)(((BIntegerField*)row->GetField(threadIdCol))->Value()));
+	}
+
+	while (get_next_thread_info(wnd->fId, &cookie, &info) >= B_OK) {
+		prevRows.RemoveItem((void*)(addr_t)info.thread);
+		row = FindIntRow(view, threadIdCol, NULL, info.thread);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		}
+
+		row->SetField(new BIntegerField(info.thread), threadIdCol);
+		row->SetField(new BStringField(info.name), threadNameCol);
+
+		switch (info.state) {
+		case B_THREAD_RUNNING: str = "running"; break;
+		case B_THREAD_READY: str = "ready"; break;
+		case B_THREAD_RECEIVING: str = "receiving"; break;
+		case B_THREAD_ASLEEP: str = "asleep"; break;
+		case B_THREAD_SUSPENDED: str = "suspended"; break;
+		case B_THREAD_WAITING: str = "waiting"; break;
+		default:
+			str.SetToFormat("? (%d)", info.state);
+		}
+		row->SetField(new BStringField(str), threadStateCol);
+
+		row->SetField(new BIntegerField(info.priority), threadPriorityCol);
+		GetSemString(str, info.sem);
+		row->SetField(new BStringField(str), threadSemCol);
+		row->SetField(new BIntegerField(info.user_time), threadUserTimeCol);
+		row->SetField(new BIntegerField(info.kernel_time), threadKernelTimeCol);
+		row->SetField(new Int64Field((addr_t)info.stack_base), threadStackBaseCol);
+		row->SetField(new Int64Field((addr_t)info.stack_end), threadStackEndCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = FindIntRow(view, threadIdCol, NULL, (int32)(addr_t)prevRows.ItemAt(i));
+		view->RemoveRow(row);
+		delete row;
+	}
+}
+
+static BColumnListView *NewThreadsView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Threads", B_NAVIGABLE);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), threadIdCol);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), threadNameCol);
+	view->AddColumn(new BStringColumn("State", 150, 50, 500, B_TRUNCATE_END), threadStateCol);
+	view->AddColumn(new BIntegerColumn("Priority", 96, 32, 128, B_ALIGN_RIGHT), threadPriorityCol);
+	view->AddColumn(new BStringColumn("Sem", 96, 32, 512, B_TRUNCATE_END), threadSemCol);
+	view->AddColumn(new BIntegerColumn("User time", 96, 32, 128, B_ALIGN_RIGHT), threadUserTimeCol);
+	view->AddColumn(new BIntegerColumn("Kernel time", 96, 32, 128, B_ALIGN_RIGHT), threadKernelTimeCol);
+	view->AddColumn(new HexIntegerColumn("Stack base", 128, 50, 500, B_ALIGN_RIGHT), threadStackBaseCol);
+	view->AddColumn(new HexIntegerColumn("Stack end", 128, 50, 500, B_ALIGN_RIGHT), threadStackEndCol);
+	view->SetInvocationMessage(new BMessage(threadsInvokeMsg));
+	ListThreads(wnd, view);
+	return view;
+}
+
+static void ListAreas(TeamWindow *wnd, BColumnListView *view)
+{
+	ssize_t cookie = 0;
+	area_info info;
+	BString str, str2;
+	BRow *row;
+	BList prevRows;
+
+	for (int32 i = 0; i < view->CountRows(); i++) {
+		row = view->RowAt(i);
+		prevRows.AddItem((void*)(addr_t)(((BIntegerField*)row->GetField(areaIdCol))->Value()));
+	}
+
+	while (get_next_area_info(wnd->fId, &cookie, &info) >= B_OK) {
+		prevRows.RemoveItem((void*)(addr_t)info.area);
+		row = FindIntRow(view, areaIdCol, NULL, info.area);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		}
+
+		row->SetField(new BIntegerField(info.area), areaIdCol);
+		row->SetField(new BStringField(info.name), areaNameCol);
+		row->SetField(new Int64Field((addr_t)info.address), areaAdrCol);
+		row->SetField(new Int64Field(info.size), areaSizeCol);
+		row->SetField(new Int64Field(info.ram_size), areaAllocCol);
+
+		str = "";
+		if (B_READ_AREA & info.protection) str += "R";
+		if (B_WRITE_AREA & info.protection) str += "W";
+		if (B_EXECUTE_AREA & info.protection) str += "X";
+		if (B_STACK_AREA & info.protection) str += "S";
+		if (B_KERNEL_READ_AREA & info.protection) str += "r";
+		if (B_KERNEL_WRITE_AREA & info.protection) str += "w";
+		if (B_KERNEL_EXECUTE_AREA & info.protection) str += "x";
+		if (B_KERNEL_STACK_AREA & info.protection) str += "s";
+		if (B_CLONEABLE_AREA & info.protection) str += "C";
+		row->SetField(new BStringField(str), areaProtCol);
+
+		switch (info.lock) {
+		case B_NO_LOCK: str = "no"; break;
+		case B_LAZY_LOCK: str = "lazy"; break;
+		case B_FULL_LOCK: str = "full"; break;
+		case B_CONTIGUOUS: str = "contiguous"; break;
+		case B_LOMEM: str = "lomem"; break;
+		case B_32_BIT_FULL_LOCK: str = "32 bit full"; break;
+		case B_32_BIT_CONTIGUOUS: str = "32 bit contiguous"; break;
+		default:
+			str.SetToFormat("? (%" B_PRIu32 ")", info.lock);
+		}
+		row->SetField(new BStringField(str), areaLockCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = FindIntRow(view, areaIdCol, NULL, (int32)(addr_t)prevRows.ItemAt(i));
+		view->RemoveRow(row);
+		delete row;
+	}
+}
+
+static BColumnListView *NewAreasView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Areas", B_NAVIGABLE);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), areaIdCol);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), areaNameCol);
+	view->AddColumn(new HexIntegerColumn("Address", 128, 50, 500, B_ALIGN_RIGHT), areaAdrCol);
+	view->AddColumn(new HexIntegerColumn("Size", 128, 50, 500, B_ALIGN_RIGHT), areaSizeCol);
+	view->AddColumn(new HexIntegerColumn("Alloc", 128, 50, 500, B_ALIGN_RIGHT), areaAllocCol);
+	view->AddColumn(new BStringColumn("Prot", 64, 50, 500, B_TRUNCATE_END, B_ALIGN_RIGHT), areaProtCol);
+	view->AddColumn(new BStringColumn("lock", 64, 50, 500, B_TRUNCATE_END, B_ALIGN_RIGHT), areaLockCol);
+	ListAreas(wnd, view);
+	return view;
+}
+
+static void ListPorts(TeamWindow *wnd, BColumnListView *view)
+{
+	int32 cookie = 0;
+	port_info info;
+	BString str, str2;
+	BRow *row;
+	BList prevRows;
+
+	for (int32 i = 0; i < view->CountRows(); i++) {
+		row = view->RowAt(i);
+		prevRows.AddItem((void*)(addr_t)(((BIntegerField*)row->GetField(portIdCol))->Value()));
+	}
+
+	while (get_next_port_info(wnd->fId, &cookie, &info) >= B_OK) {
+		prevRows.RemoveItem((void*)(addr_t)info.port);
+		row = FindIntRow(view, portIdCol, NULL, info.port);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		}
+
+		row->SetField(new BIntegerField(info.port), portIdCol);
+		row->SetField(new BStringField(info.name), portNameCol);
+		row->SetField(new BIntegerField(info.capacity), portCapacityCol);
+		row->SetField(new BIntegerField(info.queue_count), portQueuedCol);
+		row->SetField(new BIntegerField(info.total_count), portTotalCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = FindIntRow(view, portIdCol, NULL, (int32)(addr_t)prevRows.ItemAt(i));
+		view->RemoveRow(row);
+		delete row;
+	}
+}
+
+static BColumnListView *NewPortsView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Ports", B_NAVIGABLE);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), portIdCol);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), portNameCol);
+	view->AddColumn(new BIntegerColumn("Capacity", 64, 32, 128, B_ALIGN_RIGHT), portCapacityCol);
+	view->AddColumn(new BIntegerColumn("Queued", 64, 32, 128, B_ALIGN_RIGHT), portQueuedCol);
+	view->AddColumn(new BIntegerColumn("Total", 96, 32, 256, B_ALIGN_RIGHT), portTotalCol);
+	ListPorts(wnd, view);
+	return view;
+}
+
+static void ListSems(TeamWindow *wnd, BColumnListView *view)
+{
+	int32 cookie = 0;
+	sem_info info;
+	BRow *row;
+	BList prevRows;
+	BString str;
+
+	for (int32 i = 0; i < view->CountRows(); i++) {
+		row = view->RowAt(i);
+		prevRows.AddItem((void*)(addr_t)(((BIntegerField*)row->GetField(semIdCol))->Value()));
+	}
+
+	while (get_next_sem_info(wnd->fId, &cookie, &info) >= B_OK) {
+		prevRows.RemoveItem((void*)(addr_t)info.sem);
+		row = FindIntRow(view, semIdCol, NULL, info.sem);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		}
+
+		row->SetField(new BIntegerField(info.sem), semIdCol);
+		row->SetField(new BStringField(info.name), semNameCol);
+		row->SetField(new BIntegerField(info.count), semCountCol);
+		GetThreadString(str, info.latest_holder);
+		row->SetField(new BStringField(str), semLatestHolderCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = FindIntRow(view, semIdCol, NULL, (int32)(addr_t)prevRows.ItemAt(i));
+		view->RemoveRow(row);
+		delete row;
+	}
+}
+
+static BColumnListView *NewSemsView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Semaphores", B_NAVIGABLE);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), semIdCol);
+	view->AddColumn(new BStringColumn("Name", 150, 50, 500, B_TRUNCATE_END), semNameCol);
+	view->AddColumn(new BIntegerColumn("Count", 64, 32, 128, B_ALIGN_RIGHT), semCountCol);
+	view->AddColumn(new BStringColumn("Latest holder", 96, 32, 1024, B_TRUNCATE_END), semLatestHolderCol);
+	ListSems(wnd, view);
+	return view;
+}
+
+static void ListFiles(TeamWindow *wnd, BColumnListView *view)
+{
+	uint32 cookie = 0;
+	fd_info info;
+	fs_info fsInfo;
+	BRow *row;
+	BList prevRows;
+	BString buf;
+	char path[B_OS_NAME_LENGTH];
+
+	for (int32 i = 0; i < view->CountRows(); i++) {
+		row = view->RowAt(i);
+		prevRows.AddItem((void*)(addr_t)(((BIntegerField*)row->GetField(fileIdCol))->Value()));
+	}
+
+	while (_kern_get_next_fd_info(wnd->fId, &cookie, &info, sizeof(fd_info)) >= B_OK) {
+		prevRows.RemoveItem((void*)(addr_t)info.number);
+		row = FindIntRow(view, fileIdCol, NULL, info.number);
+		if (row == NULL) {
+			row = new BRow();
+			view->AddRow(row);
+		}
+
+		if (_kern_entry_ref_to_path(info.device, info.node, NULL, path, B_OS_NAME_LENGTH) == B_OK)
+			row->SetField(new BStringField(path), fileNameCol);
+		else
+			row->SetField(new BStringField("?"), fileNameCol);
+
+		row->SetField(new BIntegerField(info.number), fileIdCol);
+
+		if ((info.open_mode & O_RWMASK) == O_RDONLY) {buf = "R";}
+		if ((info.open_mode & O_RWMASK) == O_WRONLY) {buf = "W";}
+		if ((info.open_mode & O_RWMASK) == O_RDWR  ) {buf = "RW";}
+		row->SetField(new BStringField(buf), fileModeCol);
+		row->SetField(new BIntegerField(info.device), fileDevCol);
+		row->SetField(new BIntegerField(info.node), fileNodeCol);
+
+		fs_stat_dev(info.device, &fsInfo);
+		row->SetField(new BStringField(fsInfo.device_name), fileDevNameCol);
+		row->SetField(new BStringField(fsInfo.volume_name), fileVolNameCol);
+		row->SetField(new BStringField(fsInfo.fsh_name), fileFsNameCol);
+	}
+
+	for (int32 i = 0; i < prevRows.CountItems(); i++) {
+		row = FindIntRow(view, fileIdCol, NULL, (int32)(addr_t)prevRows.ItemAt(i));
+		view->RemoveRow(row);
+		delete row;
+	}
+}
+
+static BColumnListView *NewFilesView(TeamWindow *wnd)
+{
+	BColumnListView *view;
+	view = new BColumnListView("Files", B_NAVIGABLE);
+	view->AddColumn(new BStringColumn("Name", 250, 50, 512, B_TRUNCATE_MIDDLE), fileNameCol);
+	view->AddColumn(new BIntegerColumn("ID", 64, 32, 128, B_ALIGN_RIGHT), fileIdCol);
+	view->AddColumn(new BStringColumn("Mode", 48, 32, 128, B_TRUNCATE_MIDDLE, B_ALIGN_LEFT), fileModeCol);
+	view->AddColumn(new BIntegerColumn("Dev", 64, 32, 128, B_ALIGN_RIGHT), fileDevCol);
+	view->AddColumn(new BIntegerColumn("Node", 64, 32, 128, B_ALIGN_RIGHT), fileNodeCol);
+	view->AddColumn(new BStringColumn("Device", 96, 32, 512, B_TRUNCATE_MIDDLE, B_ALIGN_LEFT), fileDevNameCol);
+	view->AddColumn(new BStringColumn("Volume", 96, 32, 512, B_TRUNCATE_MIDDLE, B_ALIGN_LEFT), fileVolNameCol);
+	view->AddColumn(new BStringColumn("FS", 96, 32, 512, B_TRUNCATE_MIDDLE, B_ALIGN_LEFT), fileFsNameCol);
+	ListFiles(wnd, view);
+	return view;
+}
+
+
+class TabView: public BTabView
+{
+private:
+	TeamWindow *fWnd;
+
+public:
+	TabView(TeamWindow *wnd): BTabView("tabView", B_WIDTH_FROM_LABEL), fWnd(wnd) {}
+	
+	void Select(int32 index)
+	{
+		BTabView::Select(index);
+		fWnd->TabChanged();
+	}
+	
+};
+
+
+//#pragma mark TeamWindow
+
+std::map<team_id, TeamWindow*> teamWindows;
+BLocker teamWindowsLocker;
+
+TeamWindow *OpenTeamWindow(team_id id, BPoint center)
+{
+	AutoLocker<BLocker> locker(teamWindowsLocker);
+	auto it = teamWindows.find(id);
+	if (it != teamWindows.end()) {
+		it->second->Activate();
+		return it->second;
+	} else {
+		TeamWindow *wnd = new TeamWindow(id);
+		teamWindows[id] = wnd;
+		BRect frame = wnd->Frame();
+		wnd->MoveTo(center.x - frame.Width()/2, center.y - frame.Height()/2);
+		wnd->Show();
+		return wnd;
+	}
+}
+
+static BMessage *NewSignalMsg(int32 signal)
+{
+	BMessage *msg = new BMessage(threadsSendSignalMsg);
+	msg->AddInt32("val", signal);
+	return msg;
+}
+
+TeamWindow::TeamWindow(team_id id): BWindow(BRect(0, 0, 800, 480), "Team", B_DOCUMENT_WINDOW, B_ASYNCHRONOUS_CONTROLS | B_AUTO_UPDATE_SIZE_LIMITS),
+	fListUpdater(BMessenger(this), BMessage(updateMsg), 1000000),
+	fCurMenu(NULL),
+	fId(id)
+{
+	BTab *tab;
+	BMenu *menu;
+
+	try {
+		int32 cookie = 0;
+		image_info imageInfo;
+		Check(get_next_image_info(fId, &cookie, &imageInfo), "Invalid team id.");
+		BString title;
+		title.SetToFormat("%s (%" B_PRId32 ")", GetFileName(imageInfo.name), fId);
+		SetTitle(title.String());
+	} catch (StatusError &err) {
+		ShowError(err);
+		PostMessage(B_QUIT_REQUESTED);
+	}
+
+	fMenuBar = new BMenuBar("menu", B_ITEMS_IN_ROW, true);
+	BLayoutBuilder::Menu<>(fMenuBar)
+		.AddMenu(new BMenu("File"))
+			.AddItem(new BMenuItem("Close", new BMessage(B_QUIT_REQUESTED), 'W'))
+			.End()
+		.End()
+	;
+
+	menu = new BMenu("Info");
+	BLayoutBuilder::Menu<>(menu)
+		.AddItem(new BMenuItem("Show working directory", new BMessage(infoShowWorkDirMsg)))
+		.End()
+	;
+	fInfoMenu = new BMenuItem(menu);
+
+	menu = new BMenu("Image");
+	BLayoutBuilder::Menu<>(menu)
+		.AddItem(new BMenuItem("Show location", new BMessage(imagesShowLocationMsg)))
+		.End()
+	;
+	fImagesMenu = new BMenuItem(menu);
+
+	BMenu *signalMenu;
+	menu = new BMenu("Thread");
+	BLayoutBuilder::Menu<>(menu)
+		.AddItem(new BMenuItem("Terminate", new BMessage(threadsTerminateMsg), 'T'))
+		.AddItem(new BMenuItem("Suspend", NewSignalMsg(SIGSTOP)))
+		.AddItem(new BMenuItem("Resume", NewSignalMsg(SIGCONT)))
+		.AddMenu(signalMenu = new BMenu("Send signal"))
+			.End()
+		.AddSeparator()
+		.AddItem(new BMenuItem("Show semaphore", new BMessage(threadsShowSemMsg)))
+		.AddItem(new BMenuItem("Show stack area", new BMessage(threadsShowStackAreaMsg)))
+		.End()
+	;
+	fThreadsMenu = new BMenuItem(menu);
+	for (size_t i = 0; i < sizeof(signals)/sizeof(signals[0]); i++)
+		signalMenu->AddItem(new BMenuItem(signals[i].name, NewSignalMsg(signals[i].val)));
+
+	menu = new BMenu("Semaphore");
+	BLayoutBuilder::Menu<>(menu)
+		.AddItem(new BMenuItem("Show holder thread", new BMessage(semsShowThreadMsg)))
+		.End()
+	;
+	fSemsMenu = new BMenuItem(menu);
+
+	fTabView = new TabView(this);
+	fTabView->SetBorder(B_NO_BORDER);
+
+	tab = new BTab(); fTabView->AddTab(fInfoView = NewInfoView(this), tab);
+	tab = new BTab(); fTabView->AddTab(fImagesView = NewImagesView(this), tab);
+	tab = new BTab(); fTabView->AddTab(fThreadsView = NewThreadsView(this), tab);
+	tab = new BTab(); fTabView->AddTab(fAreasView = NewAreasView(this), tab);
+	tab = new BTab(); fTabView->AddTab(fPortsView = NewPortsView(this), tab);
+	tab = new BTab(); fTabView->AddTab(fSemsView = NewSemsView(this), tab);
+	tab = new BTab(); fTabView->AddTab(fFilesView = NewFilesView(this), tab);
+
+	BLayoutBuilder::Group<>(this, B_VERTICAL, 0)
+		.Add(fMenuBar)
+		.AddGroup(B_VERTICAL, 0)
+			.Add(fTabView)
+			.SetInsets(-1, 0, -1, -1)
+			.End()
+		.End()
+	;
+
+	TabChanged();
+}
+
+TeamWindow::~TeamWindow()
+{
+	printf("-TeamWindow\n");
+	AutoLocker<BLocker> locker(teamWindowsLocker);
+	teamWindows.erase(fId);
+}
+
+void TeamWindow::TabChanged()
+{
+	BMenuItem *newMenu = NULL;
+	BTab *tab = fTabView->TabAt(fTabView->Selection());
+	if (tab != NULL) {
+		BView *view = tab->View();
+		if (view == fInfoView)
+			newMenu = fInfoMenu;
+		else if (view == fImagesView)
+			newMenu = fImagesMenu;
+		else if (view == fThreadsView)
+			newMenu = fThreadsMenu;
+		else if (view == fSemsView)
+			newMenu = fSemsMenu;
+	}
+	SetMenu(newMenu);
+}
+
+void TeamWindow::SetMenu(BMenuItem *menu)
+{
+	if (fCurMenu == menu) return;
+	if (fCurMenu != NULL) fMenuBar->RemoveItem(fCurMenu);
+	fCurMenu = menu;
+	if (fCurMenu != NULL) fMenuBar->AddItem(fCurMenu);
+}
+
+void TeamWindow::MessageReceived(BMessage *msg)
+{
+	switch (msg->what) {
+	case updateMsg: {
+		BTab *tab = fTabView->TabAt(fTabView->Selection());
+		if (tab != NULL) {
+			BView *view = tab->View();
+			if (view == fInfoView)
+				ListInfo(this, fInfoView);
+			else if (view == fImagesView)
+				ListImages(this, fImagesView);
+			else if (view == fThreadsView)
+				ListThreads(this, fThreadsView);
+			else if (view == fAreasView)
+				ListAreas(this, fAreasView);
+			else if (view == fPortsView)
+				ListPorts(this, fPortsView);
+			else if (view == fSemsView)
+				ListSems(this, fSemsView);
+			else if (view == fFilesView)
+				ListFiles(this, fFilesView);
+		}
+		return;
+	}
+
+	case infoShowWorkDirMsg: {
+		BRow *row = fInfoView->RowAt(6); // !!!
+		if (row == NULL) return;
+		ShowLocation(((BStringField*)row->GetField(infoValueCol))->String());
+		return;
+	}
+	case imagesShowLocationMsg: {
+		BRow *row = fImagesView->CurrentSelection(NULL);
+		if (row == NULL) return;
+		ShowLocation(((BStringField*)row->GetField(imagePathCol))->String());
+		return;
+	}
+	
+	case threadsInvokeMsg: {
+		BRow *row = fThreadsView->CurrentSelection(NULL);
+		if (row == NULL) return;
+		BPoint center((Frame().left + Frame().right)/2, (Frame().top + Frame().bottom)/2);
+		OpenStackWindow(((BIntegerField*)row->GetField(threadIdCol))->Value(), center);
+		return;
+	}	
+	case threadsTerminateMsg:
+	case threadsSendSignalMsg: {
+		BTab *tab = fTabView->TabAt(fTabView->Selection());
+		if (tab == NULL) return;
+		BView *view = tab->View();
+		if (view != fThreadsView) return;
+		BRow *row = fThreadsView->CurrentSelection(NULL);
+		if (row == NULL) return;
+		thread_id thread = ((BIntegerField*)row->GetField(threadIdCol))->Value();
+		if (thread < B_OK) return;
+		switch (msg->what) {
+		case threadsTerminateMsg:
+			CheckErrno(kill_thread(thread), "Can't terminate thread.");
+			break;
+		case threadsSendSignalMsg:
+			int32 signal;
+			if (msg->FindInt32("val", &signal) < B_OK) return;
+			CheckErrno(send_signal(thread, signal), "Can't send signal.");
+			break;
+		}
+		return;
+	}
+	case threadsShowSemMsg: {
+		BTab *tab = fTabView->TabAt(fTabView->Selection());
+		if (tab == NULL) return;
+		BView *view = tab->View();
+		if (view != fThreadsView) return;
+		BRow *row = fThreadsView->CurrentSelection(NULL);
+		if (row == NULL) return;
+		sem_id sem = atoi(((BStringField*)row->GetField(threadSemCol))->String());
+		if (sem < B_OK) return;
+		BMessage showMsg(B_EXECUTE_PROPERTY);
+		showMsg.AddSpecifier("Sem", sem);
+		be_app_messenger.SendMessage(&showMsg);
+		return;
+	}
+	case threadsShowStackAreaMsg: {
+		BTab *tab = fTabView->TabAt(fTabView->Selection());
+		if (tab == NULL) return;
+		BView *view = tab->View();
+		if (view != fThreadsView) return;
+		BRow *row = fThreadsView->CurrentSelection(NULL);
+		if (row == NULL) return;
+		int64 stackBase = ((Int64Field*)row->GetField(threadStackBaseCol))->Value();
+		ListAreas(this, fAreasView);
+		for (int32 i = 0; i < fAreasView->CountRows(); i++) {
+			BRow *areaRow = fAreasView->RowAt(i);
+			int64 areaAdr = ((Int64Field*)areaRow->GetField(areaAdrCol))->Value();
+			int64 areaSize = ((Int64Field*)areaRow->GetField(areaSizeCol))->Value();
+			if (stackBase >= areaAdr && stackBase < areaAdr + areaSize) {
+				int32 area = ((BIntegerField*)areaRow->GetField(areaIdCol))->Value();
+				BMessage showMsg(teamWindowShowAreaMsg);
+				CheckRetVoid(showMsg.AddInt32("val", area));
+				CheckRetVoid(showMsg.AddInt32("refresh", false));
+				BMessenger(this).SendMessage(&showMsg);
+			}
+		}
+	}
+	case semsShowThreadMsg: {
+		BTab *tab = fTabView->TabAt(fTabView->Selection());
+		if (tab == NULL) return;
+		BView *view = tab->View();
+		if (view != fSemsView) return;
+		BRow *row = fSemsView->CurrentSelection(NULL);
+		if (row == NULL) return;
+		thread_id thread = atoi(((BStringField*)row->GetField(semLatestHolderCol))->String());
+		if (thread < B_OK) return;
+		BMessage showMsg(B_EXECUTE_PROPERTY);
+		showMsg.AddSpecifier("Thread", thread);
+		be_app_messenger.SendMessage(&showMsg);
+		return;
+	}
+
+	case teamWindowShowImageMsg: {
+		int32 id;
+		if (msg->FindInt32("val", &id) < B_OK) return;
+		fTabView->Select(1); // TODO: remove hard-coded constant
+		ListImages(this, fImagesView);
+		BRow *itemRow = FindIntRow(fImagesView, imageIdCol, NULL, id);
+		if (itemRow == NULL) return;
+		fImagesView->DeselectAll();
+		fImagesView->SetFocusRow(itemRow, true);
+		fImagesView->ScrollTo(itemRow);
+		return;
+	}
+	case teamWindowShowThreadMsg: {
+		int32 id;
+		if (msg->FindInt32("val", &id) < B_OK) return;
+		fTabView->Select(2); // TODO: remove hard-coded constant
+		ListThreads(this, fThreadsView);
+		BRow *itemRow = FindIntRow(fThreadsView, threadIdCol, NULL, id);
+		if (itemRow == NULL) return;
+		fThreadsView->DeselectAll();
+		fThreadsView->SetFocusRow(itemRow, true);
+		fThreadsView->ScrollTo(itemRow);
+		return;
+	}
+	case teamWindowShowAreaMsg: {
+		int32 id;
+		bool refresh;
+		if (msg->FindInt32("val", &id) < B_OK) return;
+		if (msg->FindBool("refresh", &refresh) < B_OK) refresh = true;
+		fTabView->Select(3); // TODO: remove hard-coded constant
+		if (refresh) ListAreas(this, fAreasView);
+		BRow *itemRow = FindIntRow(fAreasView, areaIdCol, NULL, id);
+		if (itemRow == NULL) return;
+		fAreasView->DeselectAll();
+		fAreasView->SetFocusRow(itemRow, true);
+		fAreasView->ScrollTo(itemRow);
+		return;
+	}
+	case teamWindowShowPortMsg: {
+		int32 id;
+		if (msg->FindInt32("val", &id) < B_OK) return;
+		fTabView->Select(4); // TODO: remove hard-coded constant
+		ListPorts(this, fPortsView);
+		BRow *itemRow = FindIntRow(fPortsView, portIdCol, NULL, id);
+		if (itemRow == NULL) return;
+		fPortsView->DeselectAll();
+		fPortsView->SetFocusRow(itemRow, true);
+		fPortsView->ScrollTo(itemRow);
+		return;
+	}
+	case teamWindowShowSemMsg: {
+		int32 id;
+		if (msg->FindInt32("val", &id) < B_OK) return;
+		fTabView->Select(5); // TODO: remove hard-coded constant
+		ListSems(this, fSemsView);
+		BRow *itemRow = FindIntRow(fSemsView, semIdCol, NULL, id);
+		if (itemRow == NULL) return;
+		fSemsView->DeselectAll();
+		fSemsView->SetFocusRow(itemRow, true);
+		fSemsView->ScrollTo(itemRow);
+		return;
+	}
+	case teamWindowShowFileMsg: {
+		int32 id;
+		if (msg->FindInt32("val", &id) < B_OK) return;
+		fTabView->Select(6); // TODO: remove hard-coded constant
+		ListFiles(this, fFilesView);
+		BRow *itemRow = FindIntRow(fFilesView, fileIdCol, NULL, id);
+		if (itemRow == NULL) return;
+		fFilesView->DeselectAll();
+		fFilesView->SetFocusRow(itemRow, true);
+		fFilesView->ScrollTo(itemRow);
+		return;
+	}
+	}
+	BWindow::MessageReceived(msg);
+}
diff --git a/src/apps/systemmanager/TeamWindow.h b/src/apps/systemmanager/TeamWindow.h
new file mode 100644
index 0000000000..e5ad85b265
--- /dev/null
+++ b/src/apps/systemmanager/TeamWindow.h
@@ -0,0 +1,54 @@
+#ifndef _TEAMWINDOW_H_
+#define _TEAMWINDOW_H_
+
+#include <Window.h>
+#include <OS.h>
+#include <MessageRunner.h>
+
+class BTabView;
+class BColumnListView;
+
+enum {
+	teamWindowShowImageMsg = 1,
+	teamWindowShowThreadMsg,
+	teamWindowShowAreaMsg,
+	teamWindowShowPortMsg,
+	teamWindowShowSemMsg,
+	teamWindowShowFileMsg,
+
+	teamWindowPrivateMsgBase
+};
+
+class TeamWindow: public BWindow
+{
+private:	
+	BMessageRunner fListUpdater;
+	BTabView *fTabView;
+	BMenuBar *fMenuBar;
+	BMenuItem *fCurMenu;
+	BMenuItem *fInfoMenu;
+	BMenuItem *fImagesMenu;
+	BMenuItem *fThreadsMenu;
+	BMenuItem *fSemsMenu;
+	BColumnListView *fInfoView;
+	BColumnListView *fImagesView;
+	BColumnListView *fThreadsView;
+	BColumnListView *fAreasView;
+	BColumnListView *fPortsView;
+	BColumnListView *fSemsView;
+	BColumnListView *fFilesView;
+
+public:
+	team_id fId;
+
+	TeamWindow(team_id id);
+	~TeamWindow();
+
+	void TabChanged();
+	void SetMenu(BMenuItem *menu);
+	void MessageReceived(BMessage *msg);
+};
+
+TeamWindow *OpenTeamWindow(team_id id, BPoint center);
+
+#endif	// _TEAMWINDOW_H_
diff --git a/src/apps/systemmanager/UIUtils.cpp b/src/apps/systemmanager/UIUtils.cpp
new file mode 100644
index 0000000000..c8ea2c6924
--- /dev/null
+++ b/src/apps/systemmanager/UIUtils.cpp
@@ -0,0 +1,95 @@
+#include "UIUtils.h"
+
+#include <stdio.h>
+
+
+IconStringField::IconStringField(BBitmap *icon, const char *string):
+	BStringField(string), fIcon(icon)
+{}
+
+
+IconStringColumn::IconStringColumn(
+	const char* title, float width,
+	float minWidth, float maxWidth, uint32 truncate,
+	alignment align
+): BStringColumn(title, width, minWidth, maxWidth, truncate, align)
+{}
+
+void IconStringColumn::DrawField(BField* _field, BRect rect, BView* parent)
+{
+	IconStringField *field = (IconStringField*)_field;
+
+	parent->PushState();
+	parent->SetDrawingMode(B_OP_ALPHA);
+	parent->DrawBitmap(field->Icon(), rect.LeftTop() + BPoint(4, 0));
+	parent->PopState();
+	rect.left += field->Icon()->Bounds().Width() + 1;
+
+	BStringColumn::DrawField(field, rect, parent);
+}
+
+float IconStringColumn::GetPreferredWidth(BField* field, BView* parent) const
+{
+	return BStringColumn::GetPreferredWidth(field, parent) + dynamic_cast<IconStringField*>(field)->Icon()->Bounds().Width() + 1;
+}
+
+bool IconStringColumn::AcceptsField(const BField* field) const
+{
+	return dynamic_cast<const IconStringField*>(field) != NULL;
+}
+
+
+HexIntegerColumn::HexIntegerColumn(
+	const char* title,
+	float width, float minWidth, float maxWidth,
+	alignment align
+): BTitledColumn(title, width, minWidth, maxWidth, align)
+{}
+
+void HexIntegerColumn::DrawField(BField *field, BRect rect, BView* parent)
+{
+	float width = rect.Width() - (2 * 8);
+	BString string;
+
+	if (dynamic_cast<Int64Field*>(field) != NULL)
+		string.SetToFormat("0x%" B_PRIx64, ((Int64Field*)field)->Value());
+	else
+		string.SetToFormat("0x%x", (int)((BIntegerField*)field)->Value());
+
+	BFont oldFont;
+	parent->GetFont(&oldFont);
+	parent->SetFont(be_fixed_font);
+	parent->TruncateString(&string, B_TRUNCATE_MIDDLE, width + 2);
+	DrawString(string.String(), parent, rect);
+	parent->SetFont(&oldFont);
+}
+
+int HexIntegerColumn::CompareFields(BField *field1, BField *field2)
+{
+	if (dynamic_cast<Int64Field*>(field1) != NULL) {
+		if (((Int64Field*)field1)->Value() == ((Int64Field*)field2)->Value())
+			return 0;
+		else if (((Int64Field*)field1)->Value() > ((Int64Field*)field2)->Value())
+			return 1;
+		else
+			return -1;
+	} else
+		return (((BIntegerField*)field1)->Value() - ((BIntegerField*)field2)->Value());
+}
+
+
+Int64Field::Int64Field(int64 value): fValue(value)
+{
+}
+
+
+void Int64Field::SetValue(int64 value)
+{
+	fValue = value;
+}
+
+
+int64 Int64Field::Value()
+{
+	return fValue;
+}
diff --git a/src/apps/systemmanager/UIUtils.h b/src/apps/systemmanager/UIUtils.h
new file mode 100644
index 0000000000..c5efad354e
--- /dev/null
+++ b/src/apps/systemmanager/UIUtils.h
@@ -0,0 +1,59 @@
+#ifndef _UIUTILS_H_
+#define _UIUTILS_H_
+
+
+#include <private/interface/ColumnListView.h>
+#include <private/interface/ColumnTypes.h>
+#include <private/shared/AutoDeleter.h>
+
+
+class IconStringField: public BStringField
+{
+private:
+	ObjectDeleter<BBitmap> fIcon;
+
+public:
+	IconStringField(BBitmap *icon, const char *string);
+	inline BBitmap *Icon() {return fIcon.Get();}
+};
+
+class IconStringColumn: public BStringColumn
+{
+public:
+	IconStringColumn(
+		const char* title, float width,
+		float minWidth, float maxWidth, uint32 truncate,
+		alignment align = B_ALIGN_LEFT
+	);
+
+	void DrawField(BField* _field, BRect rect, BView* parent);
+	float GetPreferredWidth(BField* field, BView* parent) const;
+	bool AcceptsField(const BField* field) const;
+};
+
+class HexIntegerColumn: public BTitledColumn
+{
+public:
+	HexIntegerColumn(
+		const char* title,
+		float width, float minWidth, float maxWidth,
+		alignment align
+	);
+
+	void DrawField(BField *field, BRect rect, BView* parent);
+	int CompareFields(BField *field1, BField *field2);
+};
+
+class Int64Field: public BField
+{
+public:
+	Int64Field(int64 value);
+	void SetValue(int64 value);
+	int64 Value();
+
+private:
+	int64 fValue;
+};
+
+
+#endif	// _UIUTILS_H_
diff --git a/src/apps/systemmanager/Utils.cpp b/src/apps/systemmanager/Utils.cpp
new file mode 100644
index 0000000000..b549d364b0
--- /dev/null
+++ b/src/apps/systemmanager/Utils.cpp
@@ -0,0 +1,164 @@
+#include "Utils.h"
+
+#include <pwd.h>
+#include <grp.h>
+
+#include <String.h>
+
+#include <OS.h>
+#include <Entry.h>
+#include <Messenger.h>
+#include <private/kernel/util/KMessage.h>
+#include <private/system/extended_system_info_defs.h>
+#include <private/libroot/extended_system_info.h>
+
+
+SignalRec signals[] = {
+	{"SIGHUP", 1},
+	{"SIGINT", 2},
+	{"SIGQUIT", 3},
+	{"SIGILL", 4},
+	{"SIGCHLD", 5},
+	{"SIGABRT", 6},
+	{"SIGPIPE", 7},
+	{"SIGFPE", 8},
+	{"SIGKILL", 9},
+	{"SIGSTOP", 10},
+	{"SIGSEGV", 11},
+	{"SIGCONT", 12},
+	{"SIGTSTP", 13},
+	{"SIGALRM", 14},
+	{"SIGTERM", 15},
+	{"SIGTTIN", 16},
+	{"SIGTTOU", 17},
+	{"SIGUSR1", 18},
+	{"SIGUSR2", 19},
+	{"SIGWINCH", 20},
+	{"SIGKILLTHR", 21},
+	{"SIGTRAP", 22},
+	{"SIGPOLL", 23},
+	{"SIGPROF", 24},
+	{"SIGSYS", 25},
+	{"SIGURG", 26},
+	{"SIGVTALRM", 27},
+	{"SIGXCPU", 28},
+	{"SIGXFSZ", 29},
+	{"SIGBUS", 30},
+	{"SIGRESERVED1", 31},
+	{"SIGRESERVED2", 32},
+};
+
+
+void GetSizeString(BString &str, uint64 size)
+{
+	const char* prefixes[] = {"", "K", "M", "G", "T"};
+	unsigned pow = 0;
+	int fracSize = 0;
+	while ((size >= 1024) && (pow < sizeof(prefixes)/sizeof(prefixes[0]) - 1)) {
+		fracSize = size*100/1024%100;
+		size /= 1024;
+		pow++;
+	}
+	str.SetToFormat("%" B_PRIu64 ".%02d %sB", size, fracSize, prefixes[pow]);
+}
+
+void GetUsedMax(BString &str, uint64 used, uint64 max)
+{
+	int32 ratio = 100;
+	if (max > 0) {
+		ratio = int32(double(used)/double(max)*100.0);
+	}
+	str.SetToFormat("%" B_PRIu64 "/%" B_PRIu64 " (%" B_PRId32 "%%)", used, max, ratio);
+}
+
+void GetUsedMaxSize(BString &str, uint64 used, uint64 max)
+{
+	BString str2;
+	int32 ratio = 100;
+	if (max > 0) {
+		ratio = int32(double(used)/double(max)*100.0);
+	}
+	GetSizeString(str, used);
+	str += "/";
+	GetSizeString(str2, max);
+	str += str2;
+	str2.SetToFormat(" (%" B_PRId32 "%%)", ratio);
+	str += str2;
+}
+
+
+void GetUserGroupString(BString &str, int32 uid, int32 gid, bool showId)
+{
+	BString str2;
+	passwd *userRec = getpwuid(uid);
+	if (userRec == NULL) str.SetToFormat("%" B_PRId32, uid);
+	else str = userRec->pw_name;
+	str += ":";
+	group *grpRec = getgrgid(gid);
+	if (grpRec == NULL) str2.SetToFormat("%" B_PRId32, gid);
+	else str2 = grpRec->gr_name;
+	str += str2;
+	if (showId) {
+		str2.SetToFormat(" (%" B_PRId32 ":%" B_PRId32 ")", uid, gid);
+		str += str2;
+	}
+}
+
+void GetTeamString(BString &str, team_id team)
+{
+	const char *name = NULL;
+	KMessage extInfo;
+	if (
+		team >= B_OK &&
+		get_extended_team_info(team, B_TEAM_INFO_BASIC, extInfo) >= B_OK &&
+		extInfo.FindString("name", &name) >= B_OK
+	)
+		str.SetToFormat("%" B_PRId32 " (%s)", team, name);
+	else
+		str.SetToFormat("%" B_PRId32, team);
+}
+
+void GetThreadString(BString &str, thread_id thread)
+{
+	thread_info info;
+	if (
+		thread != 0 &&
+		get_thread_info((thread >= 0)? thread: -thread, &info) >= B_OK
+	)
+		str.SetToFormat("%" B_PRId32 " (%s)", thread, info.name);
+	else
+		str.SetToFormat("%" B_PRId32, thread);
+}
+
+void GetSemString(BString &str, sem_id sem)
+{
+	sem_info info;
+	if (
+		sem >= B_OK &&
+		get_sem_info(sem, &info) >= B_OK
+	)
+		str.SetToFormat("%" B_PRId32 " (%s)", sem, info.name);
+	else
+		str.SetToFormat("%" B_PRId32, sem);
+}
+
+
+void ShowLocation(const char *path)
+{
+	BEntry entry(path);
+	if (!entry.Exists()) return;
+
+	node_ref node;
+	entry.GetNodeRef(&node);
+	
+	BEntry parent;
+	entry.GetParent(&parent);
+	entry_ref parentRef;
+	parent.GetRef(&parentRef);
+	
+	BMessage message(B_REFS_RECEIVED);
+	message.AddRef("refs", &parentRef);
+	message.AddData("nodeRefToSelect", B_RAW_TYPE, &node, sizeof(node_ref));
+	
+	BMessenger("application/x-vnd.Be-TRAK").SendMessage(&message);
+}
diff --git a/src/apps/systemmanager/Utils.h b/src/apps/systemmanager/Utils.h
new file mode 100644
index 0000000000..29c5804e8f
--- /dev/null
+++ b/src/apps/systemmanager/Utils.h
@@ -0,0 +1,29 @@
+#ifndef _UTILS_H_
+#define _UTILS_H_
+
+#include <OS.h>
+
+class BString;
+
+
+struct SignalRec
+{
+	const char *name;
+	int val;
+};
+
+extern SignalRec signals[32];
+
+
+void GetSizeString(BString &str, uint64 size);
+void GetUsedMax(BString &str, uint64 used, uint64 max);
+void GetUsedMaxSize(BString &str, uint64 used, uint64 max);
+
+void GetUserGroupString(BString &str, int32 uid, int32 gid, bool showId = false);
+void GetTeamString(BString &str, team_id team);
+void GetThreadString(BString &str, thread_id thread);
+void GetSemString(BString &str, sem_id sem);
+
+void ShowLocation(const char *path);
+
+#endif	// _UTILS_H_
-- 
2.30.2

