From 0b97c96452cdad8cfdbeec69ce76e681a4870fec Mon Sep 17 00:00:00 2001
From: X512 <danger_mail@list.ru>
Date: Mon, 6 Sep 2021 11:15:53 +0900
Subject: network/cadence_gem: add

Change-Id: Iebc4fc24a2d3e7dd3317e551efbe5c14a020e25a
---
 .../drivers/network/-cadence_gem/Jamfile      |   19 +
 .../-cadence_gem/dev/cadence/if_cgem.c        | 1984 +++++++
 .../-cadence_gem/dev/cadence/if_cgem_hw.h     |  446 ++
 .../drivers/network/-cadence_gem/glue.c       |   14 +
 .../drivers/network/cadence_gem/Jamfile       |   41 +
 .../drivers/network/cadence_gem/bus_dma.cpp   |  388 ++
 .../drivers/network/cadence_gem/bus_fdt.cpp   |  125 +
 .../network/cadence_gem/cadence_gem.cpp       |  579 ++
 .../network/cadence_gem/cadence_gem0.cpp      |  331 ++
 .../drivers/network/cadence_gem/callout.cpp   |  245 +
 .../drivers/network/cadence_gem/clock.c       |   14 +
 .../network/cadence_gem/compat/altq/if_altq.h |   44 +
 .../network/cadence_gem/compat/dev/led/led.h  |   39 +
 .../network/cadence_gem/compat/dev/mii/mii.h  |  239 +
 .../cadence_gem/compat/dev/mii/mii_bitbang.h  |   54 +
 .../cadence_gem/compat/dev/mii/miidevs        |  350 ++
 .../cadence_gem/compat/dev/mii/miivar.h       |  275 +
 .../cadence_gem/compat/dev/ofw/ofw_bus.h      |   81 +
 .../cadence_gem/compat/dev/ofw/ofw_bus_if.h   |  130 +
 .../cadence_gem/compat/dev/ofw/ofw_bus_if.m   |  171 +
 .../cadence_gem/compat/dev/ofw/ofw_bus_subr.h |  153 +
 .../cadence_gem/compat/dev/ofw/openfirm.h     |  187 +
 .../cadence_gem/compat/dev/pci/pcireg.h       |  988 ++++
 .../cadence_gem/compat/dev/pci/pcivar.h       |   69 +
 .../cadence_gem/compat/dev/usb/usbdevs        | 4910 +++++++++++++++++
 .../network/cadence_gem/compat/machine/_bus.h |   37 +
 .../cadence_gem/compat/machine/atomic.h       |   47 +
 .../network/cadence_gem/compat/machine/bus.h  |   21 +
 .../cadence_gem/compat/machine/bus_dma.h      |   11 +
 .../cadence_gem/compat/machine/clock.h        |    9 +
 .../network/cadence_gem/compat/machine/cpu.h  |   16 +
 .../cadence_gem/compat/machine/cpufunc.h      |   22 +
 .../cadence_gem/compat/machine/endian.h       |   12 +
 .../cadence_gem/compat/machine/in_cksum.h     |   32 +
 .../cadence_gem/compat/machine/md_var.h       |    0
 .../cadence_gem/compat/machine/ofw_machdep.h  |    0
 .../cadence_gem/compat/machine/resource.h     |   14 +
 .../cadence_gem/compat/machine/riscv64/bus.h  |  228 +
 .../compat/machine/riscv64/cpufunc.h          |   33 +
 .../network/cadence_gem/compat/machine/smp.h  |   12 +
 .../cadence_gem/compat/machine/stdarg.h       |   12 +
 .../cadence_gem/compat/machine/x86/bus.h      | 1104 ++++
 .../cadence_gem/compat/machine/x86/cpufunc.h  |  805 +++
 .../compat/machine/x86_64/cpufunc.h           |  911 +++
 .../network/cadence_gem/compat/miibus_if.h    |    0
 .../network/cadence_gem/compat/net/bpf.h      |   32 +
 .../network/cadence_gem/compat/net/ethernet.h |  409 ++
 .../network/cadence_gem/compat/net/if.h       |  137 +
 .../network/cadence_gem/compat/net/if_arp.h   |  115 +
 .../network/cadence_gem/compat/net/if_llc.h   |  161 +
 .../network/cadence_gem/compat/net/if_media.h |  940 ++++
 .../network/cadence_gem/compat/net/if_types.h |   12 +
 .../network/cadence_gem/compat/net/if_var.h   | 1017 ++++
 .../cadence_gem/compat/net/if_vlan_var.h      |  137 +
 .../network/cadence_gem/compat/net/route.h    |   24 +
 .../network/cadence_gem/compat/net/vnet.h     |  496 ++
 .../cadence_gem/compat/netinet/if_ether.h     |   13 +
 .../cadence_gem/compat/netinet/in_systm.h     |    0
 .../cadence_gem/compat/netinet/in_var.h       |   11 +
 .../compat/netinet/netdump/netdump.h          |   14 +
 .../compat/security/mac/mac_framework.h       |    9 +
 .../network/cadence_gem/compat/sys/_bus_dma.h |   62 +
 .../network/cadence_gem/compat/sys/_callout.h |   26 +
 .../network/cadence_gem/compat/sys/_mutex.h   |   30 +
 .../network/cadence_gem/compat/sys/_task.h    |   24 +
 .../network/cadence_gem/compat/sys/_timeval.h |   11 +
 .../network/cadence_gem/compat/sys/_types.h   |   20 +
 .../cadence_gem/compat/sys/bitstring.h        |  304 +
 .../network/cadence_gem/compat/sys/buf_ring.h |  361 ++
 .../network/cadence_gem/compat/sys/bus.h      |  173 +
 .../network/cadence_gem/compat/sys/bus_dma.h  |  263 +
 .../network/cadence_gem/compat/sys/callout.h  |   35 +
 .../network/cadence_gem/compat/sys/cdefs.h    |  373 ++
 .../network/cadence_gem/compat/sys/condvar.h  |   31 +
 .../network/cadence_gem/compat/sys/conf.h     |    1 +
 .../network/cadence_gem/compat/sys/counter.h  |   85 +
 .../network/cadence_gem/compat/sys/ctype.h    |   11 +
 .../network/cadence_gem/compat/sys/endian.h   |  197 +
 .../network/cadence_gem/compat/sys/errno.h    |   18 +
 .../network/cadence_gem/compat/sys/event.h    |   13 +
 .../cadence_gem/compat/sys/eventhandler.h     |  176 +
 .../network/cadence_gem/compat/sys/firmware.h |   23 +
 .../cadence_gem/compat/sys/haiku-module.h     |  279 +
 .../network/cadence_gem/compat/sys/ioccom.h   |   12 +
 .../network/cadence_gem/compat/sys/kdb.h      |    1 +
 .../network/cadence_gem/compat/sys/kernel.h   |   88 +
 .../network/cadence_gem/compat/sys/kthread.h  |    1 +
 .../network/cadence_gem/compat/sys/ktr.h      |  196 +
 .../network/cadence_gem/compat/sys/libkern.h  |   23 +
 .../network/cadence_gem/compat/sys/limits.h   |    9 +
 .../network/cadence_gem/compat/sys/linker.h   |    9 +
 .../cadence_gem/compat/sys/linker_set.h       |   88 +
 .../network/cadence_gem/compat/sys/lock.h     |   16 +
 .../network/cadence_gem/compat/sys/malloc.h   |   71 +
 .../cadence_gem/compat/sys/mbuf-fbsd.h        |  324 ++
 .../network/cadence_gem/compat/sys/mbuf.h     |  363 ++
 .../cadence_gem/compat/sys/method-ids.h       |   84 +
 .../network/cadence_gem/compat/sys/module.h   |   24 +
 .../network/cadence_gem/compat/sys/mount.h    |    9 +
 .../network/cadence_gem/compat/sys/mutex.h    |  144 +
 .../network/cadence_gem/compat/sys/namei.h    |    9 +
 .../network/cadence_gem/compat/sys/param.h    |  109 +
 .../network/cadence_gem/compat/sys/pcpu.h     |   23 +
 .../network/cadence_gem/compat/sys/priority.h |   19 +
 .../network/cadence_gem/compat/sys/priv.h     |   38 +
 .../network/cadence_gem/compat/sys/proc.h     |    9 +
 .../network/cadence_gem/compat/sys/protosw.h  |    0
 .../network/cadence_gem/compat/sys/queue.h    |  787 +++
 .../network/cadence_gem/compat/sys/random.h   |    0
 .../network/cadence_gem/compat/sys/rman.h     |   90 +
 .../network/cadence_gem/compat/sys/sbuf.h     |  111 +
 .../network/cadence_gem/compat/sys/smp.h      |   35 +
 .../network/cadence_gem/compat/sys/socket.h   |   18 +
 .../network/cadence_gem/compat/sys/sockio.h   |   18 +
 .../network/cadence_gem/compat/sys/sockopt.h  |    1 +
 .../network/cadence_gem/compat/sys/sx.h       |   27 +
 .../network/cadence_gem/compat/sys/sysctl.h   |  198 +
 .../network/cadence_gem/compat/sys/syslog.h   |   11 +
 .../network/cadence_gem/compat/sys/systm.h    |  119 +
 .../cadence_gem/compat/sys/taskqueue.h        |   64 +
 .../network/cadence_gem/compat/sys/time.h     |   27 +
 .../network/cadence_gem/compat/sys/types.h    |   86 +
 .../network/cadence_gem/compat/vm/pmap.h      |    0
 .../network/cadence_gem/compat/vm/uma.h       |   12 +
 .../network/cadence_gem/compat/vm/vm.h        |   36 +
 .../network/cadence_gem/dev/cadence/if_cgem.c | 1984 +++++++
 .../cadence_gem/dev/cadence/if_cgem_hw.h      |  446 ++
 .../drivers/network/cadence_gem/device.c      |  651 +++
 .../drivers/network/cadence_gem/device.h      |   90 +
 .../drivers/network/cadence_gem/device_fdt.h  |   19 +
 .../network/cadence_gem/fbsd_if_media.c       |  532 ++
 .../network/cadence_gem/fbsd_kern_mbuf.c      |  155 +
 .../drivers/network/cadence_gem/fbsd_mii.c    |  671 +++
 .../network/cadence_gem/fbsd_uipc_mbuf.c      | 1866 +++++++
 .../network/cadence_gem/fbsd_uipc_mbuf2.c     |  455 ++
 .../kernel/drivers/network/cadence_gem/glue.c |   14 +
 .../kernel/drivers/network/cadence_gem/if.c   | 1379 +++++
 .../kernel/drivers/network/cadence_gem/kobj.c |   60 +
 .../drivers/network/cadence_gem/libkern.cpp   |   38 +
 .../drivers/network/cadence_gem/malloc.cpp    |  101 +
 .../kernel/drivers/network/cadence_gem/mbuf.c |  347 ++
 .../kernel/drivers/network/cadence_gem/mii.c  |   59 +
 .../drivers/network/cadence_gem/mutex.c       |   77 +
 .../drivers/network/cadence_gem/ofw.cpp       |   62 +
 .../drivers/network/cadence_gem/ofw_bus_if.c  |  111 +
 .../drivers/network/cadence_gem/shared.h      |   70 +
 .../drivers/network/cadence_gem/taskqueue.c   |  601 ++
 147 files changed, 34342 insertions(+)
 create mode 100644 src/add-ons/kernel/drivers/network/-cadence_gem/Jamfile
 create mode 100644 src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem.c
 create mode 100644 src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem_hw.h
 create mode 100644 src/add-ons/kernel/drivers/network/-cadence_gem/glue.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/Jamfile
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/bus_dma.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/bus_fdt.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem0.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/callout.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/clock.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/altq/if_altq.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/led/led.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii_bitbang.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miidevs
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miivar.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.m
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_subr.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/openfirm.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcireg.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcivar.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/usb/usbdevs
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/_bus.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/atomic.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus_dma.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/clock.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpu.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpufunc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/endian.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/in_cksum.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/md_var.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/ofw_machdep.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/resource.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/bus.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/cpufunc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/smp.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/stdarg.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/bus.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/cpufunc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86_64/cpufunc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/miibus_if.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/bpf.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/ethernet.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_arp.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_llc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_media.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_types.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_var.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_vlan_var.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/route.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/net/vnet.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/if_ether.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_systm.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_var.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/netdump/netdump.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/security/mac/mac_framework.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_bus_dma.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_callout.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_mutex.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_task.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_timeval.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_types.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bitstring.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/buf_ring.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus_dma.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/callout.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/cdefs.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/condvar.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/conf.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/counter.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ctype.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/endian.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/errno.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/event.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/eventhandler.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/firmware.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/haiku-module.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ioccom.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kdb.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kernel.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kthread.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ktr.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/libkern.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/limits.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker_set.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/lock.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/malloc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf-fbsd.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/method-ids.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/module.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mount.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mutex.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/namei.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/param.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/pcpu.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priority.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priv.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/proc.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/protosw.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/queue.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/random.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/rman.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sbuf.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/smp.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/socket.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockio.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockopt.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sx.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sysctl.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/syslog.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/systm.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/taskqueue.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/time.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/types.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/pmap.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/uma.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/vm.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem_hw.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/device.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/device.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/device_fdt.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/fbsd_if_media.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/fbsd_kern_mbuf.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/fbsd_mii.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf2.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/glue.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/if.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/kobj.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/libkern.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/malloc.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/mbuf.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/mii.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/mutex.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/ofw.cpp
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/ofw_bus_if.c
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/shared.h
 create mode 100644 src/add-ons/kernel/drivers/network/cadence_gem/taskqueue.c

diff --git a/src/add-ons/kernel/drivers/network/-cadence_gem/Jamfile b/src/add-ons/kernel/drivers/network/-cadence_gem/Jamfile
new file mode 100644
index 0000000000..e06b771696
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/-cadence_gem/Jamfile
@@ -0,0 +1,19 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network cadence_gem ;
+
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_iflib compat ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+UsePrivateHeaders net system ;
+UsePrivateKernelHeaders ;
+
+UseHeaders [ FDirName $(SUBDIR) ] : true ;
+
+SEARCH_SOURCE += [ FDirName $(SUBDIR) dev cadence ] ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 FBSD_DRIVER=1 _XOPEN_SOURCE ] ;
+
+KernelAddon cadence_gem :
+	glue.c
+	if_cgem.c
+	:
+	freebsd_iflib.a libfreebsd_network.a
+	;
diff --git a/src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem.c b/src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem.c
new file mode 100644
index 0000000000..4372ed4725
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem.c
@@ -0,0 +1,1984 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2012-2014 Thomas Skibo <thomasskibo@yahoo.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * A network interface driver for Cadence GEM Gigabit Ethernet
+ * interface such as the one used in Xilinx Zynq-7000 SoC.
+ *
+ * Reference: Zynq-7000 All Programmable SoC Technical Reference Manual.
+ * (v1.4) November 16, 2012.  Xilinx doc UG585.  GEM is covered in Ch. 16
+ * and register definitions are in appendix B.18.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+
+#include <machine/bus.h>
+
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/if_dl.h>
+#include <net/if_media.h>
+//#include <net/if_mib.h>
+#include <net/if_types.h>
+
+#ifdef INET
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#endif
+
+#include <net/bpf.h>
+//#include <net/bpfdesc.h>
+
+//#include <dev/fdt/fdt_common.h>
+#include <sys/kobj.h>
+#include <dev/ofw/ofw_bus.h>
+#include <dev/ofw/ofw_bus_subr.h>
+
+#include <dev/mii/mii.h>
+#include <dev/mii/miivar.h>
+
+#ifdef EXT_RESOURCES
+#include <dev/extres/clk/clk.h>
+#endif
+
+#if BUS_SPACE_MAXADDR > BUS_SPACE_MAXADDR_32BIT
+#define CGEM64
+#endif
+
+#define fdt32_to_cpu B_BENDIAN_TO_HOST_INT32
+
+#include <dev/cadence/if_cgem_hw.h>
+
+#include "miibus_if.h"
+
+#define IF_CGEM_NAME "cgem"
+
+#define CGEM_NUM_RX_DESCS	512	/* size of receive descriptor ring */
+#define CGEM_NUM_TX_DESCS	512	/* size of transmit descriptor ring */
+
+/* Default for sysctl rxbufs.  Must be < CGEM_NUM_RX_DESCS of course. */
+#define DEFAULT_NUM_RX_BUFS	256	/* number of receive bufs to queue. */
+
+#define TX_MAX_DMA_SEGS		8	/* maximum segs in a tx mbuf dma */
+
+#define CGEM_CKSUM_ASSIST	(CSUM_IP | CSUM_TCP | CSUM_UDP | \
+				 CSUM_TCP_IPV6 | CSUM_UDP_IPV6)
+
+#define HWTYPE_GENERIC_GEM	1
+#define HWTYPE_ZYNQ		2
+#define HWTYPE_ZYNQMP		3
+#define HWTYPE_SIFIVE		4
+
+static struct ofw_compat_data compat_data[] = {
+	{ "cdns,zynq-gem",		HWTYPE_ZYNQ },
+	{ "cdns,zynqmp-gem",		HWTYPE_ZYNQMP },
+	{ "sifive,fu540-c000-gem",	HWTYPE_SIFIVE },
+	{ "sifive,fu740-c000-gem",	HWTYPE_SIFIVE },
+	{ "cdns,gem",			HWTYPE_GENERIC_GEM },
+	{ "cadence,gem",		HWTYPE_GENERIC_GEM },
+	{ NULL,				0 }
+};
+
+struct cgem_softc {
+	if_t			ifp;
+	struct mtx		sc_mtx;
+	device_t		dev;
+	device_t		miibus;
+	u_int			mii_media_active;	/* last active media */
+	int			if_old_flags;
+	struct resource		*mem_res;
+	struct resource		*irq_res;
+	void			*intrhand;
+	struct callout		tick_ch;
+	uint32_t		net_ctl_shadow;
+	uint32_t		net_cfg_shadow;
+#ifdef EXT_RESOURCES
+	clk_t			ref_clk;
+#else
+	int			ref_clk_num;
+#endif
+	int			neednullqs;
+
+	bus_dma_tag_t		desc_dma_tag;
+	bus_dma_tag_t		mbuf_dma_tag;
+
+	/* receive descriptor ring */
+	struct cgem_rx_desc	*rxring;
+	bus_addr_t		rxring_physaddr;
+	struct mbuf		*rxring_m[CGEM_NUM_RX_DESCS];
+	bus_dmamap_t		rxring_m_dmamap[CGEM_NUM_RX_DESCS];
+	int			rxring_hd_ptr;	/* where to put rcv bufs */
+	int			rxring_tl_ptr;	/* where to get receives */
+	int			rxring_queued;	/* how many rcv bufs queued */
+	bus_dmamap_t		rxring_dma_map;
+	int			rxbufs;		/* tunable number rcv bufs */
+	int			rxhangwar;	/* rx hang work-around */
+	u_int			rxoverruns;	/* rx overruns */
+	u_int			rxnobufs;	/* rx buf ring empty events */
+	u_int			rxdmamapfails;	/* rx dmamap failures */
+	uint32_t		rx_frames_prev;
+
+	/* transmit descriptor ring */
+	struct cgem_tx_desc	*txring;
+	bus_addr_t		txring_physaddr;
+	struct mbuf		*txring_m[CGEM_NUM_TX_DESCS];
+	bus_dmamap_t		txring_m_dmamap[CGEM_NUM_TX_DESCS];
+	int			txring_hd_ptr;	/* where to put next xmits */
+	int			txring_tl_ptr;	/* next xmit mbuf to free */
+	int			txring_queued;	/* num xmits segs queued */
+	u_int			txfull;		/* tx ring full events */
+	u_int			txdefrags;	/* tx calls to m_defrag() */
+	u_int			txdefragfails;	/* tx m_defrag() failures */
+	u_int			txdmamapfails;	/* tx dmamap failures */
+
+	/* null descriptor rings */
+	void			*null_qs;
+	bus_addr_t		null_qs_physaddr;
+
+	/* hardware provided statistics */
+	struct cgem_hw_stats {
+		uint64_t		tx_bytes;
+		uint32_t		tx_frames;
+		uint32_t		tx_frames_bcast;
+		uint32_t		tx_frames_multi;
+		uint32_t		tx_frames_pause;
+		uint32_t		tx_frames_64b;
+		uint32_t		tx_frames_65to127b;
+		uint32_t		tx_frames_128to255b;
+		uint32_t		tx_frames_256to511b;
+		uint32_t		tx_frames_512to1023b;
+		uint32_t		tx_frames_1024to1536b;
+		uint32_t		tx_under_runs;
+		uint32_t		tx_single_collisn;
+		uint32_t		tx_multi_collisn;
+		uint32_t		tx_excsv_collisn;
+		uint32_t		tx_late_collisn;
+		uint32_t		tx_deferred_frames;
+		uint32_t		tx_carrier_sense_errs;
+
+		uint64_t		rx_bytes;
+		uint32_t		rx_frames;
+		uint32_t		rx_frames_bcast;
+		uint32_t		rx_frames_multi;
+		uint32_t		rx_frames_pause;
+		uint32_t		rx_frames_64b;
+		uint32_t		rx_frames_65to127b;
+		uint32_t		rx_frames_128to255b;
+		uint32_t		rx_frames_256to511b;
+		uint32_t		rx_frames_512to1023b;
+		uint32_t		rx_frames_1024to1536b;
+		uint32_t		rx_frames_undersize;
+		uint32_t		rx_frames_oversize;
+		uint32_t		rx_frames_jabber;
+		uint32_t		rx_frames_fcs_errs;
+		uint32_t		rx_frames_length_errs;
+		uint32_t		rx_symbol_errs;
+		uint32_t		rx_align_errs;
+		uint32_t		rx_resource_errs;
+		uint32_t		rx_overrun_errs;
+		uint32_t		rx_ip_hdr_csum_errs;
+		uint32_t		rx_tcp_csum_errs;
+		uint32_t		rx_udp_csum_errs;
+	} stats;
+};
+
+#define RD4(sc, off)		(bus_read_4((sc)->mem_res, (off)))
+#define WR4(sc, off, val)	(bus_write_4((sc)->mem_res, (off), (val)))
+#define BARRIER(sc, off, len, flags) \
+	(bus_barrier((sc)->mem_res, (off), (len), (flags))
+
+#define CGEM_LOCK(sc)		mtx_lock(&(sc)->sc_mtx)
+#define CGEM_UNLOCK(sc)		mtx_unlock(&(sc)->sc_mtx)
+#define CGEM_LOCK_INIT(sc)	mtx_init(&(sc)->sc_mtx, \
+	    device_get_nameunit((sc)->dev), MTX_NETWORK_LOCK, MTX_DEF)
+#define CGEM_LOCK_DESTROY(sc)	mtx_destroy(&(sc)->sc_mtx)
+#define CGEM_ASSERT_LOCKED(sc)	mtx_assert(&(sc)->sc_mtx, MA_OWNED)
+
+/* Allow platforms to optionally provide a way to set the reference clock. */
+int cgem_set_ref_clk(int unit, int frequency);
+
+static devclass_t cgem_devclass;
+
+static int cgem_probe(device_t dev);
+static int cgem_attach(device_t dev);
+static int cgem_detach(device_t dev);
+static void cgem_tick(void *);
+static void cgem_intr(void *);
+
+static void cgem_mediachange(struct cgem_softc *, struct mii_data *);
+
+static void
+cgem_get_mac(struct cgem_softc *sc, u_char eaddr[])
+{
+	int i;
+	uint32_t rnd;
+
+	/* See if boot loader gave us a MAC address already. */
+	for (i = 0; i < 4; i++) {
+		uint32_t low = RD4(sc, CGEM_SPEC_ADDR_LOW(i));
+		uint32_t high = RD4(sc, CGEM_SPEC_ADDR_HI(i)) & 0xffff;
+		if (low != 0 || high != 0) {
+			eaddr[0] = low & 0xff;
+			eaddr[1] = (low >> 8) & 0xff;
+			eaddr[2] = (low >> 16) & 0xff;
+			eaddr[3] = (low >> 24) & 0xff;
+			eaddr[4] = high & 0xff;
+			eaddr[5] = (high >> 8) & 0xff;
+			break;
+		}
+	}
+
+	/* No MAC from boot loader?  Assign a random one. */
+	if (i == 4) {
+		rnd = arc4random();
+
+		eaddr[0] = 'b';
+		eaddr[1] = 's';
+		eaddr[2] = 'd';
+		eaddr[3] = (rnd >> 16) & 0xff;
+		eaddr[4] = (rnd >> 8) & 0xff;
+		eaddr[5] = rnd & 0xff;
+
+		device_printf(sc->dev, "no mac address found, assigning "
+		    "random: %02x:%02x:%02x:%02x:%02x:%02x\n", eaddr[0],
+		    eaddr[1], eaddr[2], eaddr[3], eaddr[4], eaddr[5]);
+	}
+
+	/* Move address to first slot and zero out the rest. */
+	WR4(sc, CGEM_SPEC_ADDR_LOW(0), (eaddr[3] << 24) |
+	    (eaddr[2] << 16) | (eaddr[1] << 8) | eaddr[0]);
+	WR4(sc, CGEM_SPEC_ADDR_HI(0), (eaddr[5] << 8) | eaddr[4]);
+
+	for (i = 1; i < 4; i++) {
+		WR4(sc, CGEM_SPEC_ADDR_LOW(i), 0);
+		WR4(sc, CGEM_SPEC_ADDR_HI(i), 0);
+	}
+}
+
+/*
+ * cgem_mac_hash():  map 48-bit address to a 6-bit hash. The 6-bit hash
+ * corresponds to a bit in a 64-bit hash register.  Setting that bit in the
+ * hash register enables reception of all frames with a destination address
+ * that hashes to that 6-bit value.
+ *
+ * The hash function is described in sec. 16.2.3 in the Zynq-7000 Tech
+ * Reference Manual.  Bits 0-5 in the hash are the exclusive-or of
+ * every sixth bit in the destination address.
+ */
+static int
+cgem_mac_hash(u_char eaddr[])
+{
+	int hash;
+	int i, j;
+
+	hash = 0;
+	for (i = 0; i < 6; i++)
+		for (j = i; j < 48; j += 6)
+			if ((eaddr[j >> 3] & (1 << (j & 7))) != 0)
+				hash ^= (1 << i);
+
+	return hash;
+}
+
+static u_int
+cgem_hash_maddr(void *arg, struct sockaddr_dl *sdl, u_int cnt)
+{
+	uint32_t *hashes = arg;
+	int index;
+
+	index = cgem_mac_hash(LLADDR(sdl));
+	if (index > 31)
+		hashes[0] |= (1U << (index - 32));
+	else
+		hashes[1] |= (1U << index);
+
+	return (1);
+}
+
+/*
+ * After any change in rx flags or multi-cast addresses, set up hash registers
+ * and net config register bits.
+ */
+static void
+cgem_rx_filter(struct cgem_softc *sc)
+{
+	if_t ifp = sc->ifp;
+	uint32_t hashes[2] = { 0, 0 };
+
+	sc->net_cfg_shadow &= ~(CGEM_NET_CFG_MULTI_HASH_EN |
+	    CGEM_NET_CFG_NO_BCAST | CGEM_NET_CFG_COPY_ALL);
+
+	if ((if_getflags(ifp) & IFF_PROMISC) != 0)
+		sc->net_cfg_shadow |= CGEM_NET_CFG_COPY_ALL;
+	else {
+		if ((if_getflags(ifp) & IFF_BROADCAST) == 0)
+			sc->net_cfg_shadow |= CGEM_NET_CFG_NO_BCAST;
+		if ((if_getflags(ifp) & IFF_ALLMULTI) != 0) {
+			hashes[0] = 0xffffffff;
+			hashes[1] = 0xffffffff;
+		} else
+			if_foreach_llmaddr(ifp, cgem_hash_maddr, hashes);
+
+		if (hashes[0] != 0 || hashes[1] != 0)
+			sc->net_cfg_shadow |= CGEM_NET_CFG_MULTI_HASH_EN;
+	}
+
+	WR4(sc, CGEM_HASH_TOP, hashes[0]);
+	WR4(sc, CGEM_HASH_BOT, hashes[1]);
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+}
+
+/* For bus_dmamap_load() callback. */
+static void
+cgem_getaddr(void *arg, bus_dma_segment_t *segs, int nsegs, int error)
+{
+
+	if (nsegs != 1 || error != 0)
+		return;
+	*(bus_addr_t *)arg = segs[0].ds_addr;
+}
+
+/* Set up null queues for priority queues we actually can't disable. */
+static void
+cgem_null_qs(struct cgem_softc *sc)
+{
+	struct cgem_rx_desc *rx_desc;
+	struct cgem_tx_desc *tx_desc;
+	uint32_t queue_mask;
+	int n;
+
+	/* Read design config register 6 to determine number of queues. */
+	queue_mask = (RD4(sc, CGEM_DESIGN_CFG6) &
+	    CGEM_DESIGN_CFG6_DMA_PRIO_Q_MASK) >> 1;
+	if (queue_mask == 0)
+		return;
+
+	/* Create empty RX queue and empty TX buf queues. */
+	memset(sc->null_qs, 0, sizeof(struct cgem_rx_desc) +
+	    sizeof(struct cgem_tx_desc));
+	rx_desc = sc->null_qs;
+	rx_desc->addr = CGEM_RXDESC_OWN | CGEM_RXDESC_WRAP;
+	tx_desc = (struct cgem_tx_desc *)(rx_desc + 1);
+	tx_desc->ctl = CGEM_TXDESC_USED | CGEM_TXDESC_WRAP;
+
+	/* Point all valid ring base pointers to the null queues. */
+	for (n = 1; (queue_mask & 1) != 0; n++, queue_mask >>= 1) {
+		WR4(sc, CGEM_RX_QN_BAR(n), sc->null_qs_physaddr);
+		WR4(sc, CGEM_TX_QN_BAR(n), sc->null_qs_physaddr +
+		    sizeof(struct cgem_rx_desc));
+	}
+}
+
+/* Create DMA'able descriptor rings. */
+static int
+cgem_setup_descs(struct cgem_softc *sc)
+{
+	int i, err;
+	int desc_rings_size = CGEM_NUM_RX_DESCS * sizeof(struct cgem_rx_desc) +
+	    CGEM_NUM_TX_DESCS * sizeof(struct cgem_tx_desc);
+
+	if (sc->neednullqs)
+		desc_rings_size += sizeof(struct cgem_rx_desc) +
+		    sizeof(struct cgem_tx_desc);
+
+	sc->txring = NULL;
+	sc->rxring = NULL;
+
+	/* Allocate non-cached DMA space for RX and TX descriptors. */
+	err = bus_dma_tag_create(bus_get_dma_tag(sc->dev), 1,
+#ifdef CGEM64
+	    1ULL << 32,	/* Do not cross a 4G boundary. */
+#else
+	    0,
+#endif
+	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,
+	    desc_rings_size, 1, desc_rings_size, 0,
+	    busdma_lock_mutex, &sc->sc_mtx, &sc->desc_dma_tag);
+	if (err)
+		return (err);
+
+	/* Set up a bus_dma_tag for mbufs. */
+	err = bus_dma_tag_create(bus_get_dma_tag(sc->dev), 1, 0,
+	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES,
+	    TX_MAX_DMA_SEGS, MCLBYTES, 0, busdma_lock_mutex, &sc->sc_mtx,
+	    &sc->mbuf_dma_tag);
+	if (err)
+		return (err);
+
+	/*
+	 * Allocate DMA memory. We allocate transmit, receive and null
+	 * descriptor queues all at once because the hardware only provides
+	 * one register for the upper 32 bits of rx and tx descriptor queues
+	 * hardware addresses.
+	 */
+	err = bus_dmamem_alloc(sc->desc_dma_tag, (void **)&sc->rxring,
+	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT | BUS_DMA_ZERO,
+	    &sc->rxring_dma_map);
+	if (err)
+		return (err);
+
+	/* Load descriptor DMA memory. */
+	err = bus_dmamap_load(sc->desc_dma_tag, sc->rxring_dma_map,
+	    (void *)sc->rxring, desc_rings_size,
+	    cgem_getaddr, &sc->rxring_physaddr, BUS_DMA_NOWAIT);
+	if (err)
+		return (err);
+
+	/* Initialize RX descriptors. */
+	for (i = 0; i < CGEM_NUM_RX_DESCS; i++) {
+		sc->rxring[i].addr = CGEM_RXDESC_OWN;
+		sc->rxring[i].ctl = 0;
+		sc->rxring_m[i] = NULL;
+		sc->rxring_m_dmamap[i] = NULL;
+	}
+	sc->rxring[CGEM_NUM_RX_DESCS - 1].addr |= CGEM_RXDESC_WRAP;
+
+	sc->rxring_hd_ptr = 0;
+	sc->rxring_tl_ptr = 0;
+	sc->rxring_queued = 0;
+
+	sc->txring = (struct cgem_tx_desc *)(sc->rxring + CGEM_NUM_RX_DESCS);
+	sc->txring_physaddr = sc->rxring_physaddr + CGEM_NUM_RX_DESCS *
+	    sizeof(struct cgem_rx_desc);
+
+	/* Initialize TX descriptor ring. */
+	for (i = 0; i < CGEM_NUM_TX_DESCS; i++) {
+		sc->txring[i].addr = 0;
+		sc->txring[i].ctl = CGEM_TXDESC_USED;
+		sc->txring_m[i] = NULL;
+		sc->txring_m_dmamap[i] = NULL;
+	}
+	sc->txring[CGEM_NUM_TX_DESCS - 1].ctl |= CGEM_TXDESC_WRAP;
+
+	sc->txring_hd_ptr = 0;
+	sc->txring_tl_ptr = 0;
+	sc->txring_queued = 0;
+
+	if (sc->neednullqs) {
+		sc->null_qs = (void *)(sc->txring + CGEM_NUM_TX_DESCS);
+		sc->null_qs_physaddr = sc->txring_physaddr +
+		    CGEM_NUM_TX_DESCS * sizeof(struct cgem_tx_desc);
+
+		cgem_null_qs(sc);
+	}
+
+	return (0);
+}
+
+/* Fill receive descriptor ring with mbufs. */
+static void
+cgem_fill_rqueue(struct cgem_softc *sc)
+{
+	struct mbuf *m = NULL;
+	bus_dma_segment_t segs[TX_MAX_DMA_SEGS];
+	int nsegs;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	while (sc->rxring_queued < sc->rxbufs) {
+		/* Get a cluster mbuf. */
+		m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);
+		if (m == NULL)
+			break;
+
+		m->m_len = MCLBYTES;
+		m->m_pkthdr.len = MCLBYTES;
+		m->m_pkthdr.rcvif = sc->ifp;
+
+		/* Load map and plug in physical address. */
+		if (bus_dmamap_create(sc->mbuf_dma_tag, 0,
+		    &sc->rxring_m_dmamap[sc->rxring_hd_ptr])) {
+			sc->rxdmamapfails++;
+			m_free(m);
+			break;
+		}
+		if (bus_dmamap_load_mbuf_sg(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_hd_ptr], m,
+		    segs, &nsegs, BUS_DMA_NOWAIT)) {
+			sc->rxdmamapfails++;
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+				   sc->rxring_m_dmamap[sc->rxring_hd_ptr]);
+			sc->rxring_m_dmamap[sc->rxring_hd_ptr] = NULL;
+			m_free(m);
+			break;
+		}
+		sc->rxring_m[sc->rxring_hd_ptr] = m;
+
+		/* Sync cache with receive buffer. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_hd_ptr],
+		    BUS_DMASYNC_PREREAD);
+
+		/* Write rx descriptor and increment head pointer. */
+		sc->rxring[sc->rxring_hd_ptr].ctl = 0;
+#ifdef CGEM64
+		sc->rxring[sc->rxring_hd_ptr].addrhi = segs[0].ds_addr >> 32;
+#endif
+		if (sc->rxring_hd_ptr == CGEM_NUM_RX_DESCS - 1) {
+			sc->rxring[sc->rxring_hd_ptr].addr = segs[0].ds_addr |
+			    CGEM_RXDESC_WRAP;
+			sc->rxring_hd_ptr = 0;
+		} else
+			sc->rxring[sc->rxring_hd_ptr++].addr = segs[0].ds_addr;
+
+		sc->rxring_queued++;
+	}
+}
+
+/* Pull received packets off of receive descriptor ring. */
+static void
+cgem_recv(struct cgem_softc *sc)
+{
+	if_t ifp = sc->ifp;
+	struct mbuf *m, *m_hd, **m_tl;
+	uint32_t ctl;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Pick up all packets in which the OWN bit is set. */
+	m_hd = NULL;
+	m_tl = &m_hd;
+	while (sc->rxring_queued > 0 &&
+	    (sc->rxring[sc->rxring_tl_ptr].addr & CGEM_RXDESC_OWN) != 0) {
+		ctl = sc->rxring[sc->rxring_tl_ptr].ctl;
+
+		/* Grab filled mbuf. */
+		m = sc->rxring_m[sc->rxring_tl_ptr];
+		sc->rxring_m[sc->rxring_tl_ptr] = NULL;
+
+		/* Sync cache with receive buffer. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_tl_ptr],
+		    BUS_DMASYNC_POSTREAD);
+
+		/* Unload and destroy dmamap. */
+		bus_dmamap_unload(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_tl_ptr]);
+		bus_dmamap_destroy(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_tl_ptr]);
+		sc->rxring_m_dmamap[sc->rxring_tl_ptr] = NULL;
+
+		/* Increment tail pointer. */
+		if (++sc->rxring_tl_ptr == CGEM_NUM_RX_DESCS)
+			sc->rxring_tl_ptr = 0;
+		sc->rxring_queued--;
+
+		/*
+		 * Check FCS and make sure entire packet landed in one mbuf
+		 * cluster (which is much bigger than the largest ethernet
+		 * packet).
+		 */
+		if ((ctl & CGEM_RXDESC_BAD_FCS) != 0 ||
+		    (ctl & (CGEM_RXDESC_SOF | CGEM_RXDESC_EOF)) !=
+		    (CGEM_RXDESC_SOF | CGEM_RXDESC_EOF)) {
+			/* discard. */
+			m_free(m);
+			if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);
+			continue;
+		}
+
+		/* Ready it to hand off to upper layers. */
+		m->m_data += ETHER_ALIGN;
+		m->m_len = (ctl & CGEM_RXDESC_LENGTH_MASK);
+		m->m_pkthdr.rcvif = ifp;
+		m->m_pkthdr.len = m->m_len;
+
+		/*
+		 * Are we using hardware checksumming?  Check the status in the
+		 * receive descriptor.
+		 */
+		if ((if_getcapenable(ifp) & IFCAP_RXCSUM) != 0) {
+			/* TCP or UDP checks out, IP checks out too. */
+			if ((ctl & CGEM_RXDESC_CKSUM_STAT_MASK) ==
+			    CGEM_RXDESC_CKSUM_STAT_TCP_GOOD ||
+			    (ctl & CGEM_RXDESC_CKSUM_STAT_MASK) ==
+			    CGEM_RXDESC_CKSUM_STAT_UDP_GOOD) {
+				m->m_pkthdr.csum_flags |=
+				    CSUM_IP_CHECKED | CSUM_IP_VALID |
+				    CSUM_DATA_VALID | CSUM_PSEUDO_HDR;
+				m->m_pkthdr.csum_data = 0xffff;
+			} else if ((ctl & CGEM_RXDESC_CKSUM_STAT_MASK) ==
+			    CGEM_RXDESC_CKSUM_STAT_IP_GOOD) {
+				/* Only IP checks out. */
+				m->m_pkthdr.csum_flags |=
+				    CSUM_IP_CHECKED | CSUM_IP_VALID;
+				m->m_pkthdr.csum_data = 0xffff;
+			}
+		}
+
+		/* Queue it up for delivery below. */
+		*m_tl = m;
+		m_tl = &m->m_next;
+	}
+
+	/* Replenish receive buffers. */
+	cgem_fill_rqueue(sc);
+
+	/* Unlock and send up packets. */
+	CGEM_UNLOCK(sc);
+	while (m_hd != NULL) {
+		m = m_hd;
+		m_hd = m_hd->m_next;
+		m->m_next = NULL;
+		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);
+		if_input(ifp, m);
+	}
+	CGEM_LOCK(sc);
+}
+
+/* Find completed transmits and free their mbufs. */
+static void
+cgem_clean_tx(struct cgem_softc *sc)
+{
+	struct mbuf *m;
+	uint32_t ctl;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* free up finished transmits. */
+	while (sc->txring_queued > 0 &&
+	    ((ctl = sc->txring[sc->txring_tl_ptr].ctl) &
+	    CGEM_TXDESC_USED) != 0) {
+		/* Sync cache. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_tl_ptr],
+		    BUS_DMASYNC_POSTWRITE);
+
+		/* Unload and destroy DMA map. */
+		bus_dmamap_unload(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_tl_ptr]);
+		bus_dmamap_destroy(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_tl_ptr]);
+		sc->txring_m_dmamap[sc->txring_tl_ptr] = NULL;
+
+		/* Free up the mbuf. */
+		m = sc->txring_m[sc->txring_tl_ptr];
+		sc->txring_m[sc->txring_tl_ptr] = NULL;
+		m_freem(m);
+
+		/* Check the status. */
+		if ((ctl & CGEM_TXDESC_AHB_ERR) != 0) {
+			/* Serious bus error. log to console. */
+#ifdef CGEM64
+			device_printf(sc->dev,
+			    "cgem_clean_tx: AHB error, addr=0x%x%08x\n",
+			    sc->txring[sc->txring_tl_ptr].addrhi,
+			    sc->txring[sc->txring_tl_ptr].addr);
+#else
+			device_printf(sc->dev,
+			    "cgem_clean_tx: AHB error, addr=0x%x\n",
+			    sc->txring[sc->txring_tl_ptr].addr);
+#endif
+		} else if ((ctl & (CGEM_TXDESC_RETRY_ERR |
+		    CGEM_TXDESC_LATE_COLL)) != 0) {
+			if_inc_counter(sc->ifp, IFCOUNTER_OERRORS, 1);
+		} else
+			if_inc_counter(sc->ifp, IFCOUNTER_OPACKETS, 1);
+
+		/*
+		 * If the packet spanned more than one tx descriptor, skip
+		 * descriptors until we find the end so that only
+		 * start-of-frame descriptors are processed.
+		 */
+		while ((ctl & CGEM_TXDESC_LAST_BUF) == 0) {
+			if ((ctl & CGEM_TXDESC_WRAP) != 0)
+				sc->txring_tl_ptr = 0;
+			else
+				sc->txring_tl_ptr++;
+			sc->txring_queued--;
+
+			ctl = sc->txring[sc->txring_tl_ptr].ctl;
+
+			sc->txring[sc->txring_tl_ptr].ctl =
+			    ctl | CGEM_TXDESC_USED;
+		}
+
+		/* Next descriptor. */
+		if ((ctl & CGEM_TXDESC_WRAP) != 0)
+			sc->txring_tl_ptr = 0;
+		else
+			sc->txring_tl_ptr++;
+		sc->txring_queued--;
+
+		if_setdrvflagbits(sc->ifp, 0, IFF_DRV_OACTIVE);
+	}
+}
+
+/* Start transmits. */
+static void
+cgem_start_locked(if_t ifp)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+	struct mbuf *m;
+	bus_dma_segment_t segs[TX_MAX_DMA_SEGS];
+	uint32_t ctl;
+	int i, nsegs, wrap, err;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((if_getdrvflags(ifp) & IFF_DRV_OACTIVE) != 0)
+		return;
+
+	for (;;) {
+		/* Check that there is room in the descriptor ring. */
+		if (sc->txring_queued >=
+		    CGEM_NUM_TX_DESCS - TX_MAX_DMA_SEGS * 2) {
+			/* Try to make room. */
+			cgem_clean_tx(sc);
+
+			/* Still no room? */
+			if (sc->txring_queued >=
+			    CGEM_NUM_TX_DESCS - TX_MAX_DMA_SEGS * 2) {
+				if_setdrvflagbits(ifp, IFF_DRV_OACTIVE, 0);
+				sc->txfull++;
+				break;
+			}
+		}
+
+		/* Grab next transmit packet. */
+		m = if_dequeue(ifp);
+		if (m == NULL)
+			break;
+
+		/* Create and load DMA map. */
+		if (bus_dmamap_create(sc->mbuf_dma_tag, 0,
+			&sc->txring_m_dmamap[sc->txring_hd_ptr])) {
+			m_freem(m);
+			sc->txdmamapfails++;
+			continue;
+		}
+		err = bus_dmamap_load_mbuf_sg(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_hd_ptr], m, segs, &nsegs,
+		    BUS_DMA_NOWAIT);
+		if (err == EFBIG) {
+			/* Too many segments!  defrag and try again. */
+			struct mbuf *m2 = m_defrag(m, M_NOWAIT);
+
+			if (m2 == NULL) {
+				sc->txdefragfails++;
+				m_freem(m);
+				bus_dmamap_destroy(sc->mbuf_dma_tag,
+				    sc->txring_m_dmamap[sc->txring_hd_ptr]);
+				sc->txring_m_dmamap[sc->txring_hd_ptr] = NULL;
+				continue;
+			}
+			m = m2;
+			err = bus_dmamap_load_mbuf_sg(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[sc->txring_hd_ptr], m, segs,
+			    &nsegs, BUS_DMA_NOWAIT);
+			sc->txdefrags++;
+		}
+		if (err) {
+			/* Give up. */
+			m_freem(m);
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[sc->txring_hd_ptr]);
+			sc->txring_m_dmamap[sc->txring_hd_ptr] = NULL;
+			sc->txdmamapfails++;
+			continue;
+		}
+		sc->txring_m[sc->txring_hd_ptr] = m;
+
+		/* Sync tx buffer with cache. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_hd_ptr],
+		    BUS_DMASYNC_PREWRITE);
+
+		/* Set wrap flag if next packet might run off end of ring. */
+		wrap = sc->txring_hd_ptr + nsegs + TX_MAX_DMA_SEGS >=
+		    CGEM_NUM_TX_DESCS;
+
+		/*
+		 * Fill in the TX descriptors back to front so that USED bit in
+		 * first descriptor is cleared last.
+		 */
+		for (i = nsegs - 1; i >= 0; i--) {
+			/* Descriptor address. */
+			sc->txring[sc->txring_hd_ptr + i].addr =
+			    segs[i].ds_addr;
+#ifdef CGEM64
+			sc->txring[sc->txring_hd_ptr + i].addrhi =
+			    segs[i].ds_addr >> 32;
+#endif
+			/* Descriptor control word. */
+			ctl = segs[i].ds_len;
+			if (i == nsegs - 1) {
+				ctl |= CGEM_TXDESC_LAST_BUF;
+				if (wrap)
+					ctl |= CGEM_TXDESC_WRAP;
+			}
+			sc->txring[sc->txring_hd_ptr + i].ctl = ctl;
+
+			if (i != 0)
+				sc->txring_m[sc->txring_hd_ptr + i] = NULL;
+		}
+
+		if (wrap)
+			sc->txring_hd_ptr = 0;
+		else
+			sc->txring_hd_ptr += nsegs;
+		sc->txring_queued += nsegs;
+
+		/* Kick the transmitter. */
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow |
+		    CGEM_NET_CTRL_START_TX);
+
+		/* If there is a BPF listener, bounce a copy to him. */
+		ETHER_BPF_MTAP(ifp, m);
+	}
+}
+
+static void
+cgem_start(if_t ifp)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+
+	CGEM_LOCK(sc);
+	cgem_start_locked(ifp);
+	CGEM_UNLOCK(sc);
+}
+
+static void
+cgem_poll_hw_stats(struct cgem_softc *sc)
+{
+	uint32_t n;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	sc->stats.tx_bytes += RD4(sc, CGEM_OCTETS_TX_BOT);
+	sc->stats.tx_bytes += (uint64_t)RD4(sc, CGEM_OCTETS_TX_TOP) << 32;
+
+	sc->stats.tx_frames += RD4(sc, CGEM_FRAMES_TX);
+	sc->stats.tx_frames_bcast += RD4(sc, CGEM_BCAST_FRAMES_TX);
+	sc->stats.tx_frames_multi += RD4(sc, CGEM_MULTI_FRAMES_TX);
+	sc->stats.tx_frames_pause += RD4(sc, CGEM_PAUSE_FRAMES_TX);
+	sc->stats.tx_frames_64b += RD4(sc, CGEM_FRAMES_64B_TX);
+	sc->stats.tx_frames_65to127b += RD4(sc, CGEM_FRAMES_65_127B_TX);
+	sc->stats.tx_frames_128to255b += RD4(sc, CGEM_FRAMES_128_255B_TX);
+	sc->stats.tx_frames_256to511b += RD4(sc, CGEM_FRAMES_256_511B_TX);
+	sc->stats.tx_frames_512to1023b += RD4(sc, CGEM_FRAMES_512_1023B_TX);
+	sc->stats.tx_frames_1024to1536b += RD4(sc, CGEM_FRAMES_1024_1518B_TX);
+	sc->stats.tx_under_runs += RD4(sc, CGEM_TX_UNDERRUNS);
+
+	n = RD4(sc, CGEM_SINGLE_COLL_FRAMES);
+	sc->stats.tx_single_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+	n = RD4(sc, CGEM_MULTI_COLL_FRAMES);
+	sc->stats.tx_multi_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+	n = RD4(sc, CGEM_EXCESSIVE_COLL_FRAMES);
+	sc->stats.tx_excsv_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+	n = RD4(sc, CGEM_LATE_COLL);
+	sc->stats.tx_late_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+
+	sc->stats.tx_deferred_frames += RD4(sc, CGEM_DEFERRED_TX_FRAMES);
+	sc->stats.tx_carrier_sense_errs += RD4(sc, CGEM_CARRIER_SENSE_ERRS);
+
+	sc->stats.rx_bytes += RD4(sc, CGEM_OCTETS_RX_BOT);
+	sc->stats.rx_bytes += (uint64_t)RD4(sc, CGEM_OCTETS_RX_TOP) << 32;
+
+	sc->stats.rx_frames += RD4(sc, CGEM_FRAMES_RX);
+	sc->stats.rx_frames_bcast += RD4(sc, CGEM_BCAST_FRAMES_RX);
+	sc->stats.rx_frames_multi += RD4(sc, CGEM_MULTI_FRAMES_RX);
+	sc->stats.rx_frames_pause += RD4(sc, CGEM_PAUSE_FRAMES_RX);
+	sc->stats.rx_frames_64b += RD4(sc, CGEM_FRAMES_64B_RX);
+	sc->stats.rx_frames_65to127b += RD4(sc, CGEM_FRAMES_65_127B_RX);
+	sc->stats.rx_frames_128to255b += RD4(sc, CGEM_FRAMES_128_255B_RX);
+	sc->stats.rx_frames_256to511b += RD4(sc, CGEM_FRAMES_256_511B_RX);
+	sc->stats.rx_frames_512to1023b += RD4(sc, CGEM_FRAMES_512_1023B_RX);
+	sc->stats.rx_frames_1024to1536b += RD4(sc, CGEM_FRAMES_1024_1518B_RX);
+	sc->stats.rx_frames_undersize += RD4(sc, CGEM_UNDERSZ_RX);
+	sc->stats.rx_frames_oversize += RD4(sc, CGEM_OVERSZ_RX);
+	sc->stats.rx_frames_jabber += RD4(sc, CGEM_JABBERS_RX);
+	sc->stats.rx_frames_fcs_errs += RD4(sc, CGEM_FCS_ERRS);
+	sc->stats.rx_frames_length_errs += RD4(sc, CGEM_LENGTH_FIELD_ERRS);
+	sc->stats.rx_symbol_errs += RD4(sc, CGEM_RX_SYMBOL_ERRS);
+	sc->stats.rx_align_errs += RD4(sc, CGEM_ALIGN_ERRS);
+	sc->stats.rx_resource_errs += RD4(sc, CGEM_RX_RESOURCE_ERRS);
+	sc->stats.rx_overrun_errs += RD4(sc, CGEM_RX_OVERRUN_ERRS);
+	sc->stats.rx_ip_hdr_csum_errs += RD4(sc, CGEM_IP_HDR_CKSUM_ERRS);
+	sc->stats.rx_tcp_csum_errs += RD4(sc, CGEM_TCP_CKSUM_ERRS);
+	sc->stats.rx_udp_csum_errs += RD4(sc, CGEM_UDP_CKSUM_ERRS);
+}
+
+static void
+cgem_tick(void *arg)
+{
+	struct cgem_softc *sc = (struct cgem_softc *)arg;
+	struct mii_data *mii;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Poll the phy. */
+	if (sc->miibus != NULL) {
+		mii = device_get_softc(sc->miibus);
+		mii_tick(mii);
+	}
+
+	/* Poll statistics registers. */
+	cgem_poll_hw_stats(sc);
+
+	/* Check for receiver hang. */
+	if (sc->rxhangwar && sc->rx_frames_prev == sc->stats.rx_frames) {
+		/*
+		 * Reset receiver logic by toggling RX_EN bit.  1usec
+		 * delay is necessary especially when operating at 100mbps
+		 * and 10mbps speeds.
+		 */
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow &
+		    ~CGEM_NET_CTRL_RX_EN);
+		DELAY(1);
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow);
+	}
+	sc->rx_frames_prev = sc->stats.rx_frames;
+
+	/* Next callout in one second. */
+	callout_reset(&sc->tick_ch, hz, cgem_tick, sc);
+}
+
+/* Interrupt handler. */
+static void
+cgem_intr(void *arg)
+{
+	struct cgem_softc *sc = (struct cgem_softc *)arg;
+	if_t ifp = sc->ifp;
+	uint32_t istatus;
+
+	CGEM_LOCK(sc);
+
+	if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) == 0) {
+		CGEM_UNLOCK(sc);
+		return;
+	}
+
+	/* Read interrupt status and immediately clear the bits. */
+	istatus = RD4(sc, CGEM_INTR_STAT);
+	WR4(sc, CGEM_INTR_STAT, istatus);
+
+	/* Packets received. */
+	if ((istatus & CGEM_INTR_RX_COMPLETE) != 0)
+		cgem_recv(sc);
+
+	/* Free up any completed transmit buffers. */
+	cgem_clean_tx(sc);
+
+	/* Hresp not ok.  Something is very bad with DMA.  Try to clear. */
+	if ((istatus & CGEM_INTR_HRESP_NOT_OK) != 0) {
+		device_printf(sc->dev,
+		    "cgem_intr: hresp not okay! rx_status=0x%x\n",
+		    RD4(sc, CGEM_RX_STAT));
+		WR4(sc, CGEM_RX_STAT, CGEM_RX_STAT_HRESP_NOT_OK);
+	}
+
+	/* Receiver overrun. */
+	if ((istatus & CGEM_INTR_RX_OVERRUN) != 0) {
+		/* Clear status bit. */
+		WR4(sc, CGEM_RX_STAT, CGEM_RX_STAT_OVERRUN);
+		sc->rxoverruns++;
+	}
+
+	/* Receiver ran out of bufs. */
+	if ((istatus & CGEM_INTR_RX_USED_READ) != 0) {
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow |
+		    CGEM_NET_CTRL_FLUSH_DPRAM_PKT);
+		cgem_fill_rqueue(sc);
+		sc->rxnobufs++;
+	}
+
+	/* Restart transmitter if needed. */
+	if (!if_sendq_empty(ifp))
+		cgem_start_locked(ifp);
+
+	CGEM_UNLOCK(sc);
+}
+
+/* Reset hardware. */
+static void
+cgem_reset(struct cgem_softc *sc)
+{
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Determine data bus width from design configuration register. */
+	switch (RD4(sc, CGEM_DESIGN_CFG1) &
+	    CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_MASK) {
+	case CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_64:
+		sc->net_cfg_shadow = CGEM_NET_CFG_DBUS_WIDTH_64;
+		break;
+	case CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_128:
+		sc->net_cfg_shadow = CGEM_NET_CFG_DBUS_WIDTH_128;
+		break;
+	default:
+		sc->net_cfg_shadow = CGEM_NET_CFG_DBUS_WIDTH_32;
+	}
+
+	WR4(sc, CGEM_NET_CTRL, 0);
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+	WR4(sc, CGEM_NET_CTRL, CGEM_NET_CTRL_CLR_STAT_REGS);
+	WR4(sc, CGEM_TX_STAT, CGEM_TX_STAT_ALL);
+	WR4(sc, CGEM_RX_STAT, CGEM_RX_STAT_ALL);
+	WR4(sc, CGEM_INTR_DIS, CGEM_INTR_ALL);
+	WR4(sc, CGEM_HASH_BOT, 0);
+	WR4(sc, CGEM_HASH_TOP, 0);
+	WR4(sc, CGEM_TX_QBAR, 0);	/* manual says do this. */
+	WR4(sc, CGEM_RX_QBAR, 0);
+
+	/* Get management port running even if interface is down. */
+	sc->net_cfg_shadow |= CGEM_NET_CFG_MDC_CLK_DIV_48;
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+
+	sc->net_ctl_shadow = CGEM_NET_CTRL_MGMT_PORT_EN;
+	WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow);
+}
+
+/* Bring up the hardware. */
+static void
+cgem_config(struct cgem_softc *sc)
+{
+	if_t ifp = sc->ifp;
+	uint32_t dma_cfg;
+	u_char *eaddr = if_getlladdr(ifp);
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Program Net Config Register. */
+	sc->net_cfg_shadow &= (CGEM_NET_CFG_MDC_CLK_DIV_MASK |
+	    CGEM_NET_CFG_DBUS_WIDTH_MASK);
+	sc->net_cfg_shadow |= (CGEM_NET_CFG_FCS_REMOVE |
+	    CGEM_NET_CFG_RX_BUF_OFFSET(ETHER_ALIGN) |
+	    CGEM_NET_CFG_GIGE_EN | CGEM_NET_CFG_1536RXEN |
+	    CGEM_NET_CFG_FULL_DUPLEX | CGEM_NET_CFG_SPEED100);
+
+	/* Enable receive checksum offloading? */
+	if ((if_getcapenable(ifp) & IFCAP_RXCSUM) != 0)
+		sc->net_cfg_shadow |=  CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN;
+
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+
+	/* Program DMA Config Register. */
+	dma_cfg = CGEM_DMA_CFG_RX_BUF_SIZE(MCLBYTES) |
+	    CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_8K |
+	    CGEM_DMA_CFG_TX_PKTBUF_MEMSZ_SEL |
+	    CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_16 |
+#ifdef CGEM64
+	    CGEM_DMA_CFG_ADDR_BUS_64 |
+#endif
+	    CGEM_DMA_CFG_DISC_WHEN_NO_AHB;
+
+	/* Enable transmit checksum offloading? */
+	if ((if_getcapenable(ifp) & IFCAP_TXCSUM) != 0)
+		dma_cfg |= CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN;
+
+	WR4(sc, CGEM_DMA_CFG, dma_cfg);
+
+	/* Write the rx and tx descriptor ring addresses to the QBAR regs. */
+	WR4(sc, CGEM_RX_QBAR, (uint32_t)sc->rxring_physaddr);
+	WR4(sc, CGEM_TX_QBAR, (uint32_t)sc->txring_physaddr);
+#ifdef CGEM64
+	WR4(sc, CGEM_RX_QBAR_HI, (uint32_t)(sc->rxring_physaddr >> 32));
+	WR4(sc, CGEM_TX_QBAR_HI, (uint32_t)(sc->txring_physaddr >> 32));
+#endif
+
+	/* Enable rx and tx. */
+	sc->net_ctl_shadow |= (CGEM_NET_CTRL_TX_EN | CGEM_NET_CTRL_RX_EN);
+	WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow);
+
+	/* Set receive address in case it changed. */
+	WR4(sc, CGEM_SPEC_ADDR_LOW(0), (eaddr[3] << 24) |
+	    (eaddr[2] << 16) | (eaddr[1] << 8) | eaddr[0]);
+	WR4(sc, CGEM_SPEC_ADDR_HI(0), (eaddr[5] << 8) | eaddr[4]);
+
+	/* Set up interrupts. */
+	WR4(sc, CGEM_INTR_EN, CGEM_INTR_RX_COMPLETE | CGEM_INTR_RX_OVERRUN |
+	    CGEM_INTR_TX_USED_READ | CGEM_INTR_RX_USED_READ |
+	    CGEM_INTR_HRESP_NOT_OK);
+}
+
+/* Turn on interface and load up receive ring with buffers. */
+static void
+cgem_init_locked(struct cgem_softc *sc)
+{
+	struct mii_data *mii;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((if_getdrvflags(sc->ifp) & IFF_DRV_RUNNING) != 0)
+		return;
+
+	cgem_config(sc);
+	cgem_fill_rqueue(sc);
+
+	if_setdrvflagbits(sc->ifp, IFF_DRV_RUNNING, IFF_DRV_OACTIVE);
+
+	if (sc->miibus != NULL) {
+		mii = device_get_softc(sc->miibus);
+		mii_mediachg(mii);
+	}
+
+	callout_reset(&sc->tick_ch, hz, cgem_tick, sc);
+}
+
+static void
+cgem_init(void *arg)
+{
+	struct cgem_softc *sc = (struct cgem_softc *)arg;
+
+	CGEM_LOCK(sc);
+	cgem_init_locked(sc);
+	CGEM_UNLOCK(sc);
+}
+
+/* Turn off interface.  Free up any buffers in transmit or receive queues. */
+static void
+cgem_stop(struct cgem_softc *sc)
+{
+	int i;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	callout_stop(&sc->tick_ch);
+
+	/* Shut down hardware. */
+	cgem_reset(sc);
+
+	/* Clear out transmit queue. */
+	memset(sc->txring, 0, CGEM_NUM_TX_DESCS * sizeof(struct cgem_tx_desc));
+	for (i = 0; i < CGEM_NUM_TX_DESCS; i++) {
+		sc->txring[i].ctl = CGEM_TXDESC_USED;
+		if (sc->txring_m[i]) {
+			/* Unload and destroy dmamap. */
+			bus_dmamap_unload(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[i]);
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[i]);
+			sc->txring_m_dmamap[i] = NULL;
+			m_freem(sc->txring_m[i]);
+			sc->txring_m[i] = NULL;
+		}
+	}
+	sc->txring[CGEM_NUM_TX_DESCS - 1].ctl |= CGEM_TXDESC_WRAP;
+
+	sc->txring_hd_ptr = 0;
+	sc->txring_tl_ptr = 0;
+	sc->txring_queued = 0;
+
+	/* Clear out receive queue. */
+	memset(sc->rxring, 0, CGEM_NUM_RX_DESCS * sizeof(struct cgem_rx_desc));
+	for (i = 0; i < CGEM_NUM_RX_DESCS; i++) {
+		sc->rxring[i].addr = CGEM_RXDESC_OWN;
+		if (sc->rxring_m[i]) {
+			/* Unload and destroy dmamap. */
+			bus_dmamap_unload(sc->mbuf_dma_tag,
+			    sc->rxring_m_dmamap[i]);
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+			    sc->rxring_m_dmamap[i]);
+			sc->rxring_m_dmamap[i] = NULL;
+
+			m_freem(sc->rxring_m[i]);
+			sc->rxring_m[i] = NULL;
+		}
+	}
+	sc->rxring[CGEM_NUM_RX_DESCS - 1].addr |= CGEM_RXDESC_WRAP;
+
+	sc->rxring_hd_ptr = 0;
+	sc->rxring_tl_ptr = 0;
+	sc->rxring_queued = 0;
+
+	/* Force next statchg or linkchg to program net config register. */
+	sc->mii_media_active = 0;
+}
+
+static int
+cgem_ioctl(if_t ifp, u_long cmd, caddr_t data)
+{
+	struct cgem_softc *sc = if_getsoftc(ifp);
+	struct ifreq *ifr = (struct ifreq *)data;
+	struct mii_data *mii;
+	int error = 0, mask;
+
+	switch (cmd) {
+	case SIOCSIFFLAGS:
+		CGEM_LOCK(sc);
+		if ((if_getflags(ifp) & IFF_UP) != 0) {
+			if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) != 0) {
+				if (((if_getflags(ifp) ^ sc->if_old_flags) &
+				    (IFF_PROMISC | IFF_ALLMULTI)) != 0) {
+					cgem_rx_filter(sc);
+				}
+			} else {
+				cgem_init_locked(sc);
+			}
+		} else if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) != 0) {
+			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);
+			cgem_stop(sc);
+		}
+		sc->if_old_flags = if_getflags(ifp);
+		CGEM_UNLOCK(sc);
+		break;
+
+	case SIOCADDMULTI:
+	case SIOCDELMULTI:
+		/* Set up multi-cast filters. */
+		if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) != 0) {
+			CGEM_LOCK(sc);
+			cgem_rx_filter(sc);
+			CGEM_UNLOCK(sc);
+		}
+		break;
+
+	case SIOCSIFMEDIA:
+	case SIOCGIFMEDIA:
+		if (sc->miibus == NULL)
+			return (ENXIO);
+		mii = device_get_softc(sc->miibus);
+		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
+		break;
+
+	case SIOCSIFCAP:
+		CGEM_LOCK(sc);
+		mask = if_getcapenable(ifp) ^ ifr->ifr_reqcap;
+
+		if ((mask & IFCAP_TXCSUM) != 0) {
+			if ((ifr->ifr_reqcap & IFCAP_TXCSUM) != 0) {
+				/* Turn on TX checksumming. */
+				if_setcapenablebit(ifp, IFCAP_TXCSUM |
+				    IFCAP_TXCSUM_IPV6, 0);
+				if_sethwassistbits(ifp, CGEM_CKSUM_ASSIST, 0);
+
+				WR4(sc, CGEM_DMA_CFG,
+				    RD4(sc, CGEM_DMA_CFG) |
+				    CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN);
+			} else {
+				/* Turn off TX checksumming. */
+				if_setcapenablebit(ifp, 0, IFCAP_TXCSUM |
+				    IFCAP_TXCSUM_IPV6);
+				if_sethwassistbits(ifp, 0, CGEM_CKSUM_ASSIST);
+
+				WR4(sc, CGEM_DMA_CFG,
+				    RD4(sc, CGEM_DMA_CFG) &
+				    ~CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN);
+			}
+		}
+		if ((mask & IFCAP_RXCSUM) != 0) {
+			if ((ifr->ifr_reqcap & IFCAP_RXCSUM) != 0) {
+				/* Turn on RX checksumming. */
+				if_setcapenablebit(ifp, IFCAP_RXCSUM |
+				    IFCAP_RXCSUM_IPV6, 0);
+				sc->net_cfg_shadow |=
+				    CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN;
+				WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+			} else {
+				/* Turn off RX checksumming. */
+				if_setcapenablebit(ifp, 0, IFCAP_RXCSUM |
+				    IFCAP_RXCSUM_IPV6);
+				sc->net_cfg_shadow &=
+				    ~CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN;
+				WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+			}
+		}
+		if ((if_getcapenable(ifp) & (IFCAP_RXCSUM | IFCAP_TXCSUM)) ==
+		    (IFCAP_RXCSUM | IFCAP_TXCSUM))
+			if_setcapenablebit(ifp, IFCAP_VLAN_HWCSUM, 0);
+		else
+			if_setcapenablebit(ifp, 0, IFCAP_VLAN_HWCSUM);
+
+		CGEM_UNLOCK(sc);
+		break;
+	default:
+		error = ether_ioctl(ifp, cmd, data);
+		break;
+	}
+
+	return (error);
+}
+
+/* MII bus support routines.
+ */
+static int
+cgem_ifmedia_upd(if_t ifp)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+	struct mii_data *mii;
+	struct mii_softc *miisc;
+	int error = 0;
+
+	mii = device_get_softc(sc->miibus);
+	CGEM_LOCK(sc);
+	if ((if_getflags(ifp) & IFF_UP) != 0) {
+		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
+			PHY_RESET(miisc);
+		error = mii_mediachg(mii);
+	}
+	CGEM_UNLOCK(sc);
+
+	return (error);
+}
+
+static void
+cgem_ifmedia_sts(if_t ifp, struct ifmediareq *ifmr)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+	struct mii_data *mii;
+
+	mii = device_get_softc(sc->miibus);
+	CGEM_LOCK(sc);
+	mii_pollstat(mii);
+	ifmr->ifm_active = mii->mii_media_active;
+	ifmr->ifm_status = mii->mii_media_status;
+	CGEM_UNLOCK(sc);
+}
+
+static int
+cgem_miibus_readreg(device_t dev, int phy, int reg)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	int tries, val;
+
+	WR4(sc, CGEM_PHY_MAINT, CGEM_PHY_MAINT_CLAUSE_22 |
+	    CGEM_PHY_MAINT_MUST_10 | CGEM_PHY_MAINT_OP_READ |
+	    (phy << CGEM_PHY_MAINT_PHY_ADDR_SHIFT) |
+	    (reg << CGEM_PHY_MAINT_REG_ADDR_SHIFT));
+
+	/* Wait for completion. */
+	tries=0;
+	while ((RD4(sc, CGEM_NET_STAT) & CGEM_NET_STAT_PHY_MGMT_IDLE) == 0) {
+		DELAY(5);
+		if (++tries > 200) {
+			device_printf(dev, "phy read timeout: %d\n", reg);
+			return (-1);
+		}
+	}
+
+	val = RD4(sc, CGEM_PHY_MAINT) & CGEM_PHY_MAINT_DATA_MASK;
+
+	if (reg == MII_EXTSR)
+		/*
+		 * MAC does not support half-duplex at gig speeds.
+		 * Let mii(4) exclude the capability.
+		 */
+		val &= ~(EXTSR_1000XHDX | EXTSR_1000THDX);
+
+	return (val);
+}
+
+static int
+cgem_miibus_writereg(device_t dev, int phy, int reg, int data)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	int tries;
+
+	WR4(sc, CGEM_PHY_MAINT, CGEM_PHY_MAINT_CLAUSE_22 |
+	    CGEM_PHY_MAINT_MUST_10 | CGEM_PHY_MAINT_OP_WRITE |
+	    (phy << CGEM_PHY_MAINT_PHY_ADDR_SHIFT) |
+	    (reg << CGEM_PHY_MAINT_REG_ADDR_SHIFT) |
+	    (data & CGEM_PHY_MAINT_DATA_MASK));
+
+	/* Wait for completion. */
+	tries = 0;
+	while ((RD4(sc, CGEM_NET_STAT) & CGEM_NET_STAT_PHY_MGMT_IDLE) == 0) {
+		DELAY(5);
+		if (++tries > 200) {
+			device_printf(dev, "phy write timeout: %d\n", reg);
+			return (-1);
+		}
+	}
+
+	return (0);
+}
+
+static void
+cgem_miibus_statchg(device_t dev)
+{
+	struct cgem_softc *sc  = device_get_softc(dev);
+	struct mii_data *mii = device_get_softc(sc->miibus);
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
+	    (IFM_ACTIVE | IFM_AVALID) &&
+	    sc->mii_media_active != mii->mii_media_active)
+		cgem_mediachange(sc, mii);
+}
+
+static void
+cgem_miibus_linkchg(device_t dev)
+{
+	struct cgem_softc *sc  = device_get_softc(dev);
+	struct mii_data *mii = device_get_softc(sc->miibus);
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
+	    (IFM_ACTIVE | IFM_AVALID) &&
+	    sc->mii_media_active != mii->mii_media_active)
+		cgem_mediachange(sc, mii);
+}
+
+/*
+ * Overridable weak symbol cgem_set_ref_clk().  This allows platforms to
+ * provide a function to set the cgem's reference clock.
+ */
+static int __used
+cgem_default_set_ref_clk(int unit, int frequency)
+{
+
+	return 0;
+}
+__weak_reference(cgem_default_set_ref_clk, cgem_set_ref_clk);
+
+/* Call to set reference clock and network config bits according to media. */
+static void
+cgem_mediachange(struct cgem_softc *sc,	struct mii_data *mii)
+{
+	int ref_clk_freq;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Update hardware to reflect media. */
+	sc->net_cfg_shadow &= ~(CGEM_NET_CFG_SPEED100 | CGEM_NET_CFG_GIGE_EN |
+	    CGEM_NET_CFG_FULL_DUPLEX);
+
+	switch (IFM_SUBTYPE(mii->mii_media_active)) {
+	case IFM_1000_T:
+		sc->net_cfg_shadow |= (CGEM_NET_CFG_SPEED100 |
+		    CGEM_NET_CFG_GIGE_EN);
+		ref_clk_freq = 125000000;
+		break;
+	case IFM_100_TX:
+		sc->net_cfg_shadow |= CGEM_NET_CFG_SPEED100;
+		ref_clk_freq = 25000000;
+		break;
+	default:
+		ref_clk_freq = 2500000;
+	}
+
+	if ((mii->mii_media_active & IFM_FDX) != 0)
+		sc->net_cfg_shadow |= CGEM_NET_CFG_FULL_DUPLEX;
+
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+
+#ifdef EXT_RESOURCES
+	if (sc->ref_clk != NULL) {
+		CGEM_UNLOCK(sc);
+		if (clk_set_freq(sc->ref_clk, ref_clk_freq, 0))
+			device_printf(sc->dev, "could not set ref clk to %d\n",
+			    ref_clk_freq);
+		CGEM_LOCK(sc);
+	}
+#else
+	/* Set the reference clock if necessary. */
+	if (cgem_set_ref_clk(sc->ref_clk_num, ref_clk_freq))
+		device_printf(sc->dev,
+		    "cgem_mediachange: could not set ref clk%d to %d.\n",
+		    sc->ref_clk_num, ref_clk_freq);
+#endif
+
+	sc->mii_media_active = mii->mii_media_active;
+}
+
+static void
+cgem_add_sysctls(device_t dev)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	struct sysctl_ctx_list *ctx;
+	struct sysctl_oid_list *child;
+	struct sysctl_oid *tree;
+
+	ctx = device_get_sysctl_ctx(dev);
+	child = SYSCTL_CHILDREN(device_get_sysctl_tree(dev));
+
+	SYSCTL_ADD_INT(ctx, child, OID_AUTO, "rxbufs", CTLFLAG_RW,
+	    &sc->rxbufs, 0, "Number receive buffers to provide");
+
+	SYSCTL_ADD_INT(ctx, child, OID_AUTO, "rxhangwar", CTLFLAG_RW,
+	    &sc->rxhangwar, 0, "Enable receive hang work-around");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_rxoverruns", CTLFLAG_RD,
+	    &sc->rxoverruns, 0, "Receive overrun events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_rxnobufs", CTLFLAG_RD,
+	    &sc->rxnobufs, 0, "Receive buf queue empty events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_rxdmamapfails", CTLFLAG_RD,
+	    &sc->rxdmamapfails, 0, "Receive DMA map failures");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txfull", CTLFLAG_RD,
+	    &sc->txfull, 0, "Transmit ring full events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txdmamapfails", CTLFLAG_RD,
+	    &sc->txdmamapfails, 0, "Transmit DMA map failures");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txdefrags", CTLFLAG_RD,
+	    &sc->txdefrags, 0, "Transmit m_defrag() calls");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txdefragfails", CTLFLAG_RD,
+	    &sc->txdefragfails, 0, "Transmit m_defrag() failures");
+
+	tree = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, "stats",
+	    CTLFLAG_RD | CTLFLAG_MPSAFE, NULL, "GEM statistics");
+	child = SYSCTL_CHILDREN(tree);
+
+	SYSCTL_ADD_UQUAD(ctx, child, OID_AUTO, "tx_bytes", CTLFLAG_RD,
+	    &sc->stats.tx_bytes, "Total bytes transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames", CTLFLAG_RD,
+	    &sc->stats.tx_frames, 0, "Total frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_bcast", CTLFLAG_RD,
+	    &sc->stats.tx_frames_bcast, 0,
+	    "Number broadcast frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_multi", CTLFLAG_RD,
+	    &sc->stats.tx_frames_multi, 0,
+	    "Number multicast frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_pause",
+	    CTLFLAG_RD, &sc->stats.tx_frames_pause, 0,
+	    "Number pause frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_64b", CTLFLAG_RD,
+	    &sc->stats.tx_frames_64b, 0,
+	    "Number frames transmitted of size 64 bytes or less");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_65to127b", CTLFLAG_RD,
+	    &sc->stats.tx_frames_65to127b, 0,
+	    "Number frames transmitted of size 65-127 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_128to255b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_128to255b, 0,
+	    "Number frames transmitted of size 128-255 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_256to511b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_256to511b, 0,
+	    "Number frames transmitted of size 256-511 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_512to1023b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_512to1023b, 0,
+	    "Number frames transmitted of size 512-1023 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_1024to1536b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_1024to1536b, 0,
+	    "Number frames transmitted of size 1024-1536 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_under_runs",
+	    CTLFLAG_RD, &sc->stats.tx_under_runs, 0,
+	    "Number transmit under-run events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_single_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_single_collisn, 0,
+	    "Number single-collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_multi_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_multi_collisn, 0,
+	    "Number multi-collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_excsv_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_excsv_collisn, 0,
+	    "Number excessive collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_late_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_late_collisn, 0,
+	    "Number late-collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_deferred_frames",
+	    CTLFLAG_RD, &sc->stats.tx_deferred_frames, 0,
+	    "Number deferred transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_carrier_sense_errs",
+	    CTLFLAG_RD, &sc->stats.tx_carrier_sense_errs, 0,
+	    "Number carrier sense errors on transmit");
+
+	SYSCTL_ADD_UQUAD(ctx, child, OID_AUTO, "rx_bytes", CTLFLAG_RD,
+	    &sc->stats.rx_bytes, "Total bytes received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames", CTLFLAG_RD,
+	    &sc->stats.rx_frames, 0, "Total frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_bcast",
+	    CTLFLAG_RD, &sc->stats.rx_frames_bcast, 0,
+	    "Number broadcast frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_multi",
+	    CTLFLAG_RD, &sc->stats.rx_frames_multi, 0,
+	    "Number multicast frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_pause",
+	    CTLFLAG_RD, &sc->stats.rx_frames_pause, 0,
+	    "Number pause frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_64b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_64b, 0,
+	    "Number frames received of size 64 bytes or less");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_65to127b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_65to127b, 0,
+	    "Number frames received of size 65-127 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_128to255b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_128to255b, 0,
+	    "Number frames received of size 128-255 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_256to511b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_256to511b, 0,
+	    "Number frames received of size 256-511 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_512to1023b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_512to1023b, 0,
+	    "Number frames received of size 512-1023 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_1024to1536b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_1024to1536b, 0,
+	    "Number frames received of size 1024-1536 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_undersize",
+	    CTLFLAG_RD, &sc->stats.rx_frames_undersize, 0,
+	    "Number undersize frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_oversize",
+	    CTLFLAG_RD, &sc->stats.rx_frames_oversize, 0,
+	    "Number oversize frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_jabber",
+	    CTLFLAG_RD, &sc->stats.rx_frames_jabber, 0,
+	    "Number jabber frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_fcs_errs",
+	    CTLFLAG_RD, &sc->stats.rx_frames_fcs_errs, 0,
+	    "Number frames received with FCS errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_length_errs",
+	    CTLFLAG_RD, &sc->stats.rx_frames_length_errs, 0,
+	    "Number frames received with length errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_symbol_errs",
+	    CTLFLAG_RD, &sc->stats.rx_symbol_errs, 0,
+	    "Number receive symbol errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_align_errs",
+	    CTLFLAG_RD, &sc->stats.rx_align_errs, 0,
+	    "Number receive alignment errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_resource_errs",
+	    CTLFLAG_RD, &sc->stats.rx_resource_errs, 0,
+	    "Number frames received when no rx buffer available");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_overrun_errs",
+	    CTLFLAG_RD, &sc->stats.rx_overrun_errs, 0,
+	    "Number frames received but not copied due to receive overrun");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_ip_hdr_csum_errs",
+	    CTLFLAG_RD, &sc->stats.rx_ip_hdr_csum_errs, 0,
+	    "Number frames received with IP header checksum errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_tcp_csum_errs",
+	    CTLFLAG_RD, &sc->stats.rx_tcp_csum_errs, 0,
+	    "Number frames received with TCP checksum errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_udp_csum_errs",
+	    CTLFLAG_RD, &sc->stats.rx_udp_csum_errs, 0,
+	    "Number frames received with UDP checksum errors");
+}
+
+static int
+cgem_probe(device_t dev)
+{
+
+	if (!ofw_bus_status_okay(dev))
+		return (ENXIO);
+
+	if (ofw_bus_search_compatible(dev, compat_data)->ocd_data == 0)
+		return (ENXIO);
+
+	device_set_desc(dev, "Cadence CGEM Gigabit Ethernet Interface");
+	return (0);
+}
+
+static int
+cgem_attach(device_t dev)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	if_t ifp = NULL;
+	int rid, err;
+	u_char eaddr[ETHER_ADDR_LEN];
+	int hwtype;
+#ifndef EXT_RESOURCES
+	phandle_t node;
+	pcell_t cell;
+#endif
+
+	sc->dev = dev;
+	CGEM_LOCK_INIT(sc);
+
+	/* Key off of compatible string and set hardware-specific options. */
+	hwtype = ofw_bus_search_compatible(dev, compat_data)->ocd_data;
+	if (hwtype == HWTYPE_ZYNQMP)
+		sc->neednullqs = 1;
+	if (hwtype == HWTYPE_ZYNQ)
+		sc->rxhangwar = 1;
+
+#ifdef EXT_RESOURCES
+	if (hwtype == HWTYPE_ZYNQ || hwtype == HWTYPE_ZYNQMP) {
+		if (clk_get_by_ofw_name(dev, 0, "tx_clk", &sc->ref_clk) != 0)
+			device_printf(dev,
+			    "could not retrieve reference clock.\n");
+		else if (clk_enable(sc->ref_clk) != 0)
+			device_printf(dev, "could not enable clock.\n");
+	} else if (hwtype == HWTYPE_SIFIVE) {
+		if (clk_get_by_ofw_name(dev, 0, "pclk", &sc->ref_clk) != 0)
+			device_printf(dev,
+			    "could not retrieve reference clock.\n");
+		else if (clk_enable(sc->ref_clk) != 0)
+			device_printf(dev, "could not enable clock.\n");
+	}
+#else
+	/* Get reference clock number and base divider from fdt. */
+	node = ofw_bus_get_node(dev);
+	sc->ref_clk_num = 0;
+	if (OF_getprop(node, "ref-clock-num", &cell, sizeof(cell)) > 0)
+		sc->ref_clk_num = fdt32_to_cpu(cell);
+#endif
+
+	/* Get memory resource. */
+	rid = 0;
+	sc->mem_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
+	    RF_ACTIVE);
+	if (sc->mem_res == NULL) {
+		device_printf(dev, "could not allocate memory resources.\n");
+		return (ENOMEM);
+	}
+
+	/* Get IRQ resource. */
+	rid = 0;
+	sc->irq_res = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid,
+	    RF_ACTIVE);
+	if (sc->irq_res == NULL) {
+		device_printf(dev, "could not allocate interrupt resource.\n");
+		cgem_detach(dev);
+		return (ENOMEM);
+	}
+
+	/* Set up ifnet structure. */
+	ifp = sc->ifp = if_alloc(IFT_ETHER);
+	if (ifp == NULL) {
+		device_printf(dev, "could not allocate ifnet structure\n");
+		cgem_detach(dev);
+		return (ENOMEM);
+	}
+	if_setsoftc(ifp, sc);
+	if_initname(ifp, IF_CGEM_NAME, device_get_unit(dev));
+	if_setflags(ifp, IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST);
+	if_setinitfn(ifp, cgem_init);
+	if_setioctlfn(ifp, cgem_ioctl);
+	if_setstartfn(ifp, cgem_start);
+	if_setcapabilitiesbit(ifp, IFCAP_HWCSUM | IFCAP_HWCSUM_IPV6 |
+	    IFCAP_VLAN_MTU | IFCAP_VLAN_HWCSUM, 0);
+	if_setsendqlen(ifp, CGEM_NUM_TX_DESCS);
+	if_setsendqready(ifp);
+
+	/* Disable hardware checksumming by default. */
+	if_sethwassist(ifp, 0);
+	if_setcapenable(ifp, if_getcapabilities(ifp) &
+	    ~(IFCAP_HWCSUM | IFCAP_HWCSUM_IPV6 | IFCAP_VLAN_HWCSUM));
+
+	sc->if_old_flags = if_getflags(ifp);
+	sc->rxbufs = DEFAULT_NUM_RX_BUFS;
+
+	/* Reset hardware. */
+	CGEM_LOCK(sc);
+	cgem_reset(sc);
+	CGEM_UNLOCK(sc);
+
+	/* Attach phy to mii bus. */
+	err = mii_attach(dev, &sc->miibus, ifp,
+	    cgem_ifmedia_upd, cgem_ifmedia_sts, BMSR_DEFCAPMASK,
+	    MII_PHY_ANY, MII_OFFSET_ANY, 0);
+	if (err)
+		device_printf(dev, "warning: attaching PHYs failed\n");
+
+	/* Set up TX and RX descriptor area. */
+	err = cgem_setup_descs(sc);
+	if (err) {
+		device_printf(dev, "could not set up dma mem for descs.\n");
+		cgem_detach(dev);
+		return (ENOMEM);
+	}
+
+	/* Get a MAC address. */
+	cgem_get_mac(sc, eaddr);
+
+	/* Start ticks. */
+	callout_init_mtx(&sc->tick_ch, &sc->sc_mtx, 0);
+
+	ether_ifattach(ifp, eaddr);
+
+	err = bus_setup_intr(dev, sc->irq_res, INTR_TYPE_NET | INTR_MPSAFE |
+	    INTR_EXCL, NULL, cgem_intr, sc, &sc->intrhand);
+	if (err) {
+		device_printf(dev, "could not set interrupt handler.\n");
+		ether_ifdetach(ifp);
+		cgem_detach(dev);
+		return (err);
+	}
+
+	cgem_add_sysctls(dev);
+
+	return (0);
+}
+
+static int
+cgem_detach(device_t dev)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	int i;
+
+	if (sc == NULL)
+		return (ENODEV);
+
+	if (device_is_attached(dev)) {
+		CGEM_LOCK(sc);
+		cgem_stop(sc);
+		CGEM_UNLOCK(sc);
+		callout_drain(&sc->tick_ch);
+		if_setflagbits(sc->ifp, 0, IFF_UP);
+		ether_ifdetach(sc->ifp);
+	}
+
+	if (sc->miibus != NULL) {
+		device_delete_child(dev, sc->miibus);
+		sc->miibus = NULL;
+	}
+
+	/* Release resources. */
+	if (sc->mem_res != NULL) {
+		bus_release_resource(dev, SYS_RES_MEMORY,
+		    rman_get_rid(sc->mem_res), sc->mem_res);
+		sc->mem_res = NULL;
+	}
+	if (sc->irq_res != NULL) {
+		if (sc->intrhand)
+			bus_teardown_intr(dev, sc->irq_res, sc->intrhand);
+		bus_release_resource(dev, SYS_RES_IRQ,
+		    rman_get_rid(sc->irq_res), sc->irq_res);
+		sc->irq_res = NULL;
+	}
+
+	/* Release DMA resources. */
+	if (sc->rxring != NULL) {
+		if (sc->rxring_physaddr != 0) {
+			bus_dmamap_unload(sc->desc_dma_tag,
+			    sc->rxring_dma_map);
+			sc->rxring_physaddr = 0;
+			sc->txring_physaddr = 0;
+			sc->null_qs_physaddr = 0;
+		}
+		bus_dmamem_free(sc->desc_dma_tag, sc->rxring,
+				sc->rxring_dma_map);
+		sc->rxring = NULL;
+		sc->txring = NULL;
+		sc->null_qs = NULL;
+
+		for (i = 0; i < CGEM_NUM_RX_DESCS; i++)
+			if (sc->rxring_m_dmamap[i] != NULL) {
+				bus_dmamap_destroy(sc->mbuf_dma_tag,
+				    sc->rxring_m_dmamap[i]);
+				sc->rxring_m_dmamap[i] = NULL;
+			}
+		for (i = 0; i < CGEM_NUM_TX_DESCS; i++)
+			if (sc->txring_m_dmamap[i] != NULL) {
+				bus_dmamap_destroy(sc->mbuf_dma_tag,
+				    sc->txring_m_dmamap[i]);
+				sc->txring_m_dmamap[i] = NULL;
+			}
+	}
+	if (sc->desc_dma_tag != NULL) {
+		bus_dma_tag_destroy(sc->desc_dma_tag);
+		sc->desc_dma_tag = NULL;
+	}
+	if (sc->mbuf_dma_tag != NULL) {
+		bus_dma_tag_destroy(sc->mbuf_dma_tag);
+		sc->mbuf_dma_tag = NULL;
+	}
+
+#ifdef EXT_RESOURCES
+	if (sc->ref_clk != NULL) {
+		clk_release(sc->ref_clk);
+		sc->ref_clk = NULL;
+	}
+#endif
+
+	bus_generic_detach(dev);
+
+	CGEM_LOCK_DESTROY(sc);
+
+	return (0);
+}
+
+static device_method_t cgem_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		cgem_probe),
+	DEVMETHOD(device_attach,	cgem_attach),
+	DEVMETHOD(device_detach,	cgem_detach),
+
+	/* MII interface */
+	DEVMETHOD(miibus_readreg,	cgem_miibus_readreg),
+	DEVMETHOD(miibus_writereg,	cgem_miibus_writereg),
+	DEVMETHOD(miibus_statchg,	cgem_miibus_statchg),
+	DEVMETHOD(miibus_linkchg,	cgem_miibus_linkchg),
+
+	DEVMETHOD_END
+};
+
+static driver_t cgem_driver = {
+	"cgem",
+	cgem_methods,
+	sizeof(struct cgem_softc),
+};
+
+DRIVER_MODULE(cgem, simplebus, cgem_driver, cgem_devclass, NULL, NULL);
+DRIVER_MODULE(miibus, cgem, miibus_driver, miibus_devclass, NULL, NULL);
+MODULE_DEPEND(cgem, miibus, 1, 1, 1);
+MODULE_DEPEND(cgem, ether, 1, 1, 1);
+SIMPLEBUS_PNP_INFO(compat_data);
diff --git a/src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem_hw.h b/src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem_hw.h
new file mode 100644
index 0000000000..784b131a88
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/-cadence_gem/dev/cadence/if_cgem_hw.h
@@ -0,0 +1,446 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2012-2013 Thomas Skibo
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * Hardware and register defines for Cadence GEM Gigabit Ethernet
+ * controller such as the one used in Zynq-7000 SoC.
+ *
+ * Reference: Zynq-7000 All Programmable SoC Technical Reference Manual.
+ * (v1.4) November 16, 2012.  Xilinx doc UG585.  GEM is covered in Ch. 16
+ * and register definitions are in appendix B.18.
+ *
+ * Additional Reference: Zynq UltraScale+ Device Register Reference
+ * (UG1087 v1.7 Feb 8,2019):
+ * https://www.xilinx.com/html_docs/registers/ug1087/ug1087-zynq-ultrascale-registers.html
+ */
+
+#ifndef _IF_CGEM_HW_H_
+#define _IF_CGEM_HW_H_
+
+/* Cadence GEM hardware register definitions. */
+#define CGEM_NET_CTRL			0x000	/* Network Control */
+#define   CGEM_NET_CTRL_FLUSH_DPRAM_PKT		(1 << 18)
+#define   CGEM_NET_CTRL_TX_PFC_PRI_PAUSE_FRAME	(1 << 17)
+#define   CGEM_NET_CTRL_EN_PFC_PRI_PAUSE_RX	(1 << 16)
+#define   CGEM_NET_CTRL_STORE_RX_TSTAMP		(1 << 15)
+#define   CGEM_NET_CTRL_TX_ZEROQ_PAUSE_FRAME	(1 << 12)
+#define   CGEM_NET_CTRL_TX_PAUSE_FRAME		(1 << 11)
+#define   CGEM_NET_CTRL_TX_HALT			(1 << 10)
+#define   CGEM_NET_CTRL_START_TX		(1 << 9)
+#define   CGEM_NET_CTRL_BACK_PRESSURE		(1 << 8)
+#define   CGEM_NET_CTRL_WREN_STAT_REGS		(1 << 7)
+#define   CGEM_NET_CTRL_INCR_STAT_REGS		(1 << 6)
+#define   CGEM_NET_CTRL_CLR_STAT_REGS		(1 << 5)
+#define   CGEM_NET_CTRL_MGMT_PORT_EN		(1 << 4)
+#define   CGEM_NET_CTRL_TX_EN			(1 << 3)
+#define   CGEM_NET_CTRL_RX_EN			(1 << 2)
+#define   CGEM_NET_CTRL_LOOP_LOCAL		(1 << 1)
+
+#define CGEM_NET_CFG			0x004	/* Netowrk Configuration */
+#define   CGEM_NET_CFG_UNIDIR_EN		(1U << 31)
+#define   CGEM_NET_CFG_IGNORE_IPG_RX_ER		(1 << 30)
+#define   CGEM_NET_CFG_RX_BAD_PREAMBLE		(1 << 29)
+#define   CGEM_NET_CFG_IPG_STRETCH_EN		(1 << 28)
+#define   CGEM_NET_CFG_SGMII_EN			(1 << 27)
+#define   CGEM_NET_CFG_IGNORE_RX_FCS		(1 << 26)
+#define   CGEM_NET_CFG_RX_HD_WHILE_TX		(1 << 25)
+#define   CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN	(1 << 24)
+#define   CGEM_NET_CFG_DIS_CP_PAUSE_FRAME	(1 << 23)
+#define   CGEM_NET_CFG_DBUS_WIDTH_32		(0 << 21)
+#define   CGEM_NET_CFG_DBUS_WIDTH_64		(1 << 21)
+#define   CGEM_NET_CFG_DBUS_WIDTH_128		(2 << 21)
+#define   CGEM_NET_CFG_DBUS_WIDTH_MASK		(3 << 21)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_8		(0 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_16		(1 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_32		(2 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_48		(3 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_64		(4 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_96		(5 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_128		(6 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_224		(7 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_MASK		(7 << 18)
+#define   CGEM_NET_CFG_FCS_REMOVE		(1 << 17)
+#define   CGEM_NET_CFG_LEN_ERR_FRAME_DISC	(1 << 16)
+#define   CGEM_NET_CFG_RX_BUF_OFFSET_SHFT	14
+#define   CGEM_NET_CFG_RX_BUF_OFFSET_MASK	(3 << 14)
+#define   CGEM_NET_CFG_RX_BUF_OFFSET(n)		((n) << 14)
+#define   CGEM_NET_CFG_PAUSE_EN			(1 << 13)
+#define   CGEM_NET_CFG_RETRY_TEST		(1 << 12)
+#define   CGEM_NET_CFG_PCS_SEL			(1 << 11)
+#define   CGEM_NET_CFG_GIGE_EN			(1 << 10)
+#define   CGEM_NET_CFG_EXT_ADDR_MATCH_EN	(1 << 9)
+#define   CGEM_NET_CFG_1536RXEN			(1 << 8)
+#define   CGEM_NET_CFG_UNI_HASH_EN		(1 << 7)
+#define   CGEM_NET_CFG_MULTI_HASH_EN		(1 << 6)
+#define   CGEM_NET_CFG_NO_BCAST			(1 << 5)
+#define   CGEM_NET_CFG_COPY_ALL			(1 << 4)
+#define   CGEM_NET_CFG_DISC_NON_VLAN		(1 << 2)
+#define   CGEM_NET_CFG_FULL_DUPLEX		(1 << 1)
+#define   CGEM_NET_CFG_SPEED100			(1 << 0)
+
+#define CGEM_NET_STAT			0x008	/* Network Status */
+#define   CGEM_NET_STAT_PFC_PRI_PAUSE_NEG	(1 << 6)
+#define   CGEM_NET_STAT_PCS_AUTONEG_PAUSE_TX_RES (1 << 5)
+#define   CGEM_NET_STAT_PCS_AUTONEG_PAUSE_RX_RES (1 << 4)
+#define   CGEM_NET_STAT_PCS_AUTONEG_DUP_RES	(1 << 3)
+#define   CGEM_NET_STAT_PHY_MGMT_IDLE		(1 << 2)
+#define   CGEM_NET_STAT_MDIO_IN_PIN_STATUS	(1 << 1)
+#define   CGEM_NET_STAT_PCS_LINK_STATE		(1 << 0)
+
+#define CGEM_USER_IO			0x00C	/* User I/O */
+
+#define CGEM_DMA_CFG			0x010	/* DMA Config */
+#define   CGEM_DMA_CFG_ADDR_BUS_64		(1 << 30)
+#define   CGEM_DMA_CFG_DISC_WHEN_NO_AHB		(1 << 24)
+#define   CGEM_DMA_CFG_RX_BUF_SIZE_SHIFT	16
+#define   CGEM_DMA_CFG_RX_BUF_SIZE_MASK		(0xff << 16)
+#define   CGEM_DMA_CFG_RX_BUF_SIZE(sz)		((((sz) + 63) / 64)  <<  16)
+#define   CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN	(1 << 11)
+#define   CGEM_DMA_CFG_TX_PKTBUF_MEMSZ_SEL	(1 << 10)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_1K	(0 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_2K	(1 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_4K	(2 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_8K	(3 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_MASK	(3 << 8)
+#define   CGEM_DMA_CFG_AHB_ENDIAN_SWAP_PKT_EN	(1 << 7)
+#define   CGEM_DMA_CFG_AHB_ENDIAN_SWAP_MGMT_EN	(1 << 6)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_1	(1 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_4	(4 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_8	(8 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_16	(16 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_MASK	(0x1f << 0)
+
+#define CGEM_TX_STAT			0x014	/* Transmit Status */
+#define   CGEM_TX_STAT_HRESP_NOT_OK		(1 << 8)
+#define   CGEM_TX_STAT_LATE_COLL		(1 << 7)
+#define   CGEM_TX_STAT_UNDERRUN			(1 << 6)
+#define   CGEM_TX_STAT_COMPLETE			(1 << 5)
+#define   CGEM_TX_STAT_CORRUPT_AHB_ERR		(1 << 4)
+#define   CGEM_TX_STAT_GO			(1 << 3)
+#define   CGEM_TX_STAT_RETRY_LIMIT_EXC		(1 << 2)
+#define   CGEM_TX_STAT_COLLISION		(1 << 1)
+#define   CGEM_TX_STAT_USED_BIT_READ		(1 << 0)
+#define   CGEM_TX_STAT_ALL			0x1ff
+
+#define CGEM_RX_QBAR			0x018	/* Receive Buf Q Base Addr */
+#define CGEM_TX_QBAR			0x01C	/* Transmit Buf Q Base Addr */
+
+#define CGEM_RX_STAT			0x020	/* Receive Status */
+#define   CGEM_RX_STAT_HRESP_NOT_OK		(1 << 3)
+#define   CGEM_RX_STAT_OVERRUN			(1 << 2)
+#define   CGEM_RX_STAT_FRAME_RECD		(1 << 1)
+#define   CGEM_RX_STAT_BUF_NOT_AVAIL		(1 << 0)
+#define   CGEM_RX_STAT_ALL			0xf
+
+#define CGEM_INTR_STAT			0x024	/* Interrupt Status */
+#define CGEM_INTR_EN			0x028	/* Interrupt Enable */
+#define CGEM_INTR_DIS			0x02C	/* Interrupt Disable */
+#define CGEM_INTR_MASK			0x030	/* Interrupt Mask */
+#define   CGEM_INTR_TSU_SEC_INCR		(1 << 26)
+#define   CGEM_INTR_PDELAY_RESP_TX		(1 << 25)
+#define   CGEM_INTR_PDELAY_REQ_TX		(1 << 24)
+#define   CGEM_INTR_PDELAY_RESP_RX		(1 << 23)
+#define   CGEM_INTR_PDELAY_REQ_RX		(1 << 22)
+#define   CGEM_INTR_SYNX_TX			(1 << 21)
+#define   CGEM_INTR_DELAY_REQ_TX		(1 << 20)
+#define   CGEM_INTR_SYNC_RX			(1 << 19)
+#define   CGEM_INTR_DELAY_REQ_RX		(1 << 18)
+#define   CGEM_INTR_PARTNER_PG_RX		(1 << 17)
+#define   CGEM_INTR_AUTONEG_COMPL		(1 << 16)
+#define   CGEM_INTR_EXT_INTR			(1 << 15)
+#define   CGEM_INTR_PAUSE_TX			(1 << 14)
+#define   CGEM_INTR_PAUSE_ZERO			(1 << 13)
+#define   CGEM_INTR_PAUSE_NONZEROQ_RX		(1 << 12)
+#define   CGEM_INTR_HRESP_NOT_OK		(1 << 11)
+#define   CGEM_INTR_RX_OVERRUN			(1 << 10)
+#define   CGEM_INTR_LINK_CHNG			(1 << 9)
+#define   CGEM_INTR_TX_COMPLETE			(1 << 7)
+#define   CGEM_INTR_TX_CORRUPT_AHB_ERR		(1 << 6)
+#define   CGEM_INTR_RETRY_EX_LATE_COLLISION	(1 << 5)
+#define   CGEM_INTR_TX_USED_READ		(1 << 3)
+#define   CGEM_INTR_RX_USED_READ		(1 << 2)
+#define   CGEM_INTR_RX_COMPLETE			(1 << 1)
+#define   CGEM_INTR_MGMT_SENT			(1 << 0)
+#define   CGEM_INTR_ALL				0x7FFFEFF
+
+#define CGEM_PHY_MAINT			0x034	/* PHY Maintenenace */
+#define   CGEM_PHY_MAINT_CLAUSE_22		(1 << 30)
+#define   CGEM_PHY_MAINT_OP_SHIFT		28
+#define   CGEM_PHY_MAINT_OP_MASK		(3 << 28)
+#define   CGEM_PHY_MAINT_OP_READ		(2 << 28)
+#define   CGEM_PHY_MAINT_OP_WRITE		(1 << 28)
+#define   CGEM_PHY_MAINT_PHY_ADDR_SHIFT		23
+#define   CGEM_PHY_MAINT_PHY_ADDR_MASK		(0x1f << 23)
+#define   CGEM_PHY_MAINT_REG_ADDR_SHIFT		18
+#define   CGEM_PHY_MAINT_REG_ADDR_MASK		(0x1f << 18)
+#define   CGEM_PHY_MAINT_MUST_10		(2 << 16)
+#define   CGEM_PHY_MAINT_DATA_MASK		0xffff
+
+#define CGEM_RX_PAUSEQ			0x038	/* Received Pause Quantum */
+#define CGEM_TX_PAUSEQ			0x03C	/* Transmit Puase Quantum */
+
+#define CGEM_HASH_BOT			0x080	/* Hash Reg Bottom [31:0] */
+#define CGEM_HASH_TOP			0x084	/* Hash Reg Top [63:32] */
+#define CGEM_SPEC_ADDR_LOW(n)		(0x088 + (n) * 8)
+#define CGEM_SPEC_ADDR_HI(n)		(0x08C + (n) * 8)
+
+#define CGEM_TYPE_ID_MATCH1		0x0A8	/* Type ID Match 1 */
+#define   CGEM_TYPE_ID_MATCH_COPY_EN		(1U << 31)
+#define CGEM_TYPE_ID_MATCH2		0x0AC	/* Type ID Match 2 */
+#define CGEM_TYPE_ID_MATCH3		0x0B0	/* Type ID Match 3 */
+#define CGEM_TYPE_ID_MATCH4		0x0B4	/* Type ID Match 4 */
+
+#define CGEM_WAKE_ON_LAN		0x0B8	/* Wake on LAN Register */
+#define   CGEM_WOL_MULTI_HASH_EN		(1 << 19)
+#define   CGEM_WOL_SPEC_ADDR1_EN		(1 << 18)
+#define   CGEM_WOL_ARP_REQ_EN			(1 << 17)
+#define   CGEM_WOL_MAGIC_PKT_EN			(1 << 16)
+#define   CGEM_WOL_ARP_REQ_IP_ADDR_MASK		0xffff
+
+#define CGEM_IPG_STRETCH		/* IPG Stretch Register */
+
+#define CGEM_STACKED_VLAN		0x0C0	/* Stacked VLAN Register */
+#define   CGEM_STACKED_VLAN_EN			(1U << 31)
+
+#define CGEM_TX_PFC_PAUSE		0x0C4	/* Transmit PFC Pause Reg */
+#define   CGEM_TX_PFC_PAUSEQ_SEL_SHIFT		8
+#define   CGEM_TX_PFC_PAUSEQ_SEL_MASK		(0xff << 8)
+#define   CGEM_TX_PFC_PAUSE_PRI_EN_VEC_VAL_MASK 0xff
+
+#define CGEM_SPEC_ADDR1_MASK_BOT	0x0C8	/* Specific Addr Mask1 [31:0]*/
+#define CGEM_SPEC_ADDR1_MASK_TOP	0x0CC	/* Specific Addr Mask1[47:32]*/
+#define CGEM_MODULE_ID			0x0FC	/* Module ID */
+#define CGEM_OCTETS_TX_BOT		0x100	/* Octets xmitted [31:0] */
+#define CGEM_OCTETS_TX_TOP		0x104	/* Octets xmitted [47:32] */
+#define CGEM_FRAMES_TX			0x108	/* Frames xmitted */
+#define CGEM_BCAST_FRAMES_TX		0x10C	/* Broadcast Frames xmitted */
+#define CGEM_MULTI_FRAMES_TX		0x110	/* Multicast Frames xmitted */
+#define CGEM_PAUSE_FRAMES_TX		0x114	/* Pause Frames xmitted */
+#define CGEM_FRAMES_64B_TX		0x118	/* 64-Byte Frames xmitted */
+#define CGEM_FRAMES_65_127B_TX		0x11C	/* 65-127 Byte Frames xmitted*/
+#define CGEM_FRAMES_128_255B_TX		0x120	/* 128-255 Byte Frames xmit */
+#define CGEM_FRAMES_256_511B_TX		0x124	/* 256-511 Byte Frames xmit */
+#define CGEM_FRAMES_512_1023B_TX	0x128	/* 512-1023 Byte frames xmit */
+#define CGEM_FRAMES_1024_1518B_TX	0x12C	/* 1024-1518 Byte frames xmit*/
+#define CGEM_TX_UNDERRUNS		0x134	/* Transmit Under-runs */
+#define CGEM_SINGLE_COLL_FRAMES		0x138	/* Single-Collision Frames */
+#define CGEM_MULTI_COLL_FRAMES		0x13C	/* Multi-Collision Frames */
+#define CGEM_EXCESSIVE_COLL_FRAMES	0x140	/* Excessive Collision Frames*/
+#define CGEM_LATE_COLL			0x144	/* Late Collisions */
+#define CGEM_DEFERRED_TX_FRAMES		0x148	/* Deferred Transmit Frames */
+#define CGEM_CARRIER_SENSE_ERRS		0x14C	/* Carrier Sense Errors */
+#define CGEM_OCTETS_RX_BOT		0x150	/* Octets Received [31:0] */
+#define CGEM_OCTETS_RX_TOP		0x154	/* Octets Received [47:32] */
+#define CGEM_FRAMES_RX			0x158	/* Frames Received */
+#define CGEM_BCAST_FRAMES_RX		0x15C	/* Broadcast Frames Received */
+#define CGEM_MULTI_FRAMES_RX		0x160	/* Multicast Frames Received */
+#define CGEM_PAUSE_FRAMES_RX		0x164	/* Pause Frames Reeived */
+#define CGEM_FRAMES_64B_RX		0x168	/* 64-Byte Frames Received */
+#define CGEM_FRAMES_65_127B_RX		0x16C	/* 65-127 Byte Frames Rx'd */
+#define CGEM_FRAMES_128_255B_RX		0x170	/* 128-255 Byte Frames Rx'd */
+#define CGEM_FRAMES_256_511B_RX		0x174	/* 256-511 Byte Frames Rx'd */
+#define CGEM_FRAMES_512_1023B_RX	0x178	/* 512-1023 Byte Frames Rx'd */
+#define CGEM_FRAMES_1024_1518B_RX	0x17C	/* 1024-1518 Byte Frames Rx'd*/
+#define CGEM_UNDERSZ_RX			0x184	/* Undersize Frames Rx'd */
+#define CGEM_OVERSZ_RX			0x188	/* Oversize Frames Rx'd */
+#define CGEM_JABBERS_RX			0x18C	/* Jabbers received */
+#define CGEM_FCS_ERRS			0x190	/* Frame Check Sequence Errs */
+#define CGEM_LENGTH_FIELD_ERRS		0x194	/* Length Firled Frame Errs */
+#define CGEM_RX_SYMBOL_ERRS		0x198	/* Receive Symbol Errs */
+#define CGEM_ALIGN_ERRS			0x19C	/* Alignment Errors */
+#define CGEM_RX_RESOURCE_ERRS		0x1A0	/* Receive Resoure Errors */
+#define CGEM_RX_OVERRUN_ERRS		0x1A4	/* Receive Overrun Errors */
+#define CGEM_IP_HDR_CKSUM_ERRS		0x1A8	/* IP Hdr Checksum Errors */
+#define CGEM_TCP_CKSUM_ERRS		0x1AC	/* TCP Checksum Errors */
+#define CGEM_UDP_CKSUM_ERRS		0x1B0	/* UDP Checksum Errors */
+#define CGEM_TIMER_STROBE_S		0x1C8	/* 1588 timer sync strobe s */
+#define CGEM_TIMER_STROBE_NS		0x1CC	/* timer sync strobe ns */
+#define CGEM_TIMER_S			0x1D0	/* 1588 timer seconds */
+#define CGEM_TIMER_NS			0x1D4	/* 1588 timer ns */
+#define CGEM_ADJUST			0x1D8	/* 1588 timer adjust */
+#define CGEM_INCR			0x1DC	/* 1588 timer increment */
+#define CGEM_PTP_TX_S			0x1E0	/* PTP Event Frame xmit secs */
+#define CGEM_PTP_TX_NS			0x1E4	/* PTP Event Frame xmit ns */
+#define CGEM_PTP_RX_S			0x1E8	/* PTP Event Frame rcv'd s */
+#define CGEM_PTP_RX_NS			0x1EC	/* PTP Event Frame rcv'd ns */
+#define CGEM_PTP_PEER_TX_S		0x1F0	/* PTP Peer Event xmit s */
+#define CGEM_PTP_PEER_TX_NS		0x1F4	/* PTP Peer Event xmit ns */
+#define CGEM_PTP_PEER_RX_S		0x1F8	/* PTP Peer Event rcv'd s */
+#define CGEM_PTP_PEER_RX_NS		0x1FC	/* PTP Peer Event rcv'd ns */
+
+#define CGEM_DESIGN_CFG1		0x280	/* Design Configuration 1 */
+#define   CGEM_DESIGN_CFG1_AXI_CACHE_WIDTH_MASK	(0xfU << 28)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_MASK	(7 << 25)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_32	(1 << 25)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_64	(2 << 25)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_128	(4 << 25)
+#define   CGEM_DESIGN_CFG1_IRQ_READ_CLR		(1 << 23)
+#define   CGEM_DESIGN_CFG1_NO_SNAPSHOT		(1 << 22)
+#define   CGEM_DESIGN_CFG1_NO_STATS		(1 << 21)
+#define   CGEM_DESIGN_CFG1_NO_SCAN_PINS		(1 << 20)
+#define   CGEM_DESIGN_CFG1_USER_IN_WIDTH_MASK	(0x1f << 15)
+#define   CGEM_DESIGN_CFG1_USER_OUT_WIDTH_MASK	(0x1f << 10)
+#define   CGEM_DESIGN_CFG1_USER_IO		(1 << 9)
+#define   CGEM_DESIGN_CFG1_APB_REV2		(1 << 8)
+#define   CGEM_DESIGN_CFG1_APB_REV1		(1 << 7)
+#define   CGEM_DESIGN_CFG1_EXT_FIFO_INTERFACE	(1 << 6)
+#define   CGEM_DESIGN_CFG1_NO_INT_LOOPBACK	(1 << 5)
+#define   CGEM_DESIGN_CFG1_INT_LOOPBACK		(1 << 4)
+#define   CGEM_DESIGN_CFG1_TDC_50		(1 << 3)
+#define   CGEM_DESIGN_CFG1_RDC_50		(1 << 2)
+#define   CGEM_DESIGN_CFG1_SERDES		(1 << 1)
+#define   CGEM_DESIGN_CFG1_NO_PCS		(1 << 0)
+
+#define CGEM_DESIGN_CFG2		0x284	/* Design Configuration 2 */
+#define   CGEM_DESIGN_CFG2_TX_PBUF_ADDR_SHIFT	26
+#define   CGEM_DESIGN_CFG2_TX_PBUF_ADDR_MASK	(0xf << 26)
+#define   CGEM_DESIGN_CFG2_RX_PBUF_ADDR_SHIFT	22
+#define   CGEM_DESIGN_CFG2_RX_PBUF_ADDR_MASK	(0xf << 22)
+#define   CGEM_DESIGN_CFG2_TX_PKT_BUF		(1 << 21)
+#define   CGEM_DESIGN_CFG2_RX_PKT_BUF		(1 << 20)
+#define   CGEM_DESIGN_CFG2_HPROT_VAL_SHIFT	16
+#define   CGEM_DESIGN_CFG2_HPROT_VAL_MASK	(0xf << 16)
+#define   CGEM_DESIGN_CFG2_JUMBO_MAX_LEN_MASK	0xffff
+
+#define CGEM_DESIGN_CFG3		0x288	/* Design Configuration 3 */
+#define   CGEM_DESIGN_CFG3_RX_BASE2_FIFO_SZ_MASK (0xffffU << 16)
+#define   CGEM_DESIGN_CFG3_RX_BASE2_FIFO_SZ_SHIFT 16
+#define   CGEM_DESIGN_CFG3_RX_FIFO_SIZE_MASK	0xffff
+
+#define CGEM_DESIGN_CFG4		0x28C	/* Design Configuration 4 */
+#define   CGEM_DESIGN_CFG4_TX_BASE2_FIFO_SZ_SHIFT 16
+#define   CGEM_DESIGN_CFG4_TX_BASE2_FIFO_SZ_MASK (0xffffU << 16)
+#define   CGEM_DESIGN_CFG4_TX_FIFO_SIZE_MASK	0xffff
+
+#define CGEM_DESIGN_CFG5		0x290	/* Design Configuration 5 */
+#define   CGEM_DESIGN_CFG5_TSU_CLK		(1 << 28)
+#define   CGEM_DESIGN_CFG5_RX_BUF_LEN_DEF_SHIFT 20
+#define   CGEM_DESIGN_CFG5_RX_BUF_LEN_DEF_MASK	(0xff << 20)
+#define   CGEM_DESIGN_CFG5_TX_PBUF_SIZE_DEF	(1 << 19)
+#define   CGEM_DESIGN_CFG5_RX_PBUF_SIZE_DEF_SHIFT 17
+#define   CGEM_DESIGN_CFG5_RX_PBUF_SIZE_DEF_MASK (3 << 17)
+#define   CGEM_DESIGN_CFG5_ENDIAN_SWAP_DEF_SHIFT 15
+#define   CGEM_DESIGN_CFG5_ENDIAN_SWAP_DEF_MASK (3 << 15)
+#define   CGEM_DESIGN_CFG5_MDC_CLOCK_DIV_SHIFT	12
+#define   CGEM_DESIGN_CFG5_MDC_CLOCK_DIV_MASK	(7 << 12)
+#define   CGEM_DESIGN_CFG5_DMA_BUS_WIDTH_SHIFT	10
+#define   CGEM_DESIGN_CFG5_DMA_BUS_WIDTH_MASK	(3 << 10)
+#define   CGEM_DESIGN_CFG5_PHY_IDENT		(1 << 9)
+#define   CGEM_DESIGN_CFG5_TSU			(1 << 8)
+#define   CGEM_DESIGN_CFG5_TX_FIFO_CNT_WIDTH_SHIFT 4
+#define   CGEM_DESIGN_CFG5_TX_FIFO_CNT_WIDTH_MASK (0xf << 4)
+#define   CGEM_DESIGN_CFG5_RX_FIFO_CNT_WIDTH_MASK 0xf
+
+#define CGEM_DESIGN_CFG6		0x294	/* Design Configuration 6 */
+#define   CGEM_DESIGN_CFG6_ADDR_64B		(1 << 23) /* 64-bit addr cap */
+#define   CGEM_DESIGN_CFG6_DMA_PRIO_Q_MASK	0xfffe
+#define   CGEM_DESIGN_CFG6_DMA_PRIO_Q(n)	(1 << (n))
+
+#define CGEM_TX_QN_BAR(n)		(0x440 + ((n) - 1) * 4)
+#define CGEM_RX_QN_BAR(n)		(0x480 + ((n) - 1) * 4)
+
+#define CGEM_TX_QBAR_HI			0x4C8
+#define CGEM_RX_QBAR_HI			0x4D4
+
+/*
+ * Transmit Descriptors:  two or four 32-bit words:
+ *	word0: address
+ *	word1: length and control
+ *	word2: address upper 32-bits (64-bit mode)
+ *	word3: unused (64-bit mode)
+ */
+
+struct cgem_tx_desc {
+	uint32_t	addr;
+	uint32_t	ctl;
+#define CGEM_TXDESC_USED			(1U << 31) /* done txmitting */
+#define CGEM_TXDESC_WRAP			(1 << 30)  /* end descr ring */
+#define CGEM_TXDESC_RETRY_ERR			(1 << 29)
+#define CGEM_TXDESC_AHB_ERR			(1 << 27)
+#define CGEM_TXDESC_LATE_COLL			(1 << 26)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_MASK		(7 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_VLAN_HDR_ERR (1 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_SNAP_HDR_ERR (2 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_IP_HDR_ERR	(3 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_UNKNOWN_TYPE (4 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_UNSUPP_FRAG	(5 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_NOT_TCPUDP	(6 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_SHORT_PKT	(7 << 20)
+#define CGEM_TXDESC_NO_CRC_APPENDED		(1 << 16)
+#define CGEM_TXDESC_LAST_BUF			(1 << 15)  /* last in frame */
+#define CGEM_TXDESC_LENGTH_MASK		0x3fff
+#ifdef CGEM64
+	uint32_t	addrhi;
+	uint32_t	unused;
+#endif
+};
+
+/*
+ * Receive Descriptors: two or four 32-bit words:
+ *	word0: address | WRAP and OWN flags
+ *	word1: length and control
+ *	word2: address upper 32 bits (64-bit mode)
+ *	word3: unused
+ */
+
+struct cgem_rx_desc {
+	uint32_t	addr;
+#define CGEM_RXDESC_WRAP			(1 << 1)  /* goes in addr! */
+#define CGEM_RXDESC_OWN				(1 << 0)  /* buf filled */
+	uint32_t	ctl;
+#define CGEM_RXDESC_BCAST			(1U << 31)/* all 1's bcast */
+#define CGEM_RXDESC_MULTI_MATCH			(1 << 30) /* mutlicast match */
+#define CGEM_RXDESC_UNICAST_MATCH		(1 << 29)
+#define CGEM_RXDESC_EXTERNAL_MATCH		(1 << 28) /* ext addr match */
+#define CGEM_RXDESC_SPEC_MATCH_SHIFT		25
+#define CGEM_RXDESC_SPEC_MATCH_MASK		(3 << 25)
+#define CGEM_RXDESC_TYPE_ID_MATCH_SHIFT		22
+#define CGEM_RXDESC_TYPE_ID_MATCH_MASK		(3 << 22)
+#define CGEM_RXDESC_CKSUM_STAT_MASK		(3 << 22) /* same as above */
+#define CGEM_RXDESC_CKSUM_STAT_NONE		(0 << 22)
+#define CGEM_RXDESC_CKSUM_STAT_IP_GOOD		(1 << 22)
+#define CGEM_RXDESC_CKSUM_STAT_TCP_GOOD		(2 << 22) /* and ip good */
+#define CGEM_RXDESC_CKSUM_STAT_UDP_GOOD		(3 << 22) /* and ip good */
+#define CGEM_RXDESC_VLAN_DETECTED		(1 << 21)
+#define CGEM_RXDESC_PRIO_DETECTED		(1 << 20)
+#define CGEM_RXDESC_VLAN_PRIO_SHIFT		17
+#define CGEM_RXDESC_VLAN_PRIO_MASK		(7 << 17)
+#define CGEM_RXDESC_CFI				(1 << 16)
+#define CGEM_RXDESC_EOF				(1 << 15) /* end of frame */
+#define CGEM_RXDESC_SOF				(1 << 14) /* start of frame */
+#define CGEM_RXDESC_BAD_FCS			(1 << 13)
+#define CGEM_RXDESC_LENGTH_MASK			0x1fff
+#ifdef CGEM64
+	uint32_t	addrhi;
+	uint32_t	unused;
+#endif
+};
+
+#endif /* _IF_CGEM_HW_H_ */
diff --git a/src/add-ons/kernel/drivers/network/-cadence_gem/glue.c b/src/add-ons/kernel/drivers/network/-cadence_gem/glue.c
new file mode 100644
index 0000000000..77af2a6593
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/-cadence_gem/glue.c
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <sys/bus.h>
+
+
+HAIKU_FBSD_DRIVER_GLUE(cadence_cgem, cgem, simplebus);
+HAIKU_DRIVER_REQUIREMENTS(0);
+NO_HAIKU_FBSD_MII_DRIVER();
+NO_HAIKU_CHECK_DISABLE_INTERRUPTS();
+NO_HAIKU_REENABLE_INTERRUPTS();
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/Jamfile b/src/add-ons/kernel/drivers/network/cadence_gem/Jamfile
new file mode 100644
index 0000000000..d7a3634c32
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/Jamfile
@@ -0,0 +1,41 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network cadence_gem ;
+
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_iflib compat ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+UsePrivateHeaders net system ;
+UsePrivateKernelHeaders ;
+
+UseHeaders [ FDirName $(SUBDIR) ] : true ;
+
+SEARCH_SOURCE += [ FDirName $(SUBDIR) dev cadence ] ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 _XOPEN_SOURCE ] ;
+
+KernelAddon cadence_gem :
+	cadence_gem0.cpp
+	
+#	if_cgem.c
+	
+#	glue.c
+	
+#	if.c
+#	malloc.cpp
+#	mutex.c
+#	mbuf.c
+#	fbsd_kern_mbuf.c
+#	device.c
+#	mii.c
+#	fbsd_mii.c
+#	bus_dma.cpp
+#	fbsd_uipc_mbuf.c
+#	fbsd_uipc_mbuf2.c
+#	bus_fdt.cpp
+#	fbsd_if_media.c
+#	ofw.cpp
+#	ofw_bus_if.c
+#	taskqueue.c
+#	callout.cpp
+#	clock.c
+#	libkern.cpp
+#	kobj.c
+;
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/bus_dma.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/bus_dma.cpp
new file mode 100644
index 0000000000..29f087e19f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/bus_dma.cpp
@@ -0,0 +1,388 @@
+/*
+ * Copyright 2019, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Augustin Cavalier <waddlesplash>
+ */
+
+extern "C" {
+#include <sys/malloc.h>
+#include <sys/bus.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/mbuf.h>
+
+#include <machine/bus.h>
+}
+
+
+// #pragma mark - structures
+
+
+struct bus_dma_tag {
+	bus_dma_tag_t	parent;
+	phys_size_t		alignment;
+	phys_addr_t		boundary;
+	phys_addr_t		lowaddr;
+	phys_addr_t		highaddr;
+	bus_dma_filter_t* filter;
+	void*			filterarg;
+	phys_size_t		maxsize;
+	uint32			maxsegments;
+	bus_dma_segment_t* segments;
+	phys_size_t		maxsegsz;
+	int32			ref_count;
+};
+
+
+// #pragma mark - functions
+
+
+void
+busdma_lock_mutex(void* arg, bus_dma_lock_op_t op)
+{
+	struct mtx* dmtx = (struct mtx*)arg;
+	switch (op) {
+	case BUS_DMA_LOCK:
+		mtx_lock(dmtx);
+	break;
+	case BUS_DMA_UNLOCK:
+		mtx_unlock(dmtx);
+	break;
+	default:
+		panic("busdma_lock_mutex: unknown operation 0x%x", op);
+	}
+}
+
+
+int
+bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, bus_size_t boundary,
+	bus_addr_t lowaddr, bus_addr_t highaddr, bus_dma_filter_t* filter,
+	void* filterarg, bus_size_t maxsize, int nsegments, bus_size_t maxsegsz,
+	int flags, bus_dma_lock_t* lockfunc, void* lockfuncarg, bus_dma_tag_t* dmat)
+{
+	if (boundary != 0 && boundary < maxsegsz)
+		maxsegsz = boundary;
+
+	*dmat = NULL;
+
+	bus_dma_tag_t newtag = (bus_dma_tag_t)kernel_malloc(sizeof(*newtag),
+		M_DEVBUF, M_ZERO | M_NOWAIT);
+	if (newtag == NULL)
+		return ENOMEM;
+
+	newtag->parent = parent;
+	newtag->alignment = alignment;
+	newtag->boundary = boundary;
+	newtag->lowaddr = lowaddr;
+	newtag->highaddr = highaddr;
+	newtag->filter = filter;
+	newtag->filterarg = filterarg;
+	newtag->maxsize = maxsize;
+	newtag->maxsegments = nsegments;
+	newtag->maxsegsz = maxsegsz;
+	newtag->ref_count = 1;
+
+	if (newtag->parent != NULL) {
+		atomic_add(&parent->ref_count, 1);
+
+		newtag->lowaddr = max_c(parent->lowaddr, newtag->lowaddr);
+		newtag->highaddr = min_c(parent->highaddr, newtag->highaddr);
+
+		if (newtag->boundary == 0) {
+			newtag->boundary = parent->boundary;
+		} else if (parent->boundary != 0) {
+			newtag->boundary = min_c(parent->boundary, newtag->boundary);
+		}
+
+		if (newtag->filter == NULL) {
+			newtag->filter = parent->filter;
+			newtag->filterarg = parent->filterarg;
+		}
+	}
+
+	if (newtag->filter != NULL)
+		panic("bus_dma_tag_create: error: filters not implemented!");
+
+	*dmat = newtag;
+	return 0;
+}
+
+
+int
+bus_dma_tag_destroy(bus_dma_tag_t dmat)
+{
+	if (dmat == NULL)
+		return 0;
+
+	while (dmat != NULL) {
+		bus_dma_tag_t parent;
+
+		parent = dmat->parent;
+		atomic_add(&dmat->ref_count, -1);
+		if (dmat->ref_count == 0) {
+			kernel_free(dmat->segments, M_DEVBUF);
+			kernel_free(dmat, M_DEVBUF);
+
+			// Last reference released, so release our reference on our parent.
+			dmat = parent;
+		} else
+			dmat = NULL;
+	}
+	return 0;
+}
+
+
+int
+bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t* mapp)
+{
+	// We never bounce, so we do not need maps.
+	*mapp = NULL;
+	return 0;
+}
+
+
+int
+bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	// We never create maps, so we never need to destroy them.
+	if (map)
+		panic("map is not NULL!");
+	return 0;
+}
+
+
+int
+bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags,
+	bus_dmamap_t* mapp)
+{
+	int mflags;
+	if (flags & BUS_DMA_NOWAIT)
+		mflags = M_NOWAIT;
+	else
+		mflags = M_WAITOK;
+
+	if (flags & BUS_DMA_ZERO)
+		mflags |= M_ZERO;
+
+	// We never need to map/bounce.
+	*mapp = NULL;
+
+	// FreeBSD uses standard malloc() for the case where maxsize <= PAGE_SIZE,
+	// however, our malloc() has no guarantees that the allocated memory will
+	// not be swapped out, which obviously is a requirement here. So we must
+	// always use kernel_contigmalloc().
+
+	// The range specified by lowaddr, highaddr is an *exclusion* range,
+	// not an inclusion range. So we want to at least start with the low end,
+	// if possible. (The most common exclusion range is 32-bit only,
+	// and ones other than that are very rare, so typically this will
+	// succeed.)
+	if (dmat->lowaddr > B_PAGE_SIZE) {
+		*vaddr = kernel_contigmalloc(dmat->maxsize, M_DEVBUF, mflags,
+			0, dmat->lowaddr,
+			dmat->alignment ? dmat->alignment : 1ul, dmat->boundary);
+		if (*vaddr == NULL)
+			dprintf("bus_dmamem_alloc: failed to allocate with lowaddr "
+				"0x%" B_PRIxPHYSADDR "\n", dmat->lowaddr);
+	}
+	if (*vaddr == NULL && dmat->highaddr < BUS_SPACE_MAXADDR) {
+		*vaddr = kernel_contigmalloc(dmat->maxsize, M_DEVBUF, mflags,
+			dmat->highaddr, BUS_SPACE_MAXADDR,
+			dmat->alignment ? dmat->alignment : 1ul, dmat->boundary);
+	}
+
+	if (*vaddr == NULL) {
+		dprintf("bus_dmamem_alloc: failed to allocate for tag (size %d, "
+			"low 0x%" B_PRIxPHYSADDR ", high 0x%" B_PRIxPHYSADDR ", "
+		    "boundary 0x%" B_PRIxPHYSADDR ")\n",
+			(int)dmat->maxsize, dmat->lowaddr, dmat->highaddr, dmat->boundary);
+		return ENOMEM;
+	} else if (vtophys(*vaddr) & (dmat->alignment - 1)) {
+		dprintf("bus_dmamem_alloc: failed to align memory: wanted %#x, got %#x\n",
+			dmat->alignment, vtophys(vaddr));
+		bus_dmamem_free(dmat, *vaddr, *mapp);
+		return ENOMEM;
+	}
+	return 0;
+}
+
+
+void
+bus_dmamem_free(bus_dma_tag_t dmat, void* vaddr, bus_dmamap_t map)
+{
+	// We never bounce, so map should be NULL.
+	if (map != NULL)
+		panic("bus_dmamem_free: map is not NULL!");
+
+	kernel_contigfree(vaddr, dmat->maxsize, M_DEVBUF);
+}
+
+
+static int
+_bus_dmamap_load_buffer(bus_dma_tag_t dmat, bus_dmamap_t /* map */, void* buf,
+	bus_size_t buflen, int flags, bus_addr_t* lastaddrp, bus_dma_segment_t* segs,
+	int& seg, bool first)
+{
+	vm_offset_t virtual_addr = (vm_offset_t)buf;
+	bus_addr_t last_phys_addr = *lastaddrp;
+	const bus_addr_t boundary_mask = ~(dmat->boundary - 1);
+
+	while (buflen > 0) {
+		const bus_addr_t phys_addr = pmap_kextract(virtual_addr);
+
+		bus_size_t segment_size = B_PAGE_SIZE - (phys_addr & (B_PAGE_SIZE - 1));
+		if (segment_size > buflen)
+			segment_size = buflen;
+
+		if (dmat->boundary > 0) {
+			// Make sure we don't cross a boundary.
+			bus_addr_t boundary_addr = (phys_addr + dmat->boundary) & boundary_mask;
+			if (segment_size > (boundary_addr - phys_addr))
+				segment_size = (boundary_addr - phys_addr);
+		}
+
+		// Insert chunk into a segment.
+		if (first) {
+			segs[seg].ds_addr = phys_addr;
+			segs[seg].ds_len = segment_size;
+			first = false;
+		} else {
+			// If possible, coalesce into the previous segment.
+			if (phys_addr == last_phys_addr
+			        && (segs[seg].ds_len + segment_size) <= dmat->maxsegsz
+					&& (dmat->boundary == 0
+						|| (segs[seg].ds_addr & boundary_mask)
+							== (phys_addr & boundary_mask))) {
+				segs[seg].ds_len += segment_size;
+			} else {
+				if (++seg >= dmat->maxsegments)
+					break;
+				segs[seg].ds_addr = phys_addr;
+				segs[seg].ds_len = segment_size;
+			}
+		}
+
+		last_phys_addr = phys_addr + segment_size;
+		virtual_addr += segment_size;
+		buflen -= segment_size;
+	}
+
+	*lastaddrp = last_phys_addr;
+	return (buflen != 0 ? EFBIG : 0);
+}
+
+
+int
+bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf,
+	bus_size_t buflen, bus_dmamap_callback_t *callback,
+	void *callback_arg, int flags)
+{
+	bus_addr_t lastaddr = 0;
+	int error, nsegs = 0;
+
+	if (dmat->segments == NULL) {
+		dmat->segments = (bus_dma_segment_t*)kernel_malloc(
+			sizeof(bus_dma_segment_t) * dmat->maxsegments, M_DEVBUF,
+			M_ZERO | M_NOWAIT);
+		if (dmat->segments == NULL)
+			return ENOMEM;
+	}
+
+	error = _bus_dmamap_load_buffer(dmat, map, buf, buflen, flags,
+		&lastaddr, dmat->segments, nsegs, true);
+
+	if (error)
+		(*callback)(callback_arg, dmat->segments, 0, error);
+	else
+		(*callback)(callback_arg, dmat->segments, nsegs + 1, 0);
+
+	// ENOMEM is returned; all other errors are only sent to the callback.
+	if (error == ENOMEM)
+		return error;
+	return 0;
+}
+
+
+int
+bus_dmamap_load_mbuf(bus_dma_tag_t dmat, bus_dmamap_t map, struct mbuf* mb,
+	bus_dmamap_callback2_t* callback, void* callback_arg, int flags)
+{
+	M_ASSERTPKTHDR(mb);
+
+	if (dmat->segments == NULL) {
+		dmat->segments = (bus_dma_segment_t*)kernel_malloc(
+			sizeof(bus_dma_segment_t) * dmat->maxsegments, M_DEVBUF,
+			M_ZERO | M_NOWAIT);
+		if (dmat->segments == NULL)
+			return ENOMEM;
+	}
+
+	int nsegs = 0, error = 0;
+	if (mb->m_pkthdr.len <= dmat->maxsize) {
+		bool first = true;
+		bus_addr_t lastaddr = 0;
+		for (struct mbuf* m = mb; m != NULL && error == 0; m = m->m_next) {
+			if (m->m_len <= 0)
+				continue;
+
+			error = _bus_dmamap_load_buffer(dmat, map, m->m_data, m->m_len,
+				flags, &lastaddr, dmat->segments, nsegs, first);
+			first = false;
+		}
+	} else {
+		error = EINVAL;
+	}
+
+	if (error) {
+		(*callback)(callback_arg, dmat->segments, 0, 0, error);
+	} else {
+		(*callback)(callback_arg, dmat->segments, nsegs + 1, mb->m_pkthdr.len,
+			error);
+	}
+	return error;
+}
+
+
+int
+bus_dmamap_load_mbuf_sg(bus_dma_tag_t dmat, bus_dmamap_t map, struct mbuf* mb,
+	bus_dma_segment_t* segs, int* nsegs, int flags)
+{
+	M_ASSERTPKTHDR(mb);
+
+	*nsegs = 0;
+	int error = 0;
+	if (mb->m_pkthdr.len <= dmat->maxsize) {
+		bool first = true;
+		bus_addr_t lastaddr = 0;
+
+		for (struct mbuf* m = mb; m != NULL && error == 0; m = m->m_next) {
+			if (m->m_len <= 0)
+				continue;
+
+			error = _bus_dmamap_load_buffer(dmat, map, m->m_data, m->m_len,
+				flags, &lastaddr, segs, *nsegs, first);
+			first = false;
+		}
+	} else {
+		error = EINVAL;
+	}
+
+	++*nsegs;
+	return error;
+}
+
+
+void
+_bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	// We never allocate bounce pages; nothing to do.
+}
+
+
+void
+_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t)
+{
+	// We never bounce; nothing to do.
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/bus_fdt.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/bus_fdt.cpp
new file mode 100644
index 0000000000..05e2f26452
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/bus_fdt.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+extern "C" {
+#include "device.h"
+}
+
+#include <stdlib.h>
+
+#include <algorithm>
+
+#include <arch/cpu.h>
+
+extern "C" {
+#include <compat/machine/resource.h>
+#include <compat/sys/mutex.h>
+#include <compat/machine/bus.h>
+#include <compat/sys/rman.h>
+#include <compat/sys/bus.h>
+}
+
+// private kernel header to get B_NO_HANDLED_INFO
+#include <int.h>
+
+
+struct resource *
+bus_alloc_resource(device_t dev, int type, int *rid, unsigned long start,
+	unsigned long end, unsigned long count, uint32 flags)
+{
+	panic("bus_alloc_resource: not implemented");
+	return NULL;
+}
+
+int
+bus_release_resource(device_t dev, int type, int rid, struct resource *res)
+{
+	panic("bus_release_resource: not implemented");
+
+	if (res->r_type != type)
+		panic("bus_release_resource: mismatch");
+
+	if (type == SYS_RES_MEMORY)
+		delete_area(res->r_mapped_area);
+
+	free(res);
+	return 0;
+}
+
+
+int
+rman_get_rid(struct resource *res)
+{
+	return 0;
+}
+
+
+//	#pragma mark - Interrupt handling
+
+
+int
+bus_setup_intr(device_t dev, struct resource *res, int flags,
+	driver_filter_t* filter, driver_intr_t handler, void *arg, void **_cookie)
+{
+	panic("bus_setup_intr: not implemented");
+	return -1;
+}
+
+
+int
+bus_teardown_intr(device_t dev, struct resource *res, void *arg)
+{
+	panic("bus_setup_intr: not bus_teardown_intr");
+
+	struct internal_intr *intr = (struct internal_intr *)arg;
+	if (intr == NULL)
+		return -1;
+
+	return 0;
+}
+
+
+//	#pragma mark - bus functions
+
+
+bus_dma_tag_t
+bus_get_dma_tag(device_t dev)
+{
+	return NULL;
+}
+
+
+void
+bus_generic_shutdown(device_t dev)
+{
+	UNIMPLEMENTED();
+}
+
+
+int
+bus_print_child_header(device_t dev, device_t child)
+{
+	UNIMPLEMENTED();
+	return B_ERROR;
+}
+
+
+int
+bus_print_child_footer(device_t dev, device_t child)
+{
+	UNIMPLEMENTED();
+	return B_ERROR;
+}
+
+
+void
+bus_enumerate_hinted_children(device_t bus)
+{
+#if 0
+	UNIMPLEMENTED();
+#endif
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem.cpp
new file mode 100644
index 0000000000..c32d000a13
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem.cpp
@@ -0,0 +1,579 @@
+/*
+ * Copyright 2013, 2018, Jrme Duval, jerome.duval@gmail.com.
+ * Copyright 2017, Philippe Houdoin, philippe.houdoin@gmail.com.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#define _KERNEL
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <net/if_media.h>
+#include <sys/sockio.h>
+#include <new>
+
+#include <drivers/bus/FDT.h>
+
+#include <lock.h>
+#include <util/DoublyLinkedList.h>
+#include <AutoDeleterDrivers.h>
+
+#include <ether_driver.h>
+
+extern "C" {
+#include <net/if.h>
+
+#include <compat/sys/bus.h>
+#include <compat/sys/mbuf.h>
+#include <compat/net/ethernet.h>
+#include <compat/net/if_media.h>
+#include <compat/net/if_var.h>
+}
+
+#include "device.h"
+
+
+#define CADENCE_GEM_DRIVER_MODULE_NAME "drivers/network/cadence_gem/driver_v1"
+#define CADENCE_GEM_DEVICE_MODULE_NAME "drivers/network/cadence_gem/device_v1"
+#define CADENCE_GEM_DEVICE_ID_GENERATOR	"cadence_gem/device_id"
+
+
+typedef struct {
+	device_node* node;
+	fdt_device_module_info* fdtModule;
+	fdt_device* fdtDev;
+	
+	struct ifnet* ifp;
+} cadence_gem_driver_info;
+
+
+typedef struct {
+	cadence_gem_driver_info* info;
+} cadence_gem_handle;
+
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <fs/devfs.h>
+
+
+#define TRACE_CADENCE_GEM
+#ifdef TRACE_CADENCE_GEM
+#	define TRACE(x...) dprintf("cadence_gem: " x)
+#else
+#	define TRACE(x...) ;
+#endif
+#define ERROR(x...)			dprintf("\33[33mcadence_gem:\33[0m " x)
+#define CALLED() 			TRACE("CALLED %s\n", __PRETTY_FUNCTION__)
+
+
+#define HWTYPE_GENERIC_GEM	1
+#define HWTYPE_ZYNQ		2
+#define HWTYPE_ZYNQMP		3
+#define HWTYPE_SIFIVE		4
+
+
+struct ofw_compat_data {
+	const char *compat;
+	uint32 info;
+};
+
+
+static struct ofw_compat_data compat_data[] = {
+	{ "cdns,zynq-gem",		HWTYPE_ZYNQ },
+	{ "cdns,zynqmp-gem",		HWTYPE_ZYNQMP },
+	{ "sifive,fu540-c000-gem",	HWTYPE_SIFIVE },
+	{ "sifive,fu740-c000-gem",	HWTYPE_SIFIVE },
+	{ "cdns,gem",			HWTYPE_GENERIC_GEM },
+	{ "cadence,gem",		HWTYPE_GENERIC_GEM },
+	{ NULL,				0 }
+};
+
+
+static device_manager_info* sDeviceManager;
+struct net_stack_module_info *gStack;
+
+struct ifnet* gDevices[MAX_DEVICES];
+int32 gDeviceCount = 0;
+
+
+const char*
+get_feature_name(uint32 feature)
+{
+	switch (feature) {
+		default:
+			;
+	}
+	return NULL;
+}
+
+
+//	#pragma mark - device module API
+
+
+static status_t
+cadence_gem_init_device(void* _info, void** _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_info;
+
+	DeviceNodePutter<&sDeviceManager> parent(sDeviceManager->get_parent_node(info->node));
+	sDeviceManager->get_driver(parent.Get(), (driver_module_info **)&info->fdtModule,
+		(void **)&info->fdtDev);
+
+	*_cookie = info;
+	return B_OK;
+}
+
+
+static void
+cadence_gem_uninit_device(void* _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_cookie;
+	(void)info;
+}
+
+
+static status_t
+cadence_gem_open(void* _info, const char* path, int openMode, void** _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_info;
+
+	ObjectDeleter<cadence_gem_handle> handle(new(std::nothrow) (cadence_gem_handle));
+	if (!handle.IsSet())
+		return B_NO_MEMORY;
+
+
+// ---
+	struct ifnet *ifp;
+	struct ifreq ifr;
+	int i;
+	status_t status;
+
+	for (i = 0; i < MAX_DEVICES; i++) {
+		if (gDevices[i] != NULL && !strcmp(gDevices[i]->device_name, path))
+			break;
+	}
+
+	if (i == MAX_DEVICES)
+		return B_ERROR;
+
+	if (get_module(NET_STACK_MODULE_NAME, (module_info **)&gStack) != B_OK)
+		return B_ERROR;
+
+	ifp = gDevices[i];
+	info->ifp = ifp;
+
+	if (atomic_or(&ifp->open_count, 1)) {
+		put_module(NET_STACK_MODULE_NAME);
+		return B_BUSY;
+	}
+
+	ifp->if_init(ifp->if_softc);
+
+	if (!HAIKU_DRIVER_REQUIRES(FBSD_WLAN_FEATURE)) {
+		ifp->if_flags &= ~IFF_UP;
+		ifp->if_ioctl(ifp, SIOCSIFFLAGS, NULL);
+
+		memset(&ifr, 0, sizeof(ifr));
+		ifr.ifr_media = IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, 0);
+		status = ifp->if_ioctl(ifp, SIOCSIFMEDIA, (caddr_t)&ifr);
+		if (status != B_OK) {
+			ifr.ifr_media = IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, 0);
+			status = ifp->if_ioctl(ifp, SIOCSIFMEDIA, (caddr_t)&ifr);
+		}
+	}
+
+	ifp->if_flags |= IFF_UP;
+	ifp->flags &= ~DEVICE_CLOSED;
+	ifp->if_ioctl(ifp, SIOCSIFFLAGS, NULL);
+// ---
+
+
+	handle->info = info;
+
+	*_cookie = handle.Detach();
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_close(void* cookie)
+{
+	CALLED();
+
+	cadence_gem_handle* handle = (cadence_gem_handle*)cookie;
+	struct ifnet *ifp = handle->info->ifp;
+
+	atomic_or(&ifp->flags, DEVICE_CLOSED);
+	//wlan_close(cookie);
+	release_sem_etc(ifp->receive_sem, 1, B_RELEASE_ALL);
+
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_free(void* cookie)
+{
+	CALLED();
+	ObjectDeleter<cadence_gem_handle> handle((cadence_gem_handle*)cookie);
+	struct ifnet *ifp = handle->info->ifp;
+
+	atomic_and(&ifp->open_count, 0);
+	put_module(NET_STACK_MODULE_NAME);
+
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_read(void* cookie, off_t position, void* buffer, size_t* numBytes)
+{
+	cadence_gem_handle* handle = (cadence_gem_handle*)cookie;
+	struct ifnet *ifp = handle->info->ifp;
+
+	uint32 semFlags = B_CAN_INTERRUPT;
+	status_t status;
+	struct mbuf *mb;
+	size_t length;
+
+	//if_printf(ifp, "compat_read(%lld, %p, [%lu])\n", position,
+	//	buffer, *numBytes);
+
+	if (ifp->flags & DEVICE_CLOSED)
+		return B_INTERRUPTED;
+
+	if (ifp->flags & DEVICE_NON_BLOCK)
+		semFlags |= B_RELATIVE_TIMEOUT;
+
+	do {
+		status = acquire_sem_etc(ifp->receive_sem, 1, semFlags, 0);
+		if (ifp->flags & DEVICE_CLOSED)
+			return B_INTERRUPTED;
+
+		if (status == B_WOULD_BLOCK) {
+			*numBytes = 0;
+			return B_OK;
+		} else if (status < B_OK)
+			return status;
+
+		IF_DEQUEUE(&ifp->receive_queue, mb);
+	} while (mb == NULL);
+
+	length = min_c(max_c((size_t)mb->m_pkthdr.len, 0), *numBytes);
+
+#if 0
+	mb = m_defrag(mb, 0);
+	if (mb == NULL) {
+		*numBytes = 0;
+		return B_NO_MEMORY;
+	}
+#endif
+
+	m_copydata(mb, 0, length, (caddr_t)buffer);
+	*numBytes = length;
+
+	m_freem(mb);
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_write(void* cookie, off_t position, const void* buffer,
+	size_t* numBytes)
+{
+	cadence_gem_handle* handle = (cadence_gem_handle*)cookie;
+	struct ifnet *ifp = handle->info->ifp;
+
+	struct mbuf *mb;
+
+	//if_printf(ifp, "compat_write(%lld, %p, [%lu])\n", position,
+	//	buffer, *numBytes);
+
+	if (*numBytes > MHLEN) {
+		mb = m_getcl(0, MT_DATA, M_PKTHDR);
+		*numBytes = min_c(*numBytes, (size_t)MCLBYTES);
+	} else {
+		mb = m_gethdr(0, MT_DATA);
+	}
+
+	if (mb == NULL)
+		return ENOBUFS;
+
+	// if we waited, check after if the ifp is still valid
+
+	mb->m_pkthdr.len = mb->m_len = *numBytes;
+	memcpy(mtod(mb, void *), buffer, mb->m_len);
+
+	return ifp->if_output(ifp, mb, NULL, NULL);
+}
+
+
+static status_t
+cadence_gem_ioctl(void* cookie, uint32 op, void* arg, size_t length)
+{
+	cadence_gem_handle* handle = (cadence_gem_handle*)cookie;
+	struct ifnet *ifp = handle->info->ifp;
+
+	//if_printf(ifp, "compat_control(op %lu, %p, [%lu])\n", op,
+	//	arg, length);
+
+	switch (op) {
+		case ETHER_INIT:
+			return B_OK;
+
+		case ETHER_GETADDR:
+			return user_memcpy(arg, IF_LLADDR(ifp), ETHER_ADDR_LEN);
+
+		case ETHER_NONBLOCK:
+		{
+			int32 value;
+			if (length < 4)
+				return B_BAD_VALUE;
+			if (user_memcpy(&value, arg, sizeof(int32)) < B_OK)
+				return B_BAD_ADDRESS;
+			if (value)
+				ifp->flags |= DEVICE_NON_BLOCK;
+			else
+				ifp->flags &= ~DEVICE_NON_BLOCK;
+			return B_OK;
+		}
+
+		case ETHER_SETPROMISC:
+		{
+			int32 value;
+			if (length < 4)
+				return B_BAD_VALUE;
+			if (user_memcpy(&value, arg, sizeof(int32)) < B_OK)
+				return B_BAD_ADDRESS;
+			if (value)
+				ifp->if_flags |= IFF_PROMISC;
+			else
+				ifp->if_flags &= ~IFF_PROMISC;
+			return ifp->if_ioctl(ifp, SIOCSIFFLAGS, NULL);
+		}
+
+		case ETHER_GETFRAMESIZE:
+		{
+			uint32 frameSize;
+			if (length < 4)
+				return B_BAD_VALUE;
+
+			frameSize = ifp->if_mtu + ETHER_HDR_LEN;
+			return user_memcpy(arg, &frameSize, 4);
+		}
+
+		case ETHER_ADDMULTI:
+		case ETHER_REMMULTI:
+		{
+			struct sockaddr_dl address;
+
+			if ((ifp->if_flags & IFF_MULTICAST) == 0)
+				return B_NOT_SUPPORTED;
+			if (length != ETHER_ADDR_LEN)
+				return B_BAD_VALUE;
+
+			memset(&address, 0, sizeof(address));
+			address.sdl_family = AF_LINK;
+			if (user_memcpy(LLADDR(&address), arg, ETHER_ADDR_LEN) < B_OK)
+				return B_BAD_ADDRESS;
+
+			if (op == ETHER_ADDMULTI)
+				return if_addmulti(ifp, (struct sockaddr *)&address, NULL);
+
+			return if_delmulti(ifp, (struct sockaddr *)&address);
+		}
+
+		case ETHER_GET_LINK_STATE:
+		{
+			struct ifmediareq mediareq;
+			ether_link_state_t state;
+			status_t status;
+
+			if (length < sizeof(ether_link_state_t))
+				return EINVAL;
+
+			memset(&mediareq, 0, sizeof(mediareq));
+			status = ifp->if_ioctl(ifp, SIOCGIFMEDIA, (caddr_t)&mediareq);
+			if (status < B_OK)
+				return status;
+
+			state.media = mediareq.ifm_active;
+			if ((mediareq.ifm_status & IFM_ACTIVE) != 0)
+				state.media |= IFM_ACTIVE;
+			state.speed = ifmedia_baudrate(mediareq.ifm_active);
+			state.quality = 1000;
+
+			return user_memcpy(arg, &state, sizeof(ether_link_state_t));
+		}
+
+		case ETHER_SET_LINK_STATE_SEM:
+			if (user_memcpy(&ifp->link_state_sem, arg, sizeof(sem_id)) < B_OK) {
+				ifp->link_state_sem = -1;
+				return B_BAD_ADDRESS;
+			}
+			return B_OK;
+	}
+
+	// return wlan_control(cookie, op, arg, length);
+	return B_DEV_INVALID_IOCTL;
+}
+
+
+//	#pragma mark - driver module API
+
+
+static float
+cadence_gem_supports_device(device_node* parent)
+{
+	const char* name;
+	const char* bus;
+	const char* compatible;
+
+	if (sDeviceManager->get_attr_string(parent, B_DEVICE_PRETTY_NAME, &name, false) >= B_OK)
+		dprintf("  name: %s\n", name);
+
+	if (
+		sDeviceManager->get_attr_string(parent, B_DEVICE_BUS, &bus, false) < B_OK ||
+		sDeviceManager->get_attr_string(parent, "fdt/compatible", &compatible, false) < B_OK
+	) {
+		return -1.0f;
+	}
+
+	if (strcmp(bus, "fdt") != 0)
+		return 0.0f;
+
+//	return 0.5f;
+	
+	for (size_t i = 0; compat_data[i].compat != NULL; i++) {
+		if (strcmp(compatible, compat_data[i].compat) != 0)
+			return 0.5f;
+	}
+
+	return 0.0f;
+}
+
+
+static status_t
+cadence_gem_register_device(device_node* node)
+{
+	CALLED();
+
+	device_attr attrs[] = {
+		{B_DEVICE_PRETTY_NAME, B_STRING_TYPE, {string: "Cadence GEM Network"}},
+		{}
+	};
+
+	return sDeviceManager->register_node(node, CADENCE_GEM_DRIVER_MODULE_NAME,
+		attrs, NULL, NULL);
+}
+
+
+static status_t
+cadence_gem_init_driver(device_node* node, void** cookie)
+{
+	CALLED();
+
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)malloc(
+		sizeof(cadence_gem_driver_info));
+	if (info == NULL)
+		return B_NO_MEMORY;
+
+	memset(info, 0, sizeof(*info));
+
+	info->node = node;
+
+	*cookie = info;
+	return B_OK;
+}
+
+
+static void
+cadence_gem_uninit_driver(void* _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_cookie;
+	free(info);
+}
+
+
+static status_t
+cadence_gem_register_child_devices(void* _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_cookie;
+	status_t status;
+
+	int32 id = sDeviceManager->create_id(CADENCE_GEM_DEVICE_ID_GENERATOR);
+	if (id < 0)
+		return id;
+
+	char name[64];
+	snprintf(name, sizeof(name), "net/cadence_gem/%" B_PRId32,
+		id);
+
+	status = sDeviceManager->publish_device(info->node, name,
+		CADENCE_GEM_DEVICE_MODULE_NAME);
+
+	return status;
+}
+
+
+//	#pragma mark -
+
+
+module_dependency module_dependencies[] = {
+	{B_DEVICE_MANAGER_MODULE_NAME, (module_info**)&sDeviceManager},
+	{}
+};
+
+struct device_module_info sVirtioNetDevice = {
+	{
+		CADENCE_GEM_DEVICE_MODULE_NAME,
+		0,
+		NULL
+	},
+
+	cadence_gem_init_device,
+	cadence_gem_uninit_device,
+	NULL, // remove,
+
+	cadence_gem_open,
+	cadence_gem_close,
+	cadence_gem_free,
+	cadence_gem_read,
+	cadence_gem_write,
+	NULL,	// io
+	cadence_gem_ioctl,
+
+	NULL,	// select
+	NULL,	// deselect
+};
+
+struct driver_module_info sVirtioNetDriver = {
+	{
+		CADENCE_GEM_DRIVER_MODULE_NAME,
+		0,
+		NULL
+	},
+
+	cadence_gem_supports_device,
+	cadence_gem_register_device,
+	cadence_gem_init_driver,
+	cadence_gem_uninit_driver,
+	cadence_gem_register_child_devices,
+	NULL,	// rescan
+	NULL,	// removed
+};
+
+module_info* modules[] = {
+	(module_info*)&sVirtioNetDriver,
+	(module_info*)&sVirtioNetDevice,
+	NULL
+};
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem0.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem0.cpp
new file mode 100644
index 0000000000..5513aac9ee
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/cadence_gem0.cpp
@@ -0,0 +1,331 @@
+/*
+ * Copyright 2013, 2018, Jrme Duval, jerome.duval@gmail.com.
+ * Copyright 2017, Philippe Houdoin, philippe.houdoin@gmail.com.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <stdint.h>
+#include <net/if_media.h>
+#include <new>
+
+#include <drivers/bus/FDT.h>
+
+#include <ethernet.h>
+#include <lock.h>
+#include <util/DoublyLinkedList.h>
+#include <AutoDeleterDrivers.h>
+
+#include "ether_driver.h"
+#define ETHER_ADDR_LEN	ETHER_ADDRESS_LENGTH
+
+
+#define CADENCE_GEM_DRIVER_MODULE_NAME "drivers/network/cadence_gem/driver_v1"
+#define CADENCE_GEM_DEVICE_MODULE_NAME "drivers/network/cadence_gem/device_v1"
+#define CADENCE_GEM_DEVICE_ID_GENERATOR	"cadence_gem/device_id"
+
+
+typedef struct {
+	device_node* node;
+	fdt_device_module_info* fdtModule;
+	fdt_device* fdtDev;
+} cadence_gem_driver_info;
+
+
+typedef struct {
+	cadence_gem_driver_info* info;
+} cadence_gem_handle;
+
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <fs/devfs.h>
+
+
+#define TRACE_CADENCE_GEM
+#ifdef TRACE_CADENCE_GEM
+#	define TRACE(x...) dprintf("cadence_gem: " x)
+#else
+#	define TRACE(x...) ;
+#endif
+#define ERROR(x...)			dprintf("\33[33mcadence_gem:\33[0m " x)
+#define CALLED() 			TRACE("CALLED %s\n", __PRETTY_FUNCTION__)
+
+
+#define HWTYPE_GENERIC_GEM	1
+#define HWTYPE_ZYNQ		2
+#define HWTYPE_ZYNQMP		3
+#define HWTYPE_SIFIVE		4
+
+
+struct ofw_compat_data {
+	const char *compat;
+	uint32 info;
+};
+
+
+static struct ofw_compat_data compat_data[] = {
+	{ "cdns,zynq-gem",		HWTYPE_ZYNQ },
+	{ "cdns,zynqmp-gem",		HWTYPE_ZYNQMP },
+	{ "sifive,fu540-c000-gem",	HWTYPE_SIFIVE },
+	{ "sifive,fu740-c000-gem",	HWTYPE_SIFIVE },
+	{ "cdns,gem",			HWTYPE_GENERIC_GEM },
+	{ "cadence,gem",		HWTYPE_GENERIC_GEM },
+	{ NULL,				0 }
+};
+
+
+static device_manager_info* sDeviceManager;
+
+
+const char*
+get_feature_name(uint32 feature)
+{
+	switch (feature) {
+		default:
+			;
+	}
+	return NULL;
+}
+
+
+//	#pragma mark - device module API
+
+
+static status_t
+cadence_gem_init_device(void* _info, void** _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_info;
+
+	DeviceNodePutter<&sDeviceManager> parent(sDeviceManager->get_parent_node(info->node));
+	sDeviceManager->get_driver(parent.Get(), (driver_module_info **)&info->fdtModule,
+		(void **)&info->fdtDev);
+
+	*_cookie = info;
+	return B_OK;
+}
+
+
+static void
+cadence_gem_uninit_device(void* _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_cookie;
+	(void)info;
+}
+
+
+static status_t
+cadence_gem_open(void* _info, const char* path, int openMode, void** _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_info;
+
+
+	ObjectDeleter<cadence_gem_handle> handle(new(std::nothrow) (cadence_gem_handle));
+	if (!handle.IsSet())
+		return B_NO_MEMORY;
+
+	handle->info = info;
+
+	*_cookie = handle.Detach();
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_close(void* cookie)
+{
+	CALLED();
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_free(void* cookie)
+{
+	CALLED();
+	ObjectDeleter<cadence_gem_handle> handle((cadence_gem_handle*)cookie);
+	return B_OK;
+}
+
+
+static status_t
+cadence_gem_read(void* cookie, off_t pos, void* buffer, size_t* _length)
+{
+	return B_ERROR;
+}
+
+
+static status_t
+cadence_gem_write(void* cookie, off_t pos, const void* buffer,
+	size_t* _length)
+{
+	*_length = 0;
+	return B_ERROR;
+}
+
+
+static status_t
+cadence_gem_ioctl(void* cookie, uint32 op, void* buffer, size_t length)
+{
+	return B_DEV_INVALID_IOCTL;
+}
+
+
+//	#pragma mark - driver module API
+
+
+static float
+cadence_gem_supports_device(device_node* parent)
+{
+	const char* name;
+	const char* bus;
+	const char* compatible;
+
+	if (sDeviceManager->get_attr_string(parent, B_DEVICE_PRETTY_NAME, &name, false) >= B_OK)
+		dprintf("  name: %s\n", name);
+
+	if (
+		sDeviceManager->get_attr_string(parent, B_DEVICE_BUS, &bus, false) < B_OK ||
+		sDeviceManager->get_attr_string(parent, "fdt/compatible", &compatible, false) < B_OK
+	) {
+		return -1.0f;
+	}
+
+	if (strcmp(bus, "fdt") != 0)
+		return 0.0f;
+
+//	return 0.5f;
+	
+	for (size_t i = 0; compat_data[i].compat != NULL; i++) {
+		if (strcmp(compatible, compat_data[i].compat) == 0) {
+			dprintf("  found: %s\n", compat_data[i].compat);
+			return 0.5f;
+		}
+	}
+
+	return 0.0f;
+}
+
+
+static status_t
+cadence_gem_register_device(device_node* node)
+{
+	CALLED();
+
+	device_attr attrs[] = {
+		{B_DEVICE_PRETTY_NAME, B_STRING_TYPE, {string: "Cadence GEM Network"}},
+		{}
+	};
+
+	return sDeviceManager->register_node(node, CADENCE_GEM_DRIVER_MODULE_NAME,
+		attrs, NULL, NULL);
+}
+
+
+static status_t
+cadence_gem_init_driver(device_node* node, void** cookie)
+{
+	CALLED();
+
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)malloc(
+		sizeof(cadence_gem_driver_info));
+	if (info == NULL)
+		return B_NO_MEMORY;
+
+	memset(info, 0, sizeof(*info));
+
+	info->node = node;
+
+	*cookie = info;
+	return B_OK;
+}
+
+
+static void
+cadence_gem_uninit_driver(void* _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_cookie;
+	free(info);
+}
+
+
+static status_t
+cadence_gem_register_child_devices(void* _cookie)
+{
+	CALLED();
+	cadence_gem_driver_info* info = (cadence_gem_driver_info*)_cookie;
+	status_t status;
+
+	int32 id = sDeviceManager->create_id(CADENCE_GEM_DEVICE_ID_GENERATOR);
+	if (id < 0)
+		return id;
+
+	char name[64];
+	snprintf(name, sizeof(name), "net/cadence_gem/%" B_PRId32,
+		id);
+
+	status = sDeviceManager->publish_device(info->node, name,
+		CADENCE_GEM_DEVICE_MODULE_NAME);
+
+	return status;
+}
+
+
+//	#pragma mark -
+
+
+module_dependency module_dependencies[] = {
+	{B_DEVICE_MANAGER_MODULE_NAME, (module_info**)&sDeviceManager},
+	{}
+};
+
+struct device_module_info sVirtioNetDevice = {
+	{
+		CADENCE_GEM_DEVICE_MODULE_NAME,
+		0,
+		NULL
+	},
+
+	cadence_gem_init_device,
+	cadence_gem_uninit_device,
+	NULL, // remove,
+
+	cadence_gem_open,
+	cadence_gem_close,
+	cadence_gem_free,
+	cadence_gem_read,
+	cadence_gem_write,
+	NULL,	// io
+	cadence_gem_ioctl,
+
+	NULL,	// select
+	NULL,	// deselect
+};
+
+struct driver_module_info sVirtioNetDriver = {
+	{
+		CADENCE_GEM_DRIVER_MODULE_NAME,
+		0,
+		NULL
+	},
+
+	cadence_gem_supports_device,
+	cadence_gem_register_device,
+	cadence_gem_init_driver,
+	cadence_gem_uninit_driver,
+	cadence_gem_register_child_devices,
+	NULL,	// rescan
+	NULL,	// removed
+};
+
+module_info* modules[] = {
+	(module_info*)&sVirtioNetDriver,
+	(module_info*)&sVirtioNetDevice,
+	NULL
+};
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/callout.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/callout.cpp
new file mode 100644
index 0000000000..53d613e35d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/callout.cpp
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2010, Axel Drfler, axeld@pinc-software.de.
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <lock.h>
+#include <thread.h>
+
+extern "C" {
+#	include "device.h"
+#	include <sys/callout.h>
+#	include <sys/mutex.h>
+}
+
+#include <util/AutoLock.h>
+
+
+//#define TRACE_CALLOUT
+#ifdef TRACE_CALLOUT
+#	define TRACE(x...) dprintf(x)
+#else
+#	define TRACE(x...) ;
+#endif
+
+
+static struct list sTimers;
+static mutex sLock;
+static sem_id sWaitSem;
+static callout* sCurrentCallout;
+static thread_id sThread;
+static bigtime_t sTimeout;
+
+
+static status_t
+callout_thread(void* /*data*/)
+{
+	status_t status = B_NO_INIT;
+
+	do {
+		bigtime_t timeout = B_INFINITE_TIMEOUT;
+
+		if (status == B_TIMED_OUT || status == B_OK) {
+			// scan timers for new timeout and/or execute a timer
+			if ((status = mutex_lock(&sLock)) != B_OK)
+				continue;
+
+			struct callout* c = NULL;
+			while (true) {
+				c = (callout*)list_get_next_item(&sTimers, c);
+				if (c == NULL)
+					break;
+
+				if (c->due < system_time()) {
+					struct mtx *mutex = c->c_mtx;
+
+					// execute timer
+					list_remove_item(&sTimers, c);
+					c->due = -1;
+					sCurrentCallout = c;
+
+					mutex_unlock(&sLock);
+
+					if (mutex != NULL)
+						mtx_lock(mutex);
+
+					c->c_func(c->c_arg);
+
+					if (mutex != NULL
+							&& (c->c_flags & CALLOUT_RETURNUNLOCKED) == 0)
+						mtx_unlock(mutex);
+
+					if ((status = mutex_lock(&sLock)) != B_OK)
+						continue;
+
+					sCurrentCallout = NULL;
+					c = NULL;
+						// restart scanning as we unlocked the list
+				} else {
+					// calculate new timeout
+					if (c->due < timeout)
+						timeout = c->due;
+				}
+			}
+
+			sTimeout = timeout;
+			mutex_unlock(&sLock);
+		}
+
+		status = acquire_sem_etc(sWaitSem, 1, B_ABSOLUTE_TIMEOUT, timeout);
+			// the wait sem normally can't be acquired, so we
+			// have to look at the status value the call returns:
+			//
+			// B_OK - a new timer has been added or canceled
+			// B_TIMED_OUT - look for timers to be executed
+			// B_BAD_SEM_ID - we are asked to quit
+	} while (status != B_BAD_SEM_ID);
+
+	return B_OK;
+}
+
+
+// #pragma mark - private API
+
+
+status_t
+init_callout(void)
+{
+	list_init(&sTimers);
+	sTimeout = B_INFINITE_TIMEOUT;
+
+	status_t status = B_OK;
+	mutex_init(&sLock, "fbsd callout");
+
+	sWaitSem = create_sem(0, "fbsd callout wait");
+	if (sWaitSem < 0) {
+		status = sWaitSem;
+		goto err1;
+	}
+
+	sThread = spawn_kernel_thread(callout_thread, "fbsd callout",
+		B_DISPLAY_PRIORITY, NULL);
+	if (sThread < 0) {
+		status = sThread;
+		goto err2;
+	}
+
+	return resume_thread(sThread);
+
+err2:
+	delete_sem(sWaitSem);
+err1:
+	mutex_destroy(&sLock);
+	return status;
+}
+
+
+void
+uninit_callout(void)
+{
+	delete_sem(sWaitSem);
+
+	wait_for_thread(sThread, NULL);
+
+	mutex_lock(&sLock);
+	mutex_destroy(&sLock);
+}
+
+
+// #pragma mark - public API
+
+
+void
+callout_init(struct callout *callout, int mpsafe)
+{
+	if (mpsafe)
+		callout_init_mtx(callout, NULL, 0);
+	else
+		callout_init_mtx(callout, &Giant, 0);
+}
+
+
+void
+callout_init_mtx(struct callout *c, struct mtx *mtx, int flags)
+{
+	c->due = 0;
+	c->flags = 0;
+
+	c->c_arg = NULL;
+	c->c_func = NULL;
+	c->c_mtx = mtx;
+	c->c_flags = flags;
+}
+
+
+int
+callout_reset(struct callout *c, int _ticks, void (*func)(void *), void *arg)
+{
+	int canceled = callout_stop(c);
+
+	MutexLocker locker(sLock);
+
+	c->c_func = func;
+	c->c_arg = arg;
+
+	TRACE("callout_reset %p, func %p, arg %p\n", c, c->c_func, c->c_arg);
+
+	if (ticks >= 0) {
+		// reschedule or add this timer
+		if (c->due <= 0)
+			list_add_item(&sTimers, c);
+
+		c->due = system_time() + TICKS_2_USEC(_ticks);
+
+		// notify timer about the change if necessary
+		if (sTimeout > c->due)
+			release_sem(sWaitSem);
+	}
+
+	return canceled;
+}
+
+
+int
+callout_schedule(struct callout *callout, int _ticks)
+{
+	return callout_reset(callout, _ticks, callout->c_func, callout->c_arg);
+}
+
+
+int
+_callout_stop_safe(struct callout *c, int safe)
+{
+	MutexLocker locker(sLock);
+
+	if (c == NULL) {
+		printf("_callout_stop_safe called with NULL callout\n");
+		return 0;
+	}
+
+	TRACE("_callout_stop_safe %p, func %p, arg %p\n", c, c->c_func, c->c_arg);
+
+	if (c->due <= 0)
+		return 0;
+
+	// this timer is scheduled, cancel it
+	list_remove_item(&sTimers, c);
+	c->due = 0;
+	return 1;
+}
+
+
+int
+callout_pending(struct callout *c)
+{
+	return c->due > 0;
+}
+
+
+int
+callout_active(struct callout *c)
+{
+	return c == sCurrentCallout;
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/clock.c b/src/add-ons/kernel/drivers/network/cadence_gem/clock.c
new file mode 100644
index 0000000000..29ae4107da
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/clock.c
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+#include <OS.h>
+#include <compat/sys/kernel.h>
+
+
+int32_t
+_get_ticks()
+{
+	return USEC_2_TICKS(system_time());
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/altq/if_altq.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/altq/if_altq.h
new file mode 100644
index 0000000000..ee9068a4e7
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/altq/if_altq.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_ALTQ_IF_ALTQ_H_
+#define _FBSD_COMPAT_ALTQ_IF_ALTQ_H_
+
+
+#include <sys/mbuf.h>
+#include <sys/mutex.h>
+
+
+struct ifaltq {
+	struct mbuf*	ifq_head;
+	struct mbuf*	ifq_tail;
+
+	int				ifq_len;
+	int				ifq_maxlen;
+	int				ifq_drops;
+	struct mtx		ifq_mtx;
+
+	struct mbuf*	ifq_drv_head;
+	struct mbuf*	ifq_drv_tail;
+	int				ifq_drv_len;
+	int				ifq_drv_maxlen;
+
+	int				altq_flags;
+};
+
+
+#define ALTQF_READY	0x1
+
+#define ALTDQ_REMOVE 1
+
+#define ALTQ_IS_ENABLED(ifq)	0
+#define ALTQ_ENQUEUE(ifr, m, foo, error) \
+	do { m_freem(m); error = -1; } while (0)
+#define ALTQ_DEQUEUE(ifr, m)	(m) = NULL
+#define ALTQ_PURGE(ifq)
+
+#define TBR_IS_ENABLED(ifq)		0
+#define tbr_dequeue_ptr(ifq, v)	NULL
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/led/led.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/led/led.h
new file mode 100644
index 0000000000..74a1029da1
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/led/led.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT license.
+ */
+#ifndef _FBSD_COMPAT_DEV_LED_LED_H_
+#define _FBSD_COMPAT_DEV_LED_LED_H_
+
+
+typedef	void led_t(void*, int);
+
+
+static inline struct cdev*
+led_create_state(led_t* func, void* priv, char const* name, int state)
+{
+	return NULL;
+}
+
+
+static inline struct cdev*
+led_create(led_t* func, void* priv, char const* name)
+{
+	return NULL;
+}
+
+
+static inline void
+led_destroy(struct cdev* dev)
+{
+}
+
+
+static inline int
+led_set(char const* name, char const* cmd)
+{
+	return -1;
+}
+
+
+#endif /* _FBSD_COMPAT_DEV_LED_LED_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii.h
new file mode 100644
index 0000000000..fa1ec84eaa
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii.h
@@ -0,0 +1,239 @@
+/*	$NetBSD: mii.h,v 1.18 2014/06/16 14:43:22 msaitoh Exp $	*/
+
+/*-
+ * Copyright (c) 1997 Manuel Bouyer.  All rights reserved.
+ *
+ * Modification to match BSD/OS 3.0 MII interface by Jason R. Thorpe,
+ * Numerical Aerospace Simulation Facility, NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _DEV_MII_MII_H_
+#define	_DEV_MII_MII_H_
+
+/*
+ * Registers common to all PHYs.
+ */
+
+#define	MII_NPHY	32	/* max # of PHYs per MII */
+
+/*
+ * MII commands, used if a device must drive the MII lines
+ * manually.
+ */
+#define	MII_COMMAND_START	0x01
+#define	MII_COMMAND_READ	0x02
+#define	MII_COMMAND_WRITE	0x01
+#define	MII_COMMAND_ACK		0x02
+
+#define	MII_BMCR	0x00	/* Basic mode control register (rw) */
+#define	BMCR_RESET	0x8000	/* reset */
+#define	BMCR_LOOP	0x4000	/* loopback */
+#define	BMCR_SPEED0	0x2000	/* speed selection (LSB) */
+#define	BMCR_AUTOEN	0x1000	/* autonegotiation enable */
+#define	BMCR_PDOWN	0x0800	/* power down */
+#define	BMCR_ISO	0x0400	/* isolate */
+#define	BMCR_STARTNEG	0x0200	/* restart autonegotiation */
+#define	BMCR_FDX	0x0100	/* Set duplex mode */
+#define	BMCR_CTEST	0x0080	/* collision test */
+#define	BMCR_SPEED1	0x0040	/* speed selection (MSB) */
+
+#define	BMCR_S10	0x0000		/* 10 Mb/s */
+#define	BMCR_S100	BMCR_SPEED0	/* 100 Mb/s */
+#define	BMCR_S1000	BMCR_SPEED1	/* 1000 Mb/s */
+
+#define	BMCR_SPEED(x)	((x) & (BMCR_SPEED0|BMCR_SPEED1))
+
+#define	MII_BMSR	0x01	/* Basic mode status register (ro) */
+#define	BMSR_100T4	0x8000	/* 100 base T4 capable */
+#define	BMSR_100TXFDX	0x4000	/* 100 base Tx full duplex capable */
+#define	BMSR_100TXHDX	0x2000	/* 100 base Tx half duplex capable */
+#define	BMSR_10TFDX	0x1000	/* 10 base T full duplex capable */
+#define	BMSR_10THDX	0x0800	/* 10 base T half duplex capable */
+#define	BMSR_100T2FDX	0x0400	/* 100 base T2 full duplex capable */
+#define	BMSR_100T2HDX	0x0200	/* 100 base T2 half duplex capable */
+#define	BMSR_EXTSTAT	0x0100	/* Extended status in register 15 */
+#define	BMSR_MFPS	0x0040	/* MII Frame Preamble Suppression */
+#define	BMSR_ACOMP	0x0020	/* Autonegotiation complete */
+#define	BMSR_RFAULT	0x0010	/* Link partner fault */
+#define	BMSR_ANEG	0x0008	/* Autonegotiation capable */
+#define	BMSR_LINK	0x0004	/* Link status */
+#define	BMSR_JABBER	0x0002	/* Jabber detected */
+#define	BMSR_EXTCAP	0x0001	/* Extended capability */
+
+#define	BMSR_DEFCAPMASK	0xffffffff
+
+/*
+ * Note that the EXTSTAT bit indicates that there is extended status
+ * info available in register 15, but 802.3 section 22.2.4.3 also
+ * states that all 1000 Mb/s capable PHYs will set this bit to 1.
+ */
+
+#define	BMSR_MEDIAMASK	(BMSR_100T4|BMSR_100TXFDX|BMSR_100TXHDX| \
+			 BMSR_10TFDX|BMSR_10THDX|BMSR_100T2FDX|BMSR_100T2HDX)
+
+/*
+ * Convert BMSR media capabilities to ANAR bits for autonegotiation.
+ * Note the shift chopps off the BMSR_ANEG bit.
+ */
+#define	BMSR_MEDIA_TO_ANAR(x)	(((x) & BMSR_MEDIAMASK) >> 6)
+
+#define	MII_PHYIDR1	0x02	/* ID register 1 (ro) */
+
+#define	MII_PHYIDR2	0x03	/* ID register 2 (ro) */
+#define	IDR2_OUILSB	0xfc00	/* OUI LSB */
+#define	IDR2_MODEL	0x03f0	/* vendor model */
+#define	IDR2_REV	0x000f	/* vendor revision */
+
+#define	MII_ANAR	0x04	/* Autonegotiation advertisement (rw) */
+		/* section 28.2.4.1 and 37.2.6.1 */
+#define ANAR_NP		0x8000	/* Next page (ro) */
+#define	ANAR_ACK	0x4000	/* link partner abilities acknowledged (ro) */
+#define ANAR_RF		0x2000	/* remote fault (ro) */
+		/* Annex 28B.2 */
+#define	ANAR_FC		0x0400	/* local device supports PAUSE */
+#define ANAR_T4		0x0200	/* local device supports 100bT4 */
+#define ANAR_TX_FD	0x0100	/* local device supports 100bTx FD */
+#define ANAR_TX		0x0080	/* local device supports 100bTx */
+#define ANAR_10_FD	0x0040	/* local device supports 10bT FD */
+#define ANAR_10		0x0020	/* local device supports 10bT */
+#define	ANAR_CSMA	0x0001	/* protocol selector CSMA/CD */
+#define	ANAR_PAUSE_NONE		(0 << 10)
+#define	ANAR_PAUSE_SYM		(1 << 10)
+#define	ANAR_PAUSE_ASYM		(2 << 10)
+#define	ANAR_PAUSE_TOWARDS	(3 << 10)
+
+		/* Annex 28D */
+#define	ANAR_X_FD	0x0020	/* local device supports 1000BASE-X FD */
+#define	ANAR_X_HD	0x0040	/* local device supports 1000BASE-X HD */
+#define	ANAR_X_PAUSE_NONE	(0 << 7)
+#define	ANAR_X_PAUSE_SYM	(1 << 7)
+#define	ANAR_X_PAUSE_ASYM	(2 << 7)
+#define	ANAR_X_PAUSE_TOWARDS	(3 << 7)
+
+#define	MII_ANLPAR	0x05	/* Autonegotiation lnk partner abilities (rw) */
+		/* section 28.2.4.1 and 37.2.6.1 */
+#define ANLPAR_NP	0x8000	/* Next page (ro) */
+#define	ANLPAR_ACK	0x4000	/* link partner accepted ACK (ro) */
+#define ANLPAR_RF	0x2000	/* remote fault (ro) */
+#define	ANLPAR_FC	0x0400	/* link partner supports PAUSE */
+#define ANLPAR_T4	0x0200	/* link partner supports 100bT4 */
+#define ANLPAR_TX_FD	0x0100	/* link partner supports 100bTx FD */
+#define ANLPAR_TX	0x0080	/* link partner supports 100bTx */
+#define ANLPAR_10_FD	0x0040	/* link partner supports 10bT FD */
+#define ANLPAR_10	0x0020	/* link partner supports 10bT */
+#define	ANLPAR_CSMA	0x0001	/* protocol selector CSMA/CD */
+#define	ANLPAR_PAUSE_MASK	(3 << 10)
+#define	ANLPAR_PAUSE_NONE	(0 << 10)
+#define	ANLPAR_PAUSE_SYM	(1 << 10)
+#define	ANLPAR_PAUSE_ASYM	(2 << 10)
+#define	ANLPAR_PAUSE_TOWARDS	(3 << 10)
+
+#define	ANLPAR_X_FD	0x0020	/* local device supports 1000BASE-X FD */
+#define	ANLPAR_X_HD	0x0040	/* local device supports 1000BASE-X HD */
+#define	ANLPAR_X_PAUSE_MASK	(3 << 7)
+#define	ANLPAR_X_PAUSE_NONE	(0 << 7)
+#define	ANLPAR_X_PAUSE_SYM	(1 << 7)
+#define	ANLPAR_X_PAUSE_ASYM	(2 << 7)
+#define	ANLPAR_X_PAUSE_TOWARDS	(3 << 7)
+
+#define	MII_ANER	0x06	/* Autonegotiation expansion (ro) */
+		/* section 28.2.4.1 and 37.2.6.1 */
+#define ANER_MLF	0x0010	/* multiple link detection fault */
+#define ANER_LPNP	0x0008	/* link parter next page-able */
+#define ANER_NP		0x0004	/* next page-able */
+#define ANER_PAGE_RX	0x0002	/* Page received */
+#define ANER_LPAN	0x0001	/* link parter autoneg-able */
+
+#define	MII_ANNP	0x07	/* Autonegotiation next page */
+		/* section 28.2.4.1 and 37.2.6.1 */
+
+#define	MII_ANLPRNP	0x08	/* Autonegotiation link partner rx next page */
+		/* section 32.5.1 and 37.2.6.1 */
+
+			/* This is also the 1000baseT control register */
+#define	MII_100T2CR	0x09	/* 100base-T2 control register */
+#define	GTCR_TEST_MASK	0xe000	/* see 802.3ab ss. 40.6.1.1.2 */
+#define	GTCR_MAN_MS	0x1000	/* enable manual master/slave control */
+#define	GTCR_ADV_MS	0x0800	/* 1 = adv. master, 0 = adv. slave */
+#define	GTCR_PORT_TYPE	0x0400	/* 1 = DCE, 0 = DTE (NIC) */
+#define	GTCR_ADV_1000TFDX 0x0200 /* adv. 1000baseT FDX */
+#define	GTCR_ADV_1000THDX 0x0100 /* adv. 1000baseT HDX */
+
+			/* This is also the 1000baseT status register */
+#define	MII_100T2SR	0x0a	/* 100base-T2 status register */
+#define	GTSR_MAN_MS_FLT	0x8000	/* master/slave config fault */
+#define	GTSR_MS_RES	0x4000	/* result: 1 = master, 0 = slave */
+#define	GTSR_LRS	0x2000	/* local rx status, 1 = ok */
+#define	GTSR_RRS	0x1000	/* remote rx status, 1 = ok */
+#define	GTSR_LP_1000TFDX 0x0800	/* link partner 1000baseT FDX capable */
+#define	GTSR_LP_1000THDX 0x0400	/* link partner 1000baseT HDX capable */
+#define	GTSR_LP_ASM_DIR	0x0200	/* link partner asym. pause dir. capable */
+#define	GTSR_IDLE_ERR	0x00ff	/* IDLE error count */
+
+#define	MII_PSECR	0x0b	/* PSE control register */
+#define	PSECR_PACTLMASK	0x000c	/* pair control mask */
+#define	PSECR_PSEENMASK	0x0003	/* PSE enable mask */
+#define	PSECR_PINOUTB	0x0008	/* PSE pinout Alternative B */
+#define	PSECR_PINOUTA	0x0004	/* PSE pinout Alternative A */
+#define	PSECR_FOPOWTST	0x0002	/* Force Power Test Mode */
+#define	PSECR_PSEEN	0x0001	/* PSE Enabled */
+#define	PSECR_PSEDIS	0x0000	/* PSE Disabled */
+
+#define	MII_PSESR	0x0c	/* PSE status register */
+#define	PSESR_PWRDENIED	0x1000	/* Power Denied */
+#define	PSESR_VALSIG	0x0800	/* Valid PD signature detected */
+#define	PSESR_INVALSIG	0x0400	/* Invalid PD signature detected */
+#define	PSESR_SHORTCIRC	0x0200	/* Short circuit condition detected */
+#define	PSESR_OVERLOAD	0x0100	/* Overload condition detected */
+#define	PSESR_MPSABSENT	0x0080	/* MPS absent condition detected */
+#define	PSESR_PDCLMASK	0x0070	/* PD Class mask */
+#define	PSESR_STATMASK	0x000e	/* PSE Status mask */
+#define	PSESR_PAIRCTABL	0x0001	/* PAIR Control Ability */
+#define	PSESR_PDCL_4		(4 << 4)	/* Class 4 */
+#define	PSESR_PDCL_3		(3 << 4)	/* Class 3 */
+#define	PSESR_PDCL_2		(2 << 4)	/* Class 2 */
+#define	PSESR_PDCL_1		(1 << 4)	/* Class 1 */
+#define	PSESR_PDCL_0		(0 << 4)	/* Class 0 */
+
+#define	MII_MMDACR	0x0d	/* MMD access control register */
+#define	MMDACR_FUNCMASK	0xc000	/* function */
+#define	MMDACR_DADDRMASK 0x001f	/* device address */
+#define	MMDACR_FN_ADDRESS	(0 << 14) /* address */
+#define	MMDACR_FN_DATANPI	(1 << 14) /* data, no post increment */
+#define	MMDACR_FN_DATAPIRW	(2 << 14) /* data, post increment on r/w */
+#define	MMDACR_FN_DATAPIW	(3 << 14) /* data, post increment on wr only */
+
+#define	MII_MMDAADR	0x0e	/* MMD access address data register */
+
+#define	MII_EXTSR	0x0f	/* Extended status register */
+#define	EXTSR_1000XFDX	0x8000	/* 1000X full-duplex capable */
+#define	EXTSR_1000XHDX	0x4000	/* 1000X half-duplex capable */
+#define	EXTSR_1000TFDX	0x2000	/* 1000T full-duplex capable */
+#define	EXTSR_1000THDX	0x1000	/* 1000T half-duplex capable */
+
+#define	EXTSR_MEDIAMASK	(EXTSR_1000XFDX|EXTSR_1000XHDX| \
+			 EXTSR_1000TFDX|EXTSR_1000THDX)
+
+#endif /* _DEV_MII_MII_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii_bitbang.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii_bitbang.h
new file mode 100644
index 0000000000..2bc7427625
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/mii_bitbang.h
@@ -0,0 +1,54 @@
+/*	$NetBSD: mii_bitbang.h,v 1.6 2009/05/12 14:31:27 cegger Exp $	*/
+
+/*-
+ * Copyright (c) 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#define	MII_BIT_MDO		0	/* data out (host->PHY) */
+#define	MII_BIT_MDI		1	/* data in (PHY->host) */
+#define	MII_BIT_MDC		2	/* clock */
+#define	MII_BIT_DIR_HOST_PHY	3	/* set direction: host->PHY */
+#define	MII_BIT_DIR_PHY_HOST	4	/* set direction: PHY->host */
+#define	MII_NBITS		5
+
+struct mii_bitbang_ops {
+	uint32_t	(*mbo_read)(device_t);
+	void		(*mbo_write)(device_t, uint32_t);
+	uint32_t	mbo_bits[MII_NBITS];
+};
+
+typedef	const struct mii_bitbang_ops *mii_bitbang_ops_t;
+
+int	mii_bitbang_readreg(device_t dev, mii_bitbang_ops_t ops,
+	    int phy, int reg);
+void	mii_bitbang_sync(device_t dev, mii_bitbang_ops_t ops);
+void	mii_bitbang_writereg(device_t dev, mii_bitbang_ops_t ops,
+	    int phy, int reg, int val);
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miidevs b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miidevs
new file mode 100644
index 0000000000..e011f9467d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miidevs
@@ -0,0 +1,350 @@
+$FreeBSD: stable/11/sys/dev/mii/miidevs 337755 2018-08-14 14:17:20Z markj $
+/*$NetBSD: miidevs,v 1.105 2011/11/25 23:28:14 jakllsch Exp $*/
+
+/*-
+ * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * List of known MII OUIs.
+ * For a complete list see http://standards.ieee.org/regauth/oui/
+ *
+ * XXX Vendors do obviously not agree how OUIs (24 bit) are mapped
+ * to the 22 bits available in the id registers.
+ * IEEE 802.3u-1995, subclause 22.2.4.3.1, figure 22-12, depicts the right
+ * mapping; the bit positions are defined in IEEE 802-1990, figure 5.2.
+ * (There is a formal 802.3 interpretation, number 1-07/98 of July 09 1998,
+ * about this.)
+ * The MII_OUI() macro in "mii.h" reflects this.
+ * If a vendor uses a different mapping, an "xx" prefixed OUI is defined here
+ * which is mangled accordingly to compensate.
+ */
+
+oui AGERE			0x00053d	Agere Systems
+oui ALTIMA			0x0010a9	Altima Communications
+oui AMD				0x00001a	Advanced Micro Devices
+oui BROADCOM			0x001018	Broadcom Corporation
+oui BROADCOM2			0x000af7	Broadcom Corporation
+oui BROADCOM3			0x001be9	Broadcom Corporation
+oui BROADCOM4			0x18c086	Broadcom Corporation
+oui CICADA			0x0003f1	Cicada Semiconductor
+oui DAVICOM			0x00606e	Davicom Semiconductor
+oui ENABLESEMI			0x0010dd	Enable Semiconductor
+oui ICPLUS			0x0090c3	IC Plus Corp.
+oui ICS				0x00a0be	Integrated Circuit Systems
+oui INTEL			0x00aa00	Intel Corporation
+oui JMICRON			0x00d831	JMicron Technologies
+oui LEVEL1			0x00207b	Level 1
+oui MARVELL			0x005043	Marvell Semiconductor
+oui MICREL			0x0010a1	Micrel
+oui MYSON			0x00c0b4	Myson Technology
+oui NATSEMI			0x080017	National Semiconductor
+oui PMCSIERRA			0x00e004	PMC-Sierra
+oui QUALSEMI			0x006051	Quality Semiconductor
+oui RDC				0x00d02d	RDC Semiconductor
+oui REALTEK			0x00e04c	RealTek Semicondctor
+oui SEEQ			0x00a07d	Seeq Technology
+oui SIS				0x00e006	Silicon Integrated Systems
+oui SMC				0x00800f	SMC
+oui TI				0x080028	Texas Instruments
+oui TSC				0x00c039	TDK Semiconductor
+oui VITESSE			0x0001c1	Vitesse Semiconductor
+oui XAQTI			0x00e0ae	XaQti Corp.
+
+/* Some Intel 82553's use an alternative OUI. */
+oui xxINTEL			0x001f00	Intel Corporation
+
+/* Some VIA 6122's use an alternative OUI. */
+oui xxCICADA			0x00c08f	Cicada Semiconductor
+
+/* bad bitorder (bits "g" and "h" (= MSBs byte 1) lost) */
+oui yyAMD			0x000058	Advanced Micro Devices
+oui xxATHEROS			0x00c82e	Atheros Communications
+oui xxBROADCOM			0x000818	Broadcom Corporation
+oui xxBROADCOM_ALT1		0x0050ef	Broadcom Corporation
+oui xxDAVICOM			0x000676	Davicom Semiconductor
+oui yyINTEL			0x005500	Intel Corporation
+oui xxJATO			0x0007c1	Jato Technologies
+oui xxMARVELL			0x000ac2	Marvell Semiconductor
+oui xxMYSON			0x00032d	Myson Technology
+oui xxNATSEMI			0x1000e8	National Semiconductor
+oui xxQUALSEMI			0x00068a	Quality Semiconductor
+oui xxTSC			0x00039c	TDK Semiconductor
+oui xxVITESSE			0x008083	Vitesse Semiconductor
+
+/* bad byteorder (bits "q" and "r" (= LSBs byte 3) lost) */
+oui xxLEVEL1			0x782000	Level 1
+oui xxXAQTI			0xace000	XaQti Corp.
+
+/* Don't know what's going on here. */
+oui xxASIX			0x000674	Asix Semiconductor
+oui yyDAVICOM			0x000602	Davicom Semiconductor
+oui xxICPLUS			0x0009c3	IC Plus Corp.
+oui xxPMCSIERRA			0x0009c0	PMC-Sierra
+oui xxPMCSIERRA2		0x009057	PMC-Sierra
+oui xxREALTEK			0x000732	RealTek Semicondctor
+oui yyREALTEK			0x000004	RealTek Semicondctor
+
+/*
+ * List of known models.  Grouped by oui.
+ */
+
+/* Agere Systems PHYs */
+model AGERE ET1011		0x0001 ET1011 10/100/1000baseT PHY
+model AGERE ET1011C		0x0004 ET1011C 10/100/1000baseT PHY
+
+/* Altima Communications PHYs */
+model ALTIMA ACXXX		0x0001 ACXXX 10/100 media interface
+model ALTIMA AC101L		0x0012 AC101L 10/100 media interface
+model ALTIMA AC101		0x0021 AC101 10/100 media interface
+/* AMD Am79C87[45] have ALTIMA OUI */
+model ALTIMA Am79C875		0x0014 Am79C875 10/100 media interface
+model ALTIMA Am79C874		0x0021 Am79C874 10/100 media interface
+
+/* Advanced Micro Devices PHYs */
+/* see Davicom DM9101 for Am79C873 */
+model yyAMD 79C972_10T		0x0001 Am79C972 internal 10BASE-T interface
+model yyAMD 79c973phy		0x0036 Am79C973 internal 10/100 media interface
+model yyAMD 79c901		0x0037 Am79C901 10BASE-T interface
+model yyAMD 79c901home		0x0039 Am79C901 HomePNA 1.0 interface
+
+/* Atheros Communications/Attansic PHYs */
+model xxATHEROS F1		0x0001 Atheros F1 10/100/1000 PHY
+model xxATHEROS F2		0x0002 Atheros F2 10/100 PHY
+model xxATHEROS AR8021		0x0004 Atheros AR8021 10/100/1000 PHY
+model xxATHEROS F1_7		0x0007 Atheros F1 10/100/1000 PHY
+
+/* Asix semiconductor PHYs */
+model xxASIX AX88X9X		0x0031 Ax88x9x internal PHY
+
+/* Broadcom Corp. PHYs */
+model xxBROADCOM 3C905B		0x0012 Broadcom 3c905B internal PHY
+model xxBROADCOM 3C905C		0x0017 Broadcom 3c905C internal PHY
+model xxBROADCOM BCM5201	0x0021 BCM5201 10/100 media interface
+model xxBROADCOM BCM5214	0x0028 BCM5214 Quad 10/100 media interface
+model xxBROADCOM BCM5221	0x001e BCM5221 10/100 media interface
+model xxBROADCOM BCM5222	0x0032 BCM5222 Dual 10/100 media interface
+model xxBROADCOM BCM4401	0x0036 BCM4401 10/100 media interface
+model xxBROADCOM BCM5365	0x0037 BCM5365 10/100 5-port PHY switch
+model BROADCOM BCM5400		0x0004 BCM5400 1000BASE-T media interface
+model BROADCOM BCM5401		0x0005 BCM5401 1000BASE-T media interface
+model BROADCOM BCM5402		0x0006 BCM5402 1000BASE-T media interface
+model BROADCOM BCM5411		0x0007 BCM5411 1000BASE-T media interface
+model BROADCOM BCM5404		0x0008 BCM5404 1000BASE-T media interface
+model BROADCOM BCM5424		0x000a BCM5424/BCM5234 1000BASE-T media interface
+model BROADCOM BCM5464		0x000b BCM5464 1000BASE-T media interface
+model BROADCOM BCM5461		0x000c BCM5461 1000BASE-T media interface
+model BROADCOM BCM5462		0x000d BCM5462 1000BASE-T media interface
+model BROADCOM BCM5421		0x000e BCM5421 1000BASE-T media interface
+model BROADCOM BCM5752		0x0010 BCM5752 1000BASE-T media interface
+model BROADCOM BCM5701		0x0011 BCM5701 1000BASE-T media interface
+model BROADCOM BCM5706		0x0015 BCM5706 1000BASE-T/SX media interface
+model BROADCOM BCM5703		0x0016 BCM5703 1000BASE-T media interface
+model BROADCOM BCM5750		0x0018 BCM5750 1000BASE-T media interface
+model BROADCOM BCM5704		0x0019 BCM5704 1000BASE-T media interface
+model BROADCOM BCM5705		0x001a BCM5705 1000BASE-T media interface
+model BROADCOM BCM54K2		0x002e BCM54K2 1000BASE-T media interface
+model BROADCOM BCM5714		0x0034 BCM5714 1000BASE-T media interface
+model BROADCOM BCM5780		0x0035 BCM5780 1000BASE-T media interface
+model BROADCOM BCM5708C		0x0036 BCM5708C 1000BASE-T media interface
+model BROADCOM BCM5466		0x003b BCM5466 1000BASE-T media interface
+model BROADCOM2 BCM5325		0x0003 BCM5325 10/100 5-port PHY switch
+model BROADCOM2 BCM5906		0x0004 BCM5906 10/100baseTX media interface
+model BROADCOM2 BCM5478		0x0008 BCM5478 1000BASE-T media interface
+model BROADCOM2 BCM5488		0x0009 BCM5488 1000BASE-T media interface
+model BROADCOM2 BCM5481		0x000a BCM5481 1000BASE-T media interface
+model BROADCOM2 BCM5482		0x000b BCM5482 1000BASE-T media interface
+model BROADCOM2 BCM5755		0x000c BCM5755 1000BASE-T media interface
+model BROADCOM2 BCM5754		0x000e BCM5754/BCM5787 1000BASE-T media interface
+model BROADCOM2 BCM5708S	0x0015 BCM5708S 1000/2500baseSX PHY
+model BROADCOM2 BCM5785		0x0016 BCM5785 1000BASE-T media interface
+model BROADCOM2 BCM5709CAX	0x002c BCM5709CAX 10/100/1000baseT PHY
+model BROADCOM2 BCM5722		0x002d BCM5722 1000BASE-T media interface
+model BROADCOM2 BCM5784		0x003a BCM5784 10/100/1000baseT PHY
+model BROADCOM2 BCM5709C	0x003c BCM5709 10/100/1000baseT PHY
+model BROADCOM2 BCM5761		0x003d BCM5761 10/100/1000baseT PHY
+model BROADCOM2 BCM5709S	0x003f BCM5709S/5720S 1000/2500baseSX PHY
+model BROADCOM3 BCM57780	0x0019 BCM57780 1000BASE-T media interface
+model BROADCOM3 BCM5717C	0x0020 BCM5717C 1000BASE-T media interface
+model BROADCOM3 BCM5719C	0x0022 BCM5719C 1000BASE-T media interface
+model BROADCOM3 BCM57765	0x0024 BCM57765 1000BASE-T media interface
+model BROADCOM3 BCM5720C	0x0036 BCM5720C 1000BASE-T media interface
+model BROADCOM4 BCM5725C	0x0038 BCM5725C 1000BASE-T media interface
+model xxBROADCOM_ALT1 BCM5906	0x0004 BCM5906 10/100baseTX media interface
+
+/* Cicada Semiconductor PHYs (now owned by Vitesse?) */
+model xxCICADA CS8201		0x0001 Cicada CS8201 10/100/1000TX PHY
+model xxCICADA CS8204		0x0004 Cicada CS8204 10/100/1000TX PHY
+model xxCICADA VSC8211		0x000b Cicada VSC8211 10/100/1000TX PHY
+model xxCICADA VSC8221		0x0015 Cicada CS8201 10/100/1000TX PHY
+model xxCICADA CS8201A		0x0020 Cicada CS8201 10/100/1000TX PHY
+model xxCICADA CS8201B		0x0021 Cicada CS8201 10/100/1000TX PHY
+model xxCICADA CS8244		0x002c Cicada CS8244 10/100/1000TX PHY
+model xxVITESSE VSC8601		0x0002 Vitesse VSC8601 10/100/1000TX PHY
+
+/* Davicom Semiconductor PHYs */
+/* AMD Am79C873 seems to be a relabeled DM9101 */
+model xxDAVICOM DM9101		0x0000 DM9101 (AMD Am79C873) 10/100 media interface
+model xxDAVICOM DM9102		0x0004 DM9102 10/100 media interface
+model yyDAVICOM DM9101		0x0000 DM9101 10/100 media interface
+
+/* IC Plus Corp. PHYs */
+model xxICPLUS IP101		0x0005 IP101 10/100 PHY
+model xxICPLUS IP1000A		0x0008 IP100A 10/100/1000 media interface
+model xxICPLUS IP1001		0x0019 IP1001 10/100/1000 media interface
+
+/* Integrated Circuit Systems PHYs */
+model ICS 1889			0x0001 ICS1889 10/100 media interface
+model ICS 1890			0x0002 ICS1890 10/100 media interface
+model ICS 1892			0x0003 ICS1892 10/100 media interface
+model ICS 1893			0x0004 ICS1893 10/100 media interface
+model ICS 1893C			0x0005 ICS1893C 10/100 media interface
+
+/* Intel Corporation PHYs */
+model xxINTEL I82553		0x0000 i82553 10/100 media interface
+model yyINTEL I82555		0x0015 i82555 10/100 media interface
+model yyINTEL I82562EH		0x0017 i82562EH HomePNA interface
+model yyINTEL I82562G		0x0031 i82562G 10/100 media interface
+model yyINTEL I82562EM		0x0032 i82562EM 10/100 media interface
+model yyINTEL I82562ET		0x0033 i82562ET 10/100 media interface
+model yyINTEL I82553		0x0035 i82553 10/100 media interface
+model yyINTEL I82566		0x0039 i82566 10/100/1000 media interface
+model INTEL I82577		0x0005 i82577 10/100/1000 media interface
+model INTEL I82579		0x0009 i82579 10/100/1000 media interface
+model xxMARVELL I82563		0x000a i82563 10/100/1000 media interface
+
+model yyINTEL IGP01E1000	0x0038 Intel IGP01E1000 Gigabit PHY
+
+/* Jato Technologies PHYs */
+model xxJATO BASEX		0x0000 Jato 1000baseX media interface
+
+/* JMicron Technologies PHYs */
+model JMICRON JMP211		0x0021 JMP211 10/100/1000 media interface
+model JMICRON JMP202		0x0022 JMP202 10/100 media interface
+
+/* Level 1 PHYs */
+model xxLEVEL1 LXT970		0x0000 LXT970 10/100 media interface
+model LEVEL1 LXT971		0x000e LXT971/2 10/100 media interface
+model LEVEL1 LXT973		0x0021 LXT973 10/100 Dual PHY
+model LEVEL1 LXT974		0x0004 LXT974 10/100 Quad PHY
+model LEVEL1 LXT975		0x0005 LXT975 10/100 Quad PHY
+model LEVEL1 LXT1000_OLD	0x0003 LXT1000 1000BASE-T media interface
+model LEVEL1 LXT1000		0x000c LXT1000 1000BASE-T media interface
+
+/* Marvell Semiconductor PHYs */
+model xxMARVELL E1000		0x0000 Marvell 88E1000 Gigabit PHY
+model xxMARVELL E1011		0x0002 Marvell 88E1011 Gigabit PHY
+model xxMARVELL E1000_3		0x0003 Marvell 88E1000 Gigabit PHY
+model xxMARVELL E1000S		0x0004 Marvell 88E1000S Gigabit PHY
+model xxMARVELL E1000_5		0x0005 Marvell 88E1000 Gigabit PHY
+model xxMARVELL E1101		0x0006 Marvell 88E1101 Gigabit PHY
+model xxMARVELL E3082		0x0008 Marvell 88E3082 10/100 Fast Ethernet PHY
+model xxMARVELL E1112		0x0009 Marvell 88E1112 Gigabit PHY
+model xxMARVELL E1149		0x000b Marvell 88E1149 Gigabit PHY
+model xxMARVELL E1111		0x000c Marvell 88E1111 Gigabit PHY
+model xxMARVELL E1145		0x000d Marvell 88E1145 Quad Gigabit PHY
+model xxMARVELL E1116		0x0021 Marvell 88E1116 Gigabit PHY
+model xxMARVELL E1116R		0x0024 Marvell 88E1116R Gigabit PHY
+model xxMARVELL E1118		0x0022 Marvell 88E1118 Gigabit PHY
+model xxMARVELL E1149R		0x0025 Marvell 88E1149R Quad Gigabit PHY
+model xxMARVELL E3016		0x0026 Marvell 88E3016 10/100 Fast Ethernet PHY
+model xxMARVELL PHYG65G		0x0027 Marvell PHYG65G Gigabit PHY
+model xxMARVELL E1116R_29	0x0029 Marvell 88E1116R Gigabit PHY
+model MARVELL E1000		0x0005 Marvell 88E1000 Gigabit PHY
+model MARVELL E1011		0x0002 Marvell 88E1011 Gigabit PHY
+model MARVELL E1000_3		0x0003 Marvell 88E1000 Gigabit PHY
+model MARVELL E1000_5		0x0005 Marvell 88E1000 Gigabit PHY
+model MARVELL E1111		0x000c Marvell 88E1111 Gigabit PHY
+
+/* Micrel PHYs */
+model MICREL KSZ8081		0x0016 Micrel KSZ8081 10/100 PHY
+model MICREL KSZ9021		0x0021 Micrel KSZ9021 10/100/1000 PHY
+model MICREL KSZ9031		0x0022 Micrel KSZ9031 10/100/1000 PHY
+
+/* Myson Technology PHYs */
+model xxMYSON MTD972		0x0000 MTD972 10/100 media interface
+model MYSON MTD803		0x0000 MTD803 3-in-1 media interface
+
+/* National Semiconductor PHYs */
+model xxNATSEMI DP83840		0x0000 DP83840 10/100 media interface
+model xxNATSEMI DP83843		0x0001 DP83843 10/100 media interface
+model xxNATSEMI DP83815		0x0002 DP83815 10/100 media interface
+model xxNATSEMI DP83847		0x0003 DP83847 10/100 media interface
+model xxNATSEMI DP83891		0x0005 DP83891 1000BASE-T media interface
+model xxNATSEMI DP83861		0x0006 DP83861 1000BASE-T media interface
+model xxNATSEMI DP83865		0x0007 DP83865 1000BASE-T media interface
+model xxNATSEMI DP83849		0x000a DP83849 10/100 media interface
+
+/* PMC Sierra PHYs */
+model xxPMCSIERRA PM8351	0x0000 PM8351 OctalPHY Gigabit interface
+model xxPMCSIERRA2 PM8352	0x0002 PM8352 OctalPHY Gigabit interface
+model xxPMCSIERRA2 PM8353	0x0003 PM8353 QuadPHY Gigabit interface
+model PMCSIERRA PM8354		0x0004 PM8354 QuadPHY Gigabit interface
+
+/* Quality Semiconductor PHYs */
+model xxQUALSEMI QS6612		0x0000 QS6612 10/100 media interface
+
+/* RDC Semiconductor PHYs */
+model RDC R6040			0x0003 R6040 10/100 media interface
+
+/* RealTek Semicondctor PHYs */
+model yyREALTEK RTL8201L	0x0020 RTL8201L 10/100 media interface
+model xxREALTEK RTL8169S	0x0011 RTL8169S/8110S/8211 1000BASE-T media interface
+model REALTEK RTL8305SC		0x0005 RTL8305SC 10/100 802.1q switch
+model REALTEK RTL8201E		0x0008 RTL8201E 10/100 media interface
+model REALTEK RTL8251		0x0000 RTL8251 1000BASE-T media interface
+model REALTEK RTL8169S		0x0011 RTL8169S/8110S/8211 1000BASE-T media interface
+
+/* Seeq Seeq PHYs */
+model SEEQ 80220		0x0003 Seeq 80220 10/100 media interface
+model SEEQ 84220		0x0004 Seeq 84220 10/100 media interface
+model SEEQ 80225		0x0008 Seeq 80225 10/100 media interface
+
+/* Silicon Integrated Systems PHYs */
+model SIS 900			0x0000 SiS 900 10/100 media interface
+
+/* Texas Instruments PHYs */
+model TI TLAN10T		0x0001 ThunderLAN 10BASE-T media interface
+model TI 100VGPMI		0x0002 ThunderLAN 100VG-AnyLan media interface
+model TI TNETE2101		0x0003 TNETE2101 media interface
+
+/* TDK Semiconductor PHYs */
+model xxTSC 78Q2120		0x0014 78Q2120 10/100 media interface
+model xxTSC 78Q2121		0x0015 78Q2121 100BASE-TX media interface
+
+/* Vitesse Semiconductor (now Microsemi) */
+model xxVITESSE VSC8501		0x0013 Vitesse VSC8501 10/100/1000TX PHY
+model xxVITESSE VSC8641		0x0003 Vitesse VSC8641 10/100/1000TX PHY
+
+/* XaQti Corp. PHYs */
+model xxXAQTI XMACII		0x0000 XaQti Corp. XMAC II gigabit interface
+
+/* SMC */
+model SMC LAN8710A		0x000F SMC LAN8710A 10/100 interface
+model SMC LAN8700		0x000C SMC LAN8700  10/100 interface
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miivar.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miivar.h
new file mode 100644
index 0000000000..e3733fadd8
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/mii/miivar.h
@@ -0,0 +1,275 @@
+/*	$NetBSD: miivar.h,v 1.8 1999/04/23 04:24:32 thorpej Exp $	*/
+
+/*-
+ * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _DEV_MII_MIIVAR_H_
+#define	_DEV_MII_MIIVAR_H_
+
+#include <sys/queue.h>
+#include <net/if_var.h>	/* XXX driver API temporary */
+
+/*
+ * Media Independent Interface data structure defintions
+ */
+
+struct mii_softc;
+
+/*
+ * A network interface driver has one of these structures in its softc.
+ * It is the interface from the network interface driver to the MII
+ * layer.
+ */
+struct mii_data {
+	struct ifmedia mii_media;	/* media information */
+	if_t mii_ifp;		/* pointer back to network interface */
+
+	/*
+	 * For network interfaces with multiple PHYs, a list of all
+	 * PHYs is required so they can all be notified when a media
+	 * request is made.
+	 */
+	LIST_HEAD(mii_listhead, mii_softc) mii_phys;
+	u_int mii_instance;
+
+	/*
+	 * PHY driver fills this in with active media status.
+	 */
+	u_int mii_media_status;
+	u_int mii_media_active;
+};
+typedef struct mii_data mii_data_t;
+
+/*
+ * Functions provided by the PHY to perform various functions.
+ */
+struct mii_phy_funcs {
+	int (*pf_service)(struct mii_softc *, struct mii_data *, int);
+	void (*pf_status)(struct mii_softc *);
+	void (*pf_reset)(struct mii_softc *);
+};
+
+/*
+ * Requests that can be made to the downcall.
+ */
+#define	MII_TICK	1	/* once-per-second tick */
+#define	MII_MEDIACHG	2	/* user changed media; perform the switch */
+#define	MII_POLLSTAT	3	/* user requested media status; fill it in */
+
+/*
+ * Each PHY driver's softc has one of these as the first member.
+ * XXX This would be better named "phy_softc", but this is the name
+ * XXX BSDI used, and we would like to have the same interface.
+ */
+struct mii_softc {
+	device_t mii_dev;		/* generic device glue */
+
+	LIST_ENTRY(mii_softc) mii_list;	/* entry on parent's PHY list */
+
+	uint32_t mii_mpd_oui;		/* the PHY's OUI (MII_OUI())*/
+	uint32_t mii_mpd_model;		/* the PHY's model (MII_MODEL())*/
+	uint32_t mii_mpd_rev;		/* the PHY's revision (MII_REV())*/
+	u_int mii_capmask;		/* capability mask for BMSR */
+	u_int mii_phy;			/* our MII address */
+	u_int mii_offset;		/* first PHY, second PHY, etc. */
+	u_int mii_inst;			/* instance for ifmedia */
+
+	/* Our PHY functions. */
+	const struct mii_phy_funcs *mii_funcs;
+
+	struct mii_data *mii_pdata;	/* pointer to parent's mii_data */
+
+	u_int mii_flags;		/* misc. flags; see below */
+	u_int mii_capabilities;		/* capabilities from BMSR */
+	u_int mii_extcapabilities;	/* extended capabilities */
+	u_int mii_ticks;		/* MII_TICK counter */
+	u_int mii_anegticks;		/* ticks before retrying aneg */
+	u_int mii_media_active;		/* last active media */
+	u_int mii_media_status;		/* last active status */
+};
+typedef struct mii_softc mii_softc_t;
+
+/* mii_flags */
+#define	MIIF_INITDONE	0x00000001	/* has been initialized (mii_data) */
+#define	MIIF_NOISOLATE	0x00000002	/* do not isolate the PHY */
+#if 0
+#define	MIIF_NOLOOP	0x00000004	/* no loopback capability */
+#endif
+#define	MIIF_DOINGAUTO	0x00000008	/* doing autonegotiation (mii_softc) */
+#define	MIIF_AUTOTSLEEP	0x00000010	/* use tsleep(), not callout() */
+#define	MIIF_HAVEFIBER	0x00000020	/* from parent: has fiber interface */
+#define	MIIF_HAVE_GTCR	0x00000040	/* has 100base-T2/1000base-T CR */
+#define	MIIF_IS_1000X	0x00000080	/* is a 1000BASE-X device */
+#define	MIIF_DOPAUSE	0x00000100	/* advertise PAUSE capability */
+#define	MIIF_IS_HPNA	0x00000200	/* is a HomePNA device */
+#define	MIIF_FORCEANEG	0x00000400	/* force auto-negotiation */
+#define	MIIF_NOMANPAUSE	0x00100000	/* no manual PAUSE selection */
+#define	MIIF_FORCEPAUSE	0x00200000	/* force PAUSE advertisement */
+#define	MIIF_MACPRIV0	0x01000000	/* private to the MAC driver */
+#define	MIIF_MACPRIV1	0x02000000	/* private to the MAC driver */
+#define	MIIF_MACPRIV2	0x04000000	/* private to the MAC driver */
+#define	MIIF_PHYPRIV0	0x10000000	/* private to the PHY driver */
+#define	MIIF_PHYPRIV1	0x20000000	/* private to the PHY driver */
+#define	MIIF_PHYPRIV2	0x40000000	/* private to the PHY driver */
+
+/* Default mii_anegticks values */
+#define	MII_ANEGTICKS		5
+#define	MII_ANEGTICKS_GIGE	17
+
+#define	MIIF_INHERIT_MASK	(MIIF_NOISOLATE|MIIF_NOLOOP|MIIF_AUTOTSLEEP)
+
+/*
+ * Special `locators' passed to mii_attach().  If one of these is not
+ * an `any' value, we look for *that* PHY and configure it.  If both
+ * are not `any', that is an error, and mii_attach() will fail.
+ */
+#define	MII_OFFSET_ANY		-1
+#define	MII_PHY_ANY		-1
+
+/*
+ * Used to attach a PHY to a parent.
+ */
+struct mii_attach_args {
+	struct mii_data *mii_data;	/* pointer to parent data */
+	u_int mii_phyno;		/* MII address */
+	u_int mii_offset;		/* first PHY, second PHY, etc. */
+	uint32_t mii_id1;		/* PHY ID register 1 */
+	uint32_t mii_id2;		/* PHY ID register 2 */
+	u_int mii_capmask;		/* capability mask for BMSR */
+};
+typedef struct mii_attach_args mii_attach_args_t;
+
+/*
+ * Used to match a PHY.
+ */
+struct mii_phydesc {
+	uint32_t mpd_oui;		/* the PHY's OUI */
+	uint32_t mpd_model;		/* the PHY's model */
+	const char *mpd_name;		/* the PHY's name */
+};
+#define MII_PHY_DESC(a, b) { MII_OUI_ ## a, MII_MODEL_ ## a ## _ ## b, \
+	MII_STR_ ## a ## _ ## b }
+#define MII_PHY_END	{ 0, 0, NULL }
+
+#ifdef _KERNEL
+
+#ifdef __HAIKU__
+int __haiku_miibus_readreg(device_t dev, int phy, int reg);
+int __haiku_miibus_writereg(device_t dev, int phy, int reg, int data);
+void __haiku_miibus_statchg(device_t dev);
+void __haiku_miibus_linkchg(device_t dev);
+void __haiku_miibus_mediainit(device_t dev);
+
+#define MIIBUS_READREG(dev, phy, reg) \
+	__haiku_miibus_readreg((dev), (phy), (reg))
+
+#define MIIBUS_WRITEREG(dev, phy, reg, value) \
+	__haiku_miibus_writereg((dev), (phy), (reg), (value))
+
+#define MIIBUS_STATCHG(dev) \
+	__haiku_miibus_statchg(dev)
+
+#define MIIBUS_LINKCHG(dev) \
+	__haiku_miibus_linkchg(dev)
+
+#define MIIBUS_MEDIAINIT(dev) \
+	__haiku_miibus_mediainit(dev)
+
+#endif
+
+#define PHY_READ(p, r) \
+	MIIBUS_READREG((p)->mii_dev, (p)->mii_phy, (r))
+
+#define PHY_WRITE(p, r, v) \
+	MIIBUS_WRITEREG((p)->mii_dev, (p)->mii_phy, (r), (v))
+
+#define	PHY_SERVICE(p, d, o) \
+	(*(p)->mii_funcs->pf_service)((p), (d), (o))
+
+#define	PHY_STATUS(p) \
+	(*(p)->mii_funcs->pf_status)(p)
+
+#define	PHY_RESET(p) \
+	(*(p)->mii_funcs->pf_reset)(p)
+
+enum miibus_device_ivars {
+	MIIBUS_IVAR_FLAGS
+};
+
+/*
+ * Simplified accessors for miibus
+ */
+#define	MIIBUS_ACCESSOR(var, ivar, type)				\
+	__BUS_ACCESSOR(miibus, var, MIIBUS, ivar, type)
+
+MIIBUS_ACCESSOR(flags,		FLAGS,		u_int)
+
+extern devclass_t	miibus_devclass;
+extern driver_t		miibus_driver;
+
+int	mii_attach(device_t, device_t *, if_t, ifm_change_cb_t,
+	    ifm_stat_cb_t, int, int, int, int);
+int	mii_mediachg(struct mii_data *);
+void	mii_tick(struct mii_data *);
+void	mii_pollstat(struct mii_data *);
+void	mii_phy_add_media(struct mii_softc *);
+
+int	mii_phy_auto(struct mii_softc *);
+int	mii_phy_detach(device_t dev);
+u_int	mii_phy_flowstatus(struct mii_softc *);
+void	mii_phy_reset(struct mii_softc *);
+void	mii_phy_setmedia(struct mii_softc *sc);
+void	mii_phy_update(struct mii_softc *, int);
+int	mii_phy_tick(struct mii_softc *);
+int	mii_phy_mac_match(struct mii_softc *, const char *);
+int	mii_dev_mac_match(device_t, const char *);
+void	*mii_phy_mac_softc(struct mii_softc *);
+void	*mii_dev_mac_softc(device_t);
+
+const struct mii_phydesc * mii_phy_match(const struct mii_attach_args *ma,
+    const struct mii_phydesc *mpd);
+const struct mii_phydesc * mii_phy_match_gen(const struct mii_attach_args *ma,
+    const struct mii_phydesc *mpd, size_t endlen);
+int mii_phy_dev_probe(device_t dev, const struct mii_phydesc *mpd, int mrv);
+void mii_phy_dev_attach(device_t dev, u_int flags,
+    const struct mii_phy_funcs *mpf, int add_media);
+
+void	ukphy_status(struct mii_softc *);
+
+u_int	mii_oui(u_int, u_int);
+#define	MII_OUI(id1, id2)	mii_oui(id1, id2)
+#define	MII_MODEL(id2)		(((id2) & IDR2_MODEL) >> 4)
+#define	MII_REV(id2)		((id2) & IDR2_REV)
+
+#endif /* _KERNEL */
+
+#endif /* _DEV_MII_MIIVAR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus.h
new file mode 100644
index 0000000000..7cbc5c0535
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus.h
@@ -0,0 +1,81 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2001, 2003 by Thomas Moestl <tmm@FreeBSD.org>
+ * Copyright (c) 2004 by Marius Strobl <marius@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef	_DEV_OFW_OFW_BUS_H_
+#define	_DEV_OFW_OFW_BUS_H_
+
+#include <sys/bus.h>
+
+#include <dev/ofw/openfirm.h>
+
+#include "ofw_bus_if.h"
+
+static __inline const char *
+ofw_bus_get_compat(device_t dev)
+{
+
+	return (OFW_BUS_GET_COMPAT(device_get_parent(dev), dev));
+}
+
+static __inline const char *
+ofw_bus_get_model(device_t dev)
+{
+
+	return (OFW_BUS_GET_MODEL(device_get_parent(dev), dev));
+}
+
+static __inline const char *
+ofw_bus_get_name(device_t dev)
+{
+
+	return (OFW_BUS_GET_NAME(device_get_parent(dev), dev));
+}
+
+static __inline phandle_t
+ofw_bus_get_node(device_t dev)
+{
+
+	return (OFW_BUS_GET_NODE(device_get_parent(dev), dev));
+}
+
+static __inline const char *
+ofw_bus_get_type(device_t dev)
+{
+
+	return (OFW_BUS_GET_TYPE(device_get_parent(dev), dev));
+}
+
+static __inline int
+ofw_bus_map_intr(device_t dev, phandle_t iparent, int icells, pcell_t *intr)
+{
+	return (OFW_BUS_MAP_INTR(dev, dev, iparent, icells, intr));
+}
+
+#endif /* !_DEV_OFW_OFW_BUS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.h
new file mode 100644
index 0000000000..99448cb5a9
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.h
@@ -0,0 +1,130 @@
+/*
+ * This file is @generated automatically.
+ * Do not modify anything in here by hand.
+ *
+ * Created from source file
+ *   /boot/data/packages/haiku/src/libs/compat/freebsd_network/compat/dev/ofw/ofw_bus_if.m
+ * with
+ *   makeobjops.awk
+ *
+ * See the source file for legal information
+ */
+
+
+#ifndef _ofw_bus_if_h_
+#define _ofw_bus_if_h_
+
+
+struct ofw_bus_devinfo {
+	phandle_t	obd_node;
+	char		*obd_compat;
+	char		*obd_model;
+	char		*obd_name;
+	char		*obd_type;
+	char		*obd_status;
+};
+
+/** @brief Unique descriptor for the OFW_BUS_GET_DEVINFO() method */
+extern struct kobjop_desc ofw_bus_get_devinfo_desc;
+/** @brief A function implementing the OFW_BUS_GET_DEVINFO() method */
+typedef const struct ofw_bus_devinfo * ofw_bus_get_devinfo_t(device_t bus,
+                                                             device_t dev);
+
+static __inline const struct ofw_bus_devinfo * OFW_BUS_GET_DEVINFO(device_t bus,
+                                                                   device_t dev)
+{
+	kobjop_t _m;
+	const struct ofw_bus_devinfo * rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_get_devinfo);
+	rc = ((ofw_bus_get_devinfo_t *) _m)(bus, dev);
+	return (rc);
+}
+
+/** @brief Unique descriptor for the OFW_BUS_GET_COMPAT() method */
+extern struct kobjop_desc ofw_bus_get_compat_desc;
+/** @brief A function implementing the OFW_BUS_GET_COMPAT() method */
+typedef const char * ofw_bus_get_compat_t(device_t bus, device_t dev);
+
+static __inline const char * OFW_BUS_GET_COMPAT(device_t bus, device_t dev)
+{
+	kobjop_t _m;
+	const char * rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_get_compat);
+	rc = ((ofw_bus_get_compat_t *) _m)(bus, dev);
+	return (rc);
+}
+
+/** @brief Unique descriptor for the OFW_BUS_GET_MODEL() method */
+extern struct kobjop_desc ofw_bus_get_model_desc;
+/** @brief A function implementing the OFW_BUS_GET_MODEL() method */
+typedef const char * ofw_bus_get_model_t(device_t bus, device_t dev);
+
+static __inline const char * OFW_BUS_GET_MODEL(device_t bus, device_t dev)
+{
+	kobjop_t _m;
+	const char * rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_get_model);
+	rc = ((ofw_bus_get_model_t *) _m)(bus, dev);
+	return (rc);
+}
+
+/** @brief Unique descriptor for the OFW_BUS_GET_NAME() method */
+extern struct kobjop_desc ofw_bus_get_name_desc;
+/** @brief A function implementing the OFW_BUS_GET_NAME() method */
+typedef const char * ofw_bus_get_name_t(device_t bus, device_t dev);
+
+static __inline const char * OFW_BUS_GET_NAME(device_t bus, device_t dev)
+{
+	kobjop_t _m;
+	const char * rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_get_name);
+	rc = ((ofw_bus_get_name_t *) _m)(bus, dev);
+	return (rc);
+}
+
+/** @brief Unique descriptor for the OFW_BUS_GET_NODE() method */
+extern struct kobjop_desc ofw_bus_get_node_desc;
+/** @brief A function implementing the OFW_BUS_GET_NODE() method */
+typedef phandle_t ofw_bus_get_node_t(device_t bus, device_t dev);
+
+static __inline phandle_t OFW_BUS_GET_NODE(device_t bus, device_t dev)
+{
+	kobjop_t _m;
+	phandle_t rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_get_node);
+	rc = ((ofw_bus_get_node_t *) _m)(bus, dev);
+	return (rc);
+}
+
+/** @brief Unique descriptor for the OFW_BUS_GET_TYPE() method */
+extern struct kobjop_desc ofw_bus_get_type_desc;
+/** @brief A function implementing the OFW_BUS_GET_TYPE() method */
+typedef const char * ofw_bus_get_type_t(device_t bus, device_t dev);
+
+static __inline const char * OFW_BUS_GET_TYPE(device_t bus, device_t dev)
+{
+	kobjop_t _m;
+	const char * rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_get_type);
+	rc = ((ofw_bus_get_type_t *) _m)(bus, dev);
+	return (rc);
+}
+
+/** @brief Unique descriptor for the OFW_BUS_MAP_INTR() method */
+extern struct kobjop_desc ofw_bus_map_intr_desc;
+/** @brief A function implementing the OFW_BUS_MAP_INTR() method */
+typedef int ofw_bus_map_intr_t(device_t bus, device_t dev, phandle_t iparent,
+                               int icells, pcell_t *interrupt);
+
+static __inline int OFW_BUS_MAP_INTR(device_t bus, device_t dev,
+                                     phandle_t iparent, int icells,
+                                     pcell_t *interrupt)
+{
+	kobjop_t _m;
+	int rc;
+	KOBJOPLOOKUP(((kobj_t)bus)->ops,ofw_bus_map_intr);
+	rc = ((ofw_bus_map_intr_t *) _m)(bus, dev, iparent, icells, interrupt);
+	return (rc);
+}
+
+#endif /* _ofw_bus_if_h_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.m b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.m
new file mode 100644
index 0000000000..36d10e6168
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_if.m
@@ -0,0 +1,171 @@
+#-
+# Copyright (c) 2001, 2003 by Thomas Moestl <tmm@FreeBSD.org>
+# Copyright (c) 2004, 2005 by Marius Strobl <marius@FreeBSD.org>
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# $FreeBSD$
+
+# Interface for retrieving the package handle and a subset, namely
+# 'compatible', 'device_type', 'model' and 'name', of the standard
+# properties of a device on an Open Firmware assisted bus for use
+# in device drivers. The rest of the standard properties, 'address',
+# 'interrupts', 'reg' and 'status', are not covered by this interface
+# as they are expected to be only of interest in the respective bus
+# driver.
+
+#include <sys/bus.h>
+
+#include <dev/ofw/openfirm.h>
+
+INTERFACE ofw_bus;
+
+HEADER {
+	struct ofw_bus_devinfo {
+		phandle_t	obd_node;
+		char		*obd_compat;
+		char		*obd_model;
+		char		*obd_name;
+		char		*obd_type;
+		char		*obd_status;
+	};
+};
+
+CODE {
+	static ofw_bus_get_devinfo_t ofw_bus_default_get_devinfo;
+	static ofw_bus_get_compat_t ofw_bus_default_get_compat;
+	static ofw_bus_get_model_t ofw_bus_default_get_model;
+	static ofw_bus_get_name_t ofw_bus_default_get_name;
+	static ofw_bus_get_node_t ofw_bus_default_get_node;
+	static ofw_bus_get_type_t ofw_bus_default_get_type;
+	static ofw_bus_map_intr_t ofw_bus_default_map_intr;
+
+	static const struct ofw_bus_devinfo *
+	ofw_bus_default_get_devinfo(device_t bus, device_t dev)
+	{
+
+		return (NULL);
+	}
+
+	static const char *
+	ofw_bus_default_get_compat(device_t bus, device_t dev)
+	{
+
+		return (NULL);
+	}
+
+	static const char *
+	ofw_bus_default_get_model(device_t bus, device_t dev)
+	{
+
+		return (NULL);
+	}
+
+	static const char *
+	ofw_bus_default_get_name(device_t bus, device_t dev)
+	{
+
+		return (NULL);
+	}
+
+	static phandle_t
+	ofw_bus_default_get_node(device_t bus, device_t dev)
+	{
+
+		return (-1);
+	}
+
+	static const char *
+	ofw_bus_default_get_type(device_t bus, device_t dev)
+	{
+
+		return (NULL);
+	}
+
+	int
+	ofw_bus_default_map_intr(device_t bus, device_t dev, phandle_t iparent,
+	    int icells, pcell_t *interrupt)
+	{
+		/* Propagate up the bus hierarchy until someone handles it. */	
+		if (device_get_parent(bus) != NULL)
+			return OFW_BUS_MAP_INTR(device_get_parent(bus), dev,
+			    iparent, icells, interrupt);
+
+		/* If that fails, then assume a one-domain system */
+		return (interrupt[0]);
+	}
+};
+
+# Get the ofw_bus_devinfo struct for the device dev on the bus. Used for bus
+# drivers which use the generic methods in ofw_bus_subr.c to implement the
+# reset of this interface. The default method will return NULL, which means
+# there is no such struct associated with the device.
+METHOD const struct ofw_bus_devinfo * get_devinfo {
+	device_t bus;
+	device_t dev;
+} DEFAULT ofw_bus_default_get_devinfo;
+
+# Get the alternate firmware name for the device dev on the bus. The default
+# method will return NULL, which means the device doesn't have such a property.
+METHOD const char * get_compat {
+	device_t bus;
+	device_t dev;
+} DEFAULT ofw_bus_default_get_compat;
+
+# Get the firmware model name for the device dev on the bus. The default method
+# will return NULL, which means the device doesn't have such a property.
+METHOD const char * get_model {
+	device_t bus;
+	device_t dev;
+} DEFAULT ofw_bus_default_get_model;
+
+# Get the firmware name for the device dev on the bus. The default method will
+# return NULL, which means the device doesn't have such a property.
+METHOD const char * get_name {
+	device_t bus;
+	device_t dev;
+} DEFAULT ofw_bus_default_get_name;
+
+# Get the firmware node for the device dev on the bus. The default method will
+# return -1, which signals that there is no such node.
+METHOD phandle_t get_node {
+	device_t bus;
+	device_t dev;
+} DEFAULT ofw_bus_default_get_node;
+
+# Get the firmware device type for the device dev on the bus. The default
+# method will return NULL, which means the device doesn't have such a property.
+METHOD const char * get_type {
+	device_t bus;
+	device_t dev;
+} DEFAULT ofw_bus_default_get_type;
+
+# Map an (interrupt parent, IRQ) pair to a unique system-wide interrupt number.
+# If the interrupt encoding includes a sense field, the interrupt sense will
+# also be configured.
+METHOD int map_intr {
+	device_t bus;
+	device_t dev;
+	phandle_t iparent;
+	int icells;
+	pcell_t *interrupt;
+} DEFAULT ofw_bus_default_map_intr;
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_subr.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_subr.h
new file mode 100644
index 0000000000..3e834f2d64
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/ofw_bus_subr.h
@@ -0,0 +1,153 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2005 Marius Strobl <marius@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef	_DEV_OFW_OFW_BUS_SUBR_H_
+#define	_DEV_OFW_OFW_BUS_SUBR_H_
+
+#include <sys/bus.h>
+#ifdef INTRNG
+#include <sys/intr.h>
+#endif
+#include <dev/ofw/openfirm.h>
+
+#include "ofw_bus_if.h"
+
+#define	ORIP_NOINT	-1
+#define	ORIR_NOTFOUND	0xffffffff
+
+struct ofw_bus_iinfo {
+	uint8_t			*opi_imap;
+	uint8_t			*opi_imapmsk;
+	int			opi_imapsz;
+	pcell_t			opi_addrc;
+};
+
+struct ofw_compat_data {
+	const char	*ocd_str;
+	uintptr_t	 ocd_data;
+};
+
+#ifdef INTRNG
+struct intr_map_data_fdt {
+	struct intr_map_data	hdr;
+	phandle_t		iparent;
+	u_int			ncells;
+	pcell_t			cells[];
+};
+#endif
+
+#define FDTCOMPAT_PNP_DESCR "Z:compat;P:#;"
+#define FDTCOMPAT_PNP_INFO(t, busname) \
+	MODULE_PNP_INFO(FDTCOMPAT_PNP_DESCR, busname, t, t, sizeof(t) / sizeof(t[0]));
+
+#define	OFWBUS_PNP_INFO(t)	FDTCOMPAT_PNP_INFO(t, ofwbus)
+#define	SIMPLEBUS_PNP_INFO(t)	FDTCOMPAT_PNP_INFO(t, simplebus)
+
+/* Generic implementation of ofw_bus_if.m methods and helper routines */
+int	ofw_bus_gen_setup_devinfo(struct ofw_bus_devinfo *, phandle_t);
+void	ofw_bus_gen_destroy_devinfo(struct ofw_bus_devinfo *);
+
+ofw_bus_get_compat_t	ofw_bus_gen_get_compat;
+ofw_bus_get_model_t	ofw_bus_gen_get_model;
+ofw_bus_get_name_t	ofw_bus_gen_get_name;
+ofw_bus_get_node_t	ofw_bus_gen_get_node;
+ofw_bus_get_type_t	ofw_bus_gen_get_type;
+
+/* Helper method to report interesting OF properties in pnpinfo */
+//bus_child_pnpinfo_t	ofw_bus_gen_child_pnpinfo;
+
+/* Routines for processing firmware interrupt maps */
+void	ofw_bus_setup_iinfo(phandle_t, struct ofw_bus_iinfo *, int);
+int	ofw_bus_lookup_imap(phandle_t, struct ofw_bus_iinfo *, void *, int,
+	    void *, int, void *, int, phandle_t *);
+int	ofw_bus_search_intrmap(void *, int, void *, int, void *, int, void *,
+	    void *, void *, int, phandle_t *);
+
+/* Routines for processing msi maps */
+int ofw_bus_msimap(phandle_t, uint16_t, phandle_t *, uint32_t *);
+
+/* Routines for parsing device-tree data into resource lists. */
+int ofw_bus_reg_to_rl(device_t, phandle_t, pcell_t, pcell_t,
+    struct resource_list *);
+int ofw_bus_assigned_addresses_to_rl(device_t, phandle_t, pcell_t, pcell_t,
+    struct resource_list *);
+int ofw_bus_intr_to_rl(device_t, phandle_t, struct resource_list *, int *);
+int ofw_bus_intr_by_rid(device_t, phandle_t, int, phandle_t *, int *,
+    pcell_t **);
+
+/* Helper to get device status property */
+const char *ofw_bus_get_status(device_t dev);
+int ofw_bus_status_okay(device_t dev);
+int ofw_bus_node_status_okay(phandle_t node);
+
+/* Helper to get node's interrupt parent */
+phandle_t ofw_bus_find_iparent(phandle_t);
+
+/* Helper routine for checking compat prop */
+int ofw_bus_is_compatible(device_t, const char *);
+int ofw_bus_is_compatible_strict(device_t, const char *);
+int ofw_bus_node_is_compatible(phandle_t, const char *);
+
+/* 
+ * Helper routine to search a list of compat properties.  The table is
+ * terminated by an entry with a NULL compat-string pointer; a pointer to that
+ * table entry is returned if none of the compat strings match for the device,
+ * giving you control over the not-found value.  Will not return NULL unless the
+ * provided table pointer is NULL.
+ */
+const struct ofw_compat_data *
+    ofw_bus_search_compatible(device_t, const struct ofw_compat_data *);
+
+/* Helper routine for checking existence of a prop */
+int ofw_bus_has_prop(device_t, const char *);
+
+/* Helper to search for a child with a given compat prop */
+phandle_t ofw_bus_find_compatible(phandle_t, const char *);
+
+/* Helper to search for a child with a given name */
+phandle_t ofw_bus_find_child(phandle_t, const char *);
+
+/* Helper routine to find a device_t child matching a given phandle_t */
+device_t ofw_bus_find_child_device_by_phandle(device_t bus, phandle_t node);
+
+/* Helper routines for parsing lists  */
+int ofw_bus_parse_xref_list_alloc(phandle_t node, const char *list_name,
+    const char *cells_name, int idx, phandle_t *producer, int *ncells,
+    pcell_t **cells);
+int ofw_bus_parse_xref_list_get_length(phandle_t node, const char *list_name,
+    const char *cells_name, int *count);
+int ofw_bus_find_string_index(phandle_t node, const char *list_name,
+    const char *name, int *idx);
+int ofw_bus_string_list_to_array(phandle_t node, const char *list_name,
+    const char ***array);
+
+#endif /* !_DEV_OFW_OFW_BUS_SUBR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/openfirm.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/openfirm.h
new file mode 100644
index 0000000000..53c8cdf88d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/ofw/openfirm.h
@@ -0,0 +1,187 @@
+/*	$NetBSD: openfirm.h,v 1.1 1998/05/15 10:16:00 tsubai Exp $	*/
+
+/*-
+ * SPDX-License-Identifier: (BSD-4-Clause AND BSD-2-Clause-FreeBSD)
+ *
+ * Copyright (C) 1995, 1996 Wolfgang Solfrank.
+ * Copyright (C) 1995, 1996 TooLs GmbH.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by TooLs GmbH.
+ * 4. The name of TooLs GmbH may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ * Copyright (C) 2000 Benno Rice.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Benno Rice ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _DEV_OPENFIRM_H_
+#define _DEV_OPENFIRM_H_
+
+#include <sys/types.h>
+#include <machine/_bus.h>
+
+/*
+ * Prototypes for Open Firmware Interface Routines
+ */
+
+typedef uint32_t	ihandle_t;
+typedef uint32_t	phandle_t;
+typedef uint32_t	pcell_t;
+
+#ifdef _KERNEL
+#include <sys/malloc.h>
+
+#include <machine/ofw_machdep.h>
+
+MALLOC_DECLARE(M_OFWPROP);
+
+/*
+ * Open Firmware interface initialization.  OF_install installs the named
+ * interface as the Open Firmware access mechanism, OF_init initializes it.
+ */
+
+boolean_t	OF_install(char *name, int prio);
+int		OF_init(void *cookie);
+
+/*
+ * Known Open Firmware interface names
+ */
+
+#define	OFW_STD_DIRECT	"ofw_std"	/* Standard OF interface */
+#define	OFW_STD_REAL	"ofw_real"	/* Real-mode OF interface */
+#define	OFW_STD_32BIT	"ofw_32bit"	/* 32-bit OF interface */
+#define	OFW_FDT		"ofw_fdt"	/* Flattened Device Tree */
+
+/* Generic functions */
+int		OF_test(const char *name);
+void		OF_printf(const char *fmt, ...);
+
+/* Device tree functions */
+phandle_t	OF_peer(phandle_t node);
+phandle_t	OF_child(phandle_t node);
+phandle_t	OF_parent(phandle_t node);
+ssize_t		OF_getproplen(phandle_t node, const char *propname);
+ssize_t		OF_getprop(phandle_t node, const char *propname, void *buf,
+		    size_t len);
+ssize_t		OF_getencprop(phandle_t node, const char *prop, pcell_t *buf,
+		    size_t len); /* Same as getprop, but maintains endianness */
+int		OF_hasprop(phandle_t node, const char *propname);
+ssize_t		OF_searchprop(phandle_t node, const char *propname, void *buf,
+		    size_t len);
+ssize_t		OF_searchencprop(phandle_t node, const char *propname,
+		    pcell_t *buf, size_t len);
+ssize_t		OF_getprop_alloc(phandle_t node, const char *propname,
+		    void **buf);
+ssize_t		OF_getprop_alloc_multi(phandle_t node, const char *propname,
+		    int elsz, void **buf);
+ssize_t		OF_getencprop_alloc(phandle_t node, const char *propname,
+		    void **buf);
+ssize_t		OF_getencprop_alloc_multi(phandle_t node, const char *propname,
+		    int elsz, void **buf);
+void		OF_prop_free(void *buf);
+int		OF_nextprop(phandle_t node, const char *propname, char *buf,
+		    size_t len);
+int		OF_setprop(phandle_t node, const char *name, const void *buf,
+		    size_t len);
+ssize_t		OF_canon(const char *path, char *buf, size_t len);
+phandle_t	OF_finddevice(const char *path);
+ssize_t		OF_package_to_path(phandle_t node, char *buf, size_t len);
+
+/*
+ * Some OF implementations (IBM, FDT) have a concept of effective phandles
+ * used for device-tree cross-references. Given one of these, returns the
+ * real phandle. If one can't be found (or running on OF implementations
+ * without this property), returns its input.
+ */
+phandle_t	OF_node_from_xref(phandle_t xref);
+phandle_t	OF_xref_from_node(phandle_t node);
+
+/*
+ * When properties contain references to other nodes using xref handles it is
+ * often necessary to use interfaces provided by the driver for the referenced
+ * instance.  These routines allow a driver that provides such an interface to
+ * register its association with an xref handle, and for other drivers to obtain
+ * the device_t associated with an xref handle.
+ */
+device_t	OF_device_from_xref(phandle_t xref);
+phandle_t	OF_xref_from_device(device_t dev);
+int		OF_device_register_xref(phandle_t xref, device_t dev);
+
+/* Device I/O functions */
+ihandle_t	OF_open(const char *path);
+void		OF_close(ihandle_t instance);
+ssize_t		OF_read(ihandle_t instance, void *buf, size_t len);
+ssize_t		OF_write(ihandle_t instance, const void *buf, size_t len);
+int		OF_seek(ihandle_t instance, uint64_t where);
+
+phandle_t	OF_instance_to_package(ihandle_t instance);
+ssize_t		OF_instance_to_path(ihandle_t instance, char *buf, size_t len);
+int		OF_call_method(const char *method, ihandle_t instance,
+		    int nargs, int nreturns, ...);
+
+/* Memory functions */
+void		*OF_claim(void *virtrequest, size_t size, u_int align);
+void		OF_release(void *virt, size_t size);
+
+/* Control transfer functions */
+void		OF_enter(void);
+void		OF_exit(void) __attribute__((noreturn));
+
+/* User interface functions */
+int		OF_interpret(const char *cmd, int nreturns, ...);
+
+/*
+ * Decode the Nth register property of the given device node and create a bus
+ * space tag and handle for accessing it.  This is for use in setting up things
+ * like early console output before newbus is available.
+ */
+int		OF_decode_addr(phandle_t dev, int regno, bus_space_tag_t *ptag,
+		    bus_space_handle_t *phandle, bus_size_t *sz);
+
+#endif /* _KERNEL */
+#endif /* _DEV_OPENFIRM_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcireg.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcireg.h
new file mode 100644
index 0000000000..ef3513560f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcireg.h
@@ -0,0 +1,988 @@
+/*-
+ * Copyright (c) 1997, Stefan Esser <se@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ *
+ */
+
+/*
+ * PCIM_xxx: mask to locate subfield in register
+ * PCIR_xxx: config register offset
+ * PCIC_xxx: device class
+ * PCIS_xxx: device subclass
+ * PCIP_xxx: device programming interface
+ * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
+ * PCID_xxx: device ID
+ * PCIY_xxx: capability identification number
+ * PCIZ_xxx: extended capability identification number
+ */
+
+/* some PCI bus constants */
+#define	PCI_DOMAINMAX	65535	/* highest supported domain number */
+#define	PCI_BUSMAX	255	/* highest supported bus number */
+#define	PCI_SLOTMAX	31	/* highest supported slot number */
+#define	PCI_FUNCMAX	7	/* highest supported function number */
+#define	PCI_REGMAX	255	/* highest supported config register addr. */
+#define	PCIE_REGMAX	4095	/* highest supported config register addr. */
+#define	PCI_MAXHDRTYPE	2
+
+/* PCI config header registers for all devices */
+
+#define	PCIR_DEVVENDOR	0x00
+#define	PCIR_VENDOR	0x00
+#define	PCIR_DEVICE	0x02
+#define	PCIR_COMMAND	0x04
+#define	PCIM_CMD_PORTEN		0x0001
+#define	PCIM_CMD_MEMEN		0x0002
+#define	PCIM_CMD_BUSMASTEREN	0x0004
+#define	PCIM_CMD_SPECIALEN	0x0008
+#define	PCIM_CMD_MWRICEN	0x0010
+#define	PCIM_CMD_PERRESPEN	0x0040
+#define	PCIM_CMD_SERRESPEN	0x0100
+#define	PCIM_CMD_BACKTOBACK	0x0200
+#define	PCIM_CMD_INTxDIS	0x0400
+#define	PCIR_STATUS	0x06
+#define	PCIM_STATUS_INTxSTATE	0x0008
+#define	PCIM_STATUS_CAPPRESENT	0x0010
+#define	PCIM_STATUS_66CAPABLE	0x0020
+#define	PCIM_STATUS_BACKTOBACK	0x0080
+#define	PCIM_STATUS_MDPERR	0x0100
+#define	PCIM_STATUS_SEL_FAST	0x0000
+#define	PCIM_STATUS_SEL_MEDIMUM	0x0200
+#define	PCIM_STATUS_SEL_SLOW	0x0400
+#define	PCIM_STATUS_SEL_MASK	0x0600
+#define	PCIM_STATUS_STABORT	0x0800
+#define	PCIM_STATUS_RTABORT	0x1000
+#define	PCIM_STATUS_RMABORT	0x2000
+#define	PCIM_STATUS_SERR	0x4000
+#define	PCIM_STATUS_PERR	0x8000
+#define	PCIR_REVID	0x08
+#define	PCIR_PROGIF	0x09
+#define	PCIR_SUBCLASS	0x0a
+#define	PCIR_CLASS	0x0b
+#define	PCIR_CACHELNSZ	0x0c
+#define	PCIR_LATTIMER	0x0d
+#define	PCIR_HDRTYPE	0x0e
+#define	PCIM_HDRTYPE		0x7f
+#define	PCIM_HDRTYPE_NORMAL	0x00
+#define	PCIM_HDRTYPE_BRIDGE	0x01
+#define	PCIM_HDRTYPE_CARDBUS	0x02
+#define	PCIM_MFDEV		0x80
+#define	PCIR_BIST	0x0f
+
+/* Capability Register Offsets */
+
+#define	PCICAP_ID	0x0
+#define	PCICAP_NEXTPTR	0x1
+
+/* Capability Identification Numbers */
+
+#define	PCIY_PMG	0x01	/* PCI Power Management */
+#define	PCIY_AGP	0x02	/* AGP */
+#define	PCIY_VPD	0x03	/* Vital Product Data */
+#define	PCIY_SLOTID	0x04	/* Slot Identification */
+#define	PCIY_MSI	0x05	/* Message Signaled Interrupts */
+#define	PCIY_CHSWP	0x06	/* CompactPCI Hot Swap */
+#define	PCIY_PCIX	0x07	/* PCI-X */
+#define	PCIY_HT		0x08	/* HyperTransport */
+#define	PCIY_VENDOR	0x09	/* Vendor Unique */
+#define	PCIY_DEBUG	0x0a	/* Debug port */
+#define	PCIY_CRES	0x0b	/* CompactPCI central resource control */
+#define	PCIY_HOTPLUG	0x0c	/* PCI Hot-Plug */
+#define	PCIY_SUBVENDOR	0x0d	/* PCI-PCI bridge subvendor ID */
+#define	PCIY_AGP8X	0x0e	/* AGP 8x */
+#define	PCIY_SECDEV	0x0f	/* Secure Device */
+#define	PCIY_EXPRESS	0x10	/* PCI Express */
+#define	PCIY_MSIX	0x11	/* MSI-X */
+#define	PCIY_SATA	0x12	/* SATA */
+#define	PCIY_PCIAF	0x13	/* PCI Advanced Features */
+
+/* Extended Capability Register Fields */
+
+#define	PCIR_EXTCAP	0x100
+#define	PCIM_EXTCAP_ID		0x0000ffff
+#define	PCIM_EXTCAP_VER		0x000f0000
+#define	PCIM_EXTCAP_NEXTPTR	0xfff00000
+#define	PCI_EXTCAP_ID(ecap)	((ecap) & PCIM_EXTCAP_ID)
+#define	PCI_EXTCAP_VER(ecap)	(((ecap) & PCIM_EXTCAP_VER) >> 16)
+#define	PCI_EXTCAP_NEXTPTR(ecap) (((ecap) & PCIM_EXTCAP_NEXTPTR) >> 20)
+
+/* Extended Capability Identification Numbers */
+
+#define	PCIZ_AER	0x0001	/* Advanced Error Reporting */
+#define	PCIZ_VC		0x0002	/* Virtual Channel */
+#define	PCIZ_SERNUM	0x0003	/* Device Serial Number */
+#define	PCIZ_PWRBDGT	0x0004	/* Power Budgeting */
+#define	PCIZ_RCLINK_DCL	0x0005	/* Root Complex Link Declaration */
+#define	PCIZ_RCLINK_CTL	0x0006	/* Root Complex Internal Link Control */
+#define	PCIZ_RCEC_ASSOC	0x0007	/* Root Complex Event Collector Association */
+#define	PCIZ_MFVC	0x0008	/* Multi-Function Virtual Channel */
+#define	PCIZ_RCRB	0x000a	/* RCRB Header */
+#define	PCIZ_VENDOR	0x000b	/* Vendor Unique */
+#define	PCIZ_ACS	0x000d	/* Access Control Services */
+#define	PCIZ_ARI	0x000e	/* Alternative Routing-ID Interpretation */
+#define	PCIZ_ATS	0x000f	/* Address Translation Services */
+#define	PCIZ_SRIOV	0x0010	/* Single Root IO Virtualization */
+#define	PCIZ_MULTICAST	0x0012	/* Multicast */
+#define	PCIZ_RESIZE_BAR	0x0015	/* Resizable BAR */
+#define	PCIZ_DPA	0x0016	/* Dynamic Power Allocation */
+#define	PCIZ_TPH_REQ	0x0017	/* TPH Requester */
+#define	PCIZ_LTR	0x0018	/* Latency Tolerance Reporting */
+#define	PCIZ_SEC_PCIE	0x0019	/* Secondary PCI Express */
+
+/* config registers for header type 0 devices */
+
+#define	PCIR_BARS	0x10
+#define	PCIR_BAR(x)		(PCIR_BARS + (x) * 4)
+#define	PCIR_MAX_BAR_0		5
+#define	PCI_RID2BAR(rid)	(((rid) - PCIR_BARS) / 4)
+#define	PCI_BAR_IO(x)		(((x) & PCIM_BAR_SPACE) == PCIM_BAR_IO_SPACE)
+#define	PCI_BAR_MEM(x)		(((x) & PCIM_BAR_SPACE) == PCIM_BAR_MEM_SPACE)
+#define	PCIM_BAR_SPACE		0x00000001
+#define	PCIM_BAR_MEM_SPACE	0
+#define	PCIM_BAR_IO_SPACE	1
+#define	PCIM_BAR_MEM_TYPE	0x00000006
+#define	PCIM_BAR_MEM_32		0
+#define	PCIM_BAR_MEM_1MB	2	/* Locate below 1MB in PCI <= 2.1 */
+#define	PCIM_BAR_MEM_64		4
+#define	PCIM_BAR_MEM_PREFETCH	0x00000008
+#define	PCIM_BAR_MEM_BASE	0xfffffffffffffff0ULL
+#define	PCIM_BAR_IO_RESERVED	0x00000002
+#define	PCIM_BAR_IO_BASE	0xfffffffc
+#define	PCIR_CIS	0x28
+#define	PCIM_CIS_ASI_MASK	0x00000007
+#define	PCIM_CIS_ASI_CONFIG	0
+#define	PCIM_CIS_ASI_BAR0	1
+#define	PCIM_CIS_ASI_BAR1	2
+#define	PCIM_CIS_ASI_BAR2	3
+#define	PCIM_CIS_ASI_BAR3	4
+#define	PCIM_CIS_ASI_BAR4	5
+#define	PCIM_CIS_ASI_BAR5	6
+#define	PCIM_CIS_ASI_ROM	7
+#define	PCIM_CIS_ADDR_MASK	0x0ffffff8
+#define	PCIM_CIS_ROM_MASK	0xf0000000
+#define PCIM_CIS_CONFIG_MASK	0xff
+#define	PCIR_SUBVEND_0	0x2c
+#define	PCIR_SUBDEV_0	0x2e
+#define	PCIR_BIOS	0x30
+#define	PCIM_BIOS_ENABLE	0x01
+#define	PCIM_BIOS_ADDR_MASK	0xfffff800
+#define	PCIR_CAP_PTR	0x34
+#define	PCIR_INTLINE	0x3c
+#define	PCIR_INTPIN	0x3d
+#define	PCIR_MINGNT	0x3e
+#define	PCIR_MAXLAT	0x3f
+
+/* config registers for header type 1 (PCI-to-PCI bridge) devices */
+
+#define	PCIR_MAX_BAR_1	1
+#define	PCIR_SECSTAT_1	0x1e
+
+#define	PCIR_PRIBUS_1	0x18
+#define	PCIR_SECBUS_1	0x19
+#define	PCIR_SUBBUS_1	0x1a
+#define	PCIR_SECLAT_1	0x1b
+
+#define	PCIR_IOBASEL_1	0x1c
+#define	PCIR_IOLIMITL_1	0x1d
+#define	PCIR_IOBASEH_1	0x30
+#define	PCIR_IOLIMITH_1	0x32
+#define	PCIM_BRIO_16		0x0
+#define	PCIM_BRIO_32		0x1
+#define	PCIM_BRIO_MASK		0xf
+
+#define	PCIR_MEMBASE_1	0x20
+#define	PCIR_MEMLIMIT_1	0x22
+
+#define	PCIR_PMBASEL_1	0x24
+#define	PCIR_PMLIMITL_1	0x26
+#define	PCIR_PMBASEH_1	0x28
+#define	PCIR_PMLIMITH_1	0x2c
+#define	PCIM_BRPM_32		0x0
+#define	PCIM_BRPM_64		0x1
+#define	PCIM_BRPM_MASK		0xf
+
+#define	PCIR_BIOS_1	0x38
+#define	PCIR_BRIDGECTL_1 0x3e
+
+/* config registers for header type 2 (CardBus) devices */
+
+#define	PCIR_MAX_BAR_2	0
+#define	PCIR_CAP_PTR_2	0x14
+#define	PCIR_SECSTAT_2	0x16
+
+#define	PCIR_PRIBUS_2	0x18
+#define	PCIR_SECBUS_2	0x19
+#define	PCIR_SUBBUS_2	0x1a
+#define	PCIR_SECLAT_2	0x1b
+
+#define	PCIR_MEMBASE0_2	0x1c
+#define	PCIR_MEMLIMIT0_2 0x20
+#define	PCIR_MEMBASE1_2	0x24
+#define	PCIR_MEMLIMIT1_2 0x28
+#define	PCIR_IOBASE0_2	0x2c
+#define	PCIR_IOLIMIT0_2	0x30
+#define	PCIR_IOBASE1_2	0x34
+#define	PCIR_IOLIMIT1_2	0x38
+
+#define	PCIR_BRIDGECTL_2 0x3e
+
+#define	PCIR_SUBVEND_2	0x40
+#define	PCIR_SUBDEV_2	0x42
+
+#define	PCIR_PCCARDIF_2	0x44
+
+/* PCI device class, subclass and programming interface definitions */
+
+#define	PCIC_OLD	0x00
+#define	PCIS_OLD_NONVGA		0x00
+#define	PCIS_OLD_VGA		0x01
+
+#define	PCIC_STORAGE	0x01
+#define	PCIS_STORAGE_SCSI	0x00
+#define	PCIS_STORAGE_IDE	0x01
+#define	PCIP_STORAGE_IDE_MODEPRIM	0x01
+#define	PCIP_STORAGE_IDE_PROGINDPRIM	0x02
+#define	PCIP_STORAGE_IDE_MODESEC	0x04
+#define	PCIP_STORAGE_IDE_PROGINDSEC	0x08
+#define	PCIP_STORAGE_IDE_MASTERDEV	0x80
+#define	PCIS_STORAGE_FLOPPY	0x02
+#define	PCIS_STORAGE_IPI	0x03
+#define	PCIS_STORAGE_RAID	0x04
+#define	PCIS_STORAGE_ATA_ADMA	0x05
+#define	PCIS_STORAGE_SATA	0x06
+#define	PCIP_STORAGE_SATA_AHCI_1_0	0x01
+#define	PCIS_STORAGE_SAS	0x07
+#define	PCIS_STORAGE_NVM	0x08
+#define	PCIP_STORAGE_NVM_NVMHCI_1_0	0x01
+#define	PCIP_STORAGE_NVM_ENTERPRISE_NVMHCI_1_0	0x02
+#define	PCIS_STORAGE_OTHER	0x80
+
+#define	PCIC_NETWORK	0x02
+#define	PCIS_NETWORK_ETHERNET	0x00
+#define	PCIS_NETWORK_TOKENRING	0x01
+#define	PCIS_NETWORK_FDDI	0x02
+#define	PCIS_NETWORK_ATM	0x03
+#define	PCIS_NETWORK_ISDN	0x04
+#define	PCIS_NETWORK_WORLDFIP	0x05
+#define	PCIS_NETWORK_PICMG	0x06
+#define	PCIS_NETWORK_OTHER	0x80
+
+#define	PCIC_DISPLAY	0x03
+#define	PCIS_DISPLAY_VGA	0x00
+#define	PCIS_DISPLAY_XGA	0x01
+#define	PCIS_DISPLAY_3D		0x02
+#define	PCIS_DISPLAY_OTHER	0x80
+
+#define	PCIC_MULTIMEDIA	0x04
+#define	PCIS_MULTIMEDIA_VIDEO	0x00
+#define	PCIS_MULTIMEDIA_AUDIO	0x01
+#define	PCIS_MULTIMEDIA_TELE	0x02
+#define	PCIS_MULTIMEDIA_HDA	0x03
+#define	PCIS_MULTIMEDIA_OTHER	0x80
+
+#define	PCIC_MEMORY	0x05
+#define	PCIS_MEMORY_RAM		0x00
+#define	PCIS_MEMORY_FLASH	0x01
+#define	PCIS_MEMORY_OTHER	0x80
+
+#define	PCIC_BRIDGE	0x06
+#define	PCIS_BRIDGE_HOST	0x00
+#define	PCIS_BRIDGE_ISA		0x01
+#define	PCIS_BRIDGE_EISA	0x02
+#define	PCIS_BRIDGE_MCA		0x03
+#define	PCIS_BRIDGE_PCI		0x04
+#define	PCIP_BRIDGE_PCI_SUBTRACTIVE	0x01
+#define	PCIS_BRIDGE_PCMCIA	0x05
+#define	PCIS_BRIDGE_NUBUS	0x06
+#define	PCIS_BRIDGE_CARDBUS	0x07
+#define	PCIS_BRIDGE_RACEWAY	0x08
+#define	PCIS_BRIDGE_PCI_TRANSPARENT 0x09
+#define	PCIS_BRIDGE_INFINIBAND	0x0a
+#define	PCIS_BRIDGE_OTHER	0x80
+
+#define	PCIC_SIMPLECOMM	0x07
+#define	PCIS_SIMPLECOMM_UART	0x00
+#define	PCIP_SIMPLECOMM_UART_8250	0x00
+#define	PCIP_SIMPLECOMM_UART_16450A	0x01
+#define	PCIP_SIMPLECOMM_UART_16550A	0x02
+#define	PCIP_SIMPLECOMM_UART_16650A	0x03
+#define	PCIP_SIMPLECOMM_UART_16750A	0x04
+#define	PCIP_SIMPLECOMM_UART_16850A	0x05
+#define	PCIP_SIMPLECOMM_UART_16950A	0x06
+#define	PCIS_SIMPLECOMM_PAR	0x01
+#define	PCIS_SIMPLECOMM_MULSER	0x02
+#define	PCIS_SIMPLECOMM_MODEM	0x03
+#define	PCIS_SIMPLECOMM_GPIB	0x04
+#define	PCIS_SIMPLECOMM_SMART_CARD 0x05
+#define	PCIS_SIMPLECOMM_OTHER	0x80
+
+#define	PCIC_BASEPERIPH	0x08
+#define	PCIS_BASEPERIPH_PIC	0x00
+#define	PCIP_BASEPERIPH_PIC_8259A	0x00
+#define	PCIP_BASEPERIPH_PIC_ISA		0x01
+#define	PCIP_BASEPERIPH_PIC_EISA	0x02
+#define	PCIP_BASEPERIPH_PIC_IO_APIC	0x10
+#define	PCIP_BASEPERIPH_PIC_IOX_APIC	0x20
+#define	PCIS_BASEPERIPH_DMA	0x01
+#define	PCIS_BASEPERIPH_TIMER	0x02
+#define	PCIS_BASEPERIPH_RTC	0x03
+#define	PCIS_BASEPERIPH_PCIHOT	0x04
+#define	PCIS_BASEPERIPH_SDHC	0x05
+#define	PCIS_BASEPERIPH_OTHER	0x80
+
+#define	PCIC_INPUTDEV	0x09
+#define	PCIS_INPUTDEV_KEYBOARD	0x00
+#define	PCIS_INPUTDEV_DIGITIZER	0x01
+#define	PCIS_INPUTDEV_MOUSE	0x02
+#define	PCIS_INPUTDEV_SCANNER	0x03
+#define	PCIS_INPUTDEV_GAMEPORT	0x04
+#define	PCIS_INPUTDEV_OTHER	0x80
+
+#define	PCIC_DOCKING	0x0a
+#define	PCIS_DOCKING_GENERIC	0x00
+#define	PCIS_DOCKING_OTHER	0x80
+
+#define	PCIC_PROCESSOR	0x0b
+#define	PCIS_PROCESSOR_386	0x00
+#define	PCIS_PROCESSOR_486	0x01
+#define	PCIS_PROCESSOR_PENTIUM	0x02
+#define	PCIS_PROCESSOR_ALPHA	0x10
+#define	PCIS_PROCESSOR_POWERPC	0x20
+#define	PCIS_PROCESSOR_MIPS	0x30
+#define	PCIS_PROCESSOR_COPROC	0x40
+
+#define	PCIC_SERIALBUS	0x0c
+#define	PCIS_SERIALBUS_FW	0x00
+#define	PCIS_SERIALBUS_ACCESS	0x01
+#define	PCIS_SERIALBUS_SSA	0x02
+#define	PCIS_SERIALBUS_USB	0x03
+#define	PCIP_SERIALBUS_USB_UHCI		0x00
+#define	PCIP_SERIALBUS_USB_OHCI		0x10
+#define	PCIP_SERIALBUS_USB_EHCI		0x20
+#define	PCIP_SERIALBUS_USB_XHCI		0x30
+#define	PCIP_SERIALBUS_USB_DEVICE	0xfe
+#define	PCIS_SERIALBUS_FC	0x04
+#define	PCIS_SERIALBUS_SMBUS	0x05
+#define	PCIS_SERIALBUS_INFINIBAND 0x06
+#define	PCIS_SERIALBUS_IPMI	0x07
+#define	PCIP_SERIALBUS_IPMI_SMIC	0x00
+#define	PCIP_SERIALBUS_IPMI_KCS		0x01
+#define	PCIP_SERIALBUS_IPMI_BT		0x02
+#define	PCIS_SERIALBUS_SERCOS	0x08
+#define	PCIS_SERIALBUS_CANBUS	0x09
+
+#define	PCIC_WIRELESS	0x0d
+#define	PCIS_WIRELESS_IRDA	0x00
+#define	PCIS_WIRELESS_IR	0x01
+#define	PCIS_WIRELESS_RF	0x10
+#define	PCIS_WIRELESS_BLUETOOTH	0x11
+#define	PCIS_WIRELESS_BROADBAND	0x12
+#define	PCIS_WIRELESS_80211A	0x20
+#define	PCIS_WIRELESS_80211B	0x21
+#define	PCIS_WIRELESS_OTHER	0x80
+
+#define	PCIC_INTELLIIO	0x0e
+#define	PCIS_INTELLIIO_I2O	0x00
+
+#define	PCIC_SATCOM	0x0f
+#define	PCIS_SATCOM_TV		0x01
+#define	PCIS_SATCOM_AUDIO	0x02
+#define	PCIS_SATCOM_VOICE	0x03
+#define	PCIS_SATCOM_DATA	0x04
+
+#define	PCIC_CRYPTO	0x10
+#define	PCIS_CRYPTO_NETCOMP	0x00
+#define	PCIS_CRYPTO_ENTERTAIN	0x10
+#define	PCIS_CRYPTO_OTHER	0x80
+
+#define	PCIC_DASP	0x11
+#define	PCIS_DASP_DPIO		0x00
+#define	PCIS_DASP_PERFCNTRS	0x01
+#define	PCIS_DASP_COMM_SYNC	0x10
+#define	PCIS_DASP_MGMT_CARD	0x20
+#define	PCIS_DASP_OTHER		0x80
+
+#define	PCIC_OTHER	0xff
+
+/* Bridge Control Values. */
+#define	PCIB_BCR_PERR_ENABLE		0x0001
+#define	PCIB_BCR_SERR_ENABLE		0x0002
+#define	PCIB_BCR_ISA_ENABLE		0x0004
+#define	PCIB_BCR_VGA_ENABLE		0x0008
+#define	PCIB_BCR_MASTER_ABORT_MODE	0x0020
+#define	PCIB_BCR_SECBUS_RESET		0x0040
+#define	PCIB_BCR_SECBUS_BACKTOBACK	0x0080
+#define	PCIB_BCR_PRI_DISCARD_TIMEOUT	0x0100
+#define	PCIB_BCR_SEC_DISCARD_TIMEOUT	0x0200
+#define	PCIB_BCR_DISCARD_TIMER_STATUS	0x0400
+#define	PCIB_BCR_DISCARD_TIMER_SERREN	0x0800
+
+/* PCI power manangement */
+#define	PCIR_POWER_CAP		0x2
+#define	PCIM_PCAP_SPEC			0x0007
+#define	PCIM_PCAP_PMEREQCLK		0x0008
+#define	PCIM_PCAP_DEVSPECINIT		0x0020
+#define	PCIM_PCAP_AUXPWR_0		0x0000
+#define	PCIM_PCAP_AUXPWR_55		0x0040
+#define	PCIM_PCAP_AUXPWR_100		0x0080
+#define	PCIM_PCAP_AUXPWR_160		0x00c0
+#define	PCIM_PCAP_AUXPWR_220		0x0100
+#define	PCIM_PCAP_AUXPWR_270		0x0140
+#define	PCIM_PCAP_AUXPWR_320		0x0180
+#define	PCIM_PCAP_AUXPWR_375		0x01c0
+#define	PCIM_PCAP_AUXPWRMASK		0x01c0
+#define	PCIM_PCAP_D1SUPP		0x0200
+#define	PCIM_PCAP_D2SUPP		0x0400
+#define	PCIM_PCAP_D0PME			0x0800
+#define	PCIM_PCAP_D1PME			0x1000
+#define	PCIM_PCAP_D2PME			0x2000
+#define	PCIM_PCAP_D3PME_HOT		0x4000
+#define	PCIM_PCAP_D3PME_COLD		0x8000
+
+#define	PCIR_POWER_STATUS	0x4
+#define	PCIM_PSTAT_D0			0x0000
+#define	PCIM_PSTAT_D1			0x0001
+#define	PCIM_PSTAT_D2			0x0002
+#define	PCIM_PSTAT_D3			0x0003
+#define	PCIM_PSTAT_DMASK		0x0003
+#define	PCIM_PSTAT_NOSOFTRESET		0x0008
+#define	PCIM_PSTAT_PMEENABLE		0x0100
+#define	PCIM_PSTAT_D0POWER		0x0000
+#define	PCIM_PSTAT_D1POWER		0x0200
+#define	PCIM_PSTAT_D2POWER		0x0400
+#define	PCIM_PSTAT_D3POWER		0x0600
+#define	PCIM_PSTAT_D0HEAT		0x0800
+#define	PCIM_PSTAT_D1HEAT		0x0a00
+#define	PCIM_PSTAT_D2HEAT		0x0c00
+#define	PCIM_PSTAT_D3HEAT		0x0e00
+#define	PCIM_PSTAT_DATASELMASK		0x1e00
+#define	PCIM_PSTAT_DATAUNKN		0x0000
+#define	PCIM_PSTAT_DATADIV10		0x2000
+#define	PCIM_PSTAT_DATADIV100		0x4000
+#define	PCIM_PSTAT_DATADIV1000		0x6000
+#define	PCIM_PSTAT_DATADIVMASK		0x6000
+#define	PCIM_PSTAT_PME			0x8000
+
+#define	PCIR_POWER_BSE		0x6
+#define	PCIM_PMCSR_BSE_D3B3		0x00
+#define	PCIM_PMCSR_BSE_D3B2		0x40
+#define	PCIM_PMCSR_BSE_BPCCE		0x80
+
+#define	PCIR_POWER_DATA		0x7
+
+/* VPD capability registers */
+#define	PCIR_VPD_ADDR		0x2
+#define	PCIR_VPD_DATA		0x4
+
+/* PCI Message Signalled Interrupts (MSI) */
+#define	PCIR_MSI_CTRL		0x2
+#define	PCIM_MSICTRL_VECTOR		0x0100
+#define	PCIM_MSICTRL_64BIT		0x0080
+#define	PCIM_MSICTRL_MME_MASK		0x0070
+#define	PCIM_MSICTRL_MME_1		0x0000
+#define	PCIM_MSICTRL_MME_2		0x0010
+#define	PCIM_MSICTRL_MME_4		0x0020
+#define	PCIM_MSICTRL_MME_8		0x0030
+#define	PCIM_MSICTRL_MME_16		0x0040
+#define	PCIM_MSICTRL_MME_32		0x0050
+#define	PCIM_MSICTRL_MMC_MASK		0x000E
+#define	PCIM_MSICTRL_MMC_1		0x0000
+#define	PCIM_MSICTRL_MMC_2		0x0002
+#define	PCIM_MSICTRL_MMC_4		0x0004
+#define	PCIM_MSICTRL_MMC_8		0x0006
+#define	PCIM_MSICTRL_MMC_16		0x0008
+#define	PCIM_MSICTRL_MMC_32		0x000A
+#define	PCIM_MSICTRL_MSI_ENABLE		0x0001
+#define	PCIR_MSI_ADDR		0x4
+#define	PCIR_MSI_ADDR_HIGH	0x8
+#define	PCIR_MSI_DATA		0x8
+#define	PCIR_MSI_DATA_64BIT	0xc
+#define	PCIR_MSI_MASK		0x10
+#define	PCIR_MSI_PENDING	0x14
+
+/* PCI-X definitions */
+
+/* For header type 0 devices */
+#define	PCIXR_COMMAND		0x2
+#define	PCIXM_COMMAND_DPERR_E		0x0001	/* Data Parity Error Recovery */
+#define	PCIXM_COMMAND_ERO		0x0002	/* Enable Relaxed Ordering */
+#define	PCIXM_COMMAND_MAX_READ		0x000c	/* Maximum Burst Read Count */
+#define	PCIXM_COMMAND_MAX_READ_512	0x0000
+#define	PCIXM_COMMAND_MAX_READ_1024	0x0004
+#define	PCIXM_COMMAND_MAX_READ_2048	0x0008
+#define	PCIXM_COMMAND_MAX_READ_4096	0x000c
+#define	PCIXM_COMMAND_MAX_SPLITS 	0x0070	/* Maximum Split Transactions */
+#define	PCIXM_COMMAND_MAX_SPLITS_1	0x0000
+#define	PCIXM_COMMAND_MAX_SPLITS_2	0x0010
+#define	PCIXM_COMMAND_MAX_SPLITS_3	0x0020
+#define	PCIXM_COMMAND_MAX_SPLITS_4	0x0030
+#define	PCIXM_COMMAND_MAX_SPLITS_8	0x0040
+#define	PCIXM_COMMAND_MAX_SPLITS_12	0x0050
+#define	PCIXM_COMMAND_MAX_SPLITS_16	0x0060
+#define	PCIXM_COMMAND_MAX_SPLITS_32	0x0070
+#define	PCIXM_COMMAND_VERSION		0x3000
+#define	PCIXR_STATUS		0x4
+#define	PCIXM_STATUS_DEVFN		0x000000FF
+#define	PCIXM_STATUS_BUS		0x0000FF00
+#define	PCIXM_STATUS_64BIT		0x00010000
+#define	PCIXM_STATUS_133CAP		0x00020000
+#define	PCIXM_STATUS_SC_DISCARDED	0x00040000
+#define	PCIXM_STATUS_UNEXP_SC		0x00080000
+#define	PCIXM_STATUS_COMPLEX_DEV	0x00100000
+#define	PCIXM_STATUS_MAX_READ		0x00600000
+#define	PCIXM_STATUS_MAX_READ_512	0x00000000
+#define	PCIXM_STATUS_MAX_READ_1024	0x00200000
+#define	PCIXM_STATUS_MAX_READ_2048	0x00400000
+#define	PCIXM_STATUS_MAX_READ_4096	0x00600000
+#define	PCIXM_STATUS_MAX_SPLITS		0x03800000
+#define	PCIXM_STATUS_MAX_SPLITS_1	0x00000000
+#define	PCIXM_STATUS_MAX_SPLITS_2	0x00800000
+#define	PCIXM_STATUS_MAX_SPLITS_3	0x01000000
+#define	PCIXM_STATUS_MAX_SPLITS_4	0x01800000
+#define	PCIXM_STATUS_MAX_SPLITS_8	0x02000000
+#define	PCIXM_STATUS_MAX_SPLITS_12	0x02800000
+#define	PCIXM_STATUS_MAX_SPLITS_16	0x03000000
+#define	PCIXM_STATUS_MAX_SPLITS_32	0x03800000
+#define	PCIXM_STATUS_MAX_CUM_READ	0x1C000000
+#define	PCIXM_STATUS_RCVD_SC_ERR	0x20000000
+#define	PCIXM_STATUS_266CAP		0x40000000
+#define	PCIXM_STATUS_533CAP		0x80000000
+
+/* For header type 1 devices (PCI-X bridges) */
+#define	PCIXR_SEC_STATUS	0x2
+#define	PCIXM_SEC_STATUS_64BIT		0x0001
+#define	PCIXM_SEC_STATUS_133CAP		0x0002
+#define	PCIXM_SEC_STATUS_SC_DISC	0x0004
+#define	PCIXM_SEC_STATUS_UNEXP_SC	0x0008
+#define	PCIXM_SEC_STATUS_SC_OVERRUN	0x0010
+#define	PCIXM_SEC_STATUS_SR_DELAYED	0x0020
+#define	PCIXM_SEC_STATUS_BUS_MODE	0x03c0
+#define	PCIXM_SEC_STATUS_VERSION	0x3000
+#define	PCIXM_SEC_STATUS_266CAP		0x4000
+#define	PCIXM_SEC_STATUS_533CAP		0x8000
+#define	PCIXR_BRIDGE_STATUS	0x4
+#define	PCIXM_BRIDGE_STATUS_DEVFN	0x000000FF
+#define	PCIXM_BRIDGE_STATUS_BUS		0x0000FF00
+#define	PCIXM_BRIDGE_STATUS_64BIT	0x00010000
+#define	PCIXM_BRIDGE_STATUS_133CAP	0x00020000
+#define	PCIXM_BRIDGE_STATUS_SC_DISCARDED 0x00040000
+#define	PCIXM_BRIDGE_STATUS_UNEXP_SC	0x00080000
+#define	PCIXM_BRIDGE_STATUS_SC_OVERRUN	0x00100000
+#define	PCIXM_BRIDGE_STATUS_SR_DELAYED	0x00200000
+#define	PCIXM_BRIDGE_STATUS_DEVID_MSGCAP 0x20000000
+#define	PCIXM_BRIDGE_STATUS_266CAP	0x40000000
+#define	PCIXM_BRIDGE_STATUS_533CAP	0x80000000
+
+/* HT (HyperTransport) Capability definitions */
+#define	PCIR_HT_COMMAND		0x2
+#define	PCIM_HTCMD_CAP_MASK		0xf800	/* Capability type. */
+#define	PCIM_HTCAP_SLAVE		0x0000	/* 000xx */
+#define	PCIM_HTCAP_HOST			0x2000	/* 001xx */
+#define	PCIM_HTCAP_SWITCH		0x4000	/* 01000 */
+#define	PCIM_HTCAP_INTERRUPT		0x8000	/* 10000 */
+#define	PCIM_HTCAP_REVISION_ID		0x8800	/* 10001 */
+#define	PCIM_HTCAP_UNITID_CLUMPING	0x9000	/* 10010 */
+#define	PCIM_HTCAP_EXT_CONFIG_SPACE	0x9800	/* 10011 */
+#define	PCIM_HTCAP_ADDRESS_MAPPING	0xa000	/* 10100 */
+#define	PCIM_HTCAP_MSI_MAPPING		0xa800	/* 10101 */
+#define	PCIM_HTCAP_DIRECT_ROUTE		0xb000	/* 10110 */
+#define	PCIM_HTCAP_VCSET		0xb800	/* 10111 */
+#define	PCIM_HTCAP_RETRY_MODE		0xc000	/* 11000 */
+#define	PCIM_HTCAP_X86_ENCODING		0xc800	/* 11001 */
+#define	PCIM_HTCAP_GEN3			0xd000	/* 11010 */
+#define	PCIM_HTCAP_FLE			0xd800	/* 11011 */
+#define	PCIM_HTCAP_PM			0xe000	/* 11100 */
+#define	PCIM_HTCAP_HIGH_NODE_COUNT	0xe800	/* 11101 */
+
+/* HT MSI Mapping Capability definitions. */
+#define	PCIM_HTCMD_MSI_ENABLE		0x0001
+#define	PCIM_HTCMD_MSI_FIXED		0x0002
+#define	PCIR_HTMSI_ADDRESS_LO	0x4
+#define	PCIR_HTMSI_ADDRESS_HI	0x8
+
+/* PCI Vendor capability definitions */
+#define	PCIR_VENDOR_LENGTH	0x2
+#define	PCIR_VENDOR_DATA	0x3
+
+/* PCI EHCI Debug Port definitions */
+#define	PCIR_DEBUG_PORT		0x2
+#define	PCIM_DEBUG_PORT_OFFSET		0x1FFF
+#define	PCIM_DEBUG_PORT_BAR		0xe000
+
+/* PCI-PCI Bridge Subvendor definitions */
+#define	PCIR_SUBVENDCAP_ID	0x4
+
+/* PCI Express definitions */
+#define	PCIER_FLAGS		0x2
+#define	PCIEM_FLAGS_VERSION		0x000F
+#define	PCIEM_FLAGS_TYPE		0x00F0
+#define	PCIEM_TYPE_ENDPOINT		0x0000
+#define	PCIEM_TYPE_LEGACY_ENDPOINT	0x0010
+#define	PCIEM_TYPE_ROOT_PORT		0x0040
+#define	PCIEM_TYPE_UPSTREAM_PORT	0x0050
+#define	PCIEM_TYPE_DOWNSTREAM_PORT	0x0060
+#define	PCIEM_TYPE_PCI_BRIDGE		0x0070
+#define	PCIEM_TYPE_PCIE_BRIDGE		0x0080
+#define	PCIEM_TYPE_ROOT_INT_EP		0x0090
+#define	PCIEM_TYPE_ROOT_EC		0x00a0
+#define	PCIEM_FLAGS_SLOT		0x0100
+#define	PCIEM_FLAGS_IRQ			0x3e00
+#define	PCIER_DEVICE_CAP	0x4
+#define	PCIEM_CAP_MAX_PAYLOAD		0x00000007
+#define	PCIEM_CAP_PHANTHOM_FUNCS	0x00000018
+#define	PCIEM_CAP_EXT_TAG_FIELD		0x00000020
+#define	PCIEM_CAP_L0S_LATENCY		0x000001c0
+#define	PCIEM_CAP_L1_LATENCY		0x00000e00
+#define	PCIEM_CAP_ROLE_ERR_RPT		0x00008000
+#define	PCIEM_CAP_SLOT_PWR_LIM_VAL	0x03fc0000
+#define	PCIEM_CAP_SLOT_PWR_LIM_SCALE	0x0c000000
+#define	PCIEM_CAP_FLR			0x10000000
+#define	PCIER_DEVICE_CTL	0x8
+#define	PCIEM_CTL_COR_ENABLE		0x0001
+#define	PCIEM_CTL_NFER_ENABLE		0x0002
+#define	PCIEM_CTL_FER_ENABLE		0x0004
+#define	PCIEM_CTL_URR_ENABLE		0x0008
+#define	PCIEM_CTL_RELAXED_ORD_ENABLE	0x0010
+#define	PCIEM_CTL_MAX_PAYLOAD		0x00e0
+#define	PCIEM_CTL_EXT_TAG_FIELD		0x0100
+#define	PCIEM_CTL_PHANTHOM_FUNCS	0x0200
+#define	PCIEM_CTL_AUX_POWER_PM		0x0400
+#define	PCIEM_CTL_NOSNOOP_ENABLE	0x0800
+#define	PCIEM_CTL_MAX_READ_REQUEST	0x7000
+#define	PCIEM_CTL_BRDG_CFG_RETRY	0x8000	/* PCI-E - PCI/PCI-X bridges */
+#define	PCIEM_CTL_INITIATE_FLR		0x8000	/* FLR capable endpoints */
+#define	PCIER_DEVICE_STA	0xa
+#define	PCIEM_STA_CORRECTABLE_ERROR	0x0001
+#define	PCIEM_STA_NON_FATAL_ERROR	0x0002
+#define	PCIEM_STA_FATAL_ERROR		0x0004
+#define	PCIEM_STA_UNSUPPORTED_REQ	0x0008
+#define	PCIEM_STA_AUX_POWER		0x0010
+#define	PCIEM_STA_TRANSACTION_PND	0x0020
+#define	PCIER_LINK_CAP		0xc
+#define	PCIEM_LINK_CAP_MAX_SPEED	0x0000000f
+#define	PCIEM_LINK_CAP_MAX_WIDTH	0x000003f0
+#define	PCIEM_LINK_CAP_ASPM		0x00000c00
+#define	PCIEM_LINK_CAP_L0S_EXIT		0x00007000
+#define	PCIEM_LINK_CAP_L1_EXIT		0x00038000
+#define	PCIEM_LINK_CAP_CLOCK_PM		0x00040000
+#define	PCIEM_LINK_CAP_SURPRISE_DOWN	0x00080000
+#define	PCIEM_LINK_CAP_DL_ACTIVE	0x00100000
+#define	PCIEM_LINK_CAP_LINK_BW_NOTIFY	0x00200000
+#define	PCIEM_LINK_CAP_ASPM_COMPLIANCE	0x00400000
+#define	PCIEM_LINK_CAP_PORT		0xff000000
+#define	PCIER_LINK_CTL		0x10
+#define	PCIEM_LINK_CTL_ASPMC_DIS	0x0000
+#define	PCIEM_LINK_CTL_ASPMC_L0S	0x0001
+#define	PCIEM_LINK_CTL_ASPMC_L1		0x0002
+#define	PCIEM_LINK_CTL_ASPMC		0x0003
+#define	PCIEM_LINK_CTL_RCB		0x0008
+#define	PCIEM_LINK_CTL_LINK_DIS		0x0010
+#define	PCIEM_LINK_CTL_RETRAIN_LINK	0x0020
+#define	PCIEM_LINK_CTL_COMMON_CLOCK	0x0040
+#define	PCIEM_LINK_CTL_EXTENDED_SYNC	0x0080
+#define	PCIEM_LINK_CTL_ECPM		0x0100
+#define	PCIEM_LINK_CTL_HAWD		0x0200
+#define	PCIEM_LINK_CTL_LBMIE		0x0400
+#define	PCIEM_LINK_CTL_LABIE		0x0800
+#define	PCIER_LINK_STA		0x12
+#define	PCIEM_LINK_STA_SPEED		0x000f
+#define	PCIEM_LINK_STA_WIDTH		0x03f0
+#define	PCIEM_LINK_STA_TRAINING_ERROR	0x0400
+#define	PCIEM_LINK_STA_TRAINING		0x0800
+#define	PCIEM_LINK_STA_SLOT_CLOCK	0x1000
+#define	PCIEM_LINK_STA_DL_ACTIVE	0x2000
+#define	PCIEM_LINK_STA_LINK_BW_MGMT	0x4000
+#define	PCIEM_LINK_STA_LINK_AUTO_BW	0x8000
+#define	PCIER_SLOT_CAP		0x14
+#define	PCIEM_SLOT_CAP_APB		0x00000001
+#define	PCIEM_SLOT_CAP_PCP		0x00000002
+#define	PCIEM_SLOT_CAP_MRLSP		0x00000004
+#define	PCIEM_SLOT_CAP_AIP		0x00000008
+#define	PCIEM_SLOT_CAP_PIP		0x00000010
+#define	PCIEM_SLOT_CAP_HPS		0x00000020
+#define	PCIEM_SLOT_CAP_HPC		0x00000040
+#define	PCIEM_SLOT_CAP_SPLV		0x00007f80
+#define	PCIEM_SLOT_CAP_SPLS		0x00018000
+#define	PCIEM_SLOT_CAP_EIP		0x00020000
+#define	PCIEM_SLOT_CAP_NCCS		0x00040000
+#define	PCIEM_SLOT_CAP_PSN		0xfff80000
+#define	PCIER_SLOT_CTL		0x18
+#define	PCIEM_SLOT_CTL_ABPE		0x0001
+#define	PCIEM_SLOT_CTL_PFDE		0x0002
+#define	PCIEM_SLOT_CTL_MRLSCE		0x0004
+#define	PCIEM_SLOT_CTL_PDCE		0x0008
+#define	PCIEM_SLOT_CTL_CCIE		0x0010
+#define	PCIEM_SLOT_CTL_HPIE		0x0020
+#define	PCIEM_SLOT_CTL_AIC		0x00c0
+#define	PCIEM_SLOT_CTL_PIC		0x0300
+#define	PCIEM_SLOT_CTL_PCC		0x0400
+#define	PCIEM_SLOT_CTL_EIC		0x0800
+#define	PCIEM_SLOT_CTL_DLLSCE		0x1000
+#define	PCIER_SLOT_STA		0x1a
+#define	PCIEM_SLOT_STA_ABP		0x0001
+#define	PCIEM_SLOT_STA_PFD		0x0002
+#define	PCIEM_SLOT_STA_MRLSC		0x0004
+#define	PCIEM_SLOT_STA_PDC		0x0008
+#define	PCIEM_SLOT_STA_CC		0x0010
+#define	PCIEM_SLOT_STA_MRLSS		0x0020
+#define	PCIEM_SLOT_STA_PDS		0x0040
+#define	PCIEM_SLOT_STA_EIS		0x0080
+#define	PCIEM_SLOT_STA_DLLSC		0x0100
+#define	PCIER_ROOT_CTL		0x1c
+#define	PCIER_ROOT_CAP		0x1e
+#define	PCIER_ROOT_STA		0x20
+#define	PCIER_DEVICE_CAP2	0x24
+#define	PCIER_DEVICE_CTL2	0x28
+#define	PCIEM_CTL2_COMP_TIMEOUT_VAL	0x000f
+#define	PCIEM_CTL2_COMP_TIMEOUT_DIS	0x0010
+#define	PCIEM_CTL2_ARI			0x0020
+#define	PCIEM_CTL2_ATOMIC_REQ_ENABLE	0x0040
+#define	PCIEM_CTL2_ATOMIC_EGR_BLOCK	0x0080
+#define	PCIEM_CTL2_ID_ORDERED_REQ_EN	0x0100
+#define	PCIEM_CTL2_ID_ORDERED_CMP_EN	0x0200
+#define	PCIEM_CTL2_LTR_ENABLE		0x0400
+#define	PCIEM_CTL2_OBFF			0x6000
+#define	PCIEM_OBFF_DISABLE		0x0000
+#define	PCIEM_OBFF_MSGA_ENABLE		0x2000
+#define	PCIEM_OBFF_MSGB_ENABLE		0x4000
+#define	PCIEM_OBFF_WAKE_ENABLE		0x6000
+#define	PCIEM_CTL2_END2END_TLP		0x8000
+#define	PCIER_DEVICE_STA2	0x2a
+#define	PCIER_LINK_CAP2		0x2c
+#define	PCIER_LINK_CTL2		0x30
+#define	PCIER_LINK_STA2		0x32
+#define	PCIER_SLOT_CAP2		0x34
+#define	PCIER_SLOT_CTL2		0x38
+#define	PCIER_SLOT_STA2		0x3a
+
+/* Old compatibility definitions for PCI Express registers */
+#define	PCIR_EXPRESS_FLAGS		PCIER_FLAGS
+#define	PCIM_EXP_FLAGS_VERSION		PCIEM_FLAGS_VERSION	
+#define	PCIM_EXP_FLAGS_TYPE		PCIEM_FLAGS_TYPE	
+#define	PCIM_EXP_TYPE_ENDPOINT		PCIEM_TYPE_ENDPOINT	
+#define	PCIM_EXP_TYPE_LEGACY_ENDPOINT	PCIEM_TYPE_LEGACY_ENDPOINT
+#define	PCIM_EXP_TYPE_ROOT_PORT		PCIEM_TYPE_ROOT_PORT	
+#define	PCIM_EXP_TYPE_UPSTREAM_PORT	PCIEM_TYPE_UPSTREAM_PORT
+#define	PCIM_EXP_TYPE_DOWNSTREAM_PORT	PCIEM_TYPE_DOWNSTREAM_PORT
+#define	PCIM_EXP_TYPE_PCI_BRIDGE	PCIEM_TYPE_PCI_BRIDGE
+#define	PCIM_EXP_TYPE_PCIE_BRIDGE	PCIEM_TYPE_PCIE_BRIDGE
+#define	PCIM_EXP_TYPE_ROOT_INT_EP	PCIEM_TYPE_ROOT_INT_EP
+#define	PCIM_EXP_TYPE_ROOT_EC		PCIEM_TYPE_ROOT_EC	
+#define	PCIM_EXP_FLAGS_SLOT		PCIEM_FLAGS_SLOT	
+#define	PCIM_EXP_FLAGS_IRQ		PCIEM_FLAGS_IRQ	
+#define	PCIR_EXPRESS_DEVICE_CAP		PCIER_DEVICE_CAP
+#define	PCIM_EXP_CAP_MAX_PAYLOAD	PCIEM_CAP_MAX_PAYLOAD
+#define	PCIM_EXP_CAP_PHANTHOM_FUNCS	PCIEM_CAP_PHANTHOM_FUNCS
+#define	PCIM_EXP_CAP_EXT_TAG_FIELD	PCIEM_CAP_EXT_TAG_FIELD
+#define	PCIM_EXP_CAP_L0S_LATENCY	PCIEM_CAP_L0S_LATENCY
+#define	PCIM_EXP_CAP_L1_LATENCY		PCIEM_CAP_L1_LATENCY	
+#define	PCIM_EXP_CAP_ROLE_ERR_RPT	PCIEM_CAP_ROLE_ERR_RPT
+#define	PCIM_EXP_CAP_SLOT_PWR_LIM_VAL	PCIEM_CAP_SLOT_PWR_LIM_VAL
+#define	PCIM_EXP_CAP_SLOT_PWR_LIM_SCALE	PCIEM_CAP_SLOT_PWR_LIM_SCALE
+#define	PCIM_EXP_CAP_FLR		PCIEM_CAP_FLR	
+#define	PCIR_EXPRESS_DEVICE_CTL		PCIER_DEVICE_CTL
+#define	PCIM_EXP_CTL_COR_ENABLE		PCIEM_CTL_COR_ENABLE	
+#define	PCIM_EXP_CTL_NFER_ENABLE	PCIEM_CTL_NFER_ENABLE
+#define	PCIM_EXP_CTL_FER_ENABLE		PCIEM_CTL_FER_ENABLE	
+#define	PCIM_EXP_CTL_URR_ENABLE		PCIEM_CTL_URR_ENABLE	
+#define	PCIM_EXP_CTL_RELAXED_ORD_ENABLE	PCIEM_CTL_RELAXED_ORD_ENABLE
+#define	PCIM_EXP_CTL_MAX_PAYLOAD	PCIEM_CTL_MAX_PAYLOAD
+#define	PCIM_EXP_CTL_EXT_TAG_FIELD	PCIEM_CTL_EXT_TAG_FIELD
+#define	PCIM_EXP_CTL_PHANTHOM_FUNCS	PCIEM_CTL_PHANTHOM_FUNCS
+#define	PCIM_EXP_CTL_AUX_POWER_PM	PCIEM_CTL_AUX_POWER_PM
+#define	PCIM_EXP_CTL_NOSNOOP_ENABLE	PCIEM_CTL_NOSNOOP_ENABLE
+#define	PCIM_EXP_CTL_MAX_READ_REQUEST	PCIEM_CTL_MAX_READ_REQUEST
+#define	PCIM_EXP_CTL_BRDG_CFG_RETRY	PCIEM_CTL_BRDG_CFG_RETRY
+#define	PCIM_EXP_CTL_INITIATE_FLR	PCIEM_CTL_INITIATE_FLR
+#define	PCIR_EXPRESS_DEVICE_STA		PCIER_DEVICE_STA
+#define	PCIM_EXP_STA_CORRECTABLE_ERROR	PCIEM_STA_CORRECTABLE_ERROR
+#define	PCIM_EXP_STA_NON_FATAL_ERROR	PCIEM_STA_NON_FATAL_ERROR
+#define	PCIM_EXP_STA_FATAL_ERROR	PCIEM_STA_FATAL_ERROR
+#define	PCIM_EXP_STA_UNSUPPORTED_REQ	PCIEM_STA_UNSUPPORTED_REQ
+#define	PCIM_EXP_STA_AUX_POWER		PCIEM_STA_AUX_POWER	
+#define	PCIM_EXP_STA_TRANSACTION_PND	PCIEM_STA_TRANSACTION_PND
+#define	PCIR_EXPRESS_LINK_CAP		PCIER_LINK_CAP
+#define	PCIM_LINK_CAP_MAX_SPEED		PCIEM_LINK_CAP_MAX_SPEED	
+#define	PCIM_LINK_CAP_MAX_WIDTH		PCIEM_LINK_CAP_MAX_WIDTH	
+#define	PCIM_LINK_CAP_ASPM		PCIEM_LINK_CAP_ASPM	
+#define	PCIM_LINK_CAP_L0S_EXIT		PCIEM_LINK_CAP_L0S_EXIT	
+#define	PCIM_LINK_CAP_L1_EXIT		PCIEM_LINK_CAP_L1_EXIT	
+#define	PCIM_LINK_CAP_CLOCK_PM		PCIEM_LINK_CAP_CLOCK_PM	
+#define	PCIM_LINK_CAP_SURPRISE_DOWN	PCIEM_LINK_CAP_SURPRISE_DOWN
+#define	PCIM_LINK_CAP_DL_ACTIVE		PCIEM_LINK_CAP_DL_ACTIVE	
+#define	PCIM_LINK_CAP_LINK_BW_NOTIFY	PCIEM_LINK_CAP_LINK_BW_NOTIFY
+#define	PCIM_LINK_CAP_ASPM_COMPLIANCE	PCIEM_LINK_CAP_ASPM_COMPLIANCE
+#define	PCIM_LINK_CAP_PORT		PCIEM_LINK_CAP_PORT	
+#define	PCIR_EXPRESS_LINK_CTL		PCIER_LINK_CTL
+#define	PCIM_EXP_LINK_CTL_ASPMC_DIS	PCIEM_LINK_CTL_ASPMC_DIS
+#define	PCIM_EXP_LINK_CTL_ASPMC_L0S	PCIEM_LINK_CTL_ASPMC_L0S
+#define	PCIM_EXP_LINK_CTL_ASPMC_L1	PCIEM_LINK_CTL_ASPMC_L1
+#define	PCIM_EXP_LINK_CTL_ASPMC		PCIEM_LINK_CTL_ASPMC	
+#define	PCIM_EXP_LINK_CTL_RCB		PCIEM_LINK_CTL_RCB	
+#define	PCIM_EXP_LINK_CTL_LINK_DIS	PCIEM_LINK_CTL_LINK_DIS
+#define	PCIM_EXP_LINK_CTL_RETRAIN_LINK	PCIEM_LINK_CTL_RETRAIN_LINK
+#define	PCIM_EXP_LINK_CTL_COMMON_CLOCK	PCIEM_LINK_CTL_COMMON_CLOCK
+#define	PCIM_EXP_LINK_CTL_EXTENDED_SYNC	PCIEM_LINK_CTL_EXTENDED_SYNC
+#define	PCIM_EXP_LINK_CTL_ECPM		PCIEM_LINK_CTL_ECPM	
+#define	PCIM_EXP_LINK_CTL_HAWD		PCIEM_LINK_CTL_HAWD	
+#define	PCIM_EXP_LINK_CTL_LBMIE		PCIEM_LINK_CTL_LBMIE	
+#define	PCIM_EXP_LINK_CTL_LABIE		PCIEM_LINK_CTL_LABIE	
+#define	PCIR_EXPRESS_LINK_STA		PCIER_LINK_STA
+#define	PCIM_LINK_STA_SPEED		PCIEM_LINK_STA_SPEED	
+#define	PCIM_LINK_STA_WIDTH		PCIEM_LINK_STA_WIDTH	
+#define	PCIM_LINK_STA_TRAINING_ERROR	PCIEM_LINK_STA_TRAINING_ERROR
+#define	PCIM_LINK_STA_TRAINING		PCIEM_LINK_STA_TRAINING	
+#define	PCIM_LINK_STA_SLOT_CLOCK	PCIEM_LINK_STA_SLOT_CLOCK
+#define	PCIM_LINK_STA_DL_ACTIVE		PCIEM_LINK_STA_DL_ACTIVE	
+#define	PCIM_LINK_STA_LINK_BW_MGMT	PCIEM_LINK_STA_LINK_BW_MGMT
+#define	PCIM_LINK_STA_LINK_AUTO_BW	PCIEM_LINK_STA_LINK_AUTO_BW
+#define	PCIR_EXPRESS_SLOT_CAP		PCIER_SLOT_CAP
+#define	PCIR_EXPRESS_SLOT_CTL		PCIER_SLOT_CTL
+#define	PCIR_EXPRESS_SLOT_STA		PCIER_SLOT_STA
+#define	PCIR_EXPRESS_ROOT_CTL		PCIER_ROOT_CTL
+#define	PCIR_EXPRESS_ROOT_CAP		PCIER_ROOT_CAP
+#define	PCIR_EXPRESS_ROOT_STA		PCIER_ROOT_STA
+#define	PCIR_EXPRESS_DEVICE_CAP2	PCIER_DEVICE_CAP2
+#define	PCIR_EXPRESS_DEVICE_CTL2	PCIER_DEVICE_CTL2
+#define	PCIM_EXP_CTL2_COMP_TIMEOUT_VAL	PCIEM_CTL2_COMP_TIMEOUT_VAL
+#define	PCIM_EXP_CTL2_COMP_TIMEOUT_DIS	PCIEM_CTL2_COMP_TIMEOUT_DIS
+#define	PCIM_EXP_CTL2_ARI		PCIEM_CTL2_ARI	
+#define	PCIM_EXP_CTL2_ATOMIC_REQ_ENABLE	PCIEM_CTL2_ATOMIC_REQ_ENABLE
+#define	PCIM_EXP_CTL2_ATOMIC_EGR_BLOCK	PCIEM_CTL2_ATOMIC_EGR_BLOCK
+#define	PCIM_EXP_CTL2_ID_ORDERED_REQ_EN	PCIEM_CTL2_ID_ORDERED_REQ_EN
+#define	PCIM_EXP_CTL2_ID_ORDERED_CMP_EN	PCIEM_CTL2_ID_ORDERED_CMP_EN
+#define	PCIM_EXP_CTL2_LTR_ENABLE	PCIEM_CTL2_LTR_ENABLE
+#define	PCIM_EXP_CTL2_OBFF		PCIEM_CTL2_OBFF	
+#define	PCIM_EXP_OBFF_DISABLE		PCIEM_OBFF_DISABLE	
+#define	PCIM_EXP_OBFF_MSGA_ENABLE	PCIEM_OBFF_MSGA_ENABLE
+#define	PCIM_EXP_OBFF_MSGB_ENABLE	PCIEM_OBFF_MSGB_ENABLE
+#define	PCIM_EXP_OBFF_WAKE_ENABLE	PCIEM_OBFF_WAKE_ENABLE
+#define	PCIM_EXP_CTL2_END2END_TLP	PCIEM_CTL2_END2END_TLP
+#define	PCIR_EXPRESS_DEVICE_STA2	PCIER_DEVICE_STA2
+#define	PCIR_EXPRESS_LINK_CAP2		PCIER_LINK_CAP2
+#define	PCIR_EXPRESS_LINK_CTL2		PCIER_LINK_CTL2
+#define	PCIR_EXPRESS_LINK_STA2		PCIER_LINK_STA2
+#define	PCIR_EXPRESS_SLOT_CAP2		PCIER_SLOT_CAP2
+#define	PCIR_EXPRESS_SLOT_CTL2		PCIER_SLOT_CTL2
+#define	PCIR_EXPRESS_SLOT_STA2		PCIER_SLOT_STA2
+
+/* MSI-X definitions */
+#define	PCIR_MSIX_CTRL		0x2
+#define	PCIM_MSIXCTRL_MSIX_ENABLE	0x8000
+#define	PCIM_MSIXCTRL_FUNCTION_MASK	0x4000
+#define	PCIM_MSIXCTRL_TABLE_SIZE	0x07FF
+#define	PCIR_MSIX_TABLE		0x4
+#define	PCIR_MSIX_PBA		0x8
+#define	PCIM_MSIX_BIR_MASK		0x7
+#define	PCIM_MSIX_BIR_BAR_10		0
+#define	PCIM_MSIX_BIR_BAR_14		1
+#define	PCIM_MSIX_BIR_BAR_18		2
+#define	PCIM_MSIX_BIR_BAR_1C		3
+#define	PCIM_MSIX_BIR_BAR_20		4
+#define	PCIM_MSIX_BIR_BAR_24		5
+#define	PCIM_MSIX_VCTRL_MASK		0x1
+
+/* PCI Advanced Features definitions */
+#define	PCIR_PCIAF_CAP		0x3
+#define	PCIM_PCIAFCAP_TP	0x01
+#define	PCIM_PCIAFCAP_FLR	0x02
+#define	PCIR_PCIAF_CTRL		0x4
+#define	PCIR_PCIAFCTRL_FLR	0x01
+#define	PCIR_PCIAF_STATUS	0x5
+#define	PCIR_PCIAFSTATUS_TP	0x01
+
+/* Advanced Error Reporting */
+#define	PCIR_AER_UC_STATUS	0x04
+#define	PCIM_AER_UC_TRAINING_ERROR	0x00000001
+#define	PCIM_AER_UC_DL_PROTOCOL_ERROR	0x00000010
+#define	PCIM_AER_UC_SURPRISE_LINK_DOWN	0x00000020
+#define	PCIM_AER_UC_POISONED_TLP	0x00001000
+#define	PCIM_AER_UC_FC_PROTOCOL_ERROR	0x00002000
+#define	PCIM_AER_UC_COMPLETION_TIMEOUT	0x00004000
+#define	PCIM_AER_UC_COMPLETER_ABORT	0x00008000
+#define	PCIM_AER_UC_UNEXPECTED_COMPLETION 0x00010000
+#define	PCIM_AER_UC_RECEIVER_OVERFLOW	0x00020000
+#define	PCIM_AER_UC_MALFORMED_TLP	0x00040000
+#define	PCIM_AER_UC_ECRC_ERROR		0x00080000
+#define	PCIM_AER_UC_UNSUPPORTED_REQUEST	0x00100000
+#define	PCIM_AER_UC_ACS_VIOLATION	0x00200000
+#define	PCIM_AER_UC_INTERNAL_ERROR	0x00400000
+#define	PCIM_AER_UC_MC_BLOCKED_TLP	0x00800000
+#define	PCIM_AER_UC_ATOMIC_EGRESS_BLK	0x01000000
+#define	PCIM_AER_UC_TLP_PREFIX_BLOCKED	0x02000000
+#define	PCIR_AER_UC_MASK	0x08	/* Shares bits with UC_STATUS */
+#define	PCIR_AER_UC_SEVERITY	0x0c	/* Shares bits with UC_STATUS */
+#define	PCIR_AER_COR_STATUS	0x10
+#define	PCIM_AER_COR_RECEIVER_ERROR	0x00000001
+#define	PCIM_AER_COR_BAD_TLP		0x00000040
+#define	PCIM_AER_COR_BAD_DLLP		0x00000080
+#define	PCIM_AER_COR_REPLAY_ROLLOVER	0x00000100
+#define	PCIM_AER_COR_REPLAY_TIMEOUT	0x00001000
+#define	PCIM_AER_COR_ADVISORY_NF_ERROR	0x00002000
+#define	PCIM_AER_COR_INTERNAL_ERROR	0x00004000
+#define	PCIM_AER_COR_HEADER_LOG_OVFLOW	0x00008000
+#define	PCIR_AER_COR_MASK	0x14	/* Shares bits with COR_STATUS */
+#define	PCIR_AER_CAP_CONTROL	0x18
+#define	PCIM_AER_FIRST_ERROR_PTR	0x0000001f
+#define	PCIM_AER_ECRC_GEN_CAPABLE	0x00000020
+#define	PCIM_AER_ECRC_GEN_ENABLE	0x00000040
+#define	PCIM_AER_ECRC_CHECK_CAPABLE	0x00000080
+#define	PCIM_AER_ECRC_CHECK_ENABLE	0x00000100
+#define	PCIM_AER_MULT_HDR_CAPABLE	0x00000200
+#define	PCIM_AER_MULT_HDR_ENABLE	0x00000400
+#define	PCIM_AER_TLP_PREFIX_LOG_PRESENT	0x00000800
+#define	PCIR_AER_HEADER_LOG	0x1c
+#define	PCIR_AER_ROOTERR_CMD	0x2c	/* Only for root complex ports */
+#define	PCIM_AER_ROOTERR_COR_ENABLE	0x00000001
+#define	PCIM_AER_ROOTERR_NF_ENABLE	0x00000002
+#define	PCIM_AER_ROOTERR_F_ENABLE	0x00000004
+#define	PCIR_AER_ROOTERR_STATUS	0x30	/* Only for root complex ports */
+#define	PCIM_AER_ROOTERR_COR_ERR	0x00000001
+#define	PCIM_AER_ROOTERR_MULTI_COR_ERR	0x00000002
+#define	PCIM_AER_ROOTERR_UC_ERR		0x00000004
+#define	PCIM_AER_ROOTERR_MULTI_UC_ERR	0x00000008
+#define	PCIM_AER_ROOTERR_FIRST_UC_FATAL	0x00000010
+#define	PCIM_AER_ROOTERR_NF_ERR		0x00000020
+#define	PCIM_AER_ROOTERR_F_ERR		0x00000040
+#define	PCIM_AER_ROOTERR_INT_MESSAGE	0xf8000000
+#define	PCIR_AER_COR_SOURCE_ID	0x34	/* Only for root complex ports */
+#define	PCIR_AER_ERR_SOURCE_ID	0x36	/* Only for root complex ports */
+#define	PCIR_AER_TLP_PREFIX_LOG	0x38	/* Only for TLP prefix functions */
+
+/* Virtual Channel definitions */
+#define	PCIR_VC_CAP1		0x04
+#define	PCIM_VC_CAP1_EXT_COUNT		0x00000007
+#define	PCIM_VC_CAP1_LOWPRI_EXT_COUNT	0x00000070
+#define	PCIR_VC_CAP2		0x08
+#define	PCIR_VC_CONTROL		0x0C
+#define	PCIR_VC_STATUS		0x0E
+#define	PCIR_VC_RESOURCE_CAP(n)	(0x10 + (n) * 0x0C)
+#define	PCIR_VC_RESOURCE_CTL(n)	(0x14 + (n) * 0x0C)
+#define	PCIR_VC_RESOURCE_STA(n)	(0x18 + (n) * 0x0C)
+
+/* Serial Number definitions */
+#define	PCIR_SERIAL_LOW		0x04
+#define	PCIR_SERIAL_HIGH	0x08
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcivar.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcivar.h
new file mode 100644
index 0000000000..12f302e6fb
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/pci/pcivar.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_DEV_PCI_PCIVAR_H_
+#define _FBSD_COMPAT_DEV_PCI_PCIVAR_H_
+
+
+#include <sys/bus.h>
+
+
+#define	PCI_RF_DENSE	0x10000
+	// ignored on x86
+
+#define	PCI_POWERSTATE_D0	0
+#define	PCI_POWERSTATE_D1	1
+#define	PCI_POWERSTATE_D2	2
+#define	PCI_POWERSTATE_D3	3
+#define	PCI_POWERSTATE_UNKNOWN	-1
+
+
+int pci_enable_busmaster(device_t dev);
+int pci_enable_io(device_t dev, int reg);
+
+uint32_t pci_get_devid(device_t dev);
+void pci_set_intpin(device_t dev, uint8_t pin);
+uint8_t pci_get_intpin(device_t dev);
+
+uint16_t pci_get_vendor(device_t dev);
+uint16_t pci_get_device(device_t dev);
+uint16_t pci_get_subvendor(device_t dev);
+uint16_t pci_get_subdevice(device_t dev);
+uint8_t pci_get_revid(device_t dev);
+uint8_t pci_get_cachelnsz(device_t dev);
+uint8_t *pci_get_ether(device_t dev);
+
+uint32_t pci_read_config(device_t dev, int reg, int width);
+void pci_write_config(device_t dev, int reg, uint32_t val, int width);
+
+uint32_t pci_get_domain(device_t dev);
+uint8_t pci_get_bus(device_t dev);
+uint8_t pci_get_slot(device_t dev);
+uint8_t pci_get_function(device_t dev);
+device_t pci_find_dbsf(uint32_t domain, uint8_t bus, uint8_t slot,
+	uint8_t func);
+
+int pci_find_cap(device_t dev, int capability, int *capreg);
+int pci_find_extcap(device_t dev, int capability, int *capreg);
+
+int pci_msi_count(device_t dev);
+int pci_alloc_msi(device_t dev, int *count);
+int pci_release_msi(device_t dev);
+int pci_msix_count(device_t dev);
+int pci_alloc_msix(device_t dev, int *count);
+
+int pci_get_max_read_req(device_t dev);
+int pci_set_max_read_req(device_t dev, int size);
+
+int pci_get_powerstate(device_t dev);
+int pci_set_powerstate(device_t dev, int newPowerState);
+
+static inline int
+pci_get_vpd_ident(device_t dev, const char **identptr)
+{
+	return -1;
+}
+
+#endif	/* _FBSD_COMPAT_DEV_PCI_PCIVAR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/usb/usbdevs b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/usb/usbdevs
new file mode 100644
index 0000000000..d8efff2f6d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/dev/usb/usbdevs
@@ -0,0 +1,4910 @@
+$FreeBSD$
+/* $NetBSD: usbdevs,v 1.392 2004/12/29 08:38:44 imp Exp $ */
+
+/*-
+ * Copyright (c) 1998-2004 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * List of known USB vendors
+ *
+ * USB.org publishes a VID list of USB-IF member companies at
+ * http://www.usb.org/developers/tools
+ * Note that it does not show companies that have obtained a Vendor ID
+ * without becoming full members.
+ *
+ * Please note that these IDs do not do anything. Adding an ID here and
+ * regenerating the usbdevs.h and usbdevs_data.h only makes a symbolic name
+ * available to the source code and does not change any functionality, nor
+ * does it make your device available to a specific driver.
+ * It will however make the descriptive string available if a device does not
+ * provide the string itself.
+ *
+ * After adding a vendor ID VNDR and a product ID PRDCT you will have the
+ * following extra defines:
+ * #define USB_VENDOR_VNDR              0x????
+ * #define USB_PRODUCT_VNDR_PRDCT       0x????
+ *
+ * You may have to add these defines to the respective probe routines to
+ * make the device recognised by the appropriate device driver.
+ */
+
+vendor UNKNOWN1		0x0053	Unknown vendor
+vendor UNKNOWN2		0x0105	Unknown vendor
+vendor EGALAX2		0x0123	eGalax, Inc.
+vendor CHIPSBANK	0x0204	Chipsbank Microelectronics Co.
+vendor HUMAX		0x02ad	HUMAX
+vendor QUAN		0x01e1	Quan
+vendor LTS		0x0386	LTS
+vendor BWCT		0x03da	Bernd Walter Computer Technology
+vendor AOX		0x03e8	AOX
+vendor THESYS		0x03e9	Thesys
+vendor DATABROADCAST	0x03ea	Data Broadcasting
+vendor ATMEL		0x03eb	Atmel
+vendor IWATSU		0x03ec	Iwatsu America
+vendor MITSUMI		0x03ee	Mitsumi
+vendor HP		0x03f0	Hewlett Packard
+vendor GENOA		0x03f1	Genoa
+vendor OAK		0x03f2	Oak
+vendor ADAPTEC		0x03f3	Adaptec
+vendor DIEBOLD		0x03f4	Diebold
+vendor SIEMENSELECTRO	0x03f5	Siemens Electromechanical
+vendor EPSONIMAGING	0x03f8	Epson Imaging
+vendor KEYTRONIC	0x03f9	KeyTronic
+vendor OPTI		0x03fb	OPTi
+vendor ELITEGROUP	0x03fc	Elitegroup
+vendor XILINX		0x03fd	Xilinx
+vendor FARALLON		0x03fe	Farallon Communications
+vendor NATIONAL		0x0400	National Semiconductor
+vendor NATIONALREG	0x0401	National Registry
+vendor ACERLABS		0x0402	Acer Labs
+vendor FTDI		0x0403	Future Technology Devices
+vendor NCR		0x0404	NCR
+vendor SYNOPSYS2	0x0405	Synopsys
+vendor FUJITSUICL	0x0406	Fujitsu-ICL
+vendor FUJITSU2		0x0407	Fujitsu Personal Systems
+vendor QUANTA		0x0408	Quanta
+vendor NEC		0x0409	NEC
+vendor KODAK		0x040a	Eastman Kodak
+vendor WELTREND		0x040b	Weltrend Semiconductor
+vendor VIA		0x040d	VIA
+vendor MCCI		0x040e	MCCI
+vendor MELCO		0x0411	Melco
+vendor LEADTEK		0x0413	Leadtek
+vendor WINBOND		0x0416	Winbond
+vendor PHOENIX		0x041a	Phoenix
+vendor CREATIVE		0x041e	Creative Labs
+vendor NOKIA		0x0421	Nokia
+vendor ADI		0x0422	ADI Systems
+vendor CATC		0x0423	Computer Access Technology
+vendor SMC2		0x0424	Microchip (Standard Microsystems)
+vendor MOTOROLA_HK	0x0425	Motorola HK
+vendor GRAVIS		0x0428	Advanced Gravis Computer
+vendor CIRRUSLOGIC	0x0429	Cirrus Logic
+vendor INNOVATIVE	0x042c	Innovative Semiconductors
+vendor MOLEX		0x042f	Molex
+vendor SUN		0x0430	Sun Microsystems
+vendor UNISYS		0x0432	Unisys
+vendor TAUGA		0x0436	Taugagreining HF
+vendor AMD		0x0438	Advanced Micro Devices
+vendor LEXMARK		0x043d	Lexmark International
+vendor LG		0x043e	LG Electronics
+vendor NANAO		0x0440	NANAO
+vendor GATEWAY		0x0443	Gateway 2000
+vendor NMB		0x0446	NMB
+vendor ALPS		0x044e	Alps Electric
+vendor THRUST		0x044f	Thrustmaster
+vendor TI		0x0451	Texas Instruments
+vendor ANALOGDEVICES	0x0456	Analog Devices
+vendor SIS		0x0457	Silicon Integrated Systems Corp.
+vendor KYE		0x0458	KYE Systems
+vendor DIAMOND2		0x045a	Diamond (Supra)
+vendor RENESAS		0x045b	Renesas
+vendor MICROSOFT	0x045e	Microsoft
+vendor PRIMAX		0x0461	Primax Electronics
+vendor MGE		0x0463	MGE UPS Systems
+vendor AMP		0x0464	AMP
+vendor CHERRY		0x046a	Cherry Mikroschalter
+vendor MEGATRENDS	0x046b	American Megatrends
+vendor LOGITECH		0x046d	Logitech
+vendor BTC		0x046e	Behavior Tech. Computer
+vendor PHILIPS		0x0471	Philips
+vendor SUN2		0x0472	Sun Microsystems (official)
+vendor SANYO		0x0474	Sanyo Electric
+vendor SEAGATE		0x0477	Seagate
+vendor CONNECTIX	0x0478	Connectix
+vendor SEMTECH		0x047a	Semtech
+vendor KENSINGTON	0x047d	Kensington
+vendor LUCENT		0x047e	Lucent
+vendor PLANTRONICS	0x047f	Plantronics
+vendor KYOCERA		0x0482	Kyocera Wireless Corp.
+vendor STMICRO		0x0483	STMicroelectronics
+vendor FOXCONN		0x0489	Foxconn / Hon Hai
+vendor MEIZU		0x0492	Meizu Electronics
+vendor YAMAHA		0x0499	YAMAHA
+vendor COMPAQ		0x049f	Compaq
+vendor HITACHI		0x04a4	Hitachi
+vendor ACERP		0x04a5	Acer Peripherals
+vendor DAVICOM		0x04a6	Davicom
+vendor VISIONEER	0x04a7	Visioneer
+vendor CANON		0x04a9	Canon
+vendor NIKON		0x04b0	Nikon
+vendor PAN		0x04b1	Pan International
+vendor IBM		0x04b3	IBM
+vendor CYPRESS		0x04b4	Cypress Semiconductor
+vendor ROHM		0x04b5	ROHM
+vendor COMPAL		0x04b7	Compal
+vendor EPSON		0x04b8	Seiko Epson
+vendor RAINBOW		0x04b9	Rainbow Technologies
+vendor IODATA		0x04bb	I-O Data
+vendor TDK		0x04bf	TDK
+vendor 3COMUSR		0x04c1	U.S. Robotics
+vendor METHODE		0x04c2	Methode Electronics Far East
+vendor MAXISWITCH	0x04c3	Maxi Switch
+vendor LOCKHEEDMER	0x04c4	Lockheed Martin Energy Research
+vendor FUJITSU		0x04c5	Fujitsu
+vendor TOSHIBAAM	0x04c6	Toshiba America
+vendor MICROMACRO	0x04c7	Micro Macro Technologies
+vendor KONICA		0x04c8	Konica
+vendor LITEON		0x04ca	Lite-On Technology
+vendor FUJIPHOTO	0x04cb	Fuji Photo Film
+vendor PHILIPSSEMI	0x04cc	Philips Semiconductors
+vendor TATUNG		0x04cd	Tatung Co. Of America
+vendor SCANLOGIC	0x04ce	ScanLogic
+vendor MYSON		0x04cf	Myson Technology
+vendor DIGI2		0x04d0	Digi
+vendor ITTCANON		0x04d1	ITT Canon
+vendor ALTEC		0x04d2	Altec Lansing
+vendor LSI		0x04d4	LSI
+vendor MENTORGRAPHICS	0x04d6	Mentor Graphics
+vendor ITUNERNET	0x04d8	I-Tuner Networks
+vendor HOLTEK		0x04d9	Holtek Semiconductor, Inc.
+vendor PANASONIC	0x04da	Panasonic (Matsushita)
+vendor HUANHSIN		0x04dc	Huan Hsin
+vendor SHARP		0x04dd	Sharp
+vendor IIYAMA		0x04e1	Iiyama
+vendor SHUTTLE		0x04e6	Shuttle Technology
+vendor ELO		0x04e7	Elo TouchSystems
+vendor SAMSUNG		0x04e8	Samsung Electronics
+vendor NORTHSTAR	0x04eb	Northstar
+vendor TOKYOELECTRON	0x04ec	Tokyo Electron
+vendor ANNABOOKS	0x04ed	Annabooks
+vendor JVC		0x04f1	JVC
+vendor CHICONY		0x04f2	Chicony Electronics
+vendor ELAN		0x04f3	ELAN Microelectronics
+vendor NEWNEX		0x04f7	Newnex
+vendor BROTHER		0x04f9	Brother Industries
+vendor DALLAS		0x04fa	Dallas Semiconductor
+vendor AIPTEK2		0x04fc	AIPTEK International
+vendor PFU		0x04fe	PFU
+vendor FUJIKURA		0x0501	Fujikura/DDK
+vendor ACER		0x0502	Acer
+vendor 3COM		0x0506	3Com
+vendor HOSIDEN		0x0507	Hosiden Corporation
+vendor AZTECH		0x0509	Aztech Systems
+vendor BELKIN		0x050d	Belkin Components
+vendor KAWATSU		0x050f	Kawatsu Semiconductor
+vendor FCI		0x0514	FCI
+vendor LONGWELL		0x0516	Longwell
+vendor COMPOSITE	0x0518	Composite
+vendor STAR		0x0519	Star Micronics
+vendor APC		0x051d	American Power Conversion
+vendor SCIATLANTA	0x051e	Scientific Atlanta
+vendor TSM		0x0520	TSM
+vendor CONNECTEK	0x0522	Advanced Connectek USA
+vendor NETCHIP		0x0525	NetChip Technology
+vendor ALTRA		0x0527	ALTRA
+vendor ATI		0x0528	ATI Technologies
+vendor AKS		0x0529	Aladdin Knowledge Systems
+vendor TEKOM		0x052b	Tekom
+vendor CANONDEV		0x052c	Canon
+vendor WACOMTECH	0x0531	Wacom
+vendor INVENTEC		0x0537	Inventec
+vendor SHYHSHIUN	0x0539	Shyh Shiun Terminals
+vendor PREHWERKE	0x053a	Preh Werke Gmbh & Co. KG
+vendor SYNOPSYS		0x053f	Synopsys
+vendor UNIACCESS	0x0540	Universal Access
+vendor VIEWSONIC	0x0543	ViewSonic
+vendor XIRLINK		0x0545	Xirlink
+vendor ANCHOR		0x0547	Anchor Chips
+vendor SONY		0x054c	Sony
+vendor FUJIXEROX	0x0550	Fuji Xerox
+vendor VISION		0x0553	VLSI Vision
+vendor ASAHIKASEI	0x0556	Asahi Kasei Microsystems
+vendor ATEN		0x0557	ATEN International
+vendor SAMSUNG2		0x055d	Samsung Electronics
+vendor MUSTEK		0x055f	Mustek Systems
+vendor TELEX		0x0562	Telex Communications
+vendor CHINON		0x0564	Chinon
+vendor PERACOM		0x0565	Peracom Networks
+vendor ALCOR2		0x0566	Alcor Micro
+vendor XYRATEX		0x0567	Xyratex
+vendor WACOM		0x056a	WACOM
+vendor ETEK		0x056c	e-TEK Labs
+vendor EIZO		0x056d	EIZO
+vendor ELECOM		0x056e	Elecom
+vendor CONEXANT		0x0572	Conexant
+vendor HAUPPAUGE	0x0573	Hauppauge Computer Works
+vendor BAFO		0x0576	BAFO/Quality Computer Accessories
+vendor YEDATA		0x057b	Y-E Data
+vendor AVM		0x057c	AVM
+vendor NINTENDO		0x057e	Nintendo
+vendor QUICKSHOT	0x057f	Quickshot
+vendor ROLAND		0x0582	Roland
+vendor ROCKFIRE		0x0583	Rockfire
+vendor RATOC		0x0584	RATOC Systems
+vendor ZYXEL		0x0586	ZyXEL Communication
+vendor INFINEON		0x058b	Infineon
+vendor MICREL		0x058d	Micrel
+vendor ALCOR		0x058f	Alcor Micro
+vendor OMRON		0x0590	OMRON
+vendor ZORAN		0x0595	Zoran Microelectronics
+vendor NIIGATA		0x0598	Niigata
+vendor IOMEGA		0x059b	Iomega
+vendor ATREND		0x059c	A-Trend Technology
+vendor AID		0x059d	Advanced Input Devices
+vendor LACIE		0x059f	LaCie
+vendor FUJIFILM		0x05a2	Fuji Film
+vendor ARC		0x05a3	ARC
+vendor ORTEK		0x05a4	Ortek
+vendor CISCOLINKSYS3	0x05a6	Cisco-Linksys
+vendor BOSE		0x05a7	Bose
+vendor OMNIVISION	0x05a9	OmniVision
+vendor INSYSTEM		0x05ab	In-System Design
+vendor APPLE		0x05ac	Apple Computer
+vendor YCCABLE		0x05ad	Y.C. Cable
+vendor DIGITALPERSONA	0x05ba	DigitalPersona
+vendor 3G		0x05bc	3G Green Green Globe
+vendor RAFI		0x05bd	RAFI
+vendor TYCO		0x05be	Tyco
+vendor KAWASAKI		0x05c1	Kawasaki
+vendor DIGI		0x05c5	Digi International
+vendor QUALCOMM2	0x05c6	Qualcomm
+vendor QTRONIX		0x05c7	Qtronix
+vendor FOXLINK		0x05c8	Foxlink
+vendor RICOH		0x05ca	Ricoh
+vendor ELSA		0x05cc	ELSA
+vendor SCIWORX		0x05ce	sci-worx
+vendor BRAINBOXES	0x05d1	Brainboxes Limited
+vendor ULTIMA		0x05d8	Ultima
+vendor AXIOHM		0x05d9	Axiohm Transaction Solutions
+vendor MICROTEK		0x05da	Microtek
+vendor SUNTAC		0x05db	SUN Corporation
+vendor LEXAR		0x05dc	Lexar Media
+vendor ADDTRON		0x05dd	Addtron
+vendor SYMBOL		0x05e0	Symbol Technologies
+vendor SYNTEK		0x05e1	Syntek
+vendor GENESYS		0x05e3	Genesys Logic
+vendor FUJI		0x05e5	Fuji Electric
+vendor KEITHLEY		0x05e6	Keithley Instruments
+vendor EIZONANAO	0x05e7	EIZO Nanao
+vendor KLSI		0x05e9	Kawasaki LSI
+vendor FFC		0x05eb	FFC
+vendor ANKO		0x05ef	Anko Electronic
+vendor PIENGINEERING	0x05f3	P.I. Engineering
+vendor AOC		0x05f6	AOC International
+vendor CHIC		0x05fe	Chic Technology
+vendor BARCO		0x0600	Barco Display Systems
+vendor BRIDGE		0x0607	Bridge Information
+vendor SMK		0x0609	SMK
+vendor SOLIDYEAR	0x060b	Solid Year
+vendor BIORAD		0x0614	Bio-Rad Laboratories
+vendor MACALLY		0x0618	Macally
+vendor ACTLABS		0x061c	Act Labs
+vendor ALARIS		0x0620	Alaris
+vendor APEX		0x0624	Apex
+vendor CREATIVE3	0x062a	Creative Labs
+vendor MICRON		0x0634	Micron Technology
+vendor VIVITAR		0x0636	Vivitar
+vendor GUNZE		0x0637	Gunze Electronics USA
+vendor AVISION		0x0638	Avision
+vendor TEAC		0x0644	TEAC
+vendor ACTON		0x0647	Acton Research Corp.
+vendor OPTO		0x065a	Optoelectronics Co., Ltd
+vendor SGI		0x065e	Silicon Graphics
+vendor SANWASUPPLY	0x0663	Sanwa Supply
+vendor MEGATEC		0x0665	Megatec
+vendor LINKSYS		0x066b	Linksys
+vendor ACERSA		0x066e	Acer Semiconductor America
+vendor SIGMATEL		0x066f	Sigmatel
+vendor DRAYTEK		0x0675	DrayTek
+vendor AIWA		0x0677	Aiwa
+vendor ACARD		0x0678	ACARD Technology
+vendor PROLIFIC		0x067b	Prolific Technology
+vendor SIEMENS		0x067c	Siemens
+vendor AVANCELOGIC	0x0680	Avance Logic
+vendor SIEMENS2		0x0681	Siemens
+vendor MINOLTA		0x0686	Minolta
+vendor CHPRODUCTS	0x068e	CH Products
+vendor HAGIWARA		0x0693	Hagiwara Sys-Com
+vendor CTX		0x0698	Chuntex
+vendor ASKEY		0x069a	Askey Computer
+vendor SAITEK		0x06a3	Saitek
+vendor ALCATELT		0x06b9	Alcatel Telecom
+vendor AGFA		0x06bd	AGFA-Gevaert
+vendor ASIAMD		0x06be	Asia Microelectronic Development
+vendor BIZLINK		0x06c4	Bizlink International
+vendor KEYSPAN		0x06cd	Keyspan / InnoSys Inc.
+vendor CONTEC		0x06ce	Contec products
+vendor AASHIMA		0x06d6	Aashima Technology
+vendor LIEBERT		0x06da	Liebert
+vendor MULTITECH	0x06e0	MultiTech
+vendor ADS		0x06e1	ADS Technologies
+vendor ALCATELM		0x06e4	Alcatel Microelectronics
+vendor SIRIUS		0x06ea	Sirius Technologies
+vendor GUILLEMOT	0x06f8	Guillemot
+vendor BOSTON		0x06fd	Boston Acoustics
+vendor SMC		0x0707	Standard Microsystems
+vendor PUTERCOM		0x0708	Putercom
+vendor MCT		0x0711	MCT
+vendor IMATION		0x0718	Imation
+vendor TECLAST		0x071b	Teclast
+vendor SONYERICSSON	0x0731	Sony Ericsson
+vendor EICON		0x0734	Eicon Networks
+vendor MADCATZ		0x0738	Mad Catz, Inc.
+vendor SYNTECH		0x0745	Syntech Information
+vendor DIGITALSTREAM	0x074e	Digital Stream
+vendor AUREAL		0x0755	Aureal Semiconductor
+vendor MAUDIO		0x0763	M-Audio
+vendor CYBERPOWER	0x0764	Cyber Power Systems, Inc.
+vendor SURECOM		0x0769	Surecom Technology
+vendor HIDGLOBAL	0x076b	HID Global
+vendor LINKSYS2		0x077b	Linksys
+vendor GRIFFIN		0x077d	Griffin Technology
+vendor SANDISK		0x0781	SanDisk
+vendor JENOPTIK		0x0784	Jenoptik
+vendor LOGITEC		0x0789	Logitec
+vendor NOKIA2		0x078b	Nokia
+vendor BRIMAX		0x078e	Brimax
+vendor AXIS		0x0792	Axis Communications
+vendor ABL		0x0794	ABL Electronics
+vendor SAGEM		0x079b	Sagem
+vendor SUNCOMM		0x079c	Sun Communications, Inc.
+vendor ALFADATA		0x079d	Alfadata Computer
+vendor NATIONALTECH	0x07a2	National Technical Systems
+vendor ONNTO		0x07a3	Onnto
+vendor BE		0x07a4	Be
+vendor ADMTEK		0x07a6	ADMtek
+vendor COREGA		0x07aa	Corega
+vendor FREECOM		0x07ab	Freecom
+vendor MICROTECH	0x07af	Microtech
+vendor GENERALINSTMNTS	0x07b2	General Instruments (Motorola)
+vendor OLYMPUS		0x07b4	Olympus
+vendor ABOCOM		0x07b8	AboCom Systems
+vendor KINGSUN		0x07c0	KingSun
+vendor KEISOKUGIKEN	0x07c1	Keisokugiken
+vendor ONSPEC		0x07c4	OnSpec
+vendor APG		0x07c5	APG Cash Drawer
+vendor BUG		0x07c8	B.U.G.
+vendor ALLIEDTELESYN	0x07c9	Allied Telesyn International
+vendor AVERMEDIA	0x07ca	AVerMedia Technologies
+vendor SIIG		0x07cc	SIIG
+vendor CASIO		0x07cf	CASIO
+vendor DLINK2		0x07d1	D-Link
+vendor APTIO		0x07d2	Aptio Products
+vendor ARASAN		0x07da	Arasan Chip Systems
+vendor ALLIEDCABLE	0x07e6	Allied Cable
+vendor STSN		0x07ef	STSN
+vendor BEWAN		0x07fa	Bewan
+vendor CENTURY		0x07f7	Century Corp
+vendor NEWLINK		0x07ff	NEWlink
+vendor MAGTEK		0x0801	Mag-Tek
+vendor ZOOM		0x0803	Zoom Telephonics
+vendor PCS		0x0810	Personal Communication Systems
+vendor SYNET		0x0812	Synet Electronics
+vendor ALPHASMART	0x081e	AlphaSmart, Inc.
+vendor BROADLOGIC	0x0827	BroadLogic
+vendor HANDSPRING	0x082d	Handspring
+vendor PALM		0x0830	Palm Computing
+vendor SOURCENEXT	0x0833	SOURCENEXT
+vendor ACTIONSTAR	0x0835	Action Star Enterprise
+vendor SAMSUNG_TECHWIN	0x0839	Samsung Techwin
+vendor ACCTON		0x083a	Accton Technology
+vendor DIAMOND		0x0841	Diamond
+vendor NETGEAR		0x0846	BayNETGEAR
+vendor TOPRE		0x0853	Topre Corporation
+vendor ACTIVEWIRE	0x0854	ActiveWire
+vendor BBELECTRONICS	0x0856	B&B Electronics
+vendor PORTGEAR		0x085a	PortGear
+vendor NETGEAR2		0x0864	Netgear
+vendor SYSTEMTALKS	0x086e	System Talks
+vendor METRICOM		0x0870	Metricom
+vendor ADESSOKBTEK	0x087c	ADESSO/Kbtek America
+vendor JATON		0x087d	Jaton
+vendor APT		0x0880	APT Technologies
+vendor BOCARESEARCH	0x0885	Boca Research
+vendor ANDREA		0x08a8	Andrea Electronics
+vendor BURRBROWN	0x08bb	Burr-Brown Japan
+vendor 2WIRE		0x08c8	2Wire
+vendor AIPTEK		0x08ca	AIPTEK International
+vendor SMARTBRIDGES	0x08d1	SmartBridges
+vendor FUJITSUSIEMENS	0x08d4	Fujitsu-Siemens
+vendor BILLIONTON	0x08dd	Billionton Systems
+vendor GEMALTO		0x08e6	Gemalto SA
+vendor EXTENDED		0x08e9	Extended Systems
+vendor MSYSTEMS		0x08ec	M-Systems
+vendor DIGIANSWER	0x08fd	Digianswer
+vendor AUTHENTEC	0x08ff	AuthenTec
+vendor AUDIOTECHNICA	0x0909	Audio-Technica
+vendor TRUMPION		0x090a	Trumpion Microelectronics
+vendor FEIYA		0x090c	Feiya
+vendor ALATION		0x0910	Alation Systems
+vendor GLOBESPAN	0x0915	Globespan
+vendor CONCORDCAMERA	0x0919	Concord Camera
+vendor GARMIN		0x091e	Garmin International
+vendor GOHUBS		0x0921	GoHubs
+vendor DYMO		0x0922	DYMO
+vendor XEROX		0x0924	Xerox
+vendor BIOMETRIC	0x0929	American Biometric Company
+vendor TOSHIBA		0x0930	Toshiba
+vendor PLEXTOR		0x093b	Plextor
+vendor INTREPIDCS	0x093c	Intrepid
+vendor YANO		0x094f	Yano
+vendor KINGSTON		0x0951	Kingston Technology
+vendor NVIDIA		0x0955	NVIDIA Corporation
+vendor BLUEWATER	0x0956	BlueWater Systems
+vendor AGILENT		0x0957	Agilent Technologies
+vendor GUDE		0x0959	Gude ADS
+vendor PORTSMITH	0x095a	Portsmith
+vendor ACERW		0x0967	Acer
+vendor ADIRONDACK	0x0976	Adirondack Wire & Cable
+vendor BECKHOFF		0x0978	Beckhoff
+vendor MINDSATWORK	0x097a	Minds At Work
+vendor ZIPPY		0x099a	Zippy Technology Corporation
+vendor POINTCHIPS	0x09a6	PointChips
+vendor INTERSIL		0x09aa	Intersil
+vendor TRIPPLITE2	0x09ae	Tripp Lite
+vendor ALTIUS		0x09b3	Altius Solutions
+vendor ARRIS		0x09c1	Arris Interactive
+vendor ACTIVCARD	0x09c3	ACTIVCARD
+vendor ACTISYS		0x09c4	ACTiSYS
+vendor NOVATEL2		0x09d7	Novatel Wireless
+vendor AFOURTECH	0x09da	A-FOUR TECH
+vendor AIMEX		0x09dc	AIMEX
+vendor ADDONICS		0x09df	Addonics Technologies
+vendor AKAI		0x09e8	AKAI professional M.I.
+vendor ARESCOM		0x09f5	ARESCOM
+vendor BAY		0x09f9	Bay Associates
+vendor ALTERA		0x09fb	Altera
+vendor CSR		0x0a12	Cambridge Silicon Radio
+vendor TREK		0x0a16	Trek Technology
+vendor ASAHIOPTICAL	0x0a17	Asahi Optical
+vendor BOCASYSTEMS	0x0a43	Boca Systems
+vendor SHANTOU		0x0a46	ShanTou
+vendor MEDIAGEAR	0x0a48	MediaGear
+vendor PLOYTEC		0x0a4a	Ploytec GmbH
+vendor BROADCOM		0x0a5c	Broadcom
+vendor GREENHOUSE	0x0a6b	GREENHOUSE
+vendor MEDELI		0x0a67	Medeli
+vendor GEOCAST		0x0a79	Geocast Network Systems
+vendor EGO		0x0a92	EGO systems
+vendor IDQUANTIQUE	0x0aba	ID Quantique
+vendor IDTECH		0x0acd	ID TECH
+vendor ZYDAS		0x0ace	Zydas Technology Corporation
+vendor NEODIO		0x0aec	Neodio
+vendor OPTION		0x0af0	Option N.V.
+vendor ASUS		0x0b05	ASUSTeK Computer
+vendor TODOS		0x0b0c	Todos Data System
+vendor SIIG2		0x0b39	SIIG
+vendor TEKRAM		0x0b3b	Tekram Technology
+vendor HAL		0x0b41	HAL Corporation
+vendor EMS		0x0b43	EMS Production
+vendor NEC2		0x0b62	NEC
+vendor ADLINK		0x0b63	ADLINK Technoligy, Inc.
+vendor ATI2		0x0b6f	ATI Technologies
+vendor ZEEVO		0x0b7a	Zeevo, Inc.
+vendor KURUSUGAWA	0x0b7e	Kurusugawa Electronics, Inc.
+vendor SMART		0x0b8c	Smart Technologies
+vendor ASIX		0x0b95	ASIX Electronics
+vendor O2MICRO		0x0b97	O2 Micro, Inc.
+vendor USR		0x0baf	U.S. Robotics
+vendor AMBIT		0x0bb2	Ambit Microsystems
+vendor HTC		0x0bb4	HTC
+vendor REALTEK		0x0bda	Realtek
+vendor ERICSSON2	0x0bdb	Ericsson
+vendor MEI		0x0bed	MEI
+vendor ADDONICS2	0x0bf6	Addonics Technology
+vendor FSC		0x0bf8	Fujitsu Siemens Computers
+vendor AGATE		0x0c08	Agate Technologies
+vendor DMI		0x0c0b	DMI
+vendor CANYON		0x0c10	Canyon
+vendor ICOM		0x0c26	Icom Inc.
+vendor GNOTOMETRICS	0x0c33	GN Otometrics
+vendor CHICONY2		0x0c45	Chicony / Microdia / Sonix Technology Co., Ltd.
+vendor REINERSCT	0x0c4b	Reiner-SCT
+vendor SEALEVEL		0x0c52	Sealevel System
+vendor JETI		0x0c6c	Jeti
+vendor LUWEN		0x0c76	Luwen
+vendor ELEKTOR		0x0c7d	ELEKTOR Electronics
+vendor KYOCERA2		0x0c88	Kyocera Wireless Corp.
+vendor ZCOM		0x0cde	Z-Com
+vendor ATHEROS2		0x0cf3	Atheros Communications
+vendor POSIFLEX		0x0d3a	POSIFLEX
+vendor TANGTOP		0x0d3d	Tangtop
+vendor KOBIL		0x0d46	KOBIL
+vendor SMC3		0x0d5c	Standard Microsystems
+vendor ADDON		0x0d7d	Add-on Technology
+vendor ACDC		0x0d7e	American Computer & Digital Components
+vendor CMEDIA		0x0d8c	CMEDIA
+vendor CONCEPTRONIC	0x0d8e	Conceptronic
+vendor SKANHEX		0x0d96	Skanhex Technology, Inc.
+vendor MSI		0x0db0	Micro Star International
+vendor ELCON		0x0db7	ELCON Systemtechnik
+vendor UNKNOWN4		0x0dcd	Unknown vendor
+vendor NETAC		0x0dd8	Netac
+vendor SITECOMEU	0x0df6	Sitecom Europe
+vendor MOBILEACTION	0x0df7	Mobile Action
+vendor AMIGO		0x0e0b	Amigo Technology
+vendor SPEEDDRAGON	0x0e55	Speed Dragon Multimedia
+vendor HAWKING		0x0e66	Hawking
+vendor FOSSIL		0x0e67	Fossil, Inc
+vendor GMATE		0x0e7e	G.Mate, Inc
+vendor MEDIATEK		0x0e8d	MediaTek, Inc.
+vendor OTI		0x0ea0	Ours Technology
+vendor YISO		0x0eab	Yiso Wireless Co.
+vendor PILOTECH		0x0eaf	Pilotech
+vendor NOVATECH		0x0eb0	NovaTech
+vendor ITEGNO		0x0eba	iTegno
+vendor WINMAXGROUP	0x0ed1	WinMaxGroup
+vendor TOD		0x0ede	TOD
+vendor EGALAX		0x0eef	eGalax, Inc.
+vendor AIRPRIME		0x0f3d	AirPrime, Inc.
+vendor MICROTUNE	0x0f4d	Microtune
+vendor VTECH		0x0f88	VTech
+vendor FALCOM		0x0f94	Falcom Wireless Communications GmbH
+vendor RIM		0x0fca	Research In Motion
+vendor DYNASTREAM	0x0fcf	Dynastream Innovations
+vendor LARSENBRUSGAARD	0x0fd8	Larsen and Brusgaard
+vendor OWL		0x0fde	OWL
+vendor KONTRON		0x0fe6	Kontron AG
+vendor DVICO		0x0fe9	DViCO
+vendor QUALCOMM		0x1004	Qualcomm
+vendor APACER		0x1005	Apacer
+vendor MOTOROLA4	0x100d	Motorola
+vendor HP3		0x103c	Hewlett Packard
+vendor AIRPLUS		0x1011  Airplus
+vendor DESKNOTE		0x1019	Desknote
+vendor AMD2		0x1022  Advanced Micro Devices
+vendor NEC3		0x1033	NEC
+vendor TTI		0x103e	Thurlby Thandar Instruments
+vendor GIGABYTE		0x1044	GIGABYTE
+vendor WESTERN		0x1058	Western Digital
+vendor MOTOROLA		0x1063	Motorola
+vendor CCYU		0x1065	CCYU Technology
+vendor CURITEL		0x106c	Curitel Communications Inc
+vendor SILABS2		0x10a6	SILABS2
+vendor USI		0x10ab	USI
+vendor HONEYWELL	0x10ac	Honeywell
+vendor LIEBERT2		0x10af	Liebert
+vendor PLX		0x10b5	PLX
+vendor ASANTE		0x10bd	Asante
+vendor SILABS		0x10c4	Silicon Labs
+vendor SILABS3		0x10c5	Silicon Labs
+vendor SILABS4		0x10ce	Silicon Labs
+vendor ACTIONS		0x10d6  Actions
+vendor MOXA		0x110a	Moxa
+vendor ANALOG		0x1110	Analog Devices
+vendor TENX		0x1130	Ten X Technology, Inc.
+vendor ISSC		0x1131	Integrated System Solution Corp.
+vendor JRC		0x1145	Japan Radio Company
+vendor SPHAIRON		0x114b	Sphairon Access Systems GmbH
+vendor DELORME		0x1163	DeLorme
+vendor SERVERWORKS	0x1166	ServerWorks
+vendor DLINK3		0x1186	Dlink
+vendor ACERCM		0x1189	Acer Communications & Multimedia
+vendor SIERRA		0x1199	Sierra Wireless
+vendor SANWA		0x11ad	Sanwa Electric Instrument Co., Ltd.
+vendor TOPFIELD		0x11db	Topfield Co., Ltd
+vendor SIEMENS3		0x11f5	Siemens
+vendor NETINDEX		0x11f6	NetIndex
+vendor ALCATEL		0x11f7	Alcatel
+vendor INTERBIOMETRICS	0x1209	Interbiometrics
+vendor FUJITSU3		0x1221	Fujitsu Ltd.
+vendor UNKNOWN3		0x1233	Unknown vendor
+vendor TSUNAMI		0x1241	Tsunami
+vendor PHEENET		0x124a	Pheenet
+vendor TARGUS		0x1267	Targus
+vendor TWINMOS		0x126f	TwinMOS
+vendor TENDA		0x1286	Tenda
+vendor TESTO		0x128d	Testo products
+vendor CREATIVE2	0x1292	Creative Labs
+vendor BELKIN2		0x1293	Belkin Components
+vendor CYBERTAN		0x129b	CyberTAN Technology
+vendor HUAWEI		0x12d1	Huawei Technologies
+vendor ARANEUS		0x12d8	Araneus Information Systems
+vendor TAPWAVE		0x12ef	Tapwave
+vendor AINCOMM		0x12fd	Aincomm
+vendor MOBILITY		0x1342	Mobility
+vendor DICKSMITH	0x1371	Dick Smith Electronics
+vendor NETGEAR3		0x1385	Netgear
+vendor VALIDITY		0x138a	Validity Sensors, Inc.
+vendor BALTECH		0x13ad	Baltech
+vendor CISCOLINKSYS	0x13b1	Cisco-Linksys
+vendor SHARK		0x13d2	Shark
+vendor AZUREWAVE	0x13d3	AsureWave
+vendor INITIO		0x13fd	Initio Corporation
+vendor EMTEC		0x13fe	Emtec
+vendor NOVATEL		0x1410	Novatel Wireless
+vendor OMNIVISION2	0x1415	OmniVision Technologies, Inc.
+vendor MERLIN		0x1416	Merlin
+vendor REDOCTANE	0x1430	RedOctane
+vendor WISTRONNEWEB	0x1435	Wistron NeWeb
+vendor RADIOSHACK	0x1453	Radio Shack
+vendor FIC		0x1457	FIC / OpenMoko
+vendor HUAWEI3COM	0x1472	Huawei-3Com
+vendor ABOCOM2		0x1482	AboCom Systems
+vendor SILICOM		0x1485	Silicom
+vendor RALINK		0x148f	Ralink Technology
+vendor IMAGINATION	0x149a	Imagination Technologies
+vendor ATP		0x14af	ATP Electronics
+vendor CONCEPTRONIC2	0x14b2	Conceptronic
+vendor SUPERTOP		0x14cd	Super Top
+vendor PLANEX3		0x14ea	Planex Communications
+vendor SILICONPORTALS	0x1527	Silicon Portals
+vendor UBIQUAM		0x1529	UBIQUAM Co., Ltd.
+vendor JMICRON		0x152d	JMicron
+vendor UBLOX		0x1546	U-blox
+vendor PNY		0x154b	PNY
+vendor OWEN		0x1555	Owen
+vendor OQO		0x1557	OQO
+vendor UMEDIA		0x157e	U-MEDIA Communications
+vendor FIBERLINE	0x1582	Fiberline
+vendor FREESCALE	0x15a2  Freescale Semiconductor, Inc.
+vendor AFATECH		0x15a4	Afatech Technologies, Inc.
+vendor SPARKLAN		0x15a9	SparkLAN
+vendor OLIMEX		0x15ba	Olimex
+vendor SOUNDGRAPH 	0x15c2	Soundgraph, Inc.
+vendor AMIT2		0x15c5	AMIT
+vendor TEXTECH		0x15ca	Textech International Ltd.
+vendor SOHOWARE		0x15e8	SOHOware
+vendor ABIT		0x15eb	ABIT Corporation
+vendor UMAX		0x1606	UMAX Data Systems
+vendor INSIDEOUT	0x1608	Inside Out Networks
+vendor AMOI		0x1614	Amoi Electronics
+vendor GOODWAY		0x1631	Good Way Technology
+vendor ENTREGA		0x1645	Entrega
+vendor ACTIONTEC	0x1668	Actiontec Electronics
+vendor CLIPSAL		0x166a	Clipsal
+vendor CISCOLINKSYS2	0x167b  Cisco-Linksys
+vendor ATHEROS		0x168c	Atheros Communications
+vendor GIGASET		0x1690	Gigaset
+vendor GLOBALSUN	0x16ab	Global Sun Technology
+vendor ANYDATA		0x16d5	AnyDATA Corporation
+vendor JABLOTRON	0x16d6	Jablotron
+vendor CMOTECH		0x16d8	C-motech
+vendor WIENERPLEINBAUS	0x16dc	WIENER Plein & Baus GmbH.
+vendor AXESSTEL		0x1726  Axesstel Co., Ltd.
+vendor LINKSYS4		0x1737	Linksys
+vendor SENAO		0x1740	Senao
+vendor ASUS2		0x1761	ASUS
+vendor SWEEX2		0x177f	Sweex
+vendor METAGEEK		0x1781	MetaGeek
+vendor KAMSTRUP		0x17a8	Kamstrup A/S
+vendor MISC		0x1781	Misc Vendors
+vendor DISPLAYLINK	0x17e9	DisplayLink
+vendor LENOVO		0x17ef	Lenovo
+vendor WAVESENSE	0x17f4	WaveSense
+vendor VAISALA		0x1843	Vaisala
+vendor E3C		0x18b4	E3C Technologies
+vendor AMIT		0x18c5	AMIT
+vendor GOOGLE		0x18d1	Google
+vendor QCOM		0x18e8	Qcom
+vendor ELV		0x18ef	ELV
+vendor LINKSYS3		0x1915	Linksys
+vendor MEINBERG		0x1938	Meinberg Funkuhren
+vendor BECEEM		0x198f	Beceem Communications
+vendor ZTE		0x19d2	ZTE
+vendor QUALCOMMINC	0x19d2	Qualcomm, Incorporated
+vendor QUALCOMM3	0x19f5	Qualcomm, Inc.
+vendor QUANTA2		0x1a32	Quanta
+vendor TERMINUS		0x1a40	Terminus Technology
+vendor ABBOTT		0x1a61	Abbott Diabetics
+vendor BAYER		0x1a79	Bayer
+vendor WCH2		0x1a86	QinHeng Electronics
+vendor STELERA		0x1a8d	Stelera Wireless
+vendor SEL		0x1adb	Schweitzer Engineering Laboratories
+vendor CORSAIR		0x1b1c	Corsair
+vendor ASM		0x1b21	ASMedia Technology
+vendor MATRIXORBITAL	0x1b3d	Matrix Orbital
+vendor OVISLINK		0x1b75	OvisLink
+vendor TML		0x1b91	The Mobility Lab
+vendor TCTMOBILE	0x1bbb  TCT Mobile
+vendor ALTI2		0x1bc9	Alti-2 products
+vendor SUNPLUS		0x1bcf	Sunplus Innovation Technology Inc.
+vendor WAGO		0x1be3  WAGO Kontakttechnik GmbH.
+vendor TELIT		0x1bc7  Telit
+vendor IONICS		0x1c0c	Ionics PlugComputer
+vendor LONGCHEER	0x1c9e	Longcheer Holdings, Ltd.
+vendor MPMAN		0x1cae	MpMan
+vendor DRESDENELEKTRONIK 0x1cf1 dresden elektronik
+vendor NEOTEL		0x1d09	Neotel
+vendor DREAMLINK	0x1d34	Dream Link
+vendor PEGATRON		0x1d4d	Pegatron
+vendor QISDA		0x1da5  Qisda
+vendor METAGEEK2	0x1dd5	MetaGeek
+vendor ALINK		0x1e0e  Alink
+vendor AIRTIES		0x1eda	AirTies
+vendor FESTO		0x1e29	Festo
+vendor LAKESHORE	0x1fb9	Lake Shore Cryotronics, Inc.
+vendor VERTEX		0x1fe7  Vertex Wireless Co., Ltd.
+vendor DLINK		0x2001	D-Link
+vendor PLANEX2		0x2019	Planex Communications
+vendor HAUPPAUGE2	0x2040	Hauppauge Computer Works
+vendor TLAYTECH		0x20b9	Tlay Tech
+vendor ENCORE		0x203d	Encore
+vendor QIHARDWARE	0x20b7	QI-hardware
+vendor PARA		0x20b8	PARA Industrial
+vendor SIMTEC		0x20df	Simtec Electronics
+vendor TRENDNET		0x20f4  TRENDnet
+vendor RTSYSTEMS	0x2100	RT Systems
+vendor DLINK4		0x2101	D-Link
+vendor INTENSO		0x2109	INTENSO
+vendor VIALABS		0x2109	VIA Labs
+vendor ERICSSON		0x2282	Ericsson
+vendor MOTOROLA2	0x22b8	Motorola
+vendor WETELECOM	0x22de	WeTelecom
+vendor PINNACLE		0x2304	Pinnacle Systems
+vendor ARDUINO		0x2341	Arduino SA
+vendor TPLINK		0x2357	TP-Link
+vendor WESTMOUNTAIN	0x2405	West Mountain Radio
+vendor TRIPPLITE	0x2478	Tripp-Lite
+vendor HIROSE		0x2631	Hirose Electric
+vendor NHJ		0x2770	NHJ
+vendor THINGM		0x27b8	ThingM
+vendor PERASO		0x2932	Peraso Technologies, Inc.
+vendor PLANEX		0x2c02	Planex Communications
+vendor QUECTEL		0x2c7c	Quectel Wireless Solutions
+vendor VIDZMEDIA	0x3275	VidzMedia Pte Ltd
+vendor LINKINSTRUMENTS	0x3195	Link Instruments Inc.
+vendor AEI		0x3334	AEI
+vendor HANK		0x3353	Hank Connection
+vendor PQI		0x3538	PQI
+vendor DAISY		0x3579	Daisy Technology
+vendor NI		0x3923	National Instruments
+vendor MICRONET		0x3980	Micronet Communications
+vendor IODATA2		0x40bb	I-O Data
+vendor IRIVER		0x4102	iRiver
+vendor DELL		0x413c	Dell
+vendor WCH		0x4348	QinHeng Electronics
+vendor ACEECA		0x4766	Aceeca
+vendor FEIXUN		0x4855	FeiXun Communication
+vendor PAPOUCH		0x5050	Papouch products
+vendor AVERATEC		0x50c2	Averatec
+vendor SWEEX		0x5173	Sweex
+vendor PROLIFIC2	0x5372	Prolific Technologies
+vendor ONSPEC2		0x55aa	OnSpec Electronic Inc.
+vendor ZINWELL		0x5a57	Zinwell
+vendor INGENIC		0x601a	Ingenic Semiconductor Ltd.
+vendor SITECOM		0x6189	Sitecom
+vendor SPRINGERDESIGN	0x6400	Springer Design, Inc.
+vendor ARKMICRO		0x6547	Arkmicro Technologies Inc.
+vendor 3COM2		0x6891	3Com
+vendor EDIMAX		0x7392	Edimax
+vendor INTEL		0x8086	Intel
+vendor INTEL2		0x8087	Intel
+vendor ALLWIN		0x8516	ALLWIN Tech
+vendor SITECOM2		0x9016	Sitecom
+vendor MOSCHIP		0x9710	MosChip Semiconductor
+vendor NETGEAR4		0x9846  Netgear
+vendor MARVELL		0x9e88	Marvell Technology Group Ltd.
+vendor 3COM3		0xa727	3Com
+vendor CACE		0xcace	CACE Technologies
+vendor COMPARE		0xcdab	Compare
+vendor DATAAPEX		0xdaae	DataApex
+vendor EVOLUTION	0xdeee	Evolution Robotics
+vendor EMPIA		0xeb1a	eMPIA Technology
+vendor HP2		0xf003	Hewlett Packard
+vendor LOGILINK		0xfc08	LogiLink
+vendor USRP		0xfffe	GNU Radio USRP
+
+/*
+ * List of known products.  Grouped by vendor.
+ */
+
+/* 3Com products */
+product 3COM HOMECONN		0x009d	HomeConnect USB Camera
+product 3COM 3CREB96		0x00a0	Bluetooth USB Adapter
+product 3COM 3C19250		0x03e8	3C19250 Ethernet Adapter
+product 3COM 3CRSHEW696		0x0a01	3CRSHEW696 Wireless Adapter
+product 3COM 3C460		0x11f8	HomeConnect 3C460
+product 3COM USR56K		0x3021	U.S.Robotics 56000 Voice FaxModem Pro
+product 3COM 3C460B		0x4601	HomeConnect 3C460B
+product 3COM2 3CRUSB10075	0xa727	3CRUSB10075
+product 3COM3 AR5523_1		0x6893	AR5523
+product 3COM3 AR5523_2		0x6895	AR5523
+product 3COM3 AR5523_3		0x6897	AR5523
+
+product 3COMUSR OFFICECONN	0x0082	3Com OfficeConnect Analog Modem
+product 3COMUSR USRISDN		0x008f	3Com U.S. Robotics Pro ISDN TA
+product 3COMUSR HOMECONN	0x009d	3Com HomeConnect Camera
+product 3COMUSR USR56K		0x3021	U.S. Robotics 56000 Voice FaxModem Pro
+
+/* Abbott Diabetics */
+product ABBOTT STEREO_PLUG	0x3410	Abbott Diabetics Stereo Plug
+product ABBOTT STRIP_PORT	0x3420	Abbott Diabetics Strip Port
+
+/* ABIT products */
+product ABIT AK_020		0x7d0e	3G modem
+
+product ACDC HUB		0x2315	USB Pen Drive HUB
+product ACDC SECWRITE		0x2316	USB Pen Drive Secure Write
+product ACDC PEN		0x2317	USB Pen Drive with Secure Write
+
+/* AboCom products */
+product ABOCOM XX1		0x110c	XX1
+product ABOCOM XX2		0x200c	XX2
+product ABOCOM RT2770		0x2770	RT2770
+product ABOCOM RT2870		0x2870	RT2870
+product ABOCOM RT3070		0x3070	RT3070
+product ABOCOM RT3071		0x3071	RT3071
+product ABOCOM RT3072		0x3072	RT3072
+product ABOCOM2 RT2870_1	0x3c09	RT2870
+product ABOCOM URE450		0x4000	URE450 Ethernet Adapter
+product ABOCOM UFE1000		0x4002	UFE1000 Fast Ethernet Adapter
+product ABOCOM DSB650TX_PNA	0x4003	1/10/100 Ethernet Adapter
+product ABOCOM XX4		0x4004	XX4
+product ABOCOM XX5		0x4007	XX5
+product ABOCOM XX6		0x400b	XX6
+product ABOCOM XX7		0x400c	XX7
+product ABOCOM RTL8151		0x401a	RTL8151
+product ABOCOM XX8		0x4102	XX8
+product ABOCOM XX9		0x4104	XX9
+product ABOCOM UF200		0x420a	UF200 Ethernet
+product ABOCOM WL54		0x6001	WL54
+product ABOCOM XX10		0xabc1	XX10
+product ABOCOM BWU613		0xb000	BWU613
+product ABOCOM HWU54DM		0xb21b	HWU54DM
+product ABOCOM RT2573_2		0xb21c	RT2573
+product ABOCOM RT2573_3		0xb21d	RT2573
+product ABOCOM RT2573_4		0xb21e	RT2573
+product ABOCOM RTL8188CU_1	0x8188  RTL8188CU
+product ABOCOM RTL8188CU_2	0x8189  RTL8188CU
+product ABOCOM RTL8192CU	0x8178  RTL8192CU
+product ABOCOM RTL8188EU	0x8179  RTL8188EU
+product ABOCOM WUG2700		0xb21f	WUG2700
+
+/* Acton Research Corp. */
+product ACTON SPECTRAPRO	0x0100	FTDI compatible adapter
+
+/* Accton products */
+product ACCTON USB320_EC	0x1046	USB320-EC Ethernet Adapter
+product ACCTON 2664W		0x3501	2664W
+product ACCTON 111		0x3503	T-Sinus 111 Wireless Adapter
+product ACCTON SMCWUSBG_NF	0x4505	SMCWUSB-G (no firmware)
+product ACCTON SMCWUSBG		0x4506	SMCWUSB-G
+product ACCTON SMCWUSBTG2_NF	0x4507	SMCWUSBT-G2 (no firmware)
+product ACCTON SMCWUSBTG2	0x4508	SMCWUSBT-G2
+product ACCTON PRISM_GT		0x4521	PrismGT USB 2.0 WLAN
+product ACCTON SS1001		0x5046	SpeedStream Ethernet Adapter
+product ACCTON RT2870_2		0x6618	RT2870
+product ACCTON RT3070		0x7511	RT3070
+product ACCTON RT2770		0x7512	RT2770
+product ACCTON RT2870_3		0x7522	RT2870
+product ACCTON RT2870_5		0x8522	RT2870
+product ACCTON RT3070_4		0xa512	RT3070
+product ACCTON RT2870_4		0xa618	RT2870
+product	ACCTON RT3070_1		0xa701	RT3070
+product	ACCTON RT3070_2		0xa702	RT3070
+product ACCTON RT2870_1		0xb522	RT2870
+product	ACCTON RT3070_3		0xc522	RT3070
+product	ACCTON RT3070_5		0xd522	RT3070
+product ACCTON RTL8192SU        0xc512  RTL8192SU
+product ACCTON ZD1211B		0xe501	ZD1211B
+product ACCTON WN7512		0xf522	WN7512
+
+/* Aceeca products */
+product ACEECA MEZ1000		0x0001	MEZ1000 RDA
+
+/* Acer Communications & Multimedia (oemd by Surecom) */
+product ACERCM EP1427X2		0x0893	EP-1427X-2 Ethernet Adapter
+
+/* Acer Labs products */
+product ACERLABS M5632		0x5632	USB 2.0 Data Link
+
+/* Acer Peripherals, Inc. products */
+product ACERP ACERSCAN_C310U	0x12a6	Acerscan C310U
+product ACERP ACERSCAN_320U	0x2022	Acerscan 320U
+product ACERP ACERSCAN_640U	0x2040	Acerscan 640U
+product ACERP ACERSCAN_620U	0x2060	Acerscan 620U
+product ACERP ACERSCAN_4300U	0x20b0	Benq 3300U/4300U
+product ACERP ACERSCAN_640BT	0x20be	Acerscan 640BT
+product ACERP ACERSCAN_1240U	0x20c0	Acerscan 1240U
+product ACERP S81		0x4027	BenQ S81 phone
+product ACERP H10		0x4068	AWL400 Wireless Adapter
+product ACERP ATAPI		0x6003	ATA/ATAPI Adapter
+product ACERP AWL300		0x9000	AWL300 Wireless Adapter
+product ACERP AWL400		0x9001	AWL400 Wireless Adapter
+
+/* Acer Warp products */
+product ACERW WARPLINK		0x0204	Warplink
+
+/* Actions products */
+product ACTIONS MP4		0x1101  Actions MP4 Player
+
+/* Actiontec, Inc. products */
+product ACTIONTEC PRISM_25	0x0408	Prism2.5 Wireless Adapter
+product ACTIONTEC PRISM_25A	0x0421	Prism2.5 Wireless Adapter A
+product ACTIONTEC FREELAN	0x6106	ROPEX FreeLan 802.11b
+product ACTIONTEC UAT1		0x7605	UAT1 Wireless Ethernet Adapter
+
+/* ACTiSYS products */
+product ACTISYS IR2000U		0x0011	ACT-IR2000U FIR
+
+/* ActiveWire, Inc. products */
+product ACTIVEWIRE IOBOARD	0x0100	I/O Board
+product ACTIVEWIRE IOBOARD_FW1	0x0101	I/O Board, rev. 1 firmware
+
+/* Adaptec products */
+product ADAPTEC AWN8020		0x0020	AWN-8020 WLAN
+
+/* Addonics products */
+product ADDONICS2 205		0xa001	Cable 205
+
+/* Addtron products */
+product ADDTRON AWU120		0xff31	AWU-120
+
+/* ADLINK Texhnology products */
+product ADLINK ND6530		0x6530	ND-6530 USB-Serial
+
+/* ADMtek products */
+product ADMTEK PEGASUSII_4	0x07c2	AN986A Ethernet
+product ADMTEK PEGASUS		0x0986	AN986 Ethernet
+product ADMTEK PEGASUSII	0x8511	AN8511 Ethernet
+product ADMTEK PEGASUSII_2	0x8513	AN8513 Ethernet
+product ADMTEK PEGASUSII_3	0x8515	AN8515 Ethernet
+
+/* ADDON products */
+/* PNY OEMs these */
+product ADDON ATTACHE		0x1300	USB 2.0 Flash Drive
+product ADDON ATTACHE		0x1300	USB 2.0 Flash Drive
+product ADDON A256MB		0x1400	Attache 256MB USB 2.0 Flash Drive
+product ADDON DISKPRO512	0x1420	USB 2.0 Flash Drive (DANE-ELEC zMate 512MB USB flash drive)
+
+/* Addonics products */
+product ADDONICS2 CABLE_205	0xa001	Cable 205
+
+/* ADS products */
+product ADS UBS10BT		0x0008	UBS-10BT Ethernet
+product ADS UBS10BTX		0x0009	UBS-10BT Ethernet
+
+/* AEI products */
+product AEI FASTETHERNET	0x1701	Fast Ethernet
+
+/* Afatech Technologies, Inc. */
+product AFATECH AFATECH1336	0x1336	Flash Card Reader
+
+/* Agate Technologies products */
+product AGATE QDRIVE		0x0378	Q-Drive
+
+/* AGFA products */
+product AGFA SNAPSCAN1212U	0x0001	SnapScan 1212U
+product AGFA SNAPSCAN1236U	0x0002	SnapScan 1236U
+product AGFA SNAPSCANTOUCH	0x0100	SnapScan Touch
+product AGFA SNAPSCAN1212U2	0x2061	SnapScan 1212U
+product AGFA SNAPSCANE40	0x208d	SnapScan e40
+product AGFA SNAPSCANE50	0x208f	SnapScan e50
+product AGFA SNAPSCANE20	0x2091	SnapScan e20
+product AGFA SNAPSCANE25	0x2095	SnapScan e25
+product AGFA SNAPSCANE26	0x2097	SnapScan e26
+product AGFA SNAPSCANE52	0x20fd	SnapScan e52
+
+/* Ain Communication Technology products */
+product AINCOMM AWU2000B	0x1001	AWU2000B Wireless Adapter
+
+/* AIPTEK products */
+product AIPTEK POCKETCAM3M	0x2011	PocketCAM 3Mega
+product AIPTEK2 PENCAM_MEGA_1_3 0x504a	PenCam Mega 1.3
+product AIPTEK2 SUNPLUS_TECH	0x0c15	Sunplus Technology Inc.
+
+/* AirPlis products */
+product AIRPLUS MCD650		0x3198	MCD650 modem
+
+/* AirPrime products */
+product AIRPRIME PC5220		0x0112	CDMA Wireless PC Card
+product AIRPRIME USB308		0x68A3	USB308 HSPA+ USB Modem
+product AIRPRIME AC313U		0x68aa	Sierra Wireless AirCard 313U
+
+/* AirTies products */
+product AIRTIES RT3070		0x2310	RT3070
+
+/* AKS products */
+product AKS USBHASP		0x0001	USB-HASP 0.06
+
+/* Alcatel products */
+product ALCATEL OT535		0x02df	One Touch 535/735
+
+/* Alcor Micro, Inc. products */
+product ALCOR2 KBD_HUB		0x2802	Kbd Hub
+
+product ALCOR DUMMY		0x0000	Dummy product
+product ALCOR SDCR_6335		0x6335	SD/MMC Card Reader
+product ALCOR SDCR_6362		0x6362	SD/MMC Card Reader
+product ALCOR SDCR_6366		0x6366	SD/MMC Card Reader
+product ALCOR TRANSCEND		0x6387	Transcend JetFlash Drive
+product ALCOR MA_KBD_HUB	0x9213	MacAlly Kbd Hub
+product ALCOR AU9814		0x9215	AU9814 Hub
+product ALCOR UMCR_9361		0x9361	USB Multimedia Card Reader
+product ALCOR SM_KBD		0x9410	MicroConnectors/StrongMan Keyboard
+product ALCOR NEC_KBD_HUB	0x9472	NEC Kbd Hub
+product ALCOR AU9720 		0x9720	USB2 - RS-232
+product ALCOR AU6390	0x6390	AU6390 USB-IDE converter
+
+/* Alink products */
+product ALINK DWM652U5		0xce16	DWM-652
+product ALINK 3G		0x9000	3G modem
+product ALINK SIM7600E		0x9001	LTE modem
+product ALINK 3GU		0x9200	3G modem
+
+/* Altec Lansing products */
+product ALTEC ADA70		0x0070	ADA70 Speakers
+product ALTEC ASC495		0xff05	ASC495 Speakers
+
+/* Alti-2 products */
+product ALTI2 N3		0x6001	FTDI compatible adapter
+
+/* Allied Telesyn International products */
+product ALLIEDTELESYN ATUSB100	0xb100	AT-USB100
+
+/* ALLWIN Tech products */
+product ALLWIN RT2070		0x2070	RT2070
+product ALLWIN RT2770		0x2770	RT2770
+product ALLWIN RT2870		0x2870	RT2870
+product ALLWIN RT3070		0x3070	RT3070
+product ALLWIN RT3071		0x3071	RT3071
+product ALLWIN RT3072		0x3072	RT3072
+product ALLWIN RT3572		0x3572	RT3572
+
+/* AlphaSmart, Inc. products */
+product ALPHASMART DANA_KB	0xdbac	AlphaSmart Dana Keyboard
+product ALPHASMART DANA_SYNC	0xdf00	AlphaSmart Dana HotSync
+
+/* Amoi products */
+product AMOI H01		0x0800	H01 3G modem
+product AMOI H01A		0x7002	H01A 3G modem
+product AMOI H02		0x0802	H02 3G modem
+
+/* American Power Conversion products */
+product APC UPS			0x0002	Uninterruptible Power Supply
+
+/* Ambit Microsystems products */
+product AMBIT WLAN		0x0302	WLAN
+product AMBIT NTL_250		0x6098	NTL 250 cable modem
+
+/* Apacer products */
+product APACER HT202		0xb113	USB 2.0 Flash Drive
+
+/* American Power Conversion products */
+product APC UPS			0x0002	Uninterruptible Power Supply
+
+/* Amigo Technology products */
+product AMIGO RT2870_1		0x9031	RT2870
+product AMIGO RT2870_2		0x9041	RT2870
+
+/* AMIT products */
+product AMIT CGWLUSB2GO		0x0002	CG-WLUSB2GO
+product AMIT CGWLUSB2GNR	0x0008	CG-WLUSB2GNR
+product AMIT RT2870_1		0x0012	RT2870
+
+/* AMIT(2) products */
+product AMIT2 RT2870		0x0008	RT2870
+
+/* Analog Devices products */
+product ANALOGDEVICES GNICE	0xf000	FTDI compatible adapter
+product ANALOGDEVICES GNICEPLUS	0xf001	FTDI compatible adapter
+
+/* Anchor products */
+product ANCHOR SERIAL		0x2008	Serial
+product ANCHOR EZUSB		0x2131	EZUSB
+product ANCHOR EZLINK		0x2720	EZLINK
+
+/* AnyData products */
+product ANYDATA ADU_620UW	0x6202	CDMA 2000 EV-DO USB Modem
+product ANYDATA ADU_E100X	0x6501	CDMA 2000 1xRTT/EV-DO USB Modem
+product ANYDATA ADU_500A	0x6502	CDMA 2000 EV-DO USB Modem
+
+/* AOX, Inc. products */
+product AOX USB101		0x0008	Ethernet
+
+/* American Power Conversion products */
+product APC UPS			0x0002	Uninterruptible Power Supply
+
+/* Apple Computer products */
+product APPLE DUMMY		0x0000	Dummy product
+product APPLE IMAC_KBD		0x0201	USB iMac Keyboard
+product APPLE KBD		0x0202	USB Keyboard M2452
+product APPLE EXT_KBD		0x020c	Apple Extended USB Keyboard
+/* MacbookAir, aka wellspring */
+product APPLE WELLSPRING_ANSI	0x0223	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING_ISO	0x0224	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING_JIS	0x0225	Apple Internal Keyboard/Trackpad
+/* MacbookProPenryn, aka wellspring2 */
+product APPLE WELLSPRING2_ANSI	0x0230	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING2_ISO	0x0231	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING2_JIS	0x0232	Apple Internal Keyboard/Trackpad
+/* Macbook5,1 (unibody), aka wellspring3 */
+product APPLE WELLSPRING3_ANSI	0x0236	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING3_ISO	0x0237	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING3_JIS	0x0238	Apple Internal Keyboard/Trackpad
+/* MacbookAir3,2 (unibody), aka wellspring4 */
+product APPLE WELLSPRING4_ANSI	0x023f	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING4_ISO	0x0240	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING4_JIS	0x0241	Apple Internal Keyboard/Trackpad
+/* MacbookAir3,1 (unibody), aka wellspring4 */
+product APPLE WELLSPRING4A_ANSI	0x0242	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING4A_ISO	0x0243	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING4A_JIS	0x0244	Apple Internal Keyboard/Trackpad
+/* Macbook8 (unibody, March 2011) */
+product APPLE WELLSPRING5_ANSI	0x0245	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING5_ISO	0x0246	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING5_JIS	0x0247	Apple Internal Keyboard/Trackpad
+/* MacbookAir4,1 (unibody, July 2011) */
+product APPLE WELLSPRING6A_ANSI	0x0249	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING6A_ISO	0x024a	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING6A_JIS	0x024b	Apple Internal Keyboard/Trackpad
+/* MacbookAir4,2 (unibody, July 2011) */
+product APPLE WELLSPRING6_ANSI	0x024c	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING6_ISO	0x024d	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING6_JIS	0x024e	Apple Internal Keyboard/Trackpad
+/* Macbook8,2 (unibody) */
+product APPLE WELLSPRING5A_ANSI	0x0252	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING5A_ISO	0x0253	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING5A_JIS	0x0254	Apple Internal Keyboard/Trackpad
+/* MacbookPro10,1 (unibody, June 2012) */
+product APPLE WELLSPRING7_ANSI	0x0262	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING7_ISO	0x0263	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING7_JIS	0x0264	Apple Internal Keyboard/Trackpad
+/* MacbookPro10,2 (unibody, October 2012) */
+product APPLE WELLSPRING7A_ANSI	0x0259	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING7A_ISO	0x025a	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING7A_JIS	0x025b	Apple Internal Keyboard/Trackpad
+/* MacbookAir6,2 (unibody, June 2013) */
+product APPLE WELLSPRING8_ANSI	0x0290	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING8_ISO	0x0291	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING8_JIS	0x0292	Apple Internal Keyboard/Trackpad
+/* MacbookPro12,1 */
+product APPLE WELLSPRING9_ANSI	0x0272	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING9_ISO	0x0273	Apple Internal Keyboard/Trackpad
+product APPLE WELLSPRING9_JIS	0x0274	Apple Internal Keyboard/Trackpad
+product APPLE MOUSE		0x0301	Mouse M4848
+product APPLE OPTMOUSE		0x0302	Optical mouse
+product APPLE MIGHTYMOUSE	0x0304	Mighty Mouse
+product APPLE KBD_HUB		0x1001	Hub in Apple USB Keyboard
+product APPLE EXT_KBD_HUB	0x1003	Hub in Apple Extended USB Keyboard
+product APPLE SPEAKERS		0x1101	Speakers
+product APPLE IPOD		0x1201	iPod
+product APPLE IPOD2G		0x1202	iPod 2G
+product APPLE IPOD3G		0x1203	iPod 3G
+product APPLE IPOD_04		0x1204	iPod '04'
+product APPLE IPODMINI		0x1205	iPod Mini
+product APPLE IPOD_06		0x1206	iPod '06'
+product APPLE IPOD_07		0x1207	iPod '07'
+product APPLE IPOD_08		0x1208	iPod '08'
+product APPLE IPODVIDEO		0x1209	iPod Video
+product APPLE IPODNANO		0x120a	iPod Nano
+product APPLE IPHONE		0x1290	iPhone
+product APPLE IPOD_TOUCH	0x1291	iPod Touch
+product APPLE IPHONE_3G		0x1292	iPhone 3G
+product APPLE IPHONE_3GS	0x1294	iPhone 3GS
+product APPLE IPHONE_4		0x1297	iPhone 4
+product APPLE IPHONE_4S		0x12a0	iPhone 4S
+product APPLE IPHONE_5		0x12a8  iPhone 5
+product APPLE IPAD		0x129a	iPad
+product APPLE ETHERNET		0x1402	Ethernet A1277
+
+/* Arkmicro Technologies */
+product ARKMICRO ARK3116	0x0232	ARK3116 Serial
+
+/* Asahi Optical products */
+product ASAHIOPTICAL OPTIO230	0x0004	Digital camera
+product ASAHIOPTICAL OPTIO330	0x0006	Digital camera
+
+/* Asante products */
+product ASANTE EA		0x1427	Ethernet
+
+/* ASIX Electronics products */
+product ASIX AX88172		0x1720	10/100 Ethernet
+product ASIX AX88178		0x1780	AX88178
+product ASIX AX88178A		0x178a	AX88178A USB 2.0 10/100/1000 Ethernet
+product ASIX AX88179		0x1790	AX88179 USB 3.0 10/100/1000 Ethernet
+product ASIX AX88772		0x7720	AX88772
+product ASIX AX88772A		0x772a	AX88772A USB 2.0 10/100 Ethernet
+product ASIX AX88772B		0x772b	AX88772B USB 2.0 10/100 Ethernet
+product ASIX AX88772B_1		0x7e2b	AX88772B USB 2.0 10/100 Ethernet
+
+/* ASUS products */
+product ASUS2 USBN11		0x0b05	USB-N11
+product ASUS RT2570		0x1706	RT2500USB Wireless Adapter
+product ASUS WL167G		0x1707	WL-167g Wireless Adapter
+product ASUS WL159G		0x170c	WL-159g
+product ASUS A9T_WIFI		0x171b	A9T wireless
+product ASUS P5B_WIFI		0x171d	P5B wireless
+product ASUS RT2573_1		0x1723	RT2573
+product ASUS RT2573_2		0x1724	RT2573
+product ASUS LCM		0x1726	LCM display
+product ASUS RT2870_1		0x1731	RT2870
+product ASUS RT2870_2		0x1732	RT2870
+product ASUS RT2870_3		0x1742	RT2870
+product ASUS RT2870_4		0x1760	RT2870
+product ASUS RT2870_5		0x1761	RT2870
+product	ASUS USBN13		0x1784	USB-N13
+product ASUS USBN10		0x1786	USB-N10
+product ASUS RT3070_1		0x1790	RT3070
+product ASUS RTL8192SU		0x1791  RTL8192SU
+product ASUS USB_N53		0x179d	ASUS Black Diamond Dual Band USB-N53
+product ASUS RTL8192CU		0x17ab	RTL8192CU
+product ASUS USBN66		0x17ad	USB-N66
+product ASUS USBN10NANO		0x17ba	USB-N10 Nano
+product ASUS USBAC51		0x17d1	USB-AC51
+product ASUS USBAC56		0x17d2	USB-AC56
+product ASUS A730W		0x4202	ASUS MyPal A730W
+product ASUS P535		0x420f	ASUS P535 PDA
+product ASUS GMSC		0x422f	ASUS Generic Mass Storage
+
+/* ATen products */
+product ATEN UC1284		0x2001	Parallel printer
+product ATEN UC10T		0x2002	10Mbps Ethernet
+product ATEN UC110T		0x2007	UC-110T Ethernet
+product ATEN UC232A		0x2008	Serial
+product ATEN UC210T		0x2009	UC-210T Ethernet
+product ATEN DSB650C		0x4000	DSB-650C
+
+/* ATP Electronics products */
+product ATP EUSB		0xaf01	ATP IG eUSB SSD
+
+/* Atheros Communications products */
+product ATHEROS AR5523		0x0001	AR5523
+product ATHEROS AR5523_NF	0x0002	AR5523 (no firmware)
+product ATHEROS2 AR5523_1	0x0001	AR5523
+product ATHEROS2 AR5523_1_NF	0x0002	AR5523 (no firmware)
+product ATHEROS2 AR5523_2	0x0003	AR5523
+product ATHEROS2 AR5523_2_NF	0x0004	AR5523 (no firmware)
+product ATHEROS2 AR5523_3	0x0005	AR5523
+product ATHEROS2 AR5523_3_NF	0x0006	AR5523 (no firmware)
+product ATHEROS2 TG121N		0x1001	TG121N
+product ATHEROS2 WN821NV2	0x1002	WN821NV2
+product ATHEROS2 3CRUSBN275	0x1010	3CRUSBN275
+product ATHEROS2 WN612		0x1011	WN612
+product ATHEROS2 AR9170		0x9170	AR9170
+
+/* Atmel Comp. products */
+product ATMEL STK541		0x2109	Zigbee Controller
+product ATMEL UHB124		0x3301	AT43301 USB 1.1 Hub
+product ATMEL DWL120		0x7603	DWL-120 Wireless Adapter
+product ATMEL BW002		0x7605	BW002 Wireless Adapter
+product ATMEL WL1130USB		0x7613	WL-1130 USB
+product ATMEL AT76C505A		0x7614	AT76c505a Wireless Adapter
+
+/* AuthenTec products */
+product AUTHENTEC AES1610	0x1600	AES1610 Fingerprint Sensor
+
+/* Avision products */
+product AVISION 1200U		0x0268	1200U scanner
+
+/* AVM products */
+product AVM FRITZWLAN		0x8401	FRITZ!WLAN N
+
+/* Axesstel products */
+product AXESSTEL DATAMODEM	0x1000  Data Modem
+
+/* AsureWave products */
+product AZUREWAVE RT2870_1	0x3247	RT2870
+product AZUREWAVE RT2870_2	0x3262	RT2870
+product AZUREWAVE RT3070_1	0x3273	RT3070
+product	AZUREWAVE RT3070_2	0x3284	RT3070
+product	AZUREWAVE RT3070_3	0x3305	RT3070
+product AZUREWAVE RTL8188CU	0x3357	RTL8188CU
+product AZUREWAVE RTL8188CE_1	0x3358  RTL8188CE
+product AZUREWAVE RTL8188CE_2	0x3359  RTL8188CE
+product AZUREWAVE RTL8192SU_1	0x3306	RTL8192SU
+product AZUREWAVE RTL8192SU_2	0x3309	RTL8192SU
+product AZUREWAVE RTL8192SU_3	0x3310	RTL8192SU
+product AZUREWAVE RTL8192SU_4	0x3311	RTL8192SU
+product AZUREWAVE RTL8192SU_5	0x3325	RTL8192SU
+
+/* Baltech products */
+product BALTECH CARDREADER	0x9999	Card reader
+
+/* Bayer products */
+product BAYER CONTOUR_CABLE	0x6001	FTDI compatible adapter
+
+/* B&B Electronics products */
+product BBELECTRONICS USOTL4	0xAC01	RS-422/485
+product BBELECTRONICS 232USB9M		0xac27	FTDI compatible adapter
+product BBELECTRONICS 485USB9F_2W	0xac25	FTDI compatible adapter
+product BBELECTRONICS 485USB9F_4W	0xac26	FTDI compatible adapter
+product BBELECTRONICS 485USBTB_2W	0xac33	FTDI compatible adapter
+product BBELECTRONICS 485USBTB_4W	0xac34	FTDI compatible adapter
+product BBELECTRONICS TTL3USB9M		0xac50	FTDI compatible adapter
+product BBELECTRONICS TTL5USB9M		0xac49	FTDI compatible adapter
+product BBELECTRONICS USO9ML2		0xac03	FTDI compatible adapter
+product BBELECTRONICS USO9ML2DR		0xac17	FTDI compatible adapter
+product BBELECTRONICS USO9ML2DR_2	0xac16	FTDI compatible adapter
+product BBELECTRONICS USOPTL4		0xac11	FTDI compatible adapter
+product BBELECTRONICS USOPTL4DR		0xac19	FTDI compatible adapter
+product BBELECTRONICS USOPTL4DR2	0xac18	FTDI compatible adapter
+product BBELECTRONICS USPTL4		0xac12	FTDI compatible adapter
+product BBELECTRONICS USTL4		0xac02	FTDI compatible adapter
+product BBELECTRONICS ZZ_PROG1_USB	0xba02	FTDI compatible adapter
+
+/* Belkin products */
+/*product BELKIN F5U111		0x????	F5U111 Ethernet*/
+product BELKIN F5D6050		0x0050	F5D6050 802.11b Wireless Adapter
+product BELKIN FBT001V		0x0081	FBT001v2 Bluetooth
+product BELKIN FBT003V		0x0084	FBT003v2 Bluetooth
+product BELKIN F5U103		0x0103	F5U103 Serial
+product BELKIN F5U109		0x0109	F5U109 Serial
+product BELKIN USB2SCSI		0x0115	USB to SCSI
+product BELKIN F8T012		0x0121	F8T012xx1 Bluetooth USB Adapter
+product BELKIN USB2LAN		0x0121	USB to LAN
+product BELKIN F5U208		0x0208	F5U208 VideoBus II
+product BELKIN F5U237		0x0237	F5U237 USB 2.0 7-Port Hub
+product BELKIN F5U257		0x0257	F5U257 Serial
+product BELKIN F5U409		0x0409	F5U409 Serial
+product BELKIN F6C550AVR	0x0551	F6C550-AVR UPS
+product BELKIN F5U120		0x1203	F5U120-PC Hub
+product BELKIN RTL8188CU	0x1102  RTL8188CU Wireless Adapter
+product BELKIN F9L1103		0x1103	F9L1103 Wireless Adapter
+product BELKIN RTL8192CU	0x2102	RTL8192CU Wireless Adapter
+product BELKIN F7D2102		0x2103  F7D2102 Wireless Adapter
+product BELKIN F5U258		0x258A	F5U258 Host to Host cable
+product BELKIN ZD1211B		0x4050	ZD1211B
+product BELKIN F5D5055		0x5055	F5D5055
+product BELKIN F5D7050		0x7050	F5D7050 Wireless Adapter
+product BELKIN F5D7051		0x7051	F5D7051 54g USB Network Adapter
+product BELKIN F5D7050A		0x705a	F5D7050A Wireless Adapter
+/* Also sold as 'Ativa 802.11g wireless card' */
+product BELKIN F5D7050_V4000	0x705c	F5D7050 v4000 Wireless Adapter
+product BELKIN F5D7050E		0x705e	F5D7050E Wireless Adapter
+product BELKIN RT2870_1		0x8053	RT2870
+product BELKIN RT2870_2		0x805c	RT2870
+product BELKIN F5D8053V3	0x815c	F5D8053 v3
+product BELKIN RTL8192SU_1	0x815f	RTL8192SU
+product BELKIN RTL8192SU_2	0x845a	RTL8192SU
+product BELKIN RTL8192SU_3	0x945a	RTL8192SU
+product BELKIN F5D8055		0x825a	F5D8055
+product BELKIN F5D8055V2	0x825b	F5D8055 v2
+product BELKIN F5D9050V3	0x905b	F5D9050 ver 3 Wireless Adapter
+product BELKIN2 F5U002		0x0002	F5U002 Parallel printer
+product BELKIN F6D4050V1	0x935a	F6D4050 v1
+product BELKIN F6D4050V2	0x935b	F6D4050 v2
+
+/* Billionton products */
+product BILLIONTON USB100	0x0986	USB100N 10/100 FastEthernet
+product BILLIONTON USBLP100	0x0987	USB100LP
+product BILLIONTON USBEL100	0x0988	USB100EL
+product BILLIONTON USBE100	0x8511	USBE100
+product BILLIONTON USB2AR	0x90ff	USB2AR Ethernet
+
+/* Broadcom products */
+product BROADCOM BCM2033	0x2033	BCM2033 Bluetooth USB dongle
+
+/* Brother Industries products */
+product BROTHER HL1050		0x0002	HL-1050 laser printer
+product BROTHER MFC8600_9650	0x0100	MFC8600/9650 multifunction device
+
+/* Behavior Technology Computer products */
+product BTC BTC6100		0x5550	6100C Keyboard
+product BTC BTC7932		0x6782	Keyboard with mouse port
+
+/* CACE Technologies products */
+product CACE AIRPCAPNX		0x0300	AirPcap NX
+
+/* Canon, Inc. products */
+product CANON N656U		0x2206	CanoScan N656U
+product CANON N1220U		0x2207	CanoScan N1220U
+product CANON D660U		0x2208	CanoScan D660U
+product CANON N676U		0x220d	CanoScan N676U
+product CANON N1240U		0x220e	CanoScan N1240U
+product CANON LIDE25		0x2220	CanoScan LIDE 25
+product CANON S10		0x3041	PowerShot S10
+product CANON S100		0x3045	PowerShot S100
+product CANON S200		0x3065	PowerShot S200
+product CANON REBELXT		0x30ef	Digital Rebel XT
+
+/* CATC products */
+product CATC NETMATE		0x000a	Netmate Ethernet
+product CATC NETMATE2		0x000c	Netmate2 Ethernet
+product CATC CHIEF		0x000d	USB Chief Bus & Protocol Analyzer
+product CATC ANDROMEDA		0x1237	Andromeda hub
+
+/* CASIO products */
+product CASIO QV_DIGICAM	0x1001	QV DigiCam
+product CASIO EXS880		0x1105	Exilim EX-S880
+product CASIO BE300		0x2002	BE-300 PDA
+product CASIO NAMELAND		0x4001	CASIO Nameland EZ-USB
+
+/* CCYU products */
+product CCYU ED1064		0x2136	EasyDisk ED1064
+
+/* Century products */
+product CENTURY EX35QUAT	0x011e	Century USB Disk Enclosure
+product CENTURY EX35SW4_SB4	0x011f	Century USB Disk Enclosure
+
+/* Cherry products */
+product CHERRY MY3000KBD	0x0001	My3000 keyboard
+product CHERRY MY3000HUB	0x0003	My3000 hub
+product CHERRY CYBOARD		0x0004	CyBoard Keyboard
+
+/* Chic Technology products */
+product CHIC MOUSE1		0x0001	mouse
+product CHIC CYPRESS		0x0003	Cypress USB Mouse
+
+/* Chicony products */
+product CHICONY KB8933		0x0001	KB-8933 keyboard
+product CHICONY KU0325		0x0116	KU-0325 keyboard
+product CHICONY CNF7129		0xb071	Notebook Web Camera
+product CHICONY HDUVCCAM	0xb40a	HD UVC WebCam
+product	CHICONY RTL8188CUS_1	0xaff7	RTL8188CUS
+product	CHICONY RTL8188CUS_2	0xaff8	RTL8188CUS
+product	CHICONY RTL8188CUS_3	0xaff9	RTL8188CUS
+product	CHICONY RTL8188CUS_4	0xaffa	RTL8188CUS
+product	CHICONY RTL8188CUS_5	0xaffa	RTL8188CUS
+product CHICONY2 TWINKLECAM	0x600d	TwinkleCam USB camera
+
+/* CH Products */
+product CHPRODUCTS PROTHROTTLE	0x00f1	Pro Throttle
+product CHPRODUCTS PROPEDALS	0x00f2	Pro Pedals
+product CHPRODUCTS FIGHTERSTICK 0x00f3	Fighterstick
+product CHPRODUCTS FLIGHTYOKE	0x00ff	Flight Sim Yoke
+
+/* Cisco-Linksys products */
+product CISCOLINKSYS WUSB54AG	0x000c	WUSB54AG Wireless Adapter
+product CISCOLINKSYS WUSB54G	0x000d	WUSB54G Wireless Adapter
+product CISCOLINKSYS WUSB54GP	0x0011	WUSB54GP Wireless Adapter
+product CISCOLINKSYS USB200MV2	0x0018	USB200M v2
+product CISCOLINKSYS HU200TS	0x001a	HU200TS Wireless Adapter
+product CISCOLINKSYS WUSB54GC	0x0020	WUSB54GC
+product CISCOLINKSYS WUSB54GR	0x0023	WUSB54GR
+product CISCOLINKSYS WUSBF54G	0x0024	WUSBF54G
+product CISCOLINKSYS AE1000	0x002f	AE1000
+product CISCOLINKSYS WUSB6300	0x003f	WUSB6300
+product CISCOLINKSYS USB3GIGV1	0x0041  USB3GIGV1 USB Ethernet Adapter
+product CISCOLINKSYS2 RT3070	0x4001	RT3070
+product CISCOLINKSYS3 RT3070	0x0101	RT3070
+
+/* Clipsal products */
+product CLIPSAL 560884		0x0101	560884 C-Bus Audio Matrix Switch
+product CLIPSAL 5500PACA	0x0201	5500PACA C-Bus Pascal Automation Controller
+product CLIPSAL 5800PC		0x0301	5800PC C-Bus Wireless Interface
+product CLIPSAL 5500PCU		0x0303	5500PCU C-Bus Interface
+product CLIPSAL 5000CT2		0x0304	5000CT2 C-Bus Touch Screen
+product CLIPSAL C5000CT2	0x0305	C5000CT2 C-Bus Touch Screen
+product CLIPSAL L51xx		0x0401	L51xx C-Bus Dimmer
+
+/* C-Media products */
+product CMEDIA CM6206		0x0102	CM106 compatible sound device
+
+/* CMOTECH products */
+product CMOTECH CNU510		0x5141	CDMA Technologies USB modem
+product CMOTECH CNU550		0x5543	CDMA 2000 1xRTT/1xEVDO USB modem
+product CMOTECH CGU628		0x6006	CGU-628
+product CMOTECH CDMA_MODEM1	0x6280	CDMA Technologies USB modem
+product CMOTECH DISK		0xf000	disk mode
+
+/* Compaq products */
+product COMPAQ IPAQPOCKETPC	0x0003	iPAQ PocketPC
+product COMPAQ PJB100		0x504a	Personal Jukebox PJB100
+product COMPAQ IPAQLINUX	0x505a	iPAQ Linux
+
+/* Composite Corp products looks the same as "TANGTOP" */
+product COMPOSITE USBPS2	0x0001	USB to PS2 Adaptor
+
+/* Conceptronic products */
+product CONCEPTRONIC PRISM_GT	0x3762	PrismGT USB 2.0 WLAN
+product CONCEPTRONIC C11U	0x7100	C11U
+product CONCEPTRONIC WL210	0x7110	WL-210
+product CONCEPTRONIC AR5523_1	0x7801	AR5523
+product CONCEPTRONIC AR5523_1_NF	0x7802	AR5523 (no firmware)
+product CONCEPTRONIC AR5523_2	0x7811	AR5523
+product CONCEPTRONIC AR5523_2_NF	0x7812	AR5523 (no firmware)
+product CONCEPTRONIC2 RTL8192SU_1	0x3300	RTL8192SU
+product CONCEPTRONIC2 RTL8192SU_2	0x3301	RTL8192SU
+product CONCEPTRONIC2 RTL8192SU_3	0x3302	RTL8192SU
+product CONCEPTRONIC2 C54RU	0x3c02	C54RU WLAN
+product CONCEPTRONIC2 C54RU2	0x3c22	C54RU
+product CONCEPTRONIC2 RT3070_1	0x3c08	RT3070
+product CONCEPTRONIC2 RT3070_2	0x3c11	RT3070
+product CONCEPTRONIC2 VIGORN61	0x3c25	VIGORN61
+product CONCEPTRONIC2 RT2870_1	0x3c06	RT2870
+product CONCEPTRONIC2 RT2870_2	0x3c07	RT2870
+product CONCEPTRONIC2 RT2870_7	0x3c09	RT2870
+product CONCEPTRONIC2 RT2870_8	0x3c12	RT2870
+product CONCEPTRONIC2 RT2870_3	0x3c23	RT2870
+product CONCEPTRONIC2 RT2870_4	0x3c25	RT2870
+product CONCEPTRONIC2 RT2870_5	0x3c27	RT2870
+product CONCEPTRONIC2 RT2870_6	0x3c28	RT2870
+
+/* Connectix products */
+product CONNECTIX QUICKCAM	0x0001	QuickCam
+
+/* Conect products */
+product CONTEC COM1USBH		0x8311	FTDI compatible adapter
+
+/* Corega products */
+product COREGA ETHER_USB_T	0x0001	Ether USB-T
+product COREGA FETHER_USB_TX	0x0004	FEther USB-TX
+product COREGA WLAN_USB_USB_11	0x000c	WirelessLAN USB-11
+product COREGA FETHER_USB_TXS	0x000d	FEther USB-TXS
+product COREGA WLANUSB		0x0012	Wireless LAN Stick-11
+product COREGA FETHER_USB2_TX	0x0017	FEther USB2-TX
+product COREGA WLUSB_11_KEY	0x001a	ULUSB-11 Key
+product COREGA CGUSBRS232R	0x002a	CG-USBRS232R
+product COREGA CGWLUSB2GL	0x002d	CG-WLUSB2GL
+product COREGA CGWLUSB2GPX	0x002e	CG-WLUSB2GPX
+product COREGA RT2870_1		0x002f	RT2870
+product COREGA RT2870_2		0x003c	RT2870
+product COREGA RT2870_3		0x003f	RT2870
+product COREGA RT3070		0x0041	RT3070
+product COREGA CGWLUSB300GNM	0x0042	CG-WLUSB300GNM
+product COREGA RTL8192SU        0x0047  RTL8192SU
+product COREGA RTL8192CU	0x0056  RTL8192CU
+
+product COREGA WLUSB_11_STICK	0x7613	WLAN USB Stick 11
+product COREGA FETHER_USB_TXC	0x9601	FEther USB-TXC
+
+/* Corsair products */
+product CORSAIR K60		0x0a60	Corsair Vengeance K60 keyboard
+product CORSAIR K70		0x1b09	Corsair Vengeance K70 keyboard
+product CORSAIR K70_RGB		0x1b13	Corsair K70 RGB Keyboard
+product CORSAIR STRAFE		0x1b15	Cossair STRAFE Gaming keyboard
+
+/* Creative products */
+product CREATIVE NOMAD_II	0x1002	Nomad II MP3 player
+product CREATIVE NOMAD_IIMG	0x4004	Nomad II MG
+product CREATIVE NOMAD		0x4106	Nomad
+product CREATIVE2 VOIP_BLASTER	0x0258	Voip Blaster
+product CREATIVE3 OPTICAL_MOUSE	0x0001	Notebook Optical Mouse
+
+/* Cambridge Silicon Radio Ltd. products */
+product CSR BT_DONGLE		0x0001	Bluetooth USB dongle
+product CSR CSRDFU		0xffff	USB Bluetooth Device in DFU State
+
+/* Chipsbank Microelectronics Co., Ltd */
+product CHIPSBANK USBMEMSTICK	0x6025	CBM2080 Flash drive controller
+product CHIPSBANK USBMEMSTICK1	0x6026	CBM1180 Flash drive controller
+
+/* CTX products */
+product CTX EX1300		0x9999	Ex1300 hub
+
+/* Curitel products */
+product CURITEL HX550C		0x1101	CDMA 2000 1xRTT USB modem (HX-550C)
+product CURITEL HX57XB		0x2101	CDMA 2000 1xRTT USB modem (HX-570/575B/PR-600)
+product CURITEL PC5740		0x3701	Broadband Wireless modem
+product CURITEL UM150		0x3711	EVDO modem
+product CURITEL UM175		0x3714	EVDO modem
+
+/* CyberPower products */
+product CYBERPOWER 1500CAVRLCD	0x0501	1500CAVRLCD
+
+/* CyberTAN Technology products */
+product CYBERTAN TG54USB	0x1666	TG54USB
+product CYBERTAN RT2870		0x1828	RT2870
+
+/* Cypress Semiconductor products */
+product CYPRESS MOUSE		0x0001	mouse
+product CYPRESS THERMO		0x0002	thermometer
+product CYPRESS WISPY1A		0x0bad	MetaGeek Wi-Spy
+product CYPRESS KBDHUB		0x0101	Keyboard/Hub
+product CYPRESS FMRADIO		0x1002	FM Radio
+product CYPRESS IKARILASER	0x121f	Ikari Laser SteelSeries ApS
+
+product CYPRESS USBRS232	0x5500	USB-RS232 Interface
+product CYPRESS SLIM_HUB	0x6560	Slim Hub
+product CYPRESS XX6830XX	0x6830	PATA Storage Device
+product CYPRESS SILVERSHIELD	0xfd13	Gembird Silver Shield PM
+
+/* Daisy Technology products */
+product DAISY DMC		0x6901	USB MultiMedia Reader
+
+/* Dallas Semiconductor products */
+product DALLAS J6502		0x4201	J-6502 speakers
+
+/* DataApex products */
+product DATAAPEX MULTICOM	0xead6	MultiCom
+
+/* Dell products */
+product DELL PORT		0x0058	Port Replicator
+product DELL AIO926		0x5115	Photo AIO Printer 926
+product DELL BC02		0x8000	BC02 Bluetooth USB Adapter
+product DELL PRISM_GT_1		0x8102	PrismGT USB 2.0 WLAN
+product DELL TM350		0x8103	TrueMobile 350 Bluetooth USB Adapter
+product DELL PRISM_GT_2		0x8104	PrismGT USB 2.0 WLAN
+product DELL U5700		0x8114	Dell 5700 3G
+product DELL U5500		0x8115	Dell 5500 3G
+product DELL U5505		0x8116	Dell 5505 3G
+product DELL U5700_2		0x8117	Dell 5700 3G
+product DELL U5510		0x8118	Dell 5510 3G
+product DELL U5700_3		0x8128	Dell 5700 3G
+product DELL U5700_4		0x8129	Dell 5700 3G
+product DELL U5720		0x8133	Dell 5720 3G
+product DELL U5720_2		0x8134	Dell 5720 3G
+product DELL U740		0x8135	Dell U740 CDMA
+product DELL U5520		0x8136	Dell 5520 3G
+product DELL U5520_2		0x8137	Dell 5520 3G
+product DELL U5520_3		0x8138	Dell 5520 3G
+product DELL U5730		0x8180	Dell 5730 3G
+product DELL U5730_2		0x8181	Dell 5730 3G
+product DELL U5730_3		0x8182	Dell 5730 3G
+product DELL DW700		0x9500	Dell DW700 GPS
+
+/* Delorme Paublishing products */
+product DELORME EARTHMATE	0x0100	Earthmate GPS
+
+/* Desknote products */
+product DESKNOTE UCR_61S2B	0x0c55	UCR-61S2B
+
+/* Diamond products */
+product DIAMOND RIO500USB	0x0001	Rio 500 USB
+
+/* Dick Smith Electronics (really C-Net) products */
+product DICKSMITH RT2573	0x9022	RT2573
+product DICKSMITH CWD854F	0x9032	C-Net CWD-854 rev F
+
+/* Digi International products */
+product DIGI ACCELEPORT2	0x0002	AccelePort USB 2
+product DIGI ACCELEPORT4	0x0004	AccelePort USB 4
+product DIGI ACCELEPORT8	0x0008	AccelePort USB 8
+
+/* Digianswer A/S products */
+product DIGIANSWER ZIGBEE802154	0x000a	ZigBee/802.15.4 MAC
+
+/* D-Link products */
+/*product DLINK DSBS25		0x0100	DSB-S25 serial*/
+product DLINK DUBE100		0x1a00	10/100 Ethernet
+product DLINK DUBE100C1		0x1a02	DUB-E100 rev C1
+product DLINK DSB650TX4		0x200c	10/100 Ethernet
+product DLINK DWL120E		0x3200	DWL-120 rev E
+product DLINK RTL8192CU_1	0x3307	RTL8192CU
+product DLINK RTL8188CU		0x3308	RTL8188CU
+product DLINK RTL8192CU_2	0x3309	RTL8192CU
+product DLINK RTL8192CU_3	0x330a	RTL8192CU
+product DLINK DWA131B		0x330d	DWA-131 rev B
+product DLINK DWA125D1		0x330f	DWA-125 rev D1
+product DLINK DWA123D1		0x3310	DWA-123 rev D1
+product DLINK DWA171A1		0x3314	DWA-171 rev A1
+product DLINK DWA182C1		0x3315	DWA-182 rev C1
+product DLINK DWA180A1		0x3316	DWA-180 rev A1
+product DLINK DWA172A1		0x3318	DWA-172 rev A1
+product DLINK DWA131E1		0x3319	DWA-131 rev E1
+product DLINK DWL122		0x3700	DWL-122
+product DLINK DWLG120		0x3701	DWL-G120
+product DLINK DWL120F		0x3702	DWL-120 rev F
+product DLINK DWLAG132		0x3a00	DWL-AG132
+product DLINK DWLAG132_NF	0x3a01	DWL-AG132 (no firmware)
+product DLINK DWLG132		0x3a02	DWL-G132
+product DLINK DWLG132_NF	0x3a03	DWL-G132 (no firmware)
+product DLINK DWLAG122		0x3a04	DWL-AG122
+product DLINK DWLAG122_NF	0x3a05	DWL-AG122 (no firmware)
+product DLINK DWLG122		0x3c00	DWL-G122 b1 Wireless Adapter
+product DLINK DUBE100B1		0x3c05	DUB-E100 rev B1
+product DLINK RT2870		0x3c09	RT2870
+product DLINK RT3072		0x3c0a	RT3072
+product DLINK DWA140B3		0x3c15	DWA-140 rev B3
+product DLINK DWA125A3		0x3c19	DWA-125 rev A3
+product DLINK DWA160B2		0x3c1a	DWA-160 rev B2
+product DLINK DWA127		0x3c1b	DWA-127 Wireless Adapter
+product DLINK DWA162		0x3c1f	DWA-162 Wireless Adapter
+product DLINK DWA140D1		0x3c20	DWA-140 rev D1
+product DLINK DSB650C		0x4000	10Mbps Ethernet
+product DLINK DSB650TX1		0x4001	10/100 Ethernet
+product DLINK DSB650TX		0x4002	10/100 Ethernet
+product DLINK DSB650TX_PNA	0x4003	1/10/100 Ethernet
+product DLINK DSB650TX3		0x400b	10/100 Ethernet
+product DLINK DSB650TX2		0x4102	10/100 Ethernet
+product DLINK DUB1312		0x4a00	10/100/1000 Ethernet
+product DLINK DWM157		0x7d02  DWM-157
+product DLINK DWR510		0x7e12	DWR-510
+product DLINK DWM222		0x7e35	DWM-222
+product DLINK DWM157_CD		0xa707  DWM-157 CD-ROM Mode
+product DLINK DWR510_CD		0xa805	DWR-510 CD-ROM Mode
+product DLINK DWM222_CD		0xab00	DWM-222 CD-ROM Mode
+product DLINK DSB650		0xabc1	10/100 Ethernet
+product DLINK DUBH7		0xf103	DUB-H7 USB 2.0 7-Port Hub
+product DLINK2 RTL8192SU_1	0x3300	RTL8192SU
+product DLINK2 RTL8192SU_2	0x3302	RTL8192SU
+product DLINK2 DWA131A1		0x3303	DWA-131 A1
+product DLINK2 DWA160A2		0x3a09	DWA-160 A2
+product DLINK2 DWA120		0x3a0c	DWA-120
+product DLINK2 DWA120_NF	0x3a0d	DWA-120 (no firmware)
+product DLINK2 DWA130D1		0x3a0f	DWA-130 D1
+product DLINK2 DWLG122C1	0x3c03	DWL-G122 c1
+product DLINK2 WUA1340		0x3c04	WUA-1340
+product DLINK2 DWA111		0x3c06	DWA-111
+product DLINK2 DWA110		0x3c07	DWA-110
+product DLINK2 RT2870_1		0x3c09	RT2870
+product DLINK2 RT3072		0x3c0a	RT3072
+product DLINK2 RT3072_1		0x3c0b	RT3072
+product DLINK2 RT3070_1		0x3c0d	RT3070
+product DLINK2 RT3070_2		0x3c0e	RT3070
+product DLINK2 RT3070_3		0x3c0f	RT3070
+product DLINK2 DWA160A1		0x3c10	DWA-160 A1
+product DLINK2 RT2870_2		0x3c11	RT2870
+product DLINK2 DWA130		0x3c13	DWA-130
+product DLINK2 RT3070_4		0x3c15	RT3070
+product DLINK2 RT3070_5		0x3c16	RT3070
+product DLINK3 DWM652		0x3e04	DWM-652
+
+/* DisplayLink products */
+product DISPLAYLINK LCD4300U	0x01ba	LCD-4300U
+product DISPLAYLINK LCD8000U	0x01bb	LCD-8000U
+product DISPLAYLINK LD220	0x0100	Samsung LD220
+product DISPLAYLINK GUC2020	0x0059	IOGEAR DVI GUC2020
+product DISPLAYLINK VCUD60	0x0136	Rextron DVI
+product DISPLAYLINK CONV	0x0138	StarTech CONV-USB2DVI
+product DISPLAYLINK DLDVI	0x0141	DisplayLink DVI
+product DISPLAYLINK VGA10	0x015a	CMP-USBVGA10
+product DISPLAYLINK WSDVI	0x0198	WS Tech DVI
+product DISPLAYLINK EC008	0x019b	EasyCAP008 DVI
+product DISPLAYLINK HPDOCK	0x01d4	HP USB Docking
+product DISPLAYLINK NL571	0x01d7	HP USB DVI
+product DISPLAYLINK M01061	0x01e2	Lenovo DVI
+product DISPLAYLINK SWDVI	0x024c	SUNWEIT DVI
+product DISPLAYLINK NBDOCK	0x0215	VideoHome NBdock1920
+product DISPLAYLINK LUM70	0x02a9	Lilliput UM-70
+product DISPLAYLINK UM7X0	0x401a	nanovision MiMo
+product DISPLAYLINK LT1421	0x03e0	Lenovo ThinkVision LT1421
+product DISPLAYLINK POLARIS2	0x0117	Polaris2 USB dock
+product DISPLAYLINK PLUGABLE	0x0377	Plugable docking station
+product DISPLAYLINK ITEC	0x02e9  i-tec USB 2.0 Docking Station
+
+/* DMI products */
+product DMI CFSM_RW		0xa109	CF/SM Reader/Writer
+product DMI DISK		0x2bcf	Generic Disk
+
+/* DrayTek products */
+product DRAYTEK VIGOR550	0x0550	Vigor550
+
+/* Dream Link products */
+product DREAMLINK DL100B	0x0004	USB Webmail Notifier
+
+/* dresden elektronik products */
+product DRESDENELEKTRONIK SENSORTERMINALBOARD  0x0001 SensorTerminalBoard
+product DRESDENELEKTRONIK WIRELESSHANDHELDTERMINAL  0x0004 Wireless Handheld Terminal
+product DRESDENELEKTRONIK DE_RFNODE                 0x001c deRFnode
+product DRESDENELEKTRONIK LEVELSHIFTERSTICKLOWCOST  0x0022 Levelshifter Stick Low Cost
+
+/* DYMO */
+product DYMO LABELMANAGERPNP	0x1001	DYMO LabelManager PnP
+
+/* Dynastream Innovations */
+product DYNASTREAM ANTDEVBOARD	0x1003	ANT dev board
+product DYNASTREAM ANT2USB	0x1004	ANT2USB
+product DYNASTREAM ANTDEVBOARD2	0x1006	ANT dev board
+
+/* Edimax products */
+product EDIMAX EW7318USG	0x7318	USB Wireless dongle
+product EDIMAX RTL8192SU_1	0x7611	RTL8192SU
+product EDIMAX RTL8192SU_2	0x7612	RTL8192SU
+product EDIMAX EW7622UMN	0x7622	EW-7622UMn
+product EDIMAX RT2870_1		0x7711	RT2870
+product EDIMAX EW7717		0x7717	EW-7717
+product EDIMAX EW7718		0x7718	EW-7718
+product EDIMAX EW7733UND	0x7733	EW-7733UnD
+product EDIMAX EW7811UN		0x7811	EW-7811Un
+product	EDIMAX RTL8192CU	0x7822	RTL8192CU
+product EDIMAX EW7811UTC_1	0xa811	EW-7811UTC
+product EDIMAX EW7811UTC_2	0xa812	EW-7811UTC
+product EDIMAX EW7822UAC	0xa822	EW-7822UAC
+
+/* eGalax Products */
+product EGALAX TPANEL		0x0001	Touch Panel
+product EGALAX TPANEL2		0x0002	Touch Panel
+product EGALAX2 TPANEL		0x0001	Touch Panel
+
+/* EGO Products */
+product EGO DUMMY		0x0000	Dummy Product
+product EGO M4U			0x1020	ESI M4U
+
+/* Eicon Networks */
+product EICON DIVA852		0x4905	Diva 852 ISDN TA
+
+/* EIZO products */
+product EIZO HUB		0x0000	hub
+product EIZO MONITOR		0x0001	monitor
+
+/* ELCON Systemtechnik products */
+product ELCON PLAN		0x0002	Goldpfeil P-LAN
+
+/* Elecom products */
+product ELECOM MOUSE29UO	0x0002	mouse 29UO
+product ELECOM LDUSBTX0		0x200c	LD-USB/TX
+product ELECOM LDUSBTX1		0x4002	LD-USB/TX
+product ELECOM LDUSBLTX		0x4005	LD-USBL/TX
+product ELECOM WDC150SU2M	0x4008	WDC-150SU2M
+product ELECOM LDUSBTX2		0x400b	LD-USB/TX
+product ELECOM LDUSB20		0x4010	LD-USB20
+product ELECOM UCSGT		0x5003	UC-SGT
+product ELECOM UCSGT0		0x5004	UC-SGT
+product ELECOM LDUSBTX3		0xabc1	LD-USB/TX
+
+/* Elektor products */
+product ELEKTOR FT323R		0x0005	FTDI compatible adapter
+
+/* Elsa products */
+product ELSA MODEM1		0x2265	ELSA Modem Board
+product ELSA USB2ETHERNET	0x3000	Microlink USB2Ethernet
+
+/* ELV products */
+product ELV USBI2C		0xe00f	USB-I2C interface
+
+/* EMS products */
+product EMS DUAL_SHOOTER	0x0003	PSX gun controller converter
+
+/* Emtec products */
+product EMTEC RUF2PS 		0x2240 Flash Drive
+
+/* Encore products */
+product ENCORE RT3070_1		0x1480	RT3070
+product ENCORE RT3070_2		0x14a1	RT3070
+product ENCORE RT3070_3		0x14a9	RT3070
+
+/* Entrega products */
+product ENTREGA 1S		0x0001	1S serial
+product ENTREGA 2S		0x0002	2S serial
+product ENTREGA 1S25		0x0003	1S25 serial
+product ENTREGA 4S		0x0004	4S serial
+product ENTREGA E45		0x0005	E45 Ethernet
+product ENTREGA CENTRONICS	0x0006	Parallel Port
+product ENTREGA XX1		0x0008	Ethernet
+product ENTREGA 1S9		0x0093	1S9 serial
+product ENTREGA EZUSB		0x8000	EZ-USB
+/*product ENTREGA SERIAL	0x8001	DB25 Serial*/
+product ENTREGA 2U4S		0x8004	2U4S serial/usb hub
+product ENTREGA XX2		0x8005	Ethernet
+/*product ENTREGA SERIAL_DB9	0x8093	DB9 Serial*/
+
+/* Epson products */
+product EPSON PRINTER1		0x0001	USB Printer
+product EPSON PRINTER2		0x0002	ISD USB Smart Cable for Mac
+product EPSON PRINTER3		0x0003	ISD USB Smart Cable
+product EPSON PRINTER5		0x0005	USB Printer
+product EPSON 636		0x0101	Perfection 636U / 636Photo scanner
+product EPSON 610		0x0103	Perfection 610 scanner
+product EPSON 1200		0x0104	Perfection 1200U / 1200Photo scanner
+product EPSON 1600		0x0107	Expression 1600 scanner
+product EPSON 1640		0x010a	Perfection 1640SU scanner
+product EPSON 1240		0x010b	Perfection 1240U / 1240Photo scanner
+product EPSON 640U		0x010c	Perfection 640U scanner
+product EPSON 1250		0x010f	Perfection 1250U / 1250Photo scanner
+product EPSON 1650		0x0110	Perfection 1650 scanner
+product EPSON GT9700F		0x0112	GT-9700F scanner
+product EPSON GT9300UF		0x011b	GT-9300UF scanner
+product EPSON 3200		0x011c	Perfection 3200 scanner
+product EPSON 1260		0x011d	Perfection 1260 scanner
+product EPSON 1660		0x011e	Perfection 1660 scanner
+product EPSON 1670		0x011f	Perfection 1670 scanner
+product EPSON 1270		0x0120	Perfection 1270 scanner
+product EPSON 2480		0x0121	Perfection 2480 scanner
+product EPSON 3590		0x0122	Perfection 3590 scanner
+product EPSON 4990		0x012a	Perfection 4990 Photo scanner
+product EPSON CRESSI_EDY	0x0521	Cressi Edy diving computer
+product EPSON N2ITION3		0x0522	Zeagle N2iTion3 diving computer
+product EPSON STYLUS_875DC	0x0601	Stylus Photo 875DC Card Reader
+product EPSON STYLUS_895	0x0602	Stylus Photo 895 Card Reader
+product EPSON CX5400		0x0808	CX5400 scanner
+product EPSON 3500		0x080e	CX-3500/3600/3650 MFP
+product EPSON RX425		0x080f	Stylus Photo RX425 scanner
+product EPSON DX3800		0x0818	CX3700/CX3800/DX38x0 MFP scanner
+product EPSON 4800		0x0819	CX4700/CX4800/DX48x0 MFP scanner
+product EPSON 4200		0x0820	CX4100/CX4200/DX4200 MFP scanner
+product EPSON 5000		0x082b  CX4900/CX5000/DX50x0 MFP scanner
+product EPSON 6000		0x082e  CX5900/CX6000/DX60x0 MFP scanner
+product EPSON DX4000		0x082f  DX4000 MFP scanner
+product EPSON DX7400		0x0838	CX7300/CX7400/DX7400 MFP scanner
+product EPSON DX8400		0x0839	CX8300/CX8400/DX8400 MFP scanner
+product EPSON SX100		0x0841	SX100/NX100 MFP scanner
+product EPSON NX300		0x0848	NX300 MFP scanner
+product EPSON SX200		0x0849	SX200/SX205 MFP scanner
+product EPSON SX400		0x084a	SX400/NX400/TX400 MFP scanner
+
+/* e-TEK Labs products */
+product ETEK 1COM		0x8007	Serial
+
+/* Evolution products */
+product EVOLUTION ER1		0x0300	FTDI compatible adapter
+product EVOLUTION HYBRID	0x0302	FTDI compatible adapter
+product EVOLUTION RCM4		0x0303	FTDI compatible adapter
+
+/* Extended Systems products */
+product EXTENDED XTNDACCESS	0x0100	XTNDAccess IrDA
+
+/* Falcom products */
+product FALCOM TWIST		0x0001	USB GSM/GPRS Modem
+product FALCOM SAMBA		0x0005	FTDI compatible adapter
+
+/* FEIYA products */
+product FEIYA DUMMY		0x0000	Dummy product
+product FEIYA 5IN1		0x1132	5-in-1 Card Reader
+product FEIYA ELANGO		0x6200	MicroSDHC Card Reader
+product FEIYA AC110		0x6300	AC-110 Card Reader
+
+/* FeiXun Communication products */
+product FEIXUN RTL8188CU	0x0090	RTL8188CU
+product FEIXUN RTL8192CU	0x0091	RTL8192CU
+
+/* Festo */
+product FESTO CPX_USB		0x0102	CPX-USB
+product FESTO CMSP		0x0501	CMSP
+
+/* Fiberline */
+product FIBERLINE WL430U	0x6003	WL-430U
+
+/* FIC / OpenMoko */
+product FIC NEO1973_DEBUG	0x5118	FTDI compatible adapter
+
+/* Fossil, Inc products */
+product FOSSIL WRISTPDA		0x0002	Wrist PDA
+
+/* Foxconn products */
+product FOXCONN TCOM_TC_300	0xe000	T-Com TC 300
+product FOXCONN PIRELLI_DP_L10	0xe003	Pirelli DP-L10
+
+/* Freecom products */
+product FREECOM DVD		0xfc01	DVD drive
+product FREECOM HDD		0xfc05	Classic SL Hard Drive
+
+/* Fujitsu Siemens Computers products */
+product FSC E5400		0x1009	PrismGT USB 2.0 WLAN
+
+/* Future Technology Devices products */
+product FTDI SCX8_USB_PHOENIX	0x5259  SCx8 USB Phoenix interface
+product FTDI SERIAL_8U100AX	0x8372	8U100AX Serial
+product FTDI SERIAL_8U232AM	0x6001	8U232AM Serial
+product FTDI SERIAL_8U232AM4	0x6004	8U232AM Serial
+product FTDI SERIAL_232RL	0x6006	FT232RL Serial
+product FTDI SERIAL_2232C	0x6010	FT2232C Dual port Serial
+product FTDI 232H		0x6014	FTDI compatible adapter
+product FTDI 232EX		0x6015	FTDI compatible adapter
+product FTDI SERIAL_2232D	0x9e90	FT2232D Dual port Serial
+product FTDI SERIAL_4232H	0x6011	FT4232H Quad port Serial
+product FTDI XDS100V2		0xa6d0	TI XDS100V1/V2 and early Beaglebones
+product FTDI XDS100V3		0xa6d1	TI XDS100V3
+product FTDI KTLINK		0xbbe2	KT-LINK Embedded Hackers Multitool
+product FTDI TURTELIZER2	0xbdc8	egnite Turtelizer 2 JTAG/RS232 Adapter
+/* Gude Analog- und Digitalsysteme products also uses FTDI's id: */
+product FTDI TACTRIX_OPENPORT_13M 0xcc48 OpenPort 1.3 Mitsubishi
+product FTDI TACTRIX_OPENPORT_13S 0xcc49 OpenPort 1.3 Subaru
+product FTDI TACTRIX_OPENPORT_13U 0xcc4a OpenPort 1.3 Universal
+product FTDI GAMMASCOUT		0xd678	Gamma-Scout
+product FTDI KBS		0xe6c8	Pyramid KBS USB LCD
+product FTDI EISCOU		0xe888	Expert ISDN Control USB
+product FTDI UOPTBR		0xe889	USB-RS232 OptoBridge
+product FTDI EMCU2D		0xe88a	Expert mouseCLOCK USB II
+product FTDI PCMSFU		0xe88b	Precision Clock MSF USB
+product FTDI EMCU2H		0xe88c	Expert mouseCLOCK USB II HBG
+product FTDI MAXSTREAM		0xee18	Maxstream PKG-U
+product FTDI USB_UIRT		0xf850	USB-UIRT
+product FTDI USBSERIAL		0xfa00	Matrix Orbital USB Serial
+product FTDI MX2_3		0xfa01	Matrix Orbital MX2 or MX3
+product FTDI MX4_5		0xfa02	Matrix Orbital MX4 or MX5
+product FTDI LK202		0xfa03	Matrix Orbital VK/LK202 Family
+product FTDI LK204		0xfa04	Matrix Orbital VK/LK204 Family
+product FTDI CFA_632		0xfc08	Crystalfontz CFA-632 USB LCD
+product FTDI CFA_634		0xfc09	Crystalfontz CFA-634 USB LCD
+product FTDI CFA_633		0xfc0b	Crystalfontz CFA-633 USB LCD
+product FTDI CFA_631		0xfc0c	Crystalfontz CFA-631 USB LCD
+product FTDI CFA_635		0xfc0d	Crystalfontz CFA-635 USB LCD
+product FTDI SEMC_DSS20		0xfc82	SEMC DSS-20 SyncStation
+/* Commerzielle und Technische Informationssysteme GmbH products */
+product FTDI CTI_USB_NANO_485	0xf60b	CTI USB-Nano 485
+product FTDI CTI_USB_MINI_485	0xf608	CTI USB-Mini 485
+/* Other products */
+product FTDI 232RL		0xfbfa	FTDI compatible adapter
+product FTDI 4N_GALAXY_DE_1	0xf3c0	FTDI compatible adapter
+product FTDI 4N_GALAXY_DE_2	0xf3c1	FTDI compatible adapter
+product FTDI 4N_GALAXY_DE_3	0xf3c2	FTDI compatible adapter
+product FTDI 8U232AM_ALT	0x6006	FTDI compatible adapter
+product FTDI ACCESSO		0xfad0	FTDI compatible adapter
+product FTDI ACG_HFDUAL		0xdd20	FTDI compatible adapter
+product FTDI ACTIVE_ROBOTS	0xe548	FTDI compatible adapter
+product FTDI ACTZWAVE		0xf2d0	FTDI compatible adapter
+product FTDI AMC232		0xff00	FTDI compatible adapter
+product FTDI ARTEMIS		0xdf28	FTDI compatible adapter
+product FTDI ASK_RDR400		0xc991	FTDI compatible adapter
+product FTDI ATIK_ATK16		0xdf30	FTDI compatible adapter
+product FTDI ATIK_ATK16C	0xdf32	FTDI compatible adapter
+product FTDI ATIK_ATK16HR	0xdf31	FTDI compatible adapter
+product FTDI ATIK_ATK16HRC	0xdf33	FTDI compatible adapter
+product FTDI ATIK_ATK16IC	0xdf35	FTDI compatible adapter
+product FTDI BCS_SE923		0xfb99	FTDI compatible adapter
+product FTDI CANDAPTER		0x9f80	FTDI compatible adapter
+product FTDI CANUSB		0xffa8	FTDI compatible adapter
+product FTDI CCSICDU20_0	0xf9d0	FTDI compatible adapter
+product FTDI CCSICDU40_1	0xf9d1	FTDI compatible adapter
+product FTDI CCSICDU64_4	0xf9d4	FTDI compatible adapter
+product FTDI CCSLOAD_N_GO_3	0xf9d3	FTDI compatible adapter
+product FTDI CCSMACHX_2		0xf9d2	FTDI compatible adapter
+product FTDI CCSPRIME8_5	0xf9d5	FTDI compatible adapter
+product FTDI CHAMSYS_24_MASTER_WING	0xdaf8	FTDI compatible adapter
+product FTDI CHAMSYS_MAXI_WING	0xdafd	FTDI compatible adapter
+product FTDI CHAMSYS_MEDIA_WING	0xdafe	FTDI compatible adapter
+product FTDI CHAMSYS_MIDI_TIMECODE	0xdafb	FTDI compatible adapter
+product FTDI CHAMSYS_MINI_WING	0xdafc	FTDI compatible adapter
+product FTDI CHAMSYS_PC_WING	0xdaf9	FTDI compatible adapter
+product FTDI CHAMSYS_USB_DMX	0xdafa	FTDI compatible adapter
+product FTDI CHAMSYS_WING	0xdaff	FTDI compatible adapter
+product FTDI COM4SM		0xd578	FTDI compatible adapter
+product FTDI CONVERTER_0	0xd388	FTDI compatible adapter
+product FTDI CONVERTER_1	0xd389	FTDI compatible adapter
+product FTDI CONVERTER_2	0xd38a	FTDI compatible adapter
+product FTDI CONVERTER_3	0xd38b	FTDI compatible adapter
+product FTDI CONVERTER_4	0xd38c	FTDI compatible adapter
+product FTDI CONVERTER_5	0xd38d	FTDI compatible adapter
+product FTDI CONVERTER_6	0xd38e	FTDI compatible adapter
+product FTDI CONVERTER_7	0xd38f	FTDI compatible adapter
+product FTDI DMX4ALL		0xc850	FTDI compatible adapter
+product FTDI DOMINTELL_DGQG	0xef50	FTDI compatible adapter
+product FTDI DOMINTELL_DUSB	0xef51	FTDI compatible adapter
+product FTDI DOTEC		0x9868	FTDI compatible adapter
+product FTDI ECLO_COM_1WIRE	0xea90	FTDI compatible adapter
+product FTDI ECO_PRO_CDS	0xe520	FTDI compatible adapter
+product FTDI ELSTER_UNICOM	0xe700	FTDI compatible adapter
+product FTDI ELV_ALC8500	0xf06e	FTDI compatible adapter
+product FTDI ELV_CLI7000	0xfb59	FTDI compatible adapter
+product FTDI ELV_CSI8		0xe0f0	FTDI compatible adapter
+product FTDI ELV_EC3000		0xe006	FTDI compatible adapter
+product FTDI ELV_EM1000DL	0xe0f1	FTDI compatible adapter
+product FTDI ELV_EM1010PC	0xe0ef	FTDI compatible adapter
+product FTDI ELV_FEM		0xe00a	FTDI compatible adapter
+product FTDI ELV_FHZ1000PC	0xf06f	FTDI compatible adapter
+product FTDI ELV_FHZ1300PC	0xe0e8	FTDI compatible adapter
+product FTDI ELV_FM3RX		0xe0ed	FTDI compatible adapter
+product FTDI ELV_FS20SIG	0xe0f4	FTDI compatible adapter
+product FTDI ELV_HS485		0xe0ea	FTDI compatible adapter
+product FTDI ELV_KL100		0xe002	FTDI compatible adapter
+product FTDI ELV_MSM1		0xe001	FTDI compatible adapter
+product FTDI ELV_PCD200		0xf06c	FTDI compatible adapter
+product FTDI ELV_PCK100		0xe0f2	FTDI compatible adapter
+product FTDI ELV_PPS7330	0xfb5c	FTDI compatible adapter
+product FTDI ELV_RFP500		0xe0f3	FTDI compatible adapter
+product FTDI ELV_T1100		0xf06b	FTDI compatible adapter
+product FTDI ELV_TFD128		0xe0ec	FTDI compatible adapter
+product FTDI ELV_TFM100		0xfb5d	FTDI compatible adapter
+product FTDI ELV_TWS550		0xe009	FTDI compatible adapter
+product FTDI ELV_UAD8		0xf068	FTDI compatible adapter
+product FTDI ELV_UDA7		0xf069	FTDI compatible adapter
+product FTDI ELV_UDF77		0xfb5e	FTDI compatible adapter
+product FTDI ELV_UIO88		0xfb5f	FTDI compatible adapter
+product FTDI ELV_ULA200		0xf06d	FTDI compatible adapter
+product FTDI ELV_UM100		0xfb5a	FTDI compatible adapter
+product FTDI ELV_UMS100		0xe0eb	FTDI compatible adapter
+product FTDI ELV_UO100		0xfb5b	FTDI compatible adapter
+product FTDI ELV_UR100		0xfb58	FTDI compatible adapter
+product FTDI ELV_USI2		0xf06a	FTDI compatible adapter
+product FTDI ELV_USR		0xe000	FTDI compatible adapter
+product FTDI ELV_UTP8		0xe0f5	FTDI compatible adapter
+product FTDI ELV_WS300PC	0xe0f6	FTDI compatible adapter
+product FTDI ELV_WS444PC	0xe0f7	FTDI compatible adapter
+product FTDI ELV_WS500		0xe0e9	FTDI compatible adapter
+product FTDI ELV_WS550		0xe004	FTDI compatible adapter
+product FTDI ELV_WS777		0xe0ee	FTDI compatible adapter
+product FTDI ELV_WS888		0xe008	FTDI compatible adapter
+product FTDI FUTURE_0		0xf44a	FTDI compatible adapter
+product FTDI FUTURE_1		0xf44b	FTDI compatible adapter
+product FTDI FUTURE_2		0xf44c	FTDI compatible adapter
+product FTDI GENERIC		0x9378	FTDI compatible adapter
+product FTDI GUDEADS_E808	0xe808	FTDI compatible adapter
+product FTDI GUDEADS_E809	0xe809	FTDI compatible adapter
+product FTDI GUDEADS_E80A	0xe80a	FTDI compatible adapter
+product FTDI GUDEADS_E80B	0xe80b	FTDI compatible adapter
+product FTDI GUDEADS_E80C	0xe80c	FTDI compatible adapter
+product FTDI GUDEADS_E80D	0xe80d	FTDI compatible adapter
+product FTDI GUDEADS_E80E	0xe80e	FTDI compatible adapter
+product FTDI GUDEADS_E80F	0xe80f	FTDI compatible adapter
+product FTDI GUDEADS_E88D	0xe88d	FTDI compatible adapter
+product FTDI GUDEADS_E88E	0xe88e	FTDI compatible adapter
+product FTDI GUDEADS_E88F	0xe88f	FTDI compatible adapter
+product FTDI HD_RADIO		0x937c	FTDI compatible adapter
+product FTDI HO720		0xed72	FTDI compatible adapter
+product FTDI HO730		0xed73	FTDI compatible adapter
+product FTDI HO820		0xed74	FTDI compatible adapter
+product FTDI HO870		0xed71	FTDI compatible adapter
+product FTDI IBS_APP70		0xff3d	FTDI compatible adapter
+product FTDI IBS_PCMCIA		0xff3a	FTDI compatible adapter
+product FTDI IBS_PEDO		0xff3e	FTDI compatible adapter
+product FTDI IBS_PICPRO		0xff39	FTDI compatible adapter
+product FTDI IBS_PK1		0xff3b	FTDI compatible adapter
+product FTDI IBS_PROD		0xff3f	FTDI compatible adapter
+product FTDI IBS_RS232MON	0xff3c	FTDI compatible adapter
+product FTDI IBS_US485		0xff38	FTDI compatible adapter
+product FTDI IPLUS		0xd070	FTDI compatible adapter
+product FTDI IPLUS2		0xd071	FTDI compatible adapter
+product FTDI IRTRANS		0xfc60	FTDI compatible adapter
+product FTDI LENZ_LIUSB		0xd780	FTDI compatible adapter
+product FTDI LM3S_DEVEL_BOARD	0xbcd8	FTDI compatible adapter
+product FTDI LM3S_EVAL_BOARD	0xbcd9	FTDI compatible adapter
+product FTDI LM3S_ICDI_B_BOARD	0xbcda	FTDI compatible adapter
+product FTDI MASTERDEVEL2	0xf449	FTDI compatible adapter
+product FTDI MHAM_DB9		0xeeed	FTDI compatible adapter
+product FTDI MHAM_IC		0xeeec	FTDI compatible adapter
+product FTDI MHAM_KW		0xeee8	FTDI compatible adapter
+product FTDI MHAM_RS232		0xeeee	FTDI compatible adapter
+product FTDI MHAM_Y6		0xeeea	FTDI compatible adapter
+product FTDI MHAM_Y8		0xeeeb	FTDI compatible adapter
+product FTDI MHAM_Y9		0xeeef	FTDI compatible adapter
+product FTDI MHAM_YS		0xeee9	FTDI compatible adapter
+product FTDI MICRO_CHAMELEON	0xcaa0	FTDI compatible adapter
+product FTDI MTXORB_5		0xfa05	FTDI compatible adapter
+product FTDI MTXORB_6		0xfa06	FTDI compatible adapter
+product FTDI NXTCAM		0xabb8	FTDI compatible adapter
+product FTDI OCEANIC		0xf460	FTDI compatible adapter
+product FTDI OOCDLINK		0xbaf8	FTDI compatible adapter
+product FTDI OPENDCC		0xbfd8	FTDI compatible adapter
+product FTDI OPENDCC_GATEWAY	0xbfdb	FTDI compatible adapter
+product FTDI OPENDCC_GBM	0xbfdc	FTDI compatible adapter
+product FTDI OPENDCC_SNIFFER	0xbfd9	FTDI compatible adapter
+product FTDI OPENDCC_THROTTLE	0xbfda	FTDI compatible adapter
+product FTDI PCDJ_DAC2		0xfa88	FTDI compatible adapter
+product FTDI PERLE_ULTRAPORT	0xf0c0	FTDI compatible adapter
+product FTDI PHI_FISCO		0xe40b	FTDI compatible adapter
+product FTDI PIEGROUP		0xf208	FTDI compatible adapter
+product FTDI PROPOX_JTAGCABLEII	0xd738	FTDI compatible adapter
+product FTDI R2000KU_TRUE_RNG	0xfb80	FTDI compatible adapter
+product FTDI R2X0		0xfc71	FTDI compatible adapter
+product FTDI RELAIS		0xfa10	FTDI compatible adapter
+product FTDI REU_TINY		0xed22	FTDI compatible adapter
+product FTDI RMP200		0xe729	FTDI compatible adapter
+product FTDI RM_CANVIEW		0xfd60	FTDI compatible adapter
+product FTDI RRCIRKITS_LOCOBUFFER	0xc7d0	FTDI compatible adapter
+product FTDI SCIENCESCOPE_HS_LOGBOOK	0xff1d	FTDI compatible adapter
+product FTDI SCIENCESCOPE_LOGBOOKML	0xff18	FTDI compatible adapter
+product FTDI SCIENCESCOPE_LS_LOGBOOK	0xff1c	FTDI compatible adapter
+product FTDI SCS_DEVICE_0	0xd010	FTDI compatible adapter
+product FTDI SCS_DEVICE_1	0xd011	FTDI compatible adapter
+product FTDI SCS_DEVICE_2	0xd012	FTDI compatible adapter
+product FTDI SCS_DEVICE_3	0xd013	FTDI compatible adapter
+product FTDI SCS_DEVICE_4	0xd014	FTDI compatible adapter
+product FTDI SCS_DEVICE_5	0xd015	FTDI compatible adapter
+product FTDI SCS_DEVICE_6	0xd016	FTDI compatible adapter
+product FTDI SCS_DEVICE_7	0xd017	FTDI compatible adapter
+product FTDI SDMUSBQSS		0xf448	FTDI compatible adapter
+product FTDI SIGNALYZER_SH2	0xbca2	FTDI compatible adapter
+product FTDI SIGNALYZER_SH4	0xbca4	FTDI compatible adapter
+product FTDI SIGNALYZER_SLITE	0xbca1	FTDI compatible adapter
+product FTDI SIGNALYZER_ST	0xbca0	FTDI compatible adapter
+product FTDI SPECIAL_1		0xfc70	FTDI compatible adapter
+product FTDI SPECIAL_3		0xfc72	FTDI compatible adapter
+product FTDI SPECIAL_4		0xfc73	FTDI compatible adapter
+product FTDI SPROG_II		0xf0c8	FTDI compatible adapter
+product FTDI SR_RADIO		0x9379	FTDI compatible adapter
+product FTDI SUUNTO_SPORTS	0xf680	FTDI compatible adapter
+product FTDI TAVIR_STK500	0xfa33	FTDI compatible adapter
+product FTDI TERATRONIK_D2XX	0xec89	FTDI compatible adapter
+product FTDI TERATRONIK_VCP	0xec88	FTDI compatible adapter
+product FTDI THORLABS		0xfaf0	FTDI compatible adapter
+product FTDI TIAO		0x8a98	FTDI compatible adapter
+product FTDI TNC_X		0xebe0	FTDI compatible adapter
+product FTDI TTUSB		0xff20	FTDI compatible adapter
+product FTDI USBX_707		0xf857	FTDI compatible adapter
+product FTDI USINT_CAT		0xb810	FTDI compatible adapter
+product FTDI USINT_RS232	0xb812	FTDI compatible adapter
+product FTDI USINT_WKEY		0xb811	FTDI compatible adapter
+product FTDI VARDAAN		0xf070	FTDI compatible adapter
+product FTDI VNHCPCUSB_D	0xfe38	FTDI compatible adapter
+product FTDI WESTREX_MODEL_777		0xdc00	FTDI compatible adapter
+product FTDI WESTREX_MODEL_8900F	0xdc01	FTDI compatible adapter
+product FTDI XF_547		0xfc0a	FTDI compatible adapter
+product FTDI XF_640		0xfc0e	FTDI compatible adapter
+product FTDI XF_642		0xfc0f	FTDI compatible adapter
+product FTDI XM_RADIO		0x937a	FTDI compatible adapter
+product FTDI YEI_SERVOCENTER31	0xe050	FTDI compatible adapter
+
+/* Fuji photo products */
+product FUJIPHOTO MASS0100	0x0100	Mass Storage
+
+/* Fujitsu protducts */
+product FUJITSU AH_F401U	0x105b	AH-F401U Air H device
+
+/* Fujitsu-Siemens protducts */
+product FUJITSUSIEMENS SCR	0x0009	Fujitsu-Siemens SCR USB Reader
+
+/* Garmin products */
+product GARMIN FORERUNNER230	0x086d	ForeRunner 230
+product GARMIN IQUE_3600	0x0004	iQue 3600
+
+/* Gemalto products */
+product GEMALTO PROXPU		0x5501	Prox-PU/CU RFID Card Reader
+
+/* General Instruments (Motorola) products */
+product GENERALINSTMNTS SB5100	0x5100	SURFboard SB5100 Cable modem
+
+/* Genesys Logic products */
+product GENESYS GL620USB	0x0501	GL620USB Host-Host interface
+product GENESYS GL650		0x0604	GL650 HUB
+product GENESYS GL606		0x0606	GL606 USB 2.0 HUB
+product GENESYS GL850G		0x0608	GL850G USB 2.0 HUB
+product GENESYS GL3520_2	0x0610	GL3520 4-Port USB 2.0 DataPath
+product GENESYS GL3520_SS	0x0616	GL3520 4-Port USB 3.0 DataPath
+product GENESYS GL641USB	0x0700	GL641USB CompactFlash Card Reader
+product GENESYS GL641USB2IDE_2	0x0701	GL641USB USB-IDE Bridge No 2
+product GENESYS GL641USB2IDE	0x0702	GL641USB USB-IDE Bridge
+product GENESYS GL3233		0x0743	GL3233 USB 3.0 AiO Card Reader
+product GENESYS GL641USB_2	0x0760	GL641USB 6-in-1 Card Reader
+
+/* GIGABYTE products */
+product GIGABYTE GN54G		0x8001	GN-54G
+product GIGABYTE GNBR402W	0x8002	GN-BR402W
+product GIGABYTE GNWLBM101	0x8003	GN-WLBM101
+product GIGABYTE GNWBKG		0x8007	GN-WBKG
+product GIGABYTE GNWB01GS	0x8008	GN-WB01GS
+product GIGABYTE GNWI05GS	0x800a	GN-WI05GS
+
+/* Gigaset products */
+product GIGASET WLAN		0x0701	WLAN
+product GIGASET SMCWUSBTG	0x0710	SMCWUSBT-G
+product GIGASET SMCWUSBTG_NF	0x0711	SMCWUSBT-G (no firmware)
+product GIGASET AR5523		0x0712	AR5523
+product GIGASET AR5523_NF	0x0713	AR5523 (no firmware)
+product GIGASET RT2573		0x0722	RT2573
+product GIGASET RT3070_1	0x0740	RT3070
+product GIGASET RT3070_2	0x0744	RT3070
+product GIGABYTE RT2870_1	0x800b	RT2870
+product GIGABYTE GNWB31N	0x800c	GN-WB31N
+product GIGABYTE GNWB32L	0x800d	GN-WB32L
+
+/* Global Sun Technology product */
+product GLOBALSUN AR5523_1	0x7801	AR5523
+product GLOBALSUN AR5523_1_NF	0x7802	AR5523 (no firmware)
+product GLOBALSUN AR5523_2	0x7811	AR5523
+product GLOBALSUN AR5523_2_NF	0x7812	AR5523 (no firmware)
+
+/* Globespan products */
+product	GLOBESPAN MODEM_1	0x1329	USB Modem
+product GLOBESPAN PRISM_GT_1	0x2000	PrismGT USB 2.0 WLAN
+product GLOBESPAN PRISM_GT_2	0x2002	PrismGT USB 2.0 WLAN
+
+/* G.Mate, Inc products */
+product GMATE YP3X00		0x1001	YP3X00 PDA
+
+/* GN Otometrics */
+product GNOTOMETRICS USB	0x0010	FTDI compatible adapter
+
+/* GoHubs products */
+product GOHUBS GOCOM232		0x1001	GoCOM232 Serial
+
+/* Good Way Technology products */
+product GOODWAY GWUSB2E		0x6200	GWUSB2E
+product GOODWAY RT2573		0xc019	RT2573
+
+/* Google products */
+product GOOGLE NEXUSONE		0x4e11	Nexus One
+
+/* Gravis products */
+product GRAVIS GAMEPADPRO	0x4001	GamePad Pro
+
+/* GREENHOUSE products */
+product GREENHOUSE KANA21	0x0001	CF-writer with MP3
+
+/* Griffin Technology */
+product GRIFFIN IMATE		0x0405	iMate, ADB Adapter
+
+/* Guillemot Corporation */
+product GUILLEMOT DALEADER	0xa300	DA Leader
+product GUILLEMOT HWGUSB254	0xe000	HWGUSB2-54 WLAN
+product GUILLEMOT HWGUSB254LB	0xe010	HWGUSB2-54-LB
+product GUILLEMOT HWGUSB254V2AP	0xe020	HWGUSB2-54V2-AP
+product GUILLEMOT HWNU300	0xe030	HWNU-300
+product GUILLEMOT HWNUM300	0xe031	HWNUm-300
+product GUILLEMOT HWGUN54	0xe032	HWGUn-54
+product GUILLEMOT HWNUP150	0xe033	HWNUP-150
+
+/* Hagiwara products */
+product HAGIWARA FGSM		0x0002	FlashGate SmartMedia Card Reader
+product HAGIWARA FGCF		0x0003	FlashGate CompactFlash Card Reader
+product HAGIWARA FG		0x0005	FlashGate
+
+/* HAL Corporation products */
+product HAL IMR001		0x0011	Crossam2+USB IR commander
+
+/* Handspring, Inc. */
+product HANDSPRING VISOR	0x0100	Handspring Visor
+product HANDSPRING TREO		0x0200	Handspring Treo
+product HANDSPRING TREO600	0x0300	Handspring Treo 600
+
+/* Hauppauge Computer Works */
+product HAUPPAUGE WINTV_USB_FM	0x4d12	WinTV USB FM
+product HAUPPAUGE2 NOVAT500	0x9580	NovaT 500Stick
+
+/* Hawking Technologies products */
+product HAWKING RT2870_1	0x0001	RT2870
+product HAWKING RT2870_2	0x0003	RT2870
+product HAWKING HWUN2		0x0009	HWUN2
+product HAWKING RT3070		0x000b	RT3070
+product HAWKING RTL8192CU	0x0019  RTL8192CU
+product HAWKING UF100		0x400c	10/100 USB Ethernet
+product HAWKING RTL8192SU_1	0x0015	RTL8192SU
+product HAWKING RTL8192SU_2	0x0016	RTL8192SU
+product HAWKING HD65U		0x0023	HD65U
+
+/* HID Global GmbH products */
+product HIDGLOBAL CM2020	0x0596	Omnikey Cardman 2020
+product HIDGLOBAL CM6020	0x1784	Omnikey Cardman 6020
+
+/* Hitachi, Ltd. products */
+product HITACHI DVDCAM_DZ_MV100A	0x0004	DVD-CAM DZ-MV100A Camcorder
+product HITACHI DVDCAM_USB	0x001e	DVDCAM USB HS Interface
+
+/* Holtek products */
+product HOLTEK F85		0xa030	Holtek USB gaming keyboard
+
+/* Honeywell */
+product HONEYWELL HGI80		0x0102	Honeywell HGI80 Wireless USB Gateway
+
+/* HP products */
+product HP 895C			0x0004	DeskJet 895C
+product HP 4100C		0x0101	Scanjet 4100C
+product HP S20			0x0102	Photosmart S20
+product HP 880C			0x0104	DeskJet 880C
+product HP 4200C		0x0105	ScanJet 4200C
+product HP CDWRITERPLUS		0x0107	CD-Writer Plus
+product HP KBDHUB		0x010c	Multimedia Keyboard Hub
+product HP G55XI		0x0111	OfficeJet G55xi
+product HP HN210W		0x011c	HN210W 802.11b WLAN
+product HP 49GPLUS		0x0121	49g+ graphing calculator
+product HP 6200C		0x0201	ScanJet 6200C
+product HP S20b			0x0202	PhotoSmart S20
+product HP 815C			0x0204	DeskJet 815C
+product HP 3300C		0x0205	ScanJet 3300C
+product HP CDW8200		0x0207	CD-Writer Plus 8200e
+product HP MMKEYB		0x020c	Multimedia keyboard
+product HP 1220C		0x0212	DeskJet 1220C
+product HP UN2420_QDL		0x241d	UN2420 QDL Firmware Loader
+product HP UN2420		0x251d	UN2420 WWAN/GPS Module
+product HP 810C			0x0304	DeskJet 810C/812C
+product HP 4300C		0x0305	Scanjet 4300C
+product HP CDW4E		0x0307	CD-Writer+ CD-4e
+product HP G85XI		0x0311	OfficeJet G85xi
+product HP 1200			0x0317	LaserJet 1200
+product HP 5200C		0x0401	Scanjet 5200C
+product HP 830C			0x0404	DeskJet 830C
+product HP 3400CSE		0x0405	ScanJet 3400cse
+product HP 6300C		0x0601	Scanjet 6300C
+product HP 840C			0x0604	DeskJet 840c
+product HP 2200C		0x0605	ScanJet 2200C
+product HP 5300C		0x0701	Scanjet 5300C
+product HP 4400C		0x0705	Scanjet 4400C
+product	HP 4470C		0x0805	Scanjet 4470C
+product HP 82x0C		0x0b01	Scanjet 82x0C
+product HP 2300D 		0x0b17	Laserjet 2300d
+product HP 970CSE		0x1004	Deskjet 970Cse
+product HP 5400C		0x1005	Scanjet 5400C
+product HP 2215			0x1016	iPAQ 22xx/Jornada 548
+product HP 568J			0x1116	Jornada 568
+product HP 930C			0x1204	DeskJet 930c
+product HP3 RTL8188CU		0x1629	RTL8188CU
+product HP P2000U		0x1801	Inkjet P-2000U
+product HP HS2300		0x1e1d  HS2300 HSDPA (aka MC8775)
+product HP 640C			0x2004	DeskJet 640c
+product HP 4670V		0x3005	ScanJet 4670v
+product HP P1100		0x3102	Photosmart P1100
+product HP LD220		0x3524	LD220 POS Display
+product HP OJ4215		0x3d11	OfficeJet 4215
+product HP HN210E		0x811c	Ethernet HN210E
+product HP2 C500		0x6002	PhotoSmart C500
+product HP EV2200		0x1b1d  ev2200 HSDPA (aka MC5720)
+product HP HS2300		0x1e1d  hs2300 HSDPA (aka MC8775)
+
+/* HTC products */
+product HTC WINMOBILE		0x00ce	HTC USB Sync
+product HTC PPC6700MODEM	0x00cf	PPC6700 Modem
+product HTC SMARTPHONE		0x0a51	SmartPhone USB Sync
+product HTC WIZARD		0x0bce	HTC Wizard USB Sync
+product HTC LEGENDSYNC		0x0c97	HTC Legend USB Sync
+product HTC LEGEND		0x0ff9	HTC Legend
+product HTC LEGENDINTERNET	0x0ffe	HTC Legend Internet Sharing
+
+/* HUAWEI products */
+product HUAWEI MOBILE		0x1001	Huawei Mobile
+product HUAWEI E220		0x1003	HSDPA modem
+product HUAWEI E220BIS		0x1004	HSDPA modem
+product HUAWEI E1401		0x1401	3G modem
+product HUAWEI E1402		0x1402	3G modem
+product HUAWEI E1403		0x1403	3G modem
+product HUAWEI E1404		0x1404	3G modem
+product HUAWEI E1405		0x1405	3G modem
+product HUAWEI E1406		0x1406	3G modem
+product HUAWEI E1407		0x1407	3G modem
+product HUAWEI E1408		0x1408	3G modem
+product HUAWEI E1409		0x1409	3G modem
+product HUAWEI E140A		0x140a	3G modem
+product HUAWEI E140B		0x140b	3G modem
+product HUAWEI E180V		0x140c	E180V
+product HUAWEI E140D		0x140d	3G modem
+product HUAWEI E140E		0x140e	3G modem
+product HUAWEI E140F		0x140f	3G modem
+product HUAWEI E1410		0x1410	3G modem
+product HUAWEI E1411		0x1411	3G modem
+product HUAWEI E1412		0x1412	3G modem
+product HUAWEI E1413		0x1413	3G modem
+product HUAWEI E1414		0x1414	3G modem
+product HUAWEI E1415		0x1415	3G modem
+product HUAWEI E1416		0x1416	3G modem
+product HUAWEI E1417		0x1417	3G modem
+product HUAWEI E1418		0x1418	3G modem
+product HUAWEI E1419		0x1419	3G modem
+product HUAWEI E141A		0x141a	3G modem
+product HUAWEI E141B		0x141b	3G modem
+product HUAWEI E141C		0x141c	3G modem
+product HUAWEI E141D		0x141d	3G modem
+product HUAWEI E141E		0x141e	3G modem
+product HUAWEI E141F		0x141f	3G modem
+product HUAWEI E1420		0x1420	3G modem
+product HUAWEI E1421		0x1421	3G modem
+product HUAWEI E1422		0x1422	3G modem
+product HUAWEI E1423		0x1423	3G modem
+product HUAWEI E1424		0x1424	3G modem
+product HUAWEI E1425		0x1425	3G modem
+product HUAWEI E1426		0x1426	3G modem
+product HUAWEI E1427		0x1427	3G modem
+product HUAWEI E1428		0x1428	3G modem
+product HUAWEI E1429		0x1429	3G modem
+product HUAWEI E142A		0x142a	3G modem
+product HUAWEI E142B		0x142b	3G modem
+product HUAWEI E142C		0x142c	3G modem
+product HUAWEI E142D		0x142d	3G modem
+product HUAWEI E142E		0x142e	3G modem
+product HUAWEI E142F		0x142f	3G modem
+product HUAWEI E1430		0x1430	3G modem
+product HUAWEI E1431		0x1431	3G modem
+product HUAWEI E1432		0x1432	3G modem
+product HUAWEI E1433		0x1433	3G modem
+product HUAWEI E1434		0x1434	3G modem
+product HUAWEI E1435		0x1435	3G modem
+product HUAWEI E1436		0x1436	3G modem
+product HUAWEI E1437		0x1437	3G modem
+product HUAWEI E1438		0x1438	3G modem
+product HUAWEI E1439		0x1439	3G modem
+product HUAWEI E143A		0x143a	3G modem
+product HUAWEI E143B		0x143b	3G modem
+product HUAWEI E143C		0x143c	3G modem
+product HUAWEI E143D		0x143d	3G modem
+product HUAWEI E143E		0x143e	3G modem
+product HUAWEI E143F		0x143f	3G modem
+product HUAWEI E1752		0x1446	3G modem
+product HUAWEI K4505		0x1464	3G modem
+product HUAWEI K3765		0x1465	3G modem
+product HUAWEI E1820		0x14ac	E1820 HSPA+ USB Slider
+product HUAWEI K3771_INIT	0x14c4  K3771 Initial
+product HUAWEI K3770		0x14c9  3G modem
+product HUAWEI K3771		0x14ca  K3771
+product HUAWEI K3772		0x14cf	K3772
+product HUAWEI K3770_INIT	0x14d1  K3770 Initial
+product HUAWEI E3131_INIT	0x14fe	3G modem initial
+product HUAWEI E392		0x1505	LTE modem
+product HUAWEI E3131		0x1506	3G modem
+product HUAWEI K3765_INIT	0x1520	K3765 Initial
+product HUAWEI K4505_INIT	0x1521	K4505 Initial
+product HUAWEI K3772_INIT	0x1526	K3772 Initial
+product HUAWEI E3272_INIT	0x155b	LTE modem initial
+product HUAWEI ME909U		0x1573  LTE modem
+product HUAWEI R215_INIT	0x1582	LTE modem initial
+product HUAWEI R215		0x1588	LTE modem
+product HUAWEI ME909S		0x15c1  LTE modem
+product HUAWEI ETS2055		0x1803	CDMA modem
+product HUAWEI E173		0x1c05	3G modem
+product HUAWEI E173_INIT	0x1c0b	3G modem initial
+product HUAWEI E3272		0x1c1e	LTE modem
+
+/* HUAWEI 3com products */
+product HUAWEI3COM WUB320G	0x0009	Aolynk WUB320g
+
+/* IBM Corporation */
+product IBM USBCDROMDRIVE	0x4427	USB CD-ROM Drive
+product IBM USB4543		0x4543	TI IBM USB 4543 Modem
+product IBM USB454B		0x454b	TI IBM USB 454B Modem
+product IBM USB454C		0x454c	TI IBM USB 454C Modem
+
+/* Icom products */
+product ICOM SP1		0x0004	FTDI compatible adapter
+product ICOM OPC_U_UC		0x0018	FTDI compatible adapter
+product ICOM RP2C1		0x0009	FTDI compatible adapter
+product ICOM RP2C2		0x000a	FTDI compatible adapter
+product ICOM RP2D		0x000b	FTDI compatible adapter
+product ICOM RP2KVR		0x0013	FTDI compatible adapter
+product ICOM RP2KVT		0x0012	FTDI compatible adapter
+product ICOM RP2VR		0x000d	FTDI compatible adapter
+product ICOM RP2VT		0x000c	FTDI compatible adapter
+product ICOM RP4KVR		0x0011	FTDI compatible adapter
+product ICOM RP4KVT		0x0010	FTDI compatible adapter
+
+/* ID-tech products */
+product IDTECH IDT1221U		0x0300	FTDI compatible adapter
+
+/* Imagination Technologies products */
+product IMAGINATION DBX1	0x2107	DBX1 DSP core
+
+/* Initio Corporation products */
+product INITIO DUMMY		0x0000	Dummy product
+product INITIO INIC_1610P	0x1e40	USB to SATA Bridge
+
+/* Inside Out Networks products */
+product INSIDEOUT EDGEPORT4	0x0001	EdgePort/4 serial ports
+
+/* In-System products */
+product INSYSTEM F5U002		0x0002	Parallel printer
+product INSYSTEM ATAPI		0x0031	ATAPI Adapter
+product INSYSTEM ISD110		0x0200	IDE Adapter ISD110
+product INSYSTEM ISD105		0x0202	IDE Adapter ISD105
+product INSYSTEM USBCABLE	0x081a	USB cable
+product INSYSTEM STORAGE_V2	0x5701	USB Storage Adapter V2
+
+/* Intenso products */
+product INTENSO MEMORY_BOX	0x0701	External disk
+
+/* Intel products */
+product INTEL EASYPC_CAMERA	0x0110	Easy PC Camera
+product INTEL TESTBOARD		0x9890	82930 test board
+product INTEL2 IRMH        	0x0020	Integrated Rate Matching Hub
+product INTEL2 IRMH2        	0x0024	Integrated Rate Matching Hub
+product INTEL2 IRMH3        	0x8000	Integrated Rate Matching Hub
+product INTEL2 IRMH4        	0x8008	Integrated Rate Matching Hub
+product INTEL2 SFP		0x0aa7  Sandy Peak (3168) Bluetooth Module
+product INTEL2 JFP		0x0aaa	Jefferson Peak (9460/9560) Bluetooth Module
+product INTEL2 THP 		0x0025	Thunder Peak (9160/9260) Bluetooth Module
+product INTEL2 HSP 		0x0026	Harrison Peak (22560) Bluetooth Module
+
+/* Interbiometric products */
+product INTERBIOMETRICS IOBOARD		0x1002	FTDI compatible adapter
+product INTERBIOMETRICS MINI_IOBOARD		0x1006	FTDI compatible adapter
+
+/* Intersil products */
+product INTERSIL PRISM_GT	0x1000	PrismGT USB 2.0 WLAN
+product INTERSIL PRISM_2X	0x3642	Prism2.x or Atmel WLAN
+
+/* Interpid Control Systems products */
+product INTREPIDCS VALUECAN	0x0601	ValueCAN CAN bus interface
+product INTREPIDCS NEOVI	0x0701	NeoVI Blue vehicle bus interface
+
+/* I/O DATA products */
+product IODATA IU_CD2		0x0204	DVD Multi-plus unit iU-CD2
+product IODATA DVR_UEH8		0x0206	DVD Multi-plus unit DVR-UEH8
+product IODATA USBSSMRW		0x0314	USB-SSMRW SD-card
+product IODATA USBSDRW		0x031e	USB-SDRW SD-card
+product IODATA USBETT		0x0901	USB ETT
+product IODATA USBETTX		0x0904	USB ETTX
+product IODATA USBETTXS		0x0913	USB ETTX
+product IODATA USBWNB11A	0x0919	USB WN-B11
+product IODATA USBWNB11		0x0922	USB Airport WN-B11
+product IODATA ETGUS2		0x0930	ETG-US2
+product IODATA WNGDNUS2		0x093f	WN-GDN/US2
+product IODATA RT3072_1		0x0944	RT3072
+product IODATA RT3072_2		0x0945	RT3072
+product IODATA RT3072_3		0x0947	RT3072
+product IODATA RT3072_4		0x0948	RT3072
+product IODATA WNAC867U		0x0952	WN-AC867U
+product IODATA USBRSAQ		0x0a03	Serial USB-RSAQ1
+product IODATA USBRSAQ5		0x0a0e  Serial USB-RSAQ5
+product IODATA2 USB2SC		0x0a09	USB2.0-SCSI Bridge USB2-SC
+
+/* Iomega products */
+product IOMEGA ZIP100		0x0001	Zip 100
+product IOMEGA ZIP250		0x0030	Zip 250
+
+/* Ionic products */
+product IONICS PLUGCOMPUTER		0x0102	FTDI compatible adapter
+
+/* Integrated System Solution Corp. products */
+product ISSC ISSCBTA		0x1001	Bluetooth USB Adapter
+
+/* iTegno products */
+product ITEGNO WM1080A		0x1080	WM1080A GSM/GPRS modem
+product ITEGNO WM2080A		0x2080	WM2080A CDMA modem
+
+/* Ituner networks products */
+product ITUNERNET USBLCD2X20	0x0002	USB-LCD 2x20
+product ITUNERNET USBLCD4X20	0xc001	USB-LCD 4x20
+
+/* Jablotron products */
+product JABLOTRON PC60B		0x0001	PC-60B
+
+/* Jaton products */
+product JATON EDA		0x5704	Ethernet
+
+/* Jeti products */
+product JETI SPC1201		0x04b2	FTDI compatible adapter
+
+/* JMicron products */
+product JMICRON JMS567		0x0567	USB to SATA 6.0Gb/s bridge 
+product JMICRON JM20336		0x2336	USB to SATA Bridge
+product JMICRON JM20337		0x2338	USB to ATA/ATAPI Bridge
+
+/* JVC products */
+product JVC GR_DX95		0x000a	GR-DX95
+product JVC MP_PRX1		0x3008	MP-PRX1 Ethernet
+
+/* JRC products */
+product JRC AH_J3001V_J3002V	0x0001	AirH PHONE AH-J3001V/J3002V
+
+/* Kamstrrup products */
+product KAMSTRUP OPTICALEYE	0x0001	Optical Eye/3-wire
+product KAMSTRUP MBUS_250D	0x0005	M-Bus Master MultiPort 250D
+
+/* Kawatsu products */
+product KAWATSU MH4000P		0x0003	MiniHub 4000P
+
+/* Keisokugiken Corp. products */
+product KEISOKUGIKEN USBDAQ	0x0068	HKS-0200 USBDAQ
+
+/* Kensington products */
+product KENSINGTON ORBIT	0x1003	Orbit USB/PS2 trackball
+product KENSINGTON TURBOBALL	0x1005	TurboBall
+
+/* Keyspan products */
+product KEYSPAN USA28_NF	0x0101	USA-28 serial Adapter (no firmware)
+product KEYSPAN USA28X_NF	0x0102	USA-28X serial Adapter (no firmware)
+product KEYSPAN USA19_NF	0x0103	USA-19 serial Adapter (no firmware)
+product KEYSPAN USA18_NF	0x0104	USA-18 serial Adapter (no firmware)
+product KEYSPAN USA18X_NF	0x0105	USA-18X serial Adapter (no firmware)
+product KEYSPAN USA19W_NF	0x0106	USA-19W serial Adapter (no firmware)
+product KEYSPAN USA19		0x0107	USA-19 serial Adapter
+product KEYSPAN USA19W		0x0108	USA-19W serial Adapter
+product KEYSPAN USA49W_NF	0x0109	USA-49W serial Adapter (no firmware)
+product KEYSPAN USA49W		0x010a	USA-49W serial Adapter
+product KEYSPAN USA19QI_NF	0x010b	USA-19QI serial Adapter (no firmware)
+product KEYSPAN USA19QI		0x010c	USA-19QI serial Adapter
+product KEYSPAN USA19Q_NF	0x010d	USA-19Q serial Adapter (no firmware)
+product KEYSPAN USA19Q		0x010e	USA-19Q serial Adapter
+product KEYSPAN USA28		0x010f	USA-28 serial Adapter
+product KEYSPAN USA28XXB	0x0110	USA-28X/XB serial Adapter
+product KEYSPAN USA18		0x0111	USA-18 serial Adapter
+product KEYSPAN USA18X		0x0112	USA-18X serial Adapter
+product KEYSPAN USA28XB_NF	0x0113	USA-28XB serial Adapter (no firmware)
+product KEYSPAN USA28XA_NF	0x0114	USA-28XB serial Adapter (no firmware)
+product KEYSPAN USA28XA		0x0115	USA-28XA serial Adapter
+product KEYSPAN USA18XA_NF	0x0116	USA-18XA serial Adapter (no firmware)
+product KEYSPAN USA18XA		0x0117	USA-18XA serial Adapter
+product KEYSPAN USA19QW_NF	0x0118	USA-19WQ serial Adapter (no firmware)
+product KEYSPAN USA19QW		0x0119	USA-19WQ serial Adapter
+product KEYSPAN USA19HA		0x0121	USA-19HS serial Adapter
+product KEYSPAN UIA10		0x0201	UIA-10 remote control
+product KEYSPAN UIA11		0x0202	UIA-11 remote control
+
+/* Kingston products */
+product KINGSTON XX1		0x0008	Ethernet
+product KINGSTON KNU101TX	0x000a	KNU101TX USB Ethernet
+product KINGSTON HYPERX3_0	0x162b	DT HyperX 3.0
+
+/* Kawasaki products */
+product KLSI DUH3E10BT		0x0008	USB Ethernet
+product KLSI DUH3E10BTN		0x0009	USB Ethernet
+
+/* Kobil products */
+product KOBIL CONV_B1		0x2020	FTDI compatible adapter
+product KOBIL CONV_KAAN		0x2021	FTDI compatible adapter
+
+/* Kodak products */
+product KODAK DC220		0x0100	Digital Science DC220
+product KODAK DC260		0x0110	Digital Science DC260
+product KODAK DC265		0x0111	Digital Science DC265
+product KODAK DC290		0x0112	Digital Science DC290
+product KODAK DC240		0x0120	Digital Science DC240
+product KODAK DC280		0x0130	Digital Science DC280
+
+/* Kontron AG products */
+product KONTRON DM9601		0x8101	USB Ethernet
+product KONTRON JP1082		0x9700	USB Ethernet
+
+/* Konica Corp. Products */
+product KONICA CAMERA		0x0720	Digital Color Camera
+
+/* KYE products */
+product KYE NICHE		0x0001	Niche mouse
+product KYE NETSCROLL		0x0003	Genius NetScroll mouse
+product KYE FLIGHT2000		0x1004	Flight 2000 joystick
+product KYE VIVIDPRO		0x2001	ColorPage Vivid-Pro scanner
+
+/* Kyocera products */
+product KYOCERA FINECAM_S3X	0x0100	Finecam S3x
+product KYOCERA FINECAM_S4	0x0101	Finecam S4
+product KYOCERA FINECAM_S5	0x0103	Finecam S5
+product KYOCERA FINECAM_L3	0x0105	Finecam L3
+product KYOCERA AHK3001V	0x0203	AH-K3001V
+product KYOCERA2 CDMA_MSM_K	0x17da	Qualcomm Kyocera CDMA Technologies MSM
+product KYOCERA2 KPC680		0x180a	Qualcomm Kyocera CDMA Technologies MSM
+
+/* LaCie products */
+product LACIE HD		0xa601	Hard Disk
+product LACIE CDRW		0xa602	CD R/W
+
+/* Lake Shore Cryotronics products */
+product LAKESHORE 121		0x0100	121 Current Source
+product LAKESHORE 218A		0x0200	218A Temperature Monitor
+product LAKESHORE 219		0x0201	219 Temperature Monitor
+product LAKESHORE 233		0x0202	233 Temperature Transmitter
+product LAKESHORE 235		0x0203	235 Temperature Transmitter
+product LAKESHORE 335		0x0300	335 Temperature Controller
+product LAKESHORE 336		0x0301	336 Temperature Controller
+product LAKESHORE 350		0x0302	350 Temperature Controller
+product LAKESHORE 371		0x0303	371 AC Bridge
+product LAKESHORE 411		0x0400	411 Handheld Gaussmeter
+product LAKESHORE 425		0x0401	425 Gaussmeter
+product LAKESHORE 455A		0x0402	455A DSP Gaussmeter
+product LAKESHORE 475A		0x0403	475A DSP Gaussmeter
+product LAKESHORE 465		0x0404	465 Gaussmeter
+product LAKESHORE 625A		0x0600	625A Magnet PSU
+product LAKESHORE 642A		0x0601	642A Magnet PSU
+product LAKESHORE 648		0x0602	648 Magnet PSU
+product LAKESHORE 737		0x0700	737 VSM Controller
+product LAKESHORE 776		0x0701	776 Matrix Switch
+
+/* Larsen and Brusgaard products */
+product LARSENBRUSGAARD ALTITRACK	0x0001	FTDI compatible adapter
+
+/* Leadtek products */
+product LEADTEK 9531		0x2101	9531 GPS
+
+/* Lenovo products */
+product LENOVO GIGALAN		0x304b	USB 3.0 Ethernet
+product LENOVO ETHERNET		0x7203	USB 2.0 Ethernet
+product LENOVO RTL8153		0x7205	USB 3.0 Ethernet
+product LENOVO TBT3LAN		0x3069	LAN port in Thinkpad TB3 dock
+product LENOVO USBCLAN		0x3062	LAN port in Thinkpad USB-C dock
+
+/* Lexar products */
+product LEXAR JUMPSHOT		0x0001	jumpSHOT CompactFlash Reader
+product LEXAR CF_READER		0xb002	USB CF Reader
+product LEXAR JUMPDRIVE		0xa833	USB Jumpdrive Flash Drive
+
+/* Lexmark products */
+product LEXMARK S2450		0x0009	Optra S 2450
+
+/* Liebert products */
+product LIEBERT POWERSURE_PXT	0xffff	PowerSure Personal XT
+product LIEBERT2 PSI1000	0x0004	UPS PSI 1000 FW:08
+
+/* Link Instruments Inc. products */
+product	LINKINSTRUMENTS MSO19	0xf190	Link Instruments MSO-19
+product	LINKINSTRUMENTS MSO28	0xf280	Link Instruments MSO-28
+product	LINKINSTRUMENTS MSO28_2	0xf281	Link Instruments MSO-28
+
+/* Linksys products */
+product LINKSYS MAUSB2		0x0105	Camedia MAUSB-2
+product LINKSYS USB10TX1	0x200c	USB10TX
+product LINKSYS USB10T		0x2202	USB10T Ethernet
+product LINKSYS USB100TX	0x2203	USB100TX Ethernet
+product LINKSYS USB100H1	0x2204	USB100H1 Ethernet/HPNA
+product LINKSYS USB10TA		0x2206	USB10TA Ethernet
+product LINKSYS USB10TX2	0x400b	USB10TX
+product LINKSYS2 WUSB11		0x2219	WUSB11 Wireless Adapter
+product LINKSYS2 USB200M	0x2226	USB 2.0 10/100 Ethernet
+product LINKSYS3 WUSB11v28	0x2233	WUSB11 v2.8 Wireless Adapter
+product LINKSYS4 USB1000	0x0039	USB1000
+product LINKSYS4 WUSB100	0x0070	WUSB100
+product LINKSYS4 WUSB600N	0x0071	WUSB600N
+product LINKSYS4 WUSB54GCV2	0x0073	WUSB54GC v2
+product LINKSYS4 WUSB54GCV3	0x0077	WUSB54GC v3
+product LINKSYS4 RT3070		0x0078	RT3070
+product LINKSYS4 WUSB600NV2	0x0079	WUSB600N v2
+
+/* Logilink products */
+product LOGILINK DUMMY		0x0000	Dummy product
+product LOGILINK U2M		0x0101	LogiLink USB MIDI Cable
+
+/* Logitech products */
+product LOGITECH M2452		0x0203	M2452 keyboard
+product LOGITECH M4848		0x0301	M4848 mouse
+product LOGITECH PAGESCAN	0x040f	PageScan
+product LOGITECH QUICKCAMWEB	0x0801	QuickCam Web
+product LOGITECH QUICKCAMPRO	0x0810	QuickCam Pro
+product LOGITECH WEBCAMC100	0X0817	Webcam C100
+product LOGITECH QUICKCAMEXP	0x0840	QuickCam Express
+product LOGITECH QUICKCAM	0x0850	QuickCam
+product LOGITECH QUICKCAMPRO3	0x0990	QuickCam Pro 9000
+product LOGITECH N43		0xc000	N43
+product LOGITECH N48		0xc001	N48 mouse
+product LOGITECH MBA47		0xc002	M-BA47 mouse
+product LOGITECH WMMOUSE	0xc004	WingMan Gaming Mouse
+product LOGITECH BD58		0xc00c	BD58 mouse
+product LOGITECH UN58A		0xc030	iFeel Mouse
+product LOGITECH UN53B		0xc032	iFeel MouseMan
+product LOGITECH WMPAD		0xc208	WingMan GamePad Extreme
+product LOGITECH WMRPAD		0xc20a	WingMan RumblePad
+product LOGITECH WMJOY		0xc281	WingMan Force joystick
+product LOGITECH BB13		0xc401	USB-PS/2 Trackball
+product LOGITECH RK53		0xc501	Cordless mouse
+product LOGITECH RB6		0xc503	Cordless keyboard
+product LOGITECH MX700		0xc506	Cordless optical mouse
+product LOGITECH UNIFYING	0xc52b  Logitech Unifying Receiver
+product LOGITECH QUICKCAMPRO2	0xd001	QuickCam Pro
+
+/* Logitec Corp. products */
+product LOGITEC LDR_H443SU2	0x0033	DVD Multi-plus unit LDR-H443SU2
+product LOGITEC LDR_H443U2	0x00b3	DVD Multi-plus unit LDR-H443U2
+product LOGITEC LAN_GTJU2A	0x0160	LAN-GTJ/U2A Ethernet
+product LOGITEC RT2870_1	0x0162	RT2870
+product LOGITEC RT2870_2	0x0163	RT2870
+product LOGITEC RT2870_3	0x0164	RT2870
+product LOGITEC LANW300NU2	0x0166  LAN-W300N/U2
+product LOGITEC LANW150NU2	0x0168  LAN-W150N/U2
+product LOGITEC LANW300NU2S	0x0169	LAN-W300N/U2S
+
+/* Longcheer Holdings, Ltd. products */
+product LONGCHEER WM66		0x6061	Longcheer WM66 HSDPA
+product LONGCHEER W14		0x9603	Mobilcom W14
+product LONGCHEER DISK		0xf000	Driver disk
+product LONGCHEER XSSTICK	0x9605	4G Systems XSStick P14
+
+
+/* Lucent products */
+product LUCENT EVALKIT		0x1001	USS-720 evaluation kit
+
+/* Luwen products */
+product LUWEN EASYDISK		0x0005	EasyDisc
+
+/* Macally products */
+product MACALLY MOUSE1		0x0101	mouse
+
+/* Mag-Tek products */
+product MAGTEK USBSWIPE		0x0002	USB Mag Stripe Swipe Reader
+
+/* Marvell Technology Group, Ltd. products */
+product MARVELL SHEEVAPLUG	0x9e8f	SheevaPlug serial interface
+
+/* Matrix Orbital products */
+product MATRIXORBITAL FTDI_RANGE_0100		0x0100	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0101		0x0101	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0102		0x0102	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0103		0x0103	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0104		0x0104	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0105		0x0105	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0106		0x0106	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0107		0x0107	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0108		0x0108	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0109		0x0109	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_010A		0x010a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_010B		0x010b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_010C		0x010c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_010D		0x010d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_010E		0x010e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_010F		0x010f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0110		0x0110	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0111		0x0111	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0112		0x0112	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0113		0x0113	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0114		0x0114	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0115		0x0115	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0116		0x0116	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0117		0x0117	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0118		0x0118	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0119		0x0119	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_011A		0x011a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_011B		0x011b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_011C		0x011c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_011D		0x011d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_011E		0x011e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_011F		0x011f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0120		0x0120	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0121		0x0121	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0122		0x0122	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0123		0x0123	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0124		0x0124	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0125		0x0125	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0126		0x0126	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0128		0x0128	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0129		0x0129	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_012A		0x012a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_012B		0x012b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_012D		0x012d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_012E		0x012e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_012F		0x012f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0130		0x0130	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0131		0x0131	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0132		0x0132	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0133		0x0133	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0134		0x0134	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0135		0x0135	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0136		0x0136	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0137		0x0137	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0138		0x0138	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0139		0x0139	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_013A		0x013a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_013B		0x013b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_013C		0x013c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_013D		0x013d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_013E		0x013e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_013F		0x013f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0140		0x0140	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0141		0x0141	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0142		0x0142	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0143		0x0143	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0144		0x0144	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0145		0x0145	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0146		0x0146	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0147		0x0147	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0148		0x0148	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0149		0x0149	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_014A		0x014a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_014B		0x014b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_014C		0x014c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_014D		0x014d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_014E		0x014e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_014F		0x014f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0150		0x0150	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0151		0x0151	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0152		0x0152	FTDI compatible adapter
+product MATRIXORBITAL MOUA	0x0153	Martrix Orbital MOU-Axxxx LCD displays
+product MATRIXORBITAL FTDI_RANGE_0159		0x0159	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_015A		0x015a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_015B		0x015b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_015C		0x015c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_015D		0x015d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_015E		0x015e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_015F		0x015f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0160		0x0160	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0161		0x0161	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0162		0x0162	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0163		0x0163	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0164		0x0164	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0165		0x0165	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0166		0x0166	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0167		0x0167	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0168		0x0168	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0169		0x0169	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_016A		0x016a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_016B		0x016b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_016C		0x016c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_016D		0x016d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_016E		0x016e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_016F		0x016f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0170		0x0170	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0171		0x0171	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0172		0x0172	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0173		0x0173	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0174		0x0174	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0175		0x0175	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0176		0x0176	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0177		0x0177	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0178		0x0178	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0179		0x0179	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_017A		0x017a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_017B		0x017b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_017C		0x017c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_017D		0x017d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_017E		0x017e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_017F		0x017f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0180		0x0180	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0181		0x0181	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0182		0x0182	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0183		0x0183	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0184		0x0184	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0185		0x0185	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0186		0x0186	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0187		0x0187	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0188		0x0188	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0189		0x0189	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_018A		0x018a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_018B		0x018b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_018C		0x018c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_018D		0x018d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_018E		0x018e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_018F		0x018f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0190		0x0190	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0191		0x0191	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0192		0x0192	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0193		0x0193	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0194		0x0194	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0195		0x0195	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0196		0x0196	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0197		0x0197	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0198		0x0198	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_0199		0x0199	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_019A		0x019a	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_019B		0x019b	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_019C		0x019c	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_019D		0x019d	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_019E		0x019e	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_019F		0x019f	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A0		0x01a0	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A1		0x01a1	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A2		0x01a2	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A3		0x01a3	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A4		0x01a4	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A5		0x01a5	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A6		0x01a6	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A7		0x01a7	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A8		0x01a8	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01A9		0x01a9	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01AA		0x01aa	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01AB		0x01ab	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01AC		0x01ac	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01AD		0x01ad	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01AE		0x01ae	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01AF		0x01af	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B0		0x01b0	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B1		0x01b1	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B2		0x01b2	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B3		0x01b3	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B4		0x01b4	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B5		0x01b5	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B6		0x01b6	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B7		0x01b7	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B8		0x01b8	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01B9		0x01b9	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01BA		0x01ba	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01BB		0x01bb	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01BC		0x01bc	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01BD		0x01bd	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01BE		0x01be	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01BF		0x01bf	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C0		0x01c0	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C1		0x01c1	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C2		0x01c2	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C3		0x01c3	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C4		0x01c4	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C5		0x01c5	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C6		0x01c6	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C7		0x01c7	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C8		0x01c8	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01C9		0x01c9	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01CA		0x01ca	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01CB		0x01cb	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01CC		0x01cc	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01CD		0x01cd	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01CE		0x01ce	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01CF		0x01cf	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D0		0x01d0	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D1		0x01d1	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D2		0x01d2	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D3		0x01d3	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D4		0x01d4	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D5		0x01d5	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D6		0x01d6	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D7		0x01d7	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D8		0x01d8	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01D9		0x01d9	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01DA		0x01da	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01DB		0x01db	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01DC		0x01dc	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01DD		0x01dd	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01DE		0x01de	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01DF		0x01df	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E0		0x01e0	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E1		0x01e1	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E2		0x01e2	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E3		0x01e3	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E4		0x01e4	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E5		0x01e5	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E6		0x01e6	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E7		0x01e7	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E8		0x01e8	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01E9		0x01e9	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01EA		0x01ea	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01EB		0x01eb	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01EC		0x01ec	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01ED		0x01ed	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01EE		0x01ee	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01EF		0x01ef	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F0		0x01f0	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F1		0x01f1	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F2		0x01f2	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F3		0x01f3	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F4		0x01f4	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F5		0x01f5	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F6		0x01f6	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F7		0x01f7	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F8		0x01f8	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01F9		0x01f9	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01FA		0x01fa	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01FB		0x01fb	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01FC		0x01fc	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01FD		0x01fd	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01FE		0x01fe	FTDI compatible adapter
+product MATRIXORBITAL FTDI_RANGE_01FF		0x01ff	FTDI compatible adapter
+
+/* MCT Corp. */
+product MCT HUB0100		0x0100	Hub
+product MCT DU_H3SP_USB232	0x0200	D-Link DU-H3SP USB BAY Hub
+product MCT USB232		0x0210	USB-232 Interface
+product MCT SITECOM_USB232	0x0230	Sitecom USB-232 Products
+
+/* Medeli */
+product MEDELI DD305		0x5011	DD305 Digital Drum Set
+
+/* MediaTek, Inc. */
+product MEDIATEK MTK3329	0x3329	MTK II GPS Receiver
+
+/* Meizu Electronics */
+product MEIZU M6_SL		0x0140	MiniPlayer M6 (SL)
+
+/* Melco, Inc products */
+product MELCO LUATX1		0x0001	LUA-TX Ethernet
+product MELCO LUATX5		0x0005	LUA-TX Ethernet
+product MELCO LUA2TX5		0x0009	LUA2-TX Ethernet
+product MELCO LUAKTX		0x0012	LUA-KTX Ethernet
+product MELCO DUBPXXG		0x001c	DUB-PxxG
+product MELCO LUAU2KTX		0x003d	LUA-U2-KTX Ethernet
+product MELCO KG54YB		0x005e	WLI-U2-KG54-YB WLAN
+product MELCO KG54		0x0066	WLI-U2-KG54 WLAN
+product MELCO KG54AI		0x0067	WLI-U2-KG54-AI WLAN
+product MELCO LUA3U2AGT		0x006e	LUA3-U2-AGT
+product MELCO NINWIFI		0x008b	Nintendo Wi-Fi
+product MELCO PCOPRS1		0x00b3	PC-OP-RS1 RemoteStation
+product MELCO SG54HP		0x00d8	WLI-U2-SG54HP
+product MELCO G54HP		0x00d9	WLI-U2-G54HP
+product MELCO KG54L		0x00da	WLI-U2-KG54L
+product MELCO WLIUCG300N	0x00e8	WLI-UC-G300N
+product MELCO SG54HG		0x00f4	WLI-U2-SG54HG
+product MELCO WLRUCG		0x0116	WLR-UC-G
+product MELCO WLRUCGAOSS	0x0119	WLR-UC-G-AOSS
+product MELCO WLIUCAG300N	0x012e	WLI-UC-AG300N
+product MELCO WLIUCG		0x0137	WLI-UC-G
+product MELCO WLIUCG300HP	0x0148	WLI-UC-G300HP
+product MELCO RT2870_2		0x0150	RT2870
+product MELCO WLIUCGN		0x015d	WLI-UC-GN
+product MELCO WLIUCG301N	0x016f	WLI-UC-G301N
+product MELCO WLIUCGNM		0x01a2	WLI-UC-GNM
+product MELCO WLIUCG300HPV1	0x01a8	WLI-UC-G300HP-V1
+product MELCO WLIUCGNM2		0x01ee	WLI-UC-GNM2
+product MELCO WIU2433DM		0x0242	WI-U2-433DM
+product MELCO WIU3866D		0x025d	WI-U3-866D
+
+/* Merlin products */
+product MERLIN V620             0x1110  Merlin V620
+
+/* MetaGeek products */
+product METAGEEK TELLSTICK	0x0c30	FTDI compatible adapter
+product METAGEEK WISPY1B	0x083e	MetaGeek Wi-Spy
+product METAGEEK WISPY24X	0x083f	MetaGeek Wi-Spy 2.4x
+product METAGEEK2 WISPYDBX	0x5000	MetaGeek Wi-Spy DBx
+
+/* Metricom products */
+product METRICOM RICOCHET_GS	0x0001	Ricochet GS
+
+/* MGE UPS Systems */
+product MGE UPS1		0x0001	MGE UPS SYSTEMS PROTECTIONCENTER 1
+product MGE UPS2		0xffff	MGE UPS SYSTEMS PROTECTIONCENTER 2
+
+/* MEI products */
+product MEI CASHFLOW_SC		0x1100	Cashflow-SC Cash Acceptor
+product MEI S2000		0x1101	Series 2000 Combo Acceptor
+
+/* Microdia / Sonix Techonology Co., Ltd. products */
+product CHICONY2 YUREX		0x1010	YUREX
+product CHICONY2 CAM_1		0x62c0	CAM_1
+product CHICONY2 TEMPER		0x7401	TEMPer sensor
+
+/* Micro Star International products */
+product MSI BT_DONGLE		0x1967	Bluetooth USB dongle
+product MSI RT3070_1		0x3820	RT3070
+product MSI RT3070_2		0x3821	RT3070
+product MSI RT3070_8		0x3822	RT3070
+product MSI RT3070_3		0x3870	RT3070
+product MSI RT3070_9		0x3871	RT3070
+product MSI UB11B		0x6823	UB11B
+product MSI RT2570		0x6861	RT2570
+product MSI RT2570_2		0x6865	RT2570
+product MSI RT2570_3		0x6869	RT2570
+product MSI RT2573_1		0x6874	RT2573
+product MSI RT2573_2		0x6877	RT2573
+product MSI RT3070_4		0x6899	RT3070
+product MSI RT3070_5		0x821a	RT3070
+product MSI RT3070_10		0x822a	RT3070
+product MSI RT3070_6		0x870a	RT3070
+product MSI RT3070_11		0x871a	RT3070
+product MSI RT3070_7		0x899a	RT3070
+product MSI RT2573_3		0xa861	RT2573
+product MSI RT2573_4		0xa874	RT2573
+
+/* Micron products */
+product MICRON REALSSD		0x0655	Real SSD eUSB
+
+/* Microsoft products */
+product MICROSOFT SIDEPREC	0x0008	SideWinder Precision Pro
+product MICROSOFT INTELLIMOUSE	0x0009	IntelliMouse
+product MICROSOFT NATURALKBD	0x000b	Natural Keyboard Elite
+product MICROSOFT DDS80		0x0014	Digital Sound System 80
+product MICROSOFT SIDEWINDER	0x001a	Sidewinder Precision Racing Wheel
+product MICROSOFT INETPRO	0x001c	Internet Keyboard Pro
+product MICROSOFT TBEXPLORER	0x0024	Trackball Explorer
+product MICROSOFT INTELLIEYE	0x0025	IntelliEye mouse
+product MICROSOFT INETPRO2	0x002b	Internet Keyboard Pro
+product MICROSOFT INTELLIMOUSE5	0x0039	IntelliMouse 1.1 5-Button Mouse
+product MICROSOFT WHEELMOUSE	0x0040	Wheel Mouse Optical
+product MICROSOFT MN510		0x006e	MN510 Wireless
+product MICROSOFT 700WX		0x0079	Palm 700WX
+product MICROSOFT MN110		0x007a	10/100 USB NIC
+product MICROSOFT WLINTELLIMOUSE 0x008c	Wireless Optical IntelliMouse
+product MICROSOFT WLNOTEBOOK	0x00b9	Wireless Optical Mouse (Model 1023)
+product MICROSOFT COMFORT3000	0x00d1	Comfort Optical Mouse 3000 (Model 1043)
+product MICROSOFT WLNOTEBOOK3	0x00d2	Wireless Optical Mouse 3000 (Model 1049)
+product MICROSOFT NATURAL4000	0x00db	Natural Ergonomic Keyboard 4000
+product MICROSOFT WLNOTEBOOK2	0x00e1	Wireless Optical Mouse 3000 (Model 1056)
+product MICROSOFT XBOX360	0x0292	XBOX 360 WLAN
+
+/* Microtech products */
+product MICROTECH SCSIDB25	0x0004	USB-SCSI-DB25
+product MICROTECH SCSIHD50	0x0005	USB-SCSI-HD50
+product MICROTECH DPCM		0x0006	USB CameraMate
+product MICROTECH FREECOM	0xfc01	Freecom USB-IDE
+
+/* Microtek products */
+product MICROTEK 336CX		0x0094	Phantom 336CX - C3 scanner
+product MICROTEK X6U		0x0099	ScanMaker X6 - X6U
+product MICROTEK C6		0x009a	Phantom C6 scanner
+product MICROTEK 336CX2		0x00a0	Phantom 336CX - C3 scanner
+product MICROTEK V6USL		0x00a3	ScanMaker V6USL
+product MICROTEK V6USL2		0x80a3	ScanMaker V6USL
+product MICROTEK V6UL		0x80ac	ScanMaker V6UL
+
+/* Microtune, Inc. products */
+product MICROTUNE BT_DONGLE	0x1000	Bluetooth USB dongle
+
+/* Midiman products */
+product MAUDIO MIDISPORT2X2	0x1001	Midisport 2x2
+product MAUDIO FASTTRACKULTRA	0x2080	Fast Track Ultra
+product MAUDIO FASTTRACKULTRA8R	0x2081	Fast Track Ultra 8R
+
+/* MindsAtWork products */
+product MINDSATWORK WALLET	0x0001	Digital Wallet
+
+/* Minolta Co., Ltd. */
+product MINOLTA 2300		0x4001	Dimage 2300
+product MINOLTA S304		0x4007	Dimage S304
+product MINOLTA X		0x4009	Dimage X
+product MINOLTA 5400		0x400e	Dimage 5400
+product MINOLTA F300		0x4011	Dimage F300
+product MINOLTA E223		0x4017	Dimage E223
+
+/* Mitsumi products */
+product MITSUMI CDRRW		0x0000	CD-R/RW Drive
+product MITSUMI BT_DONGLE	0x641f	Bluetooth USB dongle
+product MITSUMI FDD		0x6901	USB FDD
+
+/* Mobile Action products */
+product MOBILEACTION MA620	0x0620	MA-620 Infrared Adapter
+
+/* Mobility products */
+product MOBILITY USB_SERIAL	0x0202	FTDI compatible adapter
+product MOBILITY EA		0x0204	Ethernet
+product MOBILITY EASIDOCK	0x0304	EasiDock Ethernet
+
+/* MosChip products */
+product MOSCHIP MCS7703		0x7703	MCS7703 Serial Port Adapter
+product MOSCHIP MCS7730		0x7730  MCS7730 Ethernet
+product MOSCHIP MCS7820		0x7820	MCS7820 Serial Port Adapter
+product MOSCHIP MCS7830		0x7830	MCS7830 Ethernet
+product MOSCHIP MCS7832		0x7832	MCS7832 Ethernet
+product MOSCHIP MCS7840		0x7840	MCS7840 Serial Port Adapter
+
+/* Motorola products */
+product MOTOROLA MC141555	0x1555	MC141555 hub controller
+product MOTOROLA SB4100		0x4100	SB4100 USB Cable Modem
+product MOTOROLA2 T720C		0x2822	T720c
+product MOTOROLA2 A41XV32X	0x2a22	A41x/V32x Mobile Phones
+product MOTOROLA2 E398		0x4810	E398 Mobile Phone
+product MOTOROLA2 USBLAN	0x600c	USBLAN
+product MOTOROLA2 USBLAN2	0x6027	USBLAN
+product MOTOROLA2 MB886		0x710f	MB886 Mobile Phone (Atria HD)
+product MOTOROLA4 RT2770	0x9031	RT2770
+product MOTOROLA4 RT3070	0x9032	RT3070
+
+/* Moxa */
+product MOXA MXU1_1110		0x1110	Moxa Uport 1110
+product MOXA MXU1_1130		0x1130	Moxa Uport 1130
+product MOXA MXU1_1131		0x1131	Moxa Uport 1131
+product MOXA MXU1_1150		0x1150	Moxa Uport 1150
+product MOXA MXU1_1151		0x1151	Moxa Uport 1151
+
+/* MpMan products */
+product MPMAN MPF400_2		0x25a8	MPF400 Music Player 2Go
+product MPMAN MPF400_1		0x36d0	MPF400 Music Player 1Go
+
+/* MultiTech products */
+product MULTITECH MT9234ZBA_2	0x0319	MT9234ZBA USB modem (alt)
+product MULTITECH ATLAS		0xf101	MT5634ZBA-USB modem
+product MULTITECH GSM		0xf108	GSM USB Modem
+product MULTITECH CDMA		0xf109	CDMA USB Modem
+product MULTITECH CDMA_FW	0xf110	CDMA USB Modem firmware running
+product	MULTITECH GSM_FW	0xf111	GSM USB Modem firmware running
+product MULTITECH EDGE		0xf112	Edge USB Modem
+product MULTITECH MT9234MU	0xf114	MT9234 MU
+product MULTITECH MT9234ZBA	0xf115	MT9234 ZBA
+
+/* Mustek products */
+product MUSTEK 1200CU		0x0001	1200 CU scanner
+product MUSTEK 600CU		0x0002	600 CU scanner
+product MUSTEK 1200USB		0x0003	1200 USB scanner
+product MUSTEK 1200UB		0x0006	1200 UB scanner
+product MUSTEK 1200USBPLUS	0x0007	1200 USB Plus scanner
+product MUSTEK 1200CUPLUS	0x0008	1200 CU Plus scanner
+product MUSTEK BEARPAW1200F	0x0010	BearPaw 1200F scanner
+product MUSTEK BEARPAW2400TA	0x0218	BearPaw 2400TA scanner
+product MUSTEK BEARPAW1200TA	0x021e	BearPaw 1200TA scanner
+product MUSTEK 600USB		0x0873	600 USB scanner
+product MUSTEK MDC800		0xa800	MDC-800 digital camera
+
+/* M-Systems products */
+product MSYSTEMS DISKONKEY	0x0010	DiskOnKey
+product MSYSTEMS DISKONKEY2	0x0011	DiskOnKey
+
+/* Myson products */
+product MYSON HEDEN_8813	0x8813	USB-IDE
+product MYSON HEDEN		0x8818	USB-IDE
+product MYSON HUBREADER		0x8819	COMBO Card reader with USB HUB
+product MYSON STARREADER	0x9920	USB flash card adapter
+
+/* National Semiconductor */
+product NATIONAL BEARPAW1200	0x1000	BearPaw 1200
+product NATIONAL BEARPAW2400	0x1001	BearPaw 2400
+
+/* NEC products */
+product NEC HUB_0050		0x0050	USB 2.0 7-Port Hub
+product NEC HUB_005A		0x005a	USB 2.0 4-Port Hub
+product NEC WL300NUG		0x0249	WL300NU-G
+product NEC WL900U		0x0408	Aterm WL900U
+product NEC HUB			0x55aa	hub
+product NEC HUB_B		0x55ab	hub
+
+/* NEODIO products */
+product NEODIO ND3260		0x3260	8-in-1 Multi-format Flash Controller
+product NEODIO ND5010		0x5010	Multi-format Flash Controller
+
+/* Neotel products */
+product NEOTEL PRIME		0x4000	Prime USB modem
+
+/* Netac products */
+product NETAC CF_CARD		0x1060	USB-CF-Card
+product NETAC ONLYDISK		0x0003	OnlyDisk
+
+/* NetChip Technology Products */
+product NETCHIP TURBOCONNECT	0x1080	Turbo-Connect
+product NETCHIP CLIK_40		0xa140	USB Clik! 40
+product NETCHIP GADGETZERO	0xa4a0	Linux Gadget Zero
+product NETCHIP ETHERNETGADGET	0xa4a2	Linux Ethernet/RNDIS gadget on pxa210/25x/26x
+product NETCHIP POCKETBOOK	0xa4a5	PocketBook
+
+/* Netgear products */
+product NETGEAR EA101		0x1001	Ethernet
+product NETGEAR EA101X		0x1002	Ethernet
+product NETGEAR FA101		0x1020	Ethernet 10/100, USB1.1
+product NETGEAR FA120		0x1040	USB 2.0 Ethernet
+product NETGEAR M4100		0x1100	M4100/M5300/M7100 series switch
+product NETGEAR WG111V1_2	0x4240	PrismGT USB 2.0 WLAN
+product NETGEAR WG111V3		0x4260	WG111v3
+product NETGEAR WG111U		0x4300	WG111U
+product NETGEAR WG111U_NF	0x4301	WG111U (no firmware)
+product NETGEAR WG111V2		0x6a00	WG111V2
+product NETGEAR WN111V2		0x9001	WN111V2
+product NETGEAR WNDA3100	0x9010	WNDA3100
+product NETGEAR WNDA4100	0x9012	WNDA4100
+product NETGEAR WNDA3200	0x9018	WNDA3200
+product NETGEAR RTL8192CU	0x9021	RTL8192CU
+product NETGEAR WNA1000		0x9040	WNA1000
+product NETGEAR WNA1000M	0x9041	WNA1000M
+product NETGEAR A6100		0x9052	A6100
+product NETGEAR2 MA101		0x4100	MA101
+product NETGEAR2 MA101B		0x4102	MA101 Rev B
+product NETGEAR3 WG111T		0x4250	WG111T
+product NETGEAR3 WG111T_NF	0x4251	WG111T (no firmware)
+product NETGEAR3 WPN111		0x5f00	WPN111
+product NETGEAR3 WPN111_NF	0x5f01	WPN111 (no firmware)
+product NETGEAR3 WPN111_2	0x5f02	WPN111
+product NETGEAR4 RTL8188CU	0x9041	RTL8188CU
+
+/* NetIndex products */
+product NETINDEX WS002IN	0x2001	Willcom WS002IN
+
+/* NEWlink */
+product NEWLINK USB2IDEBRIDGE	0x00ff	USB 2.0 Hard Drive Enclosure
+
+/* Nikon products */
+product NIKON E990		0x0102	Digital Camera E990
+product NIKON LS40		0x4000	CoolScan LS40 ED
+product NIKON D300		0x041a  Digital Camera D300
+
+/* NovaTech Products */
+product NOVATECH NV902		0x9020	NovaTech NV-902W
+product NOVATECH RT2573		0x9021	RT2573
+product NOVATECH RTL8188CU	0x9071	RTL8188CU
+
+/* Nokia products */
+product NOKIA N958GB		0x0070	Nokia N95 8GBc
+product NOKIA2 CA42		0x1234	CA-42 cable
+
+/* Novatel Wireless products */
+product NOVATEL V640		0x1100	Merlin V620
+product NOVATEL CDMA_MODEM	0x1110	Novatel Wireless Merlin CDMA
+product NOVATEL V620		0x1110	Merlin V620
+product NOVATEL V740		0x1120	Merlin V740
+product NOVATEL V720		0x1130	Merlin V720
+product NOVATEL U740		0x1400	Merlin U740
+product NOVATEL U740_2		0x1410	Merlin U740
+product NOVATEL U870		0x1420	Merlin U870
+product NOVATEL XU870		0x1430	Merlin XU870
+product NOVATEL X950D		0x1450	Merlin X950D
+product NOVATEL ES620		0x2100	Expedite ES620
+product NOVATEL E725		0x2120	Expedite E725
+product NOVATEL ES620_2		0x2130	Expedite ES620
+product NOVATEL ES620		0x2100	ES620 CDMA
+product NOVATEL U720		0x2110	Merlin U720
+product NOVATEL EU730		0x2400	Expedite EU730
+product NOVATEL EU740		0x2410	Expedite EU740
+product NOVATEL EU870D		0x2420	Expedite EU870D
+product NOVATEL U727		0x4100	Merlin U727 CDMA
+product NOVATEL MC950D		0x4400	Novatel MC950D HSUPA
+product NOVATEL MC990D		0x7001	Novatel MC990D
+product NOVATEL ZEROCD		0x5010	Novatel ZeroCD
+product NOVATEL MIFI2200V	0x5020	Novatel MiFi 2200 CDMA Virgin Mobile
+product NOVATEL ZEROCD2		0x5030	Novatel ZeroCD
+product NOVATEL MIFI2200	0x5041	Novatel MiFi 2200 CDMA
+product NOVATEL U727_2		0x5100	Merlin U727 CDMA
+product NOVATEL U760		0x6000	Novatel U760
+product NOVATEL MC760		0x6002	Novatel MC760
+product NOVATEL MC547		0x7042	Novatel MC547
+product NOVATEL MC679		0x7031	Novatel MC679
+product NOVATEL2 FLEXPACKGPS	0x0100	NovAtel FlexPack GPS receiver
+
+/* NVIDIA products */
+product NVIDIA RTL8153		0x09ff	USB 3.0 Ethernet
+
+/* Merlin products */
+product	MERLIN V620		0x1110	Merlin V620
+
+/* O2Micro products */
+product O2MICRO OZ776_HUB	0x7761	OZ776 hub
+product O2MICRO OZ776_CCID_SC	0x7772	OZ776 CCID SC Reader
+
+/* Olimex products */
+product OLIMEX ARM_USB_OCD		0x0003	FTDI compatible adapter
+product OLIMEX ARM_USB_OCD_H		0x002b	FTDI compatible adapter
+
+/* Olympus products */
+product OLYMPUS C1		0x0102	C-1 Digital Camera
+product OLYMPUS C700		0x0105	C-700 Ultra Zoom
+
+/* OmniVision Technologies, Inc. products */
+product OMNIVISION OV511	0x0511	OV511 Camera
+product OMNIVISION OV511PLUS	0xa511	OV511+ Camera
+
+/* OnSpec Electronic, Inc. */
+product ONSPEC SDS_HOTFIND_D	0x0400	SDS-infrared.com Hotfind-D Infrared Camera
+product ONSPEC MDCFE_B_CF_READER	0xa000	MDCFE-B USB CF Reader
+product ONSPEC CFMS_RW		0xa001	SIIG/Datafab Memory Stick+CF Reader/Writer
+product ONSPEC READER		0xa003	Datafab-based Reader
+product ONSPEC CFSM_READER	0xa005	PNY/Datafab CF+SM Reader
+product ONSPEC CFSM_READER2	0xa006	Simple Tech/Datafab CF+SM Reader
+product ONSPEC MDSM_B_READER	0xa103	MDSM-B reader
+product ONSPEC CFSM_COMBO	0xa109	USB to CF + SM Combo (LC1)
+product ONSPEC UCF100		0xa400	FlashLink UCF-100 CompactFlash Reader
+product ONSPEC2 IMAGEMATE_SDDR55	0xa103	ImageMate SDDR55
+
+/* Option products */
+product OPTION VODAFONEMC3G	0x5000	Vodafone Mobile Connect 3G datacard
+product OPTION GT3G		0x6000	GlobeTrotter 3G datacard
+product OPTION GT3GQUAD		0x6300	GlobeTrotter 3G QUAD datacard
+product OPTION GT3GPLUS		0x6600	GlobeTrotter 3G+ datacard
+product OPTION GTICON322	0xd033	GlobeTrotter Icon322 storage
+product OPTION GTMAX36		0x6701	GlobeTrotter Max 3.6 Modem
+product OPTION GTMAX72		0x6711	GlobeTrotter Max 7.2 HSDPA
+product OPTION GTHSDPA		0x6971	GlobeTrotter HSDPA
+product OPTION GTMAXHSUPA	0x7001	GlobeTrotter HSUPA
+product OPTION GTMAXHSUPAE	0x6901	GlobeTrotter HSUPA PCIe
+product OPTION GTMAX380HSUPAE	0x7211	GlobeTrotter 380HSUPA PCIe
+product OPTION GT3G_1		0x6050	3G modem
+product OPTION GT3G_2		0x6100	3G modem
+product OPTION GT3G_3		0x6150	3G modem
+product OPTION GT3G_4		0x6200	3G modem
+product OPTION GT3G_5		0x6250	3G modem
+product OPTION GT3G_6		0x6350	3G modem
+product OPTION E6500		0x6500	3G modem
+product OPTION E6501		0x6501	3G modem
+product OPTION E6601		0x6601	3G modem
+product OPTION E6721		0x6721	3G modem
+product OPTION E6741		0x6741	3G modem
+product OPTION E6761		0x6761	3G modem
+product OPTION E6800		0x6800	3G modem
+product OPTION E7021		0x7021	3G modem
+product OPTION E7041		0x7041	3G modem
+product OPTION E7061		0x7061	3G modem
+product OPTION E7100		0x7100	3G modem
+product OPTION GTM380		0x7201	3G modem
+product OPTION GE40X		0x7601	Globetrotter HSUPA
+product OPTION GSICON72		0x6911	GlobeSurfer iCON
+product OPTION GSICONHSUPA	0x7251	Globetrotter HSUPA
+product OPTION ICON401		0x7401	GlobeSurfer iCON 401
+product OPTION GTHSUPA		0x7011	Globetrotter HSUPA
+product OPTION GMT382		0x7501	Globetrotter HSUPA
+product OPTION GE40X_1		0x7301	Globetrotter HSUPA
+product OPTION GE40X_2		0x7361	Globetrotter HSUPA
+product OPTION GE40X_3		0x7381	Globetrotter HSUPA
+product OPTION GTM661W		0x9000  GTM661W
+product OPTION ICONEDGE		0xc031	GlobeSurfer iCON EDGE
+product OPTION MODHSXPA		0xd013	Globetrotter HSUPA
+product OPTION ICON321		0xd031	Globetrotter HSUPA
+product OPTION ICON505		0xd055	Globetrotter iCON 505
+product OPTION ICON452		0x7901	Globetrotter iCON 452
+
+/* Optoelectronics Co., Ltd */
+product OPTO BARCODE		0x0001	Barcode Reader
+product OPTO OPTICONCODE	0x0009	Opticon Code Reader
+product OPTO BARCODE_1		0xa002	Barcode Reader
+product OPTO CRD7734		0xc000	USB Cradle CRD-7734-RU
+product OPTO CRD7734_1		0xc001	USB Cradle CRD-7734-RU
+
+/* OvisLink product */
+product OVISLINK RT3072		0x3072	RT3072
+
+/* OQO */
+product OQO WIFI01		0x0002	model 01 WiFi interface
+product OQO BT01		0x0003	model 01 Bluetooth interface
+product OQO ETHER01PLUS		0x7720	model 01+ Ethernet
+product OQO ETHER01		0x8150	model 01 Ethernet interface
+
+/* Ours Technology Inc. */
+product OTI DKU5		0x6858	DKU-5 Serial
+
+/* Owen.ru products */
+product OWEN AC4		0x0004	AC4 USB-RS485 converter
+
+/* OWL producs */
+product OWL CM_160		0xca05	OWL CM-160 power monitor
+
+/* Palm Computing, Inc. product */
+product PALM SERIAL		0x0080	USB Serial
+product PALM M500		0x0001	Palm m500
+product PALM M505		0x0002	Palm m505
+product PALM M515		0x0003	Palm m515
+product PALM I705		0x0020	Palm i705
+product PALM TUNGSTEN_Z		0x0031	Palm Tungsten Z
+product PALM M125		0x0040	Palm m125
+product PALM M130		0x0050	Palm m130
+product PALM TUNGSTEN_T		0x0060	Palm Tungsten T
+product PALM ZIRE31		0x0061	Palm Zire 31
+product PALM ZIRE		0x0070	Palm Zire
+
+/* Panasonic products */
+product PANASONIC LS120CAM	0x0901	LS-120 Camera
+product PANASONIC KXL840AN	0x0d01	CD-R Drive KXL-840AN
+product PANASONIC KXLRW32AN	0x0d09	CD-R Drive KXL-RW32AN
+product PANASONIC KXLCB20AN	0x0d0a	CD-R Drive KXL-CB20AN
+product PANASONIC KXLCB35AN	0x0d0e	DVD-ROM & CD-R/RW
+product PANASONIC SDCAAE	0x1b00	MultiMediaCard
+product PANASONIC TYTP50P6S	0x3900	TY-TP50P6-S 50in Touch Panel
+
+/* Papouch products */
+product PAPOUCH AD4USB		0x8003	FTDI compatible adapter
+product PAPOUCH AP485		0x0101	FTDI compatible adapter
+product PAPOUCH AP485_2		0x0104	FTDI compatible adapter
+product PAPOUCH DRAK5		0x0700	FTDI compatible adapter
+product PAPOUCH DRAK6		0x1000	FTDI compatible adapter
+product PAPOUCH GMSR		0x8005	FTDI compatible adapter
+product PAPOUCH GMUX		0x8004	FTDI compatible adapter
+product PAPOUCH IRAMP		0x0500	FTDI compatible adapter
+product PAPOUCH LEC		0x0300	FTDI compatible adapter
+product PAPOUCH MU		0x8001	FTDI compatible adapter
+product PAPOUCH QUIDO10X1		0x0b00	FTDI compatible adapter
+product PAPOUCH QUIDO2X16		0x0e00	FTDI compatible adapter
+product PAPOUCH QUIDO2X2		0x0a00	FTDI compatible adapter
+product PAPOUCH QUIDO30X3		0x0c00	FTDI compatible adapter
+product PAPOUCH QUIDO3X32		0x0f00	FTDI compatible adapter
+product PAPOUCH QUIDO4X4		0x0900	FTDI compatible adapter
+product PAPOUCH QUIDO60X3		0x0d00	FTDI compatible adapter
+product PAPOUCH QUIDO8X8		0x0800	FTDI compatible adapter
+product PAPOUCH SB232		0x0301	FTDI compatible adapter
+product PAPOUCH SB422		0x0102	FTDI compatible adapter
+product PAPOUCH SB422_2		0x0105	FTDI compatible adapter
+product PAPOUCH SB485		0x0100	FTDI compatible adapter
+product PAPOUCH SB485C		0x0107	FTDI compatible adapter
+product PAPOUCH SB485S		0x0106	FTDI compatible adapter
+product PAPOUCH SB485_2		0x0103	FTDI compatible adapter
+product PAPOUCH SIMUKEY		0x8002	FTDI compatible adapter
+product PAPOUCH TMU		0x0400	FTDI compatible adapter
+product PAPOUCH UPSUSB		0x8000	FTDI compatible adapter
+
+/* PARA Industrial products */
+product PARA RT3070		0x8888	RT3070
+
+/* Simtec Electronics products */
+product SIMTEC ENTROPYKEY	0x0001	Entropy Key
+
+/* Pegatron products */
+product PEGATRON RT2870		0x0002	RT2870
+product PEGATRON RT3070		0x000c	RT3070
+product PEGATRON RT3070_2	0x000e	RT3070
+product PEGATRON RT3070_3	0x0010	RT3070
+
+/* Peracom products */
+product PERACOM SERIAL1		0x0001	Serial
+product PERACOM ENET		0x0002	Ethernet
+product PERACOM ENET3		0x0003	At Home Ethernet
+product PERACOM ENET2		0x0005	Ethernet
+
+/* Peraso Technologies, Inc products */
+product PERASO PRS4001		0x4001	PRS4001 WLAN
+
+/* Philips products */
+product PHILIPS DSS350		0x0101	DSS 350 Digital Speaker System
+product PHILIPS DSS		0x0104	DSS XXX Digital Speaker System
+product PHILIPS HUB		0x0201	hub
+product PHILIPS PCA646VC	0x0303	PCA646VC PC Camera
+product PHILIPS PCVC680K	0x0308	PCVC680K Vesta Pro PC Camera
+product PHILIPS SPC900NC	0x0329  SPC 900NC CCD PC Camera
+product PHILIPS DSS150		0x0471	DSS 150 Digital Speaker System
+product PHILIPS ACE1001		0x066a	AKTAKOM ACE-1001 cable
+product PHILIPS SPE3030CC	0x083a	USB 2.0 External Disk
+product PHILIPS SNU5600		0x1236	SNU5600
+product PHILIPS UM10016		0x1552	ISP 1581 Hi-Speed USB MPEG2 Encoder Reference Kit
+product PHILIPS DIVAUSB		0x1801	DIVA USB mp3 player
+product PHILIPS RT2870		0x200f	RT2870
+
+/* Philips Semiconductor products */
+product PHILIPSSEMI HUB1122	0x1122	HUB
+
+/* Megatec */
+product MEGATEC UPS		0x5161	Phoenixtec protocol based UPS
+
+/* P.I. Engineering products */
+product PIENGINEERING PS2USB	0x020b	PS2 to Mac USB Adapter
+
+/* Planex Communications products */
+product PLANEX GW_US11H		0x14ea	GW-US11H WLAN
+product PLANEX2 RTL8188CUS	0x1201	RTL8188CUS
+product PLANEX2 GW_US11S	0x3220	GW-US11S WLAN
+product PLANEX2 GW_US54GXS	0x5303	GW-US54GXS WLAN
+product PLANEX2 GW_US300	0x5304	GW-US300
+product PLANEX2 RTL8188CU_1	0xab2a	RTL8188CU
+product PLANEX2 RTL8188CU_2	0xed17	RTL8188CU
+product PLANEX2 RTL8188CU_3	0x4902	RTL8188CU
+product PLANEX2 RTL8188CU_4	0xab2e	RTL8188CU
+product PLANEX2 RTL8192CU	0xab2b	RTL8192CU
+product PLANEX2 GWUS54HP	0xab01	GW-US54HP
+product PLANEX2 GWUS300MINIS	0xab24	GW-US300MiniS
+product PLANEX2	RT3070		0xab25	RT3070
+product PLANEX2 MZKUE150N	0xab2f	MZK-UE150N
+product PLANEX2 GW900D		0xab30	GW-900D
+product PLANEX2 GWUS54MINI2	0xab50	GW-US54Mini2
+product PLANEX2 GWUS54SG	0xc002	GW-US54SG
+product PLANEX2 GWUS54GZL	0xc007	GW-US54GZL
+product PLANEX2 GWUS54GD	0xed01	GW-US54GD
+product PLANEX2 GWUSMM		0xed02	GW-USMM
+product PLANEX2 RT2870		0xed06	RT2870
+product PLANEX2 GWUSMICRON	0xed14	GW-USMicroN
+product PLANEX2 GWUSVALUEEZ	0xed17	GW-USValue-EZ
+product PLANEX3 GWUS54GZ	0xab10	GW-US54GZ
+product PLANEX3 GU1000T		0xab11	GU-1000T
+product PLANEX3 GWUS54MINI	0xab13	GW-US54Mini
+product PLANEX2 GWUSNANO	0xab28	GW-USNano
+
+/* Plextor Corp. */
+product PLEXTOR 40_12_40U	0x0011	PlexWriter 40/12/40U
+
+/* Ploytec GmbH */
+product PLOYTEC SPL_CRIMSON_1	0xc150	SPL Crimson Revision 1
+
+/* PLX products */
+product PLX TESTBOARD		0x9060	test board
+product PLX CA42		0xac70	CA-42
+
+/* PNY products */
+product PNY ATTACHE2		0x0010	USB 2.0 Flash Drive
+
+/* PortGear products */
+product PORTGEAR EA8		0x0008	Ethernet
+product PORTGEAR EA9		0x0009	Ethernet
+
+/* Portsmith products */
+product PORTSMITH EEA		0x3003	Express Ethernet
+
+/* Posiflex products */
+product POSIFLEX PP7000		0x0300	FTDI compatible adapter
+
+/* Primax products */
+product PRIMAX G2X300		0x0300	G2-200 scanner
+product PRIMAX G2E300		0x0301	G2E-300 scanner
+product PRIMAX G2300		0x0302	G2-300 scanner
+product PRIMAX G2E3002		0x0303	G2E-300 scanner
+product PRIMAX 9600		0x0340	Colorado USB 9600 scanner
+product PRIMAX 600U		0x0341	Colorado 600u scanner
+product PRIMAX 6200		0x0345	Visioneer 6200 scanner
+product PRIMAX 19200		0x0360	Colorado USB 19200 scanner
+product PRIMAX 1200U		0x0361	Colorado 1200u scanner
+product PRIMAX G600		0x0380	G2-600 scanner
+product PRIMAX 636I		0x0381	ReadyScan 636i
+product PRIMAX G2600		0x0382	G2-600 scanner
+product PRIMAX G2E600		0x0383	G2E-600 scanner
+product PRIMAX COMFORT		0x4d01	Comfort
+product PRIMAX MOUSEINABOX	0x4d02	Mouse-in-a-Box
+product PRIMAX PCGAUMS1		0x4d04	Sony PCGA-UMS1
+product PRIMAX HP_RH304AA	0x4d17	HP RH304AA mouse
+
+/* Prolific products */
+product PROLIFIC PL2301		0x0000	PL2301 Host-Host interface
+product PROLIFIC PL2302		0x0001	PL2302 Host-Host interface
+product PROLIFIC MOTOROLA	0x0307	Motorola Cable
+product PROLIFIC RSAQ2		0x04bb	PL2303 Serial (IODATA USB-RSAQ2)
+product PROLIFIC ALLTRONIX_GPRS	0x0609	Alltronix ACM003U00 modem
+product PROLIFIC ALDIGA_AL11U	0x0611	AlDiga AL-11U modem
+product PROLIFIC MICROMAX_610U	0x0612	Micromax 610U
+product PROLIFIC DCU11		0x1234	DCU-11 Phone Cable
+product PROLIFIC UIC_MSR206	0x206a	UIC MSR206 Card Reader
+product PROLIFIC PL2303		0x2303	PL2303 Serial (ATEN/IOGEAR UC232A)
+product PROLIFIC PL2305		0x2305	Parallel printer
+product PROLIFIC ATAPI4		0x2307	ATAPI-4 Controller
+product PROLIFIC PL2501		0x2501	PL2501 Host-Host interface
+product PROLIFIC PL2506		0x2506	PL2506 USB to IDE Bridge
+product PROLIFIC PL27A1		0x27A1	PL27A1 USB 3.0 Host-Host interface
+product PROLIFIC HCR331		0x331a	HCR331 Hybrid Card Reader
+product PROLIFIC PHAROS		0xaaa0	Prolific Pharos
+product PROLIFIC RSAQ3		0xaaa2	PL2303 Serial Adapter (IODATA USB-RSAQ3)
+product PROLIFIC2 PL2303	0x2303	PL2303 Serial Adapter
+
+/* Putercom products */
+product PUTERCOM UPA100		0x047e	USB-1284 BRIDGE
+
+/* Qcom products */
+product QCOM RT2573		0x6196	RT2573
+product QCOM RT2573_2		0x6229	RT2573
+product QCOM RT2573_3		0x6238	RT2573
+product QCOM RT2870		0x6259	RT2870
+
+/* QI-hardware */
+product QIHARDWARE JTAGSERIAL		0x0713	FTDI compatible adapter
+
+/* Qisda products */
+product QISDA H21_1		0x4512	3G modem
+product QISDA H21_2		0x4523	3G modem
+product QISDA H20_1		0x4515	3G modem
+product QISDA H20_2		0x4519	3G modem
+
+/* Qualcomm products */
+product QUALCOMM CDMA_MSM	0x6000	CDMA Technologies MSM phone
+product QUALCOMM NTT_L02C_MODEM	0x618f	NTT DOCOMO L-02C
+product QUALCOMM NTT_L02C_STORAGE	0x61dd	NTT DOCOMO L-02C
+product QUALCOMM2 MF330		0x6613	MF330
+product QUALCOMM2 RWT_FCT	0x3100	RWT FCT-CDMA 2000 1xRTT modem
+product QUALCOMM2 CDMA_MSM	0x3196	CDMA Technologies MSM modem
+product QUALCOMM2 AC8700	0x6000	AC8700
+product QUALCOMM2 VW110L	0x1000	Vertex Wireless 110L modem
+product QUALCOMM2 SIM5218	0x9000	SIM5218
+product QUALCOMM2 WM620		0x9002	Neoway WM620
+product QUALCOMM2 GOBI2000_QDL	0x9204	Qualcomm Gobi 2000 QDL
+product QUALCOMM2 GOBI2000	0x9205	Qualcomm Gobi 2000 modem
+product QUALCOMM2 VT80N		0x6500	Venus VT80N
+product QUALCOMM3 VFAST2	0x9909	Venus Fast2 modem
+product QUALCOMMINC CDMA_MSM	0x0001	CDMA Technologies MSM modem
+product QUALCOMMINC E0002	0x0002	3G modem
+product QUALCOMMINC E0003	0x0003	3G modem
+product QUALCOMMINC E0004	0x0004	3G modem
+product QUALCOMMINC E0005	0x0005	3G modem
+product QUALCOMMINC E0006	0x0006	3G modem
+product QUALCOMMINC E0007	0x0007	3G modem
+product QUALCOMMINC E0008	0x0008	3G modem
+product QUALCOMMINC E0009	0x0009	3G modem
+product QUALCOMMINC E000A	0x000a	3G modem
+product QUALCOMMINC E000B	0x000b	3G modem
+product QUALCOMMINC E000C	0x000c	3G modem
+product QUALCOMMINC E000D	0x000d	3G modem
+product QUALCOMMINC E000E	0x000e	3G modem
+product QUALCOMMINC E000F	0x000f	3G modem
+product QUALCOMMINC E0010	0x0010	3G modem
+product QUALCOMMINC E0011	0x0011	3G modem
+product QUALCOMMINC E0012	0x0012	3G modem
+product QUALCOMMINC E0013	0x0013	3G modem
+product QUALCOMMINC E0014	0x0014	3G modem
+product QUALCOMMINC MF628	0x0015	3G modem
+product QUALCOMMINC MF633R	0x0016	ZTE WCDMA modem
+product QUALCOMMINC E0017	0x0017	3G modem
+product QUALCOMMINC E0018	0x0018	3G modem
+product QUALCOMMINC E0019	0x0019	3G modem
+product QUALCOMMINC E0020	0x0020	3G modem
+product QUALCOMMINC E0021	0x0021	3G modem
+product QUALCOMMINC E0022	0x0022	3G modem
+product QUALCOMMINC E0023	0x0023	3G modem
+product QUALCOMMINC E0024	0x0024	3G modem
+product QUALCOMMINC E0025	0x0025	3G modem
+product QUALCOMMINC E0026	0x0026	3G modem
+product QUALCOMMINC E0027	0x0027	3G modem
+product QUALCOMMINC E0028	0x0028	3G modem
+product QUALCOMMINC E0029	0x0029	3G modem
+product QUALCOMMINC E0030	0x0030	3G modem
+product QUALCOMMINC MF626	0x0031	3G modem
+product QUALCOMMINC E0032	0x0032	3G modem
+product QUALCOMMINC E0033	0x0033	3G modem
+product QUALCOMMINC E0037	0x0037	3G modem
+product QUALCOMMINC E0039	0x0039	3G modem
+product QUALCOMMINC E0042	0x0042	3G modem
+product QUALCOMMINC E0043	0x0043	3G modem
+product QUALCOMMINC E0048	0x0048	3G modem
+product QUALCOMMINC E0049	0x0049	3G modem
+product QUALCOMMINC E0051	0x0051	3G modem
+product QUALCOMMINC E0052	0x0052	3G modem
+product QUALCOMMINC ZTE_STOR2	0x0053	USB ZTE Storage
+product QUALCOMMINC E0054	0x0054	3G modem
+product QUALCOMMINC E0055	0x0055	3G modem
+product QUALCOMMINC E0057	0x0057	3G modem
+product QUALCOMMINC E0058	0x0058	3G modem
+product QUALCOMMINC E0059	0x0059	3G modem
+product QUALCOMMINC E0060	0x0060	3G modem
+product QUALCOMMINC E0061	0x0061	3G modem
+product QUALCOMMINC E0062	0x0062	3G modem
+product QUALCOMMINC E0063	0x0063	3G modem
+product QUALCOMMINC E0064	0x0064	3G modem
+product QUALCOMMINC E0066	0x0066	3G modem
+product QUALCOMMINC E0069	0x0069	3G modem
+product QUALCOMMINC E0070	0x0070	3G modem
+product QUALCOMMINC E0073	0x0073	3G modem
+product QUALCOMMINC E0076	0x0076	3G modem
+product QUALCOMMINC E0078	0x0078	3G modem
+product QUALCOMMINC E0082	0x0082	3G modem
+product QUALCOMMINC E0086	0x0086	3G modem
+product QUALCOMMINC MF112	0x0103	3G modem
+product QUALCOMMINC SURFSTICK	0x0117	1&1 Surf Stick
+product QUALCOMMINC K3772_Z_INIT	0x1179	K3772-Z Initial
+product QUALCOMMINC K3772_Z	0x1181	K3772-Z
+product QUALCOMMINC ZTE_MF730M	0x1420	3G modem
+product QUALCOMMINC MF195E_INIT	0x1514	MF195E initial
+product QUALCOMMINC MF195E	0x1516	MF195E
+product QUALCOMMINC ZTE_STOR	0x2000	USB ZTE Storage
+product QUALCOMMINC E2002	0x2002	3G modem
+product QUALCOMMINC E2003	0x2003	3G modem
+product QUALCOMMINC AC682	0xffdd	CDMA 1xEVDO USB modem
+product QUALCOMMINC AC682_INIT	0xffde	CDMA 1xEVDO USB modem (initial)
+product QUALCOMMINC AC8710	0xfff1	3G modem
+product QUALCOMMINC AC2726	0xfff5	3G modem
+product QUALCOMMINC AC8700	0xfffe	CDMA 1xEVDO USB modem
+
+/* Quanta products */
+product QUANTA RW6815_1		0x00ce	HP iPAQ rw6815
+product QUANTA RT3070		0x0304	RT3070
+product QUANTA Q101_STOR	0x1000	USB Q101 Storage
+product QUANTA Q101		0xea02	HSDPA modem
+product QUANTA Q111		0xea03	HSDPA modem
+product QUANTA GLX		0xea04	HSDPA modem
+product QUANTA GKE		0xea05	HSDPA modem
+product QUANTA GLE		0xea06	HSDPA modem
+product QUANTA RW6815R		0xf003	HP iPAQ rw6815 RNDIS
+
+/* Quectel products */
+product QUECTEL EC25		0x0125	LTE modem
+
+/* Quickshot products */
+product QUICKSHOT STRIKEPAD	0x6238	USB StrikePad
+
+/* Qtronix products */
+product QTRONIX 980N		0x2011	Scorpion-980N keyboard
+
+/* Radio Shack */
+product RADIOSHACK USBCABLE	0x4026	USB to Serial Cable
+
+/* Rainbow Technologies products */
+product RAINBOW IKEY2000	0x1200	i-Key 2000
+
+/* Ralink Technology products */
+product RALINK RT2570		0x1706	RT2500USB Wireless Adapter
+product RALINK RT2070		0x2070	RT2070
+product RALINK RT2570_2		0x2570	RT2500USB Wireless Adapter
+product RALINK RT2573		0x2573	RT2501USB Wireless Adapter
+product RALINK RT2671		0x2671	RT2601USB Wireless Adapter
+product RALINK RT2770		0x2770	RT2770
+product RALINK RT2870		0x2870	RT2870
+product RALINK RT_STOR		0x2878	USB Storage
+product RALINK RT3070		0x3070	RT3070
+product RALINK RT3071		0x3071	RT3071
+product RALINK RT3072		0x3072	RT3072
+product RALINK RT3370		0x3370	RT3370
+product RALINK RT3572		0x3572	RT3572
+product RALINK RT3573		0x3573	RT3573
+product RALINK RT5370		0x5370	RT5370
+product RALINK RT5372		0x5372	RT5372
+product RALINK RT5572		0x5572	RT5572
+product RALINK RT8070		0x8070	RT8070
+product RALINK RT2570_3		0x9020	RT2500USB Wireless Adapter
+product RALINK RT2573_2		0x9021	RT2501USB Wireless Adapter
+
+/* RATOC Systems products */
+product RATOC REXUSB60		0xb000	USB serial adapter REX-USB60
+product RATOC REXUSB60F		0xb020	USB serial adapter REX-USB60F
+
+/* Realtek products */
+/* Green House and CompUSA OEM this part */
+product REALTEK DUMMY		0x0000	Dummy product
+product REALTEK USB20CRW	0x0158	USB20CRW Card Reader
+product REALTEK RTL8188ETV	0x0179	RTL8188ETV
+product REALTEK RTL8188CTV      0x018a  RTL8188CTV
+product REALTEK RTL8188RU_2	0x317f	RTL8188RU
+product REALTEK USBKR100	0x8150	USBKR100 USB Ethernet
+product REALTEK RTL8152		0x8152	RTL8152 USB Ethernet
+product REALTEK RTL8153		0x8153	RTL8153 USB Ethernet
+product REALTEK RTL8188CE_0     0x8170  RTL8188CE
+product REALTEK RTL8171		0x8171	RTL8171
+product REALTEK RTL8172		0x8172	RTL8172
+product REALTEK RTL8173		0x8173	RTL8173
+product REALTEK RTL8174		0x8174	RTL8174
+product REALTEK RTL8188CU_0	0x8176	RTL8188CU
+product REALTEK RTL8191CU	0x8177	RTL8191CU
+product REALTEK RTL8192CU	0x8178	RTL8192CU
+product REALTEK RTL8188EU	0x8179	RTL8188EU
+product REALTEK RTL8188CU_1	0x817a	RTL8188CU
+product REALTEK RTL8188CU_2	0x817b	RTL8188CU
+product REALTEK RTL8192CE	0x817c	RTL8192CE
+product REALTEK RTL8188RU_1	0x817d	RTL8188RU
+product REALTEK RTL8188CE_1	0x817e	RTL8188CE
+product REALTEK RTL8188RU_3	0x817f	RTL8188RU
+product REALTEK RTL8187		0x8187	RTL8187 Wireless Adapter
+product REALTEK RTL8187B_0	0x8189	RTL8187B Wireless Adapter
+product REALTEK RTL8188CUS	0x818a	RTL8188CUS
+product REALTEK RTL8192EU	0x818b	RTL8192EU
+product REALTEK RTL8188CU_3	0x8191	RTL8188CU
+product REALTEK RTL8196EU	0x8196	RTL8196EU
+product REALTEK RTL8187B_1	0x8197	RTL8187B Wireless Adapter
+product REALTEK RTL8187B_2	0x8198	RTL8187B Wireless Adapter
+product REALTEK RTL8712		0x8712	RTL8712
+product REALTEK RTL8713		0x8713	RTL8713
+product REALTEK RTL8188CU_COMBO	0x8754	RTL8188CU
+product REALTEK RTL8723BU	0xb720	RTL8723BU
+product REALTEK RTL8192SU	0xc512	RTL8192SU
+product REALTEK RTL8812AU	0x8812  RTL8812AU Wireless Adapter
+
+/* RedOctane products */
+product REDOCTANE DUMMY		0x0000	Dummy product
+product REDOCTANE GHMIDI	0x474b	GH MIDI INTERFACE
+
+/* Renesas products */
+product RENESAS RX610		0x0053	RX610 RX-Stick
+
+/* Ricoh products */
+product RICOH VGPVCC2		0x1830	VGP-VCC2 Camera
+product RICOH VGPVCC3		0x1832	VGP-VCC3 Camera
+product RICOH VGPVCC2_2		0x1833	VGP-VCC2 Camera
+product RICOH VGPVCC2_3		0x1834	VGP-VCC2 Camera
+product RICOH VGPVCC7		0x183a	VGP-VCC7 Camera
+product RICOH VGPVCC8		0x183b	VGP-VCC8 Camera
+
+/* Reiner-SCT products */
+product REINERSCT CYBERJACK_ECOM	0x0100	e-com cyberJack
+
+/* Roland products */
+product ROLAND UA100		0x0000	UA-100 Audio I/F
+product ROLAND UM4		0x0002	UM-4 MIDI I/F
+product ROLAND SC8850		0x0003	SC-8850 MIDI Synth
+product ROLAND U8		0x0004	U-8 Audio I/F
+product ROLAND UM2		0x0005	UM-2 MIDI I/F
+product ROLAND SC8820		0x0007	SC-8820 MIDI Synth
+product ROLAND PC300		0x0008	PC-300 MIDI Keyboard
+product ROLAND UM1		0x0009	UM-1 MIDI I/F
+product ROLAND SK500		0x000b	SK-500 MIDI Keyboard
+product ROLAND SCD70		0x000c	SC-D70 MIDI Synth
+product ROLAND UM880N		0x0014	EDIROL UM-880 MIDI I/F (native)
+product ROLAND UM880G		0x0015	EDIROL UM-880 MIDI I/F (generic)
+product ROLAND SD90		0x0016	SD-90 MIDI Synth
+product ROLAND UM550		0x0023	UM-550 MIDI I/F
+product ROLAND SD20		0x0027	SD-20 MIDI Synth
+product ROLAND SD80		0x0029	SD-80 MIDI Synth
+product ROLAND UA700		0x002b	UA-700 Audio I/F
+product ROLAND PCR300		0x0033  EDIROL PCR-300 MIDI I/F
+
+/* Rockfire products */
+product ROCKFIRE GAMEPAD	0x2033	gamepad 203USB
+
+/* RATOC Systems products */
+product RATOC REXUSB60		0xb000	REX-USB60
+product RATOC REXUSB60F		0xb020	REX-USB60F
+
+/* RT system products */
+product RTSYSTEMS CT29B		0x9e54	FTDI compatible adapter
+product RTSYSTEMS SERIAL_VX7		0x9e52	FTDI compatible adapter
+
+/* Sagem products */
+product SAGEM USBSERIAL		0x0027	USB-Serial Controller
+product SAGEM XG760A		0x004a	XG-760A
+product SAGEM XG76NA		0x0062	XG-76NA
+
+/* Samsung products */
+product SAMSUNG WIS09ABGN	0x2018	WIS09ABGN Wireless LAN adapter
+product SAMSUNG ML6060		0x3008	ML-6060 laser printer
+product SAMSUNG YP_U2		0x5050	YP-U2 MP3 Player
+product SAMSUNG YP_U4		0x5092	YP-U4 MP3 Player
+product SAMSUNG I500		0x6601	I500 Palm USB Phone
+product SAMSUNG I330		0x8001	I330 phone cradle
+product SAMSUNG2 RT2870_1	0x2018	RT2870
+
+/* Samsung Techwin products */
+product SAMSUNG_TECHWIN DIGIMAX_410	0x000a	Digimax 410
+
+/* SanDisk products */
+product SANDISK SDDR05A		0x0001	ImageMate SDDR-05a
+product SANDISK SDDR31		0x0002	ImageMate SDDR-31
+product SANDISK SDDR05		0x0005	ImageMate SDDR-05
+product SANDISK SDDR12		0x0100	ImageMate SDDR-12
+product SANDISK SDDR09		0x0200	ImageMate SDDR-09
+product SANDISK SDDR75		0x0810	ImageMate SDDR-75
+product SANDISK SDCZ2_128	0x7100	Cruzer Mini 128MB
+product SANDISK SDCZ2_256	0x7104	Cruzer Mini 256MB
+product SANDISK SDCZ4_128	0x7112	Cruzer Micro 128MB
+product SANDISK SDCZ4_256	0x7113	Cruzer Micro 256MB
+product SANDISK IMAGEMATE_SDDR289	0xb6ba	ImageMate SDDR-289
+
+/* Sanwa Electric Instrument Co., Ltd. products */
+product SANWA KB_USB2 		0x0701	KB-USB2 multimeter cable
+
+/* Sanyo Electric products */
+product SANYO SCP4900 		0x0701	Sanyo SCP-4900 USB Phone
+
+/* ScanLogic products */
+product SCANLOGIC SL11R		0x0002	SL11R IDE Adapter
+product SCANLOGIC 336CX		0x0300	Phantom 336CX - C3 scanner
+
+/* Schweitzer Engineering Laboratories products */
+product SEL C662		0x0001	C662 Cable
+
+/* Sealevel products */
+product SEALEVEL 2101		0x2101	FTDI compatible adapter
+product SEALEVEL 2102		0x2102	FTDI compatible adapter
+product SEALEVEL 2103		0x2103	FTDI compatible adapter
+product SEALEVEL 2104		0x2104	FTDI compatible adapter
+product SEALEVEL 2106		0x9020	FTDI compatible adapter
+product SEALEVEL 2201_1		0x2211	FTDI compatible adapter
+product SEALEVEL 2201_2		0x2221	FTDI compatible adapter
+product SEALEVEL 2202_1		0x2212	FTDI compatible adapter
+product SEALEVEL 2202_2		0x2222	FTDI compatible adapter
+product SEALEVEL 2203_1		0x2213	FTDI compatible adapter
+product SEALEVEL 2203_2		0x2223	FTDI compatible adapter
+product SEALEVEL 2401_1		0x2411	FTDI compatible adapter
+product SEALEVEL 2401_2		0x2421	FTDI compatible adapter
+product SEALEVEL 2401_3		0x2431	FTDI compatible adapter
+product SEALEVEL 2401_4		0x2441	FTDI compatible adapter
+product SEALEVEL 2402_1		0x2412	FTDI compatible adapter
+product SEALEVEL 2402_2		0x2422	FTDI compatible adapter
+product SEALEVEL 2402_3		0x2432	FTDI compatible adapter
+product SEALEVEL 2402_4		0x2442	FTDI compatible adapter
+product SEALEVEL 2403_1		0x2413	FTDI compatible adapter
+product SEALEVEL 2403_2		0x2423	FTDI compatible adapter
+product SEALEVEL 2403_3		0x2433	FTDI compatible adapter
+product SEALEVEL 2403_4		0x2443	FTDI compatible adapter
+product SEALEVEL 2801_1		0x2811	FTDI compatible adapter
+product SEALEVEL 2801_2		0x2821	FTDI compatible adapter
+product SEALEVEL 2801_3		0x2831	FTDI compatible adapter
+product SEALEVEL 2801_4		0x2841	FTDI compatible adapter
+product SEALEVEL 2801_5		0x2851	FTDI compatible adapter
+product SEALEVEL 2801_6		0x2861	FTDI compatible adapter
+product SEALEVEL 2801_7		0x2871	FTDI compatible adapter
+product SEALEVEL 2801_8		0x2881	FTDI compatible adapter
+product SEALEVEL 2802_1		0x2812	FTDI compatible adapter
+product SEALEVEL 2802_2		0x2822	FTDI compatible adapter
+product SEALEVEL 2802_3		0x2832	FTDI compatible adapter
+product SEALEVEL 2802_4		0x2842	FTDI compatible adapter
+product SEALEVEL 2802_5		0x2852	FTDI compatible adapter
+product SEALEVEL 2802_6		0x2862	FTDI compatible adapter
+product SEALEVEL 2802_7		0x2872	FTDI compatible adapter
+product SEALEVEL 2802_8		0x2882	FTDI compatible adapter
+product SEALEVEL 2803_1		0x2813	FTDI compatible adapter
+product SEALEVEL 2803_2		0x2823	FTDI compatible adapter
+product SEALEVEL 2803_3		0x2833	FTDI compatible adapter
+product SEALEVEL 2803_4		0x2843	FTDI compatible adapter
+product SEALEVEL 2803_5		0x2853	FTDI compatible adapter
+product SEALEVEL 2803_6		0x2863	FTDI compatible adapter
+product SEALEVEL 2803_7		0x2873	FTDI compatible adapter
+product SEALEVEL 2803_8		0x2883	FTDI compatible adapter
+
+/* Senao products */
+product SENAO EUB1200AC		0x0100	EnGenius EUB1200AC
+product SENAO RT2870_3		0x0605	RT2870
+product SENAO RT2870_4		0x0615	RT2870
+product SENAO NUB8301		0x2000	NUB-8301
+product SENAO RT2870_1		0x9701	RT2870
+product SENAO RT2870_2		0x9702	RT2870
+product SENAO RT3070		0x9703	RT3070
+product SENAO RT3071		0x9705	RT3071
+product SENAO RT3072_1		0x9706	RT3072
+product SENAO RT3072_2		0x9707	RT3072
+product SENAO RT3072_3		0x9708	RT3072
+product SENAO RT3072_4		0x9709	RT3072
+product SENAO RT3072_5		0x9801	RT3072
+product SENAO RTL8192SU_1	0x9603	RTL8192SU
+product SENAO RTL8192SU_2	0x9605	RTL8192SU
+
+/* ShanTou products */
+product SHANTOU ST268		0x0268	ST268
+product SHANTOU DM9601		0x9601	DM 9601
+product SHANTOU ADM8515		0x8515	ADM8515
+
+/* Shark products */
+product SHARK PA		0x0400	Pocket Adapter
+
+/* Sharp products */
+product SHARP SL5500		0x8004	Zaurus SL-5500 PDA
+product SHARP SLA300		0x8005	Zaurus SL-A300 PDA
+product SHARP SL5600		0x8006	Zaurus SL-5600 PDA
+product SHARP SLC700		0x8007	Zaurus SL-C700 PDA
+product SHARP SLC750		0x9031	Zaurus SL-C750 PDA
+product SHARP WZERO3ES		0x9123	W-ZERO3 ES Smartphone
+product SHARP WZERO3ADES	0x91ac	Advanced W-ZERO3 ES Smartphone
+product SHARP WILLCOM03		0x9242	WILLCOM03
+
+/* Shuttle Technology products */
+product SHUTTLE EUSB		0x0001	E-USB Bridge
+product SHUTTLE EUSCSI		0x0002	eUSCSI Bridge
+product SHUTTLE SDDR09		0x0003	ImageMate SDDR09
+product SHUTTLE EUSBCFSM	0x0005	eUSB SmartMedia / CompactFlash Adapter
+product SHUTTLE ZIOMMC		0x0006	eUSB MultiMediaCard Adapter
+product SHUTTLE HIFD		0x0007	Sony Hifd
+product SHUTTLE EUSBATAPI	0x0009	eUSB ATA/ATAPI Adapter
+product SHUTTLE CF		0x000a	eUSB CompactFlash Adapter
+product SHUTTLE EUSCSI_B	0x000b	eUSCSI Bridge
+product SHUTTLE EUSCSI_C	0x000c	eUSCSI Bridge
+product SHUTTLE CDRW		0x0101	CD-RW Device
+product SHUTTLE EUSBORCA	0x0325	eUSB ORCA Quad Reader
+
+/* Siemens products */
+product SIEMENS SPEEDSTREAM	0x1001	SpeedStream
+product SIEMENS SPEEDSTREAM22	0x1022	SpeedStream 1022
+product SIEMENS2 WLL013		0x001b	WLL013
+product SIEMENS2 ES75		0x0034  GSM module MC35
+product SIEMENS2 WL54G		0x3c06	54g USB Network Adapter
+product SIEMENS3 SX1		0x0001	SX1
+product SIEMENS3 X65		0x0003	X65
+product SIEMENS3 X75		0x0004	X75
+product SIEMENS3 EF81 		0x0005	EF81
+
+/* Sierra Wireless products */
+product SIERRA EM5625		0x0017	EM5625
+product SIERRA MC5720_2		0x0018	MC5720
+product SIERRA MC5725		0x0020	MC5725
+product SIERRA AIRCARD580	0x0112	Sierra Wireless AirCard 580
+product SIERRA AIRCARD595	0x0019	Sierra Wireless AirCard 595
+product SIERRA AC595U		0x0120	Sierra Wireless AirCard 595U
+product SIERRA AC597E		0x0021	Sierra Wireless AirCard 597E
+product SIERRA EM5725		0x0022	EM5725
+product SIERRA C597		0x0023	Sierra Wireless Compass 597
+product SIERRA MC5727		0x0024	MC5727
+product SIERRA T598		0x0025	T598
+product SIERRA T11		0x0026	T11
+product SIERRA AC402		0x0027	AC402
+product SIERRA MC5728		0x0028	MC5728
+product SIERRA E0029		0x0029	E0029
+product SIERRA AIRCARD580	0x0112	Sierra Wireless AirCard 580
+product SIERRA AC595U		0x0120	Sierra Wireless AirCard 595U
+product SIERRA MC5720		0x0218	MC5720 Wireless Modem
+product SIERRA MINI5725		0x0220	Sierra Wireless miniPCI 5275
+product SIERRA MC5727_2		0x0224	MC5727
+product SIERRA MC8755_2		0x6802	MC8755
+product SIERRA MC8765		0x6803	MC8765
+product SIERRA MC8755		0x6804	MC8755
+product SIERRA MC8765_2		0x6805	MC8765
+product SIERRA MC8755_4		0x6808	MC8755
+product SIERRA MC8765_3		0x6809	MC8765
+product SIERRA AC875U		0x6812	AC875U HSDPA USB Modem
+product SIERRA MC8755_3		0x6813	MC8755 HSDPA
+product SIERRA MC8775_2		0x6815	MC8775
+product SIERRA MC8775		0x6816	MC8775
+product SIERRA AC875		0x6820	Sierra Wireless AirCard 875
+product SIERRA AC875U_2		0x6821	AC875U
+product SIERRA AC875E		0x6822	AC875E
+product SIERRA MC8780		0x6832	MC8780
+product SIERRA MC8781		0x6833	MC8781
+product SIERRA MC8780_2		0x6834	MC8780
+product SIERRA MC8781_2		0x6835	MC8781
+product SIERRA MC8780_3		0x6838	MC8780
+product SIERRA MC8781_3		0x6839	MC8781
+product SIERRA MC8785		0x683A	MC8785
+product SIERRA MC8785_2		0x683B	MC8785
+product SIERRA MC8790		0x683C	MC8790
+product SIERRA MC8791		0x683D	MC8791
+product SIERRA MC8792		0x683E	MC8792
+product SIERRA AC880		0x6850	Sierra Wireless AirCard 880
+product SIERRA AC881		0x6851	Sierra Wireless AirCard 881
+product SIERRA AC880E		0x6852	Sierra Wireless AirCard 880E
+product SIERRA AC881E		0x6853	Sierra Wireless AirCard 881E
+product SIERRA AC880U		0x6855	Sierra Wireless AirCard 880U
+product SIERRA AC881U		0x6856	Sierra Wireless AirCard 881U
+product SIERRA AC885E		0x6859	AC885E
+product SIERRA AC885E_2		0x685A	AC885E
+product SIERRA AC885U		0x6880	Sierra Wireless AirCard 885U
+product SIERRA C888		0x6890	C888
+product SIERRA C22		0x6891	C22
+product SIERRA E6892		0x6892	E6892
+product SIERRA E6893		0x6893	E6893
+product SIERRA MC8700		0x68A3	MC8700
+product SIERRA MC7354		0x68C0	MC7354
+product SIERRA MC7355		0x9041	MC7355
+product SIERRA MC7430		0x9071	Sierra Wireless MC7430 Qualcomm Snapdragon X7 LTE-A
+product SIERRA AC313U		0x68aa	Sierra Wireless AirCard 313U
+product SIERRA TRUINSTALL	0x0fff	Aircard Tru Installer
+
+/* Sigmatel products */
+product SIGMATEL WBT_3052	0x4200	WBT-3052 IrDA/USB Bridge
+product SIGMATEL I_BEAD100	0x8008	i-Bead 100 MP3 Player
+
+/* SIIG products */
+/* Also: Omnidirectional Control Technology products */
+product SIIG DIGIFILMREADER	0x0004	DigiFilm-Combo Reader
+product SIIG WINTERREADER	0x0330	WINTERREADER Reader
+product SIIG2 DK201		0x0103	FTDI compatible adapter
+product SIIG2 USBTOETHER	0x0109	USB TO Ethernet
+product SIIG2 US2308		0x0421	Serial
+
+/* Silicom products */
+product SILICOM U2E		0x0001	U2E
+product SILICOM GPE		0x0002	Psion Gold Port Ethernet
+
+/* SI Labs */
+product SILABS	VSTABI		0x0f91	VStabi Controller
+product SILABS	ARKHAM_DS101_M	0x1101	Arkham DS101 Monitor
+product SILABS	ARKHAM_DS101_A	0x1601	Arkham DS101 Adapter
+product SILABS	BSM7DUSB	0x800a	SPORTident BSM7-D USB
+product SILABS	POLOLU		0x803b	Pololu Serial
+product SILABS	CYGNAL_DEBUG	0x8044	Cygnal Debug Adapter
+product SILABS	SB_PARAMOUNT_ME	0x8043	Software Bisque Paramount ME
+product SILABS	SAEL		0x8053	SA-EL USB
+product SILABS	GSM2228		0x8054	Enfora GSM2228 USB
+product SILABS	ARGUSISP	0x8066	Argussoft ISP
+product SILABS	IMS_USB_RS422	0x806f	IMS USB-RS422
+product SILABS	CRUMB128	0x807a	Crumb128 board
+product SILABS	OPTRIS_MSPRO	0x80c4	Optris MSpro LT Thermometer
+product SILABS	DEGREE		0x80ca	Degree Controls Inc
+product SILABS	TRACIENT	0x80dd	Tracient RFID
+product SILABS	TRAQMATE	0x80ed	Track Systems Traqmate
+product SILABS	SUUNTO		0x80f6	Suunto Sports Instrument
+product SILABS	ARYGON_MIFARE	0x8115	Arygon Mifare RFID reader
+product SILABS	BURNSIDE	0x813d	Burnside Telecon Deskmobile
+product SILABS	TAMSMASTER	0x813f	Tams Master Easy Control
+product SILABS	WMRBATT		0x814a	WMR RIGblaster Plug&Play
+product SILABS	WMRRIGBLASTER	0x814a	WMR RIGblaster Plug&Play
+product SILABS	WMRRIGTALK	0x814b	WMR RIGtalk RT1
+product SILABS	B_G_H3000	0x8156	B&G H3000 Data Cable
+product SILABS	HELICOM		0x815e	Helicomm IP-Link 1220-DVM
+product SILABS	HAMLINKUSB	0x815f	Timewave HamLinkUSB
+product SILABS	AVIT_USB_TTL	0x818b	AVIT Research USB-TTL
+product SILABS	MJS_TOSLINK	0x819f	MJS USB-TOSLINK
+product SILABS	WAVIT		0x81a6	ThinkOptics WavIt
+product SILABS	MULTIPLEX_RC	0x81a9	Multiplex RC adapter
+product SILABS	MSD_DASHHAWK	0x81ac	MSD DashHawk
+product SILABS	INSYS_MODEM	0x81ad	INSYS Modem
+product SILABS	LIPOWSKY_JTAG	0x81c8	Lipowsky Baby-JTAG
+product SILABS	LIPOWSKY_LIN	0x81e2	Lipowsky Baby-LIN
+product SILABS	AEROCOMM	0x81e7	Aerocomm Radio
+product SILABS	ZEPHYR_BIO	0x81e8	Zephyr Bioharness
+product SILABS	EMS_C1007	0x81f2	EMS C1007 HF RFID controller
+product SILABS	LIPOWSKY_HARP	0x8218	Lipowsky HARP-1
+product SILABS	C2_EDGE_MODEM	0x822b	Commander 2 EDGE(GSM) Modem
+product SILABS	CYGNAL_GPS	0x826b	Cygnal Fasttrax GPS
+product SILABS	TELEGESIS_ETRX2	0x8293	Telegesis ETRX2USB
+product SILABS	PROCYON_AVS	0x82f9	Procyon AVS
+product SILABS	MC35PU		0x8341	MC35pu
+product SILABS	CYGNAL		0x8382	Cygnal
+product SILABS	AMBER_AMB2560	0x83a8	Amber Wireless AMB2560
+product SILABS	DEKTEK_DTAPLUS	0x83d8	DekTec DTA Plus VHF/UHF Booster
+product SILABS	KYOCERA_GPS	0x8411	Kyocera GPS
+product SILABS	IRZ_SG10	0x8418	IRZ SG-10 GSM/GPRS Modem
+product SILABS	BEI_VCP		0x846e	BEI USB Sensor (VCP)
+product SILABS	BALLUFF_RFID	0x8477	Balluff RFID reader
+product SILABS	AC_SERV_IBUS	0x85ea	AC-Services IBUS Interface
+product SILABS	AC_SERV_CIS	0x85eb	AC-Services CIS-IBUS
+product SILABS	V_PREON32	0x85f8	Virtenio Preon32
+product SILABS	AC_SERV_CAN	0x8664	AC-Services CAN Interface
+product SILABS	AC_SERV_OBD	0x8665	AC-Services OBD Interface
+product SILABS	MMB_ZIGBEE	0x88a4	MMB Networks ZigBee
+product SILABS	INGENI_ZIGBEE	0x88a5	Planet Innovation Ingeni ZigBee
+product SILABS	HUBZ		0x8a2a	HubZ dual ZigBee and Z-Wave
+product SILABS	CP2102		0xea60	SILABS USB UART
+product SILABS	CP210X_2	0xea61	CP210x Serial
+product SILABS	CP210X_3	0xea70	CP210x Serial
+product SILABS	CP210X_4	0xea80	CP210x Serial
+product SILABS	INFINITY_MIC	0xea71	Infinity GPS-MIC-1 Radio Monophone
+product SILABS	USBSCOPE50	0xf001	USBscope50
+product SILABS	USBWAVE12	0xf002	USBwave12
+product SILABS	USBPULSE100	0xf003	USBpulse100
+product SILABS	USBCOUNT50	0xf004	USBcount50
+product SILABS2 DCU11CLONE	0xaa26	DCU-11 clone
+product SILABS3 GPRS_MODEM	0xea61	GPRS Modem
+product SILABS4 100EU_MODEM	0xea61	GPRS Modem 100EU
+
+/* Silicon Portals Inc. */
+product SILICONPORTALS YAPPH_NF	0x0200	YAP Phone (no firmware)
+product SILICONPORTALS YAPPHONE	0x0201	YAP Phone
+
+/* Sirius Technologies products */
+product SIRIUS ROADSTER		0x0001	NetComm Roadster II 56 USB
+
+/* Sitecom products */
+product SITECOM LN029		0x182d	USB 2.0 Ethernet
+product SITECOM SERIAL		0x2068	USB to serial cable (v2)
+product SITECOM2 WL022		0x182d	WL-022
+
+/* Sitecom Europe products */
+product SITECOMEU RT2870_1	0x0017	RT2870
+product SITECOMEU WL168V1	0x000d	WL-168 v1
+product SITECOMEU LN030  	0x0021	MCS7830
+product SITECOMEU WL168V4	0x0028	WL-168 v4
+product SITECOMEU RT2870_2	0x002b	RT2870
+product SITECOMEU RT2870_3	0x002c	RT2870
+product SITECOMEU RT2870_4	0x002d	RT2870
+product SITECOMEU RT2770	0x0039	RT2770
+product SITECOMEU RT3070_2	0x003b	RT3070
+product SITECOMEU RT3070_3	0x003c	RT3070
+product SITECOMEU RT3070_4	0x003d	RT3070
+product SITECOMEU RT3070	0x003e	RT3070
+product SITECOMEU WL608		0x003f	WL-608
+product SITECOMEU RT3071	0x0040	RT3071
+product SITECOMEU RT3072_1	0x0041	RT3072
+product SITECOMEU RT3072_2	0x0042	RT3072
+product SITECOMEU WL353		0x0045	WL-353
+product SITECOMEU RT3072_3	0x0047	RT3072
+product SITECOMEU RT3072_4	0x0048	RT3072
+product SITECOMEU RT3072_5	0x004a	RT3072
+product SITECOMEU WL349V1	0x004b	WL-349 v1
+product SITECOMEU RT3072_6	0x004d	RT3072
+product SITECOMEU WLA1000	0x005b	WLA-1000
+product SITECOMEU RTL8188CU_1	0x0052	RTL8188CU
+product SITECOMEU RTL8188CU_2	0x005c	RTL8188CU
+product SITECOMEU RTL8192CU	0x0061	RTL8192CU
+product SITECOMEU LN032		0x0072	LN-032
+product SITECOMEU WLA7100	0x0074	WLA-7100
+product SITECOMEU LN031  	0x0056	LN-031
+product SITECOMEU LN028		0x061c	LN-028
+product SITECOMEU WL113		0x9071	WL-113
+product SITECOMEU ZD1211B	0x9075	ZD1211B
+product SITECOMEU WL172		0x90ac	WL-172
+product SITECOMEU WL113R2	0x9712	WL-113 rev 2
+
+/* Skanhex Technology products */
+product SKANHEX MD_7425		0x410a	MD 7425 Camera
+product SKANHEX SX_520Z		0x5200	SX 520z Camera
+
+/* Smart Technologies products */
+product SMART PL2303		0x2303	Serial adapter
+
+/* SmartBridges products */
+product SMARTBRIDGES SMARTLINK	0x0001	SmartLink USB Ethernet
+product SMARTBRIDGES SMARTNIC	0x0003	smartNIC 2 PnP Ethernet
+
+/* SMC products */
+product SMC 2102USB		0x0100	10Mbps Ethernet
+product SMC 2202USB		0x0200	10/100 Ethernet
+product SMC 2206USB		0x0201	EZ Connect USB Ethernet
+product SMC 2862WG		0xee13	EZ Connect Wireless Adapter
+product SMC2 2020HUB		0x2020	USB Hub
+product SMC2 2514HUB		0x2514	USB Hub
+product SMC3 2662WUSB		0xa002	2662W-AR Wireless
+product SMC2 LAN7800_ETH	0x7800	USB/Ethernet
+product SMC2 LAN7801_ETH	0x7801	USB/Ethernet
+product SMC2 LAN7850_ETH	0x7850	USB/Ethernet
+product SMC2 LAN9500_ETH	0x9500	USB/Ethernet
+product SMC2 LAN9505_ETH	0x9505	USB/Ethernet
+product SMC2 LAN9530_ETH	0x9530	USB/Ethernet
+product SMC2 LAN9730_ETH	0x9730	USB/Ethernet
+product SMC2 LAN9500_SAL10	0x9900	USB/Ethernet
+product SMC2 LAN9505_SAL10	0x9901	USB/Ethernet
+product SMC2 LAN9500A_SAL10	0x9902	USB/Ethernet
+product SMC2 LAN9505A_SAL10	0x9903	USB/Ethernet
+product SMC2 LAN9514_SAL10	0x9904	USB/Ethernet
+product SMC2 LAN9500A_HAL	0x9905	USB/Ethernet
+product SMC2 LAN9505A_HAL	0x9906	USB/Ethernet
+product SMC2 LAN9500_ETH_2	0x9907	USB/Ethernet
+product SMC2 LAN9500A_ETH_2	0x9908	USB/Ethernet
+product SMC2 LAN9514_ETH_2	0x9909	USB/Ethernet
+product SMC2 LAN9500A_ETH	0x9e00	USB/Ethernet
+product SMC2 LAN9505A_ETH	0x9e01	USB/Ethernet
+product SMC2 LAN89530_ETH	0x9e08	USB/Ethernet
+product SMC2 LAN9514_ETH	0xec00	USB/Ethernet
+
+/* SOHOware products */
+product SOHOWARE NUB100		0x9100	10/100 USB Ethernet
+product SOHOWARE NUB110		0x9110	10/100 USB Ethernet
+
+/* SOLID YEAR products */
+product SOLIDYEAR KEYBOARD	0x2101	Solid Year USB keyboard
+
+/* SONY products */
+product SONY DSC		0x0010	DSC cameras
+product SONY MS_NW_MS7		0x0025	Memorystick NW-MS7
+product SONY PORTABLE_HDD_V2	0x002b	Portable USB Harddrive V2
+product SONY MSACUS1		0x002d	Memorystick MSAC-US1
+product SONY HANDYCAM		0x002e	Handycam
+product SONY MSC		0x0032	MSC memory stick slot
+product SONY CLIE_35		0x0038	Sony Clie v3.5
+product SONY MS_PEG_N760C	0x0058	PEG N760c Memorystick
+product SONY CLIE_40		0x0066	Sony Clie v4.0
+product SONY MS_MSC_U03		0x0069	Memorystick MSC-U03
+product SONY CLIE_40_MS		0x006d	Sony Clie v4.0 Memory Stick slot
+product SONY CLIE_S360		0x0095	Sony Clie s360
+product SONY CLIE_41_MS		0x0099	Sony Clie v4.1 Memory Stick slot
+product SONY CLIE_41		0x009a	Sony Clie v4.1
+product SONY CLIE_NX60		0x00da	Sony Clie nx60
+product SONY CLIE_TH55		0x0144	Sony Clie th55
+product SONY CLIE_TJ37		0x0169	Sony Clie tj37
+product SONY RF_RECEIVER	0x01db	Sony RF mouse/kbd Receiver VGP-WRC1
+product SONY QN3		0x0437	Sony QN3 CMD-Jxx phone cable
+
+/* Sony Ericsson products */
+product SONYERICSSON DCU10	0x0528	DCU-10 Phone Data Cable
+product SONYERICSSON DATAPILOT	0x2003	Datapilot Phone Cable
+
+/* SOURCENEXT products */
+product SOURCENEXT KEIKAI8	0x039f	KeikaiDenwa 8
+product SOURCENEXT KEIKAI8_CHG	0x012e	KeikaiDenwa 8 with charger
+
+/* SparkLAN products */
+product SPARKLAN RT2573		0x0004	RT2573
+product SPARKLAN RT2870_1	0x0006	RT2870
+product SPARKLAN RT3070		0x0010	RT3070
+
+/* Soundgraph products */
+product SOUNDGRAPH IMON_VFD	0x0044	Antec Veris Elite VFD Panel, Knob, and Remote
+product SOUNDGRAPH SSTONE_LC16	0xffdc	Silverstone LC16 VFD Panel, Knob, and Remote
+
+/* Speed Dragon Multimedia products */
+product SPEEDDRAGON MS3303H	0x110b	MS3303H Serial
+
+/* Sphairon Access Systems GmbH products */
+product SPHAIRON UB801R		0x0110	UB801R
+
+/* Stelera Wireless products */
+product STELERA ZEROCD		0x1000	Zerocd Installer
+product STELERA C105		0x1002	Stelera/Bandrish C105 USB
+product STELERA E1003		0x1003	3G modem
+product STELERA E1004		0x1004	3G modem
+product STELERA E1005		0x1005	3G modem
+product STELERA E1006		0x1006	3G modem
+product STELERA E1007		0x1007	3G modem
+product STELERA E1008		0x1008	3G modem
+product STELERA E1009		0x1009	3G modem
+product STELERA E100A		0x100a	3G modem
+product STELERA E100B		0x100b	3G modem
+product STELERA E100C		0x100c	3G modem
+product STELERA E100D		0x100d	3G modem
+product STELERA E100E		0x100e	3G modem
+product STELERA E100F		0x100f	3G modem
+product STELERA E1010		0x1010	3G modem
+product STELERA E1011		0x1011	3G modem
+product STELERA E1012		0x1012	3G modem
+
+/* STMicroelectronics products */
+product STMICRO BIOCPU		0x2016	Biometric Coprocessor
+product STMICRO COMMUNICATOR	0x7554	USB Communicator
+product STMICRO ST72682		0xfada  USB 2.0 Flash drive controller
+
+/* STSN products */
+product STSN STSN0001		0x0001	Internet Access Device
+
+/* SUN Corporation products */
+product SUNTAC DS96L		0x0003	SUNTAC U-Cable type D2
+product SUNTAC PS64P1		0x0005	SUNTAC U-Cable type P1
+product SUNTAC VS10U		0x0009	SUNTAC Slipper U
+product SUNTAC IS96U		0x000a	SUNTAC Ir-Trinity
+product SUNTAC AS64LX		0x000b	SUNTAC U-Cable type A3
+product SUNTAC AS144L4		0x0011	SUNTAC U-Cable type A4
+
+/* Sun Microsystems products */
+product SUN KEYBOARD_TYPE_6	0x0005	Type 6 USB keyboard
+product SUN KEYBOARD_TYPE_7	0x00a2	Type 7 USB keyboard
+/* XXX The above is a North American PC style keyboard possibly */
+product SUN MOUSE		0x0100	Type 6 USB mouse
+product SUN KBD_HUB		0x100e	Kbd Hub
+
+/* Sunplus Innovation Technology Inc. products */
+product SUNPLUS USBMOUSE	0x0007	USB Optical Mouse
+
+/* Super Top products */
+product	SUPERTOP IDE		0x6600	USB-IDE
+product	SUPERTOP FLASHDRIVE	0x121c	extrememory Snippy
+
+/* Syntech products */
+product SYNTECH CPT8001C	0x0001	CPT-8001C Barcode scanner
+product	SYNTECH CYPHERLAB100	0x1000	CipherLab USB Barcode Scanner
+
+/* Teclast products */
+product TECLAST TLC300		0x3203	USB Media Player
+
+/* Testo products */
+product TESTO USB_INTERFACE	0x0001	FTDI compatible adapter
+
+/* TexTech products */
+product TEXTECH DUMMY		0x0000	Dummy product
+product TEXTECH U2M_1		0x0101	Textech USB MIDI cable
+product TEXTECH U2M_2		0x1806	Textech USB MIDI cable
+
+/* The Mobility Lab products */
+product TML USB_SERIAL		0x0064	FTDI compatible adapter
+
+/* Thurlby Thandar Instrument products */
+product TTI QL355P		0x03e8	FTDI compatible adapter
+
+/* Supra products */
+product DIAMOND2 SUPRAEXPRESS56K 0x07da	Supra Express 56K modem
+product DIAMOND2 SUPRA2890	0x0b4a	SupraMax 2890 56K Modem
+product DIAMOND2 RIO600USB	0x5001	Rio 600 USB
+product DIAMOND2 RIO800USB	0x5002	Rio 800 USB
+
+/* Surecom Technology products */
+product SURECOM EP9001G2A	0x11f2	EP-9001-G rev 2A
+product SURECOM RT2570		0x11f3	RT2570
+product SURECOM RT2573		0x31f3	RT2573
+
+/* Sweex products */
+product SWEEX ZD1211		0x1809	ZD1211
+product SWEEX2 LW153		0x0153	LW153
+product SWEEX2 LW154		0x0154	LW154
+product SWEEX2 LW303		0x0302	LW303
+product SWEEX2 LW313		0x0313	LW313
+
+/* System TALKS, Inc. */
+product SYSTEMTALKS SGCX2UL	0x1920	SGC-X2UL
+
+/* Tapwave products */
+product TAPWAVE ZODIAC		0x0100	Zodiac
+
+/* Taugagreining products */
+product TAUGA CAMERAMATE	0x0005	CameraMate (DPCM_USB)
+
+/* TCTMobile products */
+product TCTMOBILE X060S		0x0000	X060S 3G modem
+product TCTMOBILE X080S		0xf000	X080S 3G modem
+
+/* TDK products */
+product TDK UPA9664		0x0115	USB-PDC Adapter UPA9664
+product TDK UCA1464		0x0116	USB-cdmaOne Adapter UCA1464
+product TDK UHA6400		0x0117	USB-PHS Adapter UHA6400
+product TDK UPA6400		0x0118	USB-PHS Adapter UPA6400
+product TDK BT_DONGLE		0x0309	Bluetooth USB dongle
+
+/* TEAC products */
+product TEAC FD05PUB		0x0000	FD-05PUB floppy
+
+/* Tekram Technology products */
+product TEKRAM QUICKWLAN	0x1630	QuickWLAN
+product TEKRAM ZD1211_1		0x5630	ZD1211
+product TEKRAM ZD1211_2		0x6630	ZD1211
+
+/* Telex Communications products */
+product TELEX MIC1		0x0001	Enhanced USB Microphone
+
+/* Telit products */
+product TELIT UC864E		0x1003	UC864E 3G modem
+product TELIT UC864G		0x1004	UC864G 3G modem
+
+/* Ten X Technology, Inc. */
+product TENX UAUDIO0		0xf211	USB audio headset
+
+/* ThingM products */
+product THINGM BLINK1		0x01ed	USB notification light
+
+/* Texas Intel products */
+product TI UTUSB41		0x1446	UT-USB41 hub
+product TI TUSB2046		0x2046	TUSB2046 hub
+product TI USB3410		0x3410	TI USB 3410 Modem
+product TI USB5052		0x5052	TI USB 5250 Modem
+product TI FRI2			0x5053	TI Fish River Island II
+product TI USB5052_EEPROM	0x505a	TI USB 5250 Modem w/Eeprom
+product TI USB5052_FW		0x505f	TI USB 5250 Modme w/Firmware running
+product TI USB5152		0x5152	TI USB 5152 Modem
+product TI EZ430		0xf430	TI ex430 development tool
+
+/* Thrustmaster products */
+product THRUST FUSION_PAD	0xa0a3	Fusion Digital Gamepad
+
+/* TLayTech products */
+product TLAYTECH TEU800		0x1682	TEU800 3G modem
+
+/* Topre Corporation products */
+product TOPRE HHKB		0x0100	HHKB Professional
+
+/* Toshiba Corporation products */
+product TOSHIBA POCKETPC_E740	0x0706	PocketPC e740
+product TOSHIBA RT3070		0x0a07	RT3070
+product TOSHIBA G450		0x0d45	G450 modem
+product TOSHIBA HSDPA		0x1302	G450 modem
+product TOSHIBA TRANSMEMORY	0x6545	USB ThumbDrive
+
+/* TP-Link products */
+product TPLINK T4U		0x0101	Archer T4U
+product TPLINK WN821NV5		0x0107	TL-WN821N v5
+product TPLINK WN822NV4		0x0108	TL-WN822N v4
+product TPLINK WN823NV2		0x0109	TL-WN823N v2
+product TPLINK WN722NV2		0x010c	TL-WN722N v2
+product TPLINK T4UV2		0x010d	Archer T4U ver 2
+product TPLINK T4UHV1		0x0103	Archer T4UH ver 1
+product TPLINK T4UHV2		0x010e	Archer T4UH ver 2
+product TPLINK RTL8153		0x0601	RTL8153 USB 10/100/1000 LAN
+
+/* Trek Technology products */
+product TREK THUMBDRIVE		0x1111	ThumbDrive
+product TREK MEMKEY		0x8888	IBM USB Memory Key
+product TREK THUMBDRIVE_8MB	0x9988	ThumbDrive_8MB
+
+/* TRENDnet products */
+product TRENDNET RTL8192CU	0x624d	RTL8192CU
+product TRENDNET TEW646UBH	0x646b	TEW-646UBH
+product TRENDNET RTL8188CU	0x648b	RTL8188CU
+product TRENDNET TEW805UB	0x805b	TEW-805UB
+
+/* Tripp-Lite products */
+product TRIPPLITE U209		0x2008	Serial
+
+/* Trumpion products */
+product TRUMPION T33520		0x1001	T33520 USB Flash Card Controller
+product TRUMPION C3310		0x1100	Comotron C3310 MP3 player
+product TRUMPION MP3		0x1200	MP3 player
+
+/* TwinMOS */
+product TWINMOS G240		0xa006	G240
+product TWINMOS MDIV		0x1325	Memory Disk IV
+
+/* Ubiquam products */
+product UBIQUAM UALL		0x3100	CDMA 1xRTT USB Modem (U-100/105/200/300/520)
+
+/* Ultima products */
+product ULTIMA 1200UBPLUS	0x4002	1200 UB Plus scanner
+
+/* UMAX products */
+product UMAX ASTRA1236U		0x0002	Astra 1236U Scanner
+product UMAX ASTRA1220U		0x0010	Astra 1220U Scanner
+product UMAX ASTRA2000U		0x0030	Astra 2000U Scanner
+product UMAX ASTRA2100U		0x0130	Astra 2100U Scanner
+product UMAX ASTRA2200U		0x0230	Astra 2200U Scanner
+product UMAX ASTRA3400		0x0060	Astra 3400 Scanner
+
+/* U-MEDIA Communications products */
+product UMEDIA TEW444UBEU	0x3006	TEW-444UB EU
+product UMEDIA TEW444UBEU_NF	0x3007	TEW-444UB EU (no firmware)
+product UMEDIA TEW429UB_A	0x300a	TEW-429UB_A
+product UMEDIA TEW429UB		0x300b	TEW-429UB
+product UMEDIA TEW429UBC1	0x300d	TEW-429UB C1
+product UMEDIA RT2870_1		0x300e	RT2870
+product UMEDIA ALL0298V2	0x3204	ALL0298 v2
+product UMEDIA AR5523_2		0x3205	AR5523
+product UMEDIA AR5523_2_NF	0x3206	AR5523 (no firmware)
+
+/* Universal Access products */
+product UNIACCESS PANACHE	0x0101	Panache Surf USB ISDN Adapter
+
+/* Unknown products */
+product UNKNOWN4 NF_RIC		0x0001	FTDI compatible adapter
+
+/* USI products */
+product USI MC60		0x10c5	MC60 Serial
+
+/* U.S. Robotics products */
+product USR USR5422		0x0118	USR5422 WLAN
+product USR USR5423		0x0121	USR5423 WLAN
+
+/* VIA Technologies products */
+product VIA USB2IDEBRIDGE	0x6204	USB 2.0 IDE Bridge
+
+/* VIA Labs */
+product VIALABS USB30SATABRIDGE	0x0700	USB 3.0 SATA Bridge
+
+/* Vaisala products */
+product VAISALA CABLE		0x0200	USB Interface cable
+
+/* Vertex products */
+product VERTEX VW110L		0x0100	Vertex VW110L modem
+
+/* VidzMedia products */
+product VIDZMEDIA MONSTERTV	0x4fb1	MonsterTV P2H
+
+/* Vision products */
+product VISION VC6452V002	0x0002	CPiA Camera
+
+/* Visioneer products */
+product VISIONEER 7600		0x0211	OneTouch 7600
+product VISIONEER 5300		0x0221	OneTouch 5300
+product VISIONEER 3000		0x0224	Scanport 3000
+product VISIONEER 6100		0x0231	OneTouch 6100
+product VISIONEER 6200		0x0311	OneTouch 6200
+product VISIONEER 8100		0x0321	OneTouch 8100
+product VISIONEER 8600		0x0331	OneTouch 8600
+
+/* Vivitar products */
+product VIVITAR 35XX		0x0003	Vivicam 35Xx
+
+/* VTech products */
+product VTECH RT2570		0x3012	RT2570
+product VTECH ZD1211B		0x3014	ZD1211B
+
+/* Wacom products */
+product WACOM CT0405U		0x0000	CT-0405-U Tablet
+product WACOM GRAPHIRE		0x0010	Graphire
+product WACOM GRAPHIRE3_4X5	0x0013	Graphire 3 4x5
+product WACOM INTUOSA5		0x0021	Intuos A5
+product WACOM GD0912U		0x0022	Intuos 9x12 Graphics Tablet
+
+/* WAGO Kontakttechnik GmbH products */
+product WAGO SERVICECABLE	0x07a6	USB Service Cable 750-923
+
+/* WaveSense products */
+product WAVESENSE JAZZ		0xaaaa	Jazz blood glucose meter
+
+/* WCH products */
+product WCH CH341SER		0x5523	CH341/CH340 USB-Serial Bridge
+product WCH2 DUMMY		0x0000	Dummy product
+product WCH2 CH341SER_2		0x5523	CH341/CH340 USB-Serial Bridge
+product WCH2 CH341SER		0x7523	CH341/CH340 USB-Serial Bridge
+product WCH2 U2M		0X752d	CH345 USB2.0-MIDI
+
+/* West Mountain Radio products */
+product WESTMOUNTAIN RIGBLASTER_ADVANTAGE	0x0003	RIGblaster Advantage
+
+/* Western Digital products */
+product WESTERN COMBO		0x0200	Firewire USB Combo
+product WESTERN EXTHDD		0x0400	External HDD
+product WESTERN HUB		0x0500	USB HUB
+product WESTERN MYBOOK		0x0901	MyBook External HDD
+product WESTERN MYPASSPORT_00	0x0704	MyPassport External HDD
+product WESTERN MYPASSPORT_11	0x0741	MyPassport External HDD
+product WESTERN MYPASSPORT_01	0x0746	MyPassport External HDD
+product WESTERN MYPASSPORT_02	0x0748	MyPassport External HDD
+product WESTERN MYPASSPORT_03	0x074A	MyPassport External HDD
+product WESTERN MYPASSPORT_04	0x074C	MyPassport External HDD
+product WESTERN MYPASSPORT_05	0x074E	MyPassport External HDD
+product WESTERN MYPASSPORT_06	0x07A6	MyPassport External HDD
+product WESTERN MYPASSPORT_07	0x07A8	MyPassport External HDD
+product WESTERN MYPASSPORT_08	0x07AA	MyPassport External HDD
+product WESTERN MYPASSPORT_09	0x07AC	MyPassport External HDD
+product WESTERN MYPASSPORT_10	0x07AE	MyPassport External HDD
+product WESTERN MYPASSPORTES_00	0x070A	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_01	0x071A	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_02	0x0730	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_03	0x0732	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_04	0x0740	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_05	0x0742	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_06	0x0750	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_07	0x0752	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_08	0x07A0	MyPassport Essential External HDD
+product WESTERN MYPASSPORTES_09	0x07A2	MyPassport Essential External HDD
+
+/* WeTelecom products */
+product WETELECOM WM_D200	0x6801	WM-D200
+
+/* WIENER Plein & Baus GmbH products */
+product WIENERPLEINBAUS PL512	0x0010	PL512 PSU
+product WIENERPLEINBAUS RCM	0x0011	RCM Remote Control
+product WIENERPLEINBAUS MPOD	0x0012	MPOD PSU
+product WIENERPLEINBAUS CML	0x0015	CML Data Logger
+
+/* Windbond Electronics */
+product WINBOND UH104		0x5518	4-port USB Hub
+
+/* WinMaxGroup products */
+product WINMAXGROUP FLASH64MC	0x6660	USB Flash Disk 64M-C
+
+/* Wistron NeWeb products */
+product WISTRONNEWEB WNC0600	0x0326	WNC-0600USB
+product WISTRONNEWEB UR045G	0x0427	PrismGT USB 2.0 WLAN
+product WISTRONNEWEB UR055G	0x0711	UR055G
+product WISTRONNEWEB O8494	0x0804	ORiNOCO 802.11n
+product WISTRONNEWEB AR5523_1	0x0826	AR5523
+product WISTRONNEWEB AR5523_1_NF	0x0827	AR5523 (no firmware)
+product WISTRONNEWEB AR5523_2	0x082a	AR5523
+product WISTRONNEWEB AR5523_2_NF	0x0829	AR5523 (no firmware)
+
+/* Xerox products */
+product XEROX WCM15		0xffef	WorkCenter M15
+
+/* Xirlink products */
+product XIRLINK PCCAM		0x8080	IBM PC Camera
+
+/* Xyratex products */
+product XYRATEX PRISM_GT_1	0x2000	PrismGT USB 2.0 WLAN
+product XYRATEX PRISM_GT_2	0x2002	PrismGT USB 2.0 WLAN
+
+/* Yamaha products */
+product YAMAHA UX256		0x1000	UX256 MIDI I/F
+product YAMAHA MU1000		0x1001	MU1000 MIDI Synth.
+product YAMAHA MU2000		0x1002	MU2000 MIDI Synth.
+product YAMAHA MU500		0x1003	MU500 MIDI Synth.
+product YAMAHA UW500		0x1004	UW500 USB Audio I/F
+product YAMAHA MOTIF6		0x1005	MOTIF6 MIDI Synth. Workstation
+product YAMAHA MOTIF7		0x1006	MOTIF7 MIDI Synth. Workstation
+product YAMAHA MOTIF8		0x1007	MOTIF8 MIDI Synth. Workstation
+product YAMAHA UX96		0x1008	UX96 MIDI I/F
+product YAMAHA UX16		0x1009	UX16 MIDI I/F
+product YAMAHA S08		0x100e	S08 MIDI Keyboard
+product YAMAHA CLP150		0x100f	CLP-150 digital piano
+product YAMAHA CLP170		0x1010	CLP-170 digital piano
+product YAMAHA RPU200		0x3104	RP-U200
+product YAMAHA RTA54I		0x4000	NetVolante RTA54i Broadband&ISDN Router
+product YAMAHA RTW65B		0x4001	NetVolante RTW65b Broadband Wireless Router
+product YAMAHA RTW65I		0x4002	NetVolante RTW65i Broadband&ISDN Wireless Router
+product YAMAHA RTA55I		0x4004	NetVolante RTA55i Broadband VoIP Router
+
+/* Yano products */
+product YANO U640MO		0x0101	U640MO-03
+product YANO FW800HD		0x05fc	METALWEAR-HDD
+
+/* Y.C. Cable products */
+product YCCABLE PL2303		0x0fba	PL2303 Serial
+
+/* Y-E Data products */
+product YEDATA FLASHBUSTERU	0x0000	Flashbuster-U
+
+/* Yiso Wireless Co. products */
+product	YISO C893		0xc893	CDMA 2000 1xEVDO PC Card
+
+/* Z-Com products */
+product ZCOM M4Y750		0x0001	M4Y-750
+product ZCOM XI725		0x0002	XI-725/726
+product ZCOM XI735		0x0005	XI-735
+product ZCOM XG703A		0x0008	PrismGT USB 2.0 WLAN
+product ZCOM ZD1211		0x0011	ZD1211
+product ZCOM AR5523		0x0012	AR5523
+product ZCOM AR5523_NF		0x0013	AR5523 driver (no firmware)
+product ZCOM XM142		0x0015	XM-142
+product ZCOM ZD1211B		0x001a	ZD1211B
+product ZCOM RT2870_1		0x0022	RT2870
+product ZCOM UB81		0x0023	UB81
+product ZCOM RT2870_2		0x0025	RT2870
+product ZCOM UB82		0x0026	UB82
+
+/* Zeevo, Inc. products */
+product ZEEVO BLUETOOTH		0x07d0	BT-500 Bluetooth USB Adapter
+
+/* Zinwell products */
+product ZINWELL RT2570		0x0260	RT2570
+product ZINWELL RT2870_1	0x0280	RT2870
+product ZINWELL RT2870_2	0x0282	RT2870
+product ZINWELL RT3072_1	0x0283	RT3072
+product ZINWELL RT3072_2	0x0284	RT3072
+product ZINWELL RT3070		0x5257	RT3070
+
+/* Zoom Telephonics, Inc. products */
+product ZOOM 2986L		0x9700	2986L Fax modem
+product ZOOM 3095		0x3095	3095 USB Fax modem
+
+/* Zoran Microelectronics products */
+product ZORAN EX20DSC		0x4343	Digital Camera EX-20 DSC
+
+/* ZTE products */
+product ZTE MF622		0x0001	MF622 modem
+product ZTE MF628		0x0015	MF628 modem
+product ZTE MF626		0x0031	MF626 modem
+product ZTE MF820D_INSTALLER	0x0166	MF820D CD
+product ZTE MF820D		0x0167	MF820D modem
+product ZTE INSTALLER		0x2000	UMTS CD
+product ZTE MC2718		0xffe8	MC2718 modem
+product ZTE AC8700		0xfffe	CDMA 1xEVDO USB modem
+
+/* Zydas Technology Corporation products */
+product ZYDAS ZD1201		0x1201	ZD1201
+product ZYDAS ZD1211		0x1211	ZD1211 WLAN abg
+product ZYDAS ZD1211B		0x1215	ZD1211B
+product ZYDAS ZD1221		0x1221	ZD1221
+product ZYDAS ALL0298		0xa211	ALL0298
+product ZYDAS ZD1211B_2		0xb215	ZD1211B
+
+/* ZyXEL Communication Co. products */
+product ZYXEL OMNI56K		0x1500	Omni 56K Plus
+product ZYXEL 980N		0x2011	Scorpion-980N keyboard
+product ZYXEL ZYAIRG220		0x3401	ZyAIR G-220
+product ZYXEL G200V2		0x3407	G-200 v2
+product ZYXEL AG225H		0x3409	AG-225H
+product ZYXEL M202		0x340a	M-202
+product ZYXEL G270S		0x340c	G-270S
+product ZYXEL G220V2		0x340f	G-220 v2
+product ZYXEL G202		0x3410	G-202
+product ZYXEL RT2573		0x3415	RT2573
+product ZYXEL RT2870_1		0x3416	RT2870
+product ZYXEL NWD271N		0x3417	NWD-271N
+product ZYXEL NWD211AN		0x3418	NWD-211AN
+product ZYXEL RT2870_2		0x341a	RT2870
+product ZYXEL RT3070		0x341e	NWD2105
+product ZYXEL RTL8192CU		0x341f	RTL8192CU
+product ZYXEL NWD2705		0x3421	NWD2705
+product ZYXEL NWD6605		0x3426	ND6605
+product ZYXEL PRESTIGE		0x401a	Prestige
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/_bus.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/_bus.h
new file mode 100644
index 0000000000..131711b8dd
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/_bus.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2009, Colin Gnther. All Rights Reserved.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE__BUS_H_
+#define _FBSD_COMPAT_MACHINE__BUS_H_
+
+
+#include <SupportDefs.h>
+
+
+typedef phys_addr_t bus_addr_t;
+
+
+#ifdef B_HAIKU_64_BIT
+
+typedef uint64_t bus_size_t;
+
+typedef uint64_t bus_space_tag_t;
+typedef uint64_t bus_space_handle_t;
+
+#else
+
+#if defined(__HAIKU_ARCH_PHYSICAL_64_BIT) && defined(__i386__)
+#define PAE 1
+#endif
+
+typedef uint32_t bus_size_t;
+
+typedef int bus_space_tag_t;
+typedef unsigned int bus_space_handle_t;
+
+#endif
+
+
+#endif /* _FBSD_COMPAT_MACHINE__BUS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/atomic.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/atomic.h
new file mode 100644
index 0000000000..41cb7c5b6c
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/atomic.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_ATOMIC_H_
+#define _FBSD_COMPAT_MACHINE_ATOMIC_H_
+
+
+#include <KernelExport.h>
+
+
+#define atomic_add_int(ptr, value) \
+	atomic_add((int32 *)(ptr), value)
+
+#define atomic_subtract_int(ptr, value) \
+	atomic_add((int32 *)(ptr), -value)
+
+#define atomic_load_int(ptr) \
+	atomic_get((int32 *)ptr)
+
+#define atomic_set_acq_32(ptr, value) \
+	atomic_set_int(ptr, value)
+
+#define atomic_set_int(ptr, value) \
+	atomic_or((int32 *)(ptr), value)
+
+#define atomic_readandclear_int(ptr) \
+	atomic_set((int32 *)(ptr), 0)
+
+#define atomic_cmpset_int(ptr, old, new) \
+	(atomic_test_and_set((int32 *)(ptr), new, old) == (int32)old)
+
+#define atomic_add_32			atomic_add_int
+#define atomic_subtract_32		atomic_subtract_int
+#define atomic_load_acq_32		atomic_load_int
+#define atomic_store_rel_int	atomic_set_acq_32
+#define atomic_cmpset_acq_int	atomic_cmpset_int
+
+#define	atomic_load_32(ptr)		(*(volatile uint32 *)(ptr))
+#define atomic_set_32(ptr, val)	atomic_set((int32 *)ptr, val)
+#define atomic_fetchadd_32(ptr, val)	atomic_add((int32 *)ptr, val)
+
+#define mb()    memory_full_barrier()
+#define wmb()   memory_write_barrier_inline()
+#define rmb()   memory_read_barrier()
+
+#endif	/* _FBSD_COMPAT_MACHINE_ATOMIC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus.h
new file mode 100644
index 0000000000..5ca2558077
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2009, Colin Gnther. All rights reserved.
+ * Copyright 2007, Hugo Santos. All rights reserved.
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT license.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_BUS_H_
+#define _FBSD_COMPAT_MACHINE_BUS_H_
+
+#include <machine/_bus.h>
+#include <machine/cpufunc.h>
+
+#if defined(__i386__) || defined(__amd64__)
+#  include <machine/x86/bus.h>
+#elif defined(__riscv)
+#  include <machine/riscv64/bus.h>
+#else
+#  error Need a bus.h for this arch!
+#endif
+
+#endif /* _FBSD_COMPAT_MACHINE_BUS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus_dma.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus_dma.h
new file mode 100644
index 0000000000..8520e43496
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/bus_dma.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de
+ * All Rights Reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_BUS_DMA_H_
+#define _FBSD_COMPAT_MACHINE_BUS_DMA_H_
+
+
+#include <sys/bus_dma.h>
+
+#endif /* _FBSD_COMPAT_MACHINE_BUS_DMA_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/clock.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/clock.h
new file mode 100644
index 0000000000..e458d01a13
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/clock.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_CLOCK_H_
+#define _FBSD_COMPAT_SYS_CLOCK_H_
+
+
+#endif /* _FBSD_COMPAT_SYS_CLOCK_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpu.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpu.h
new file mode 100644
index 0000000000..2177b5a07f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpu.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT license.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_CPU_H_
+#define _FBSD_COMPAT_MACHINE_CPU_H_
+
+#ifndef __riscv
+#include <arch_cpu_defs.h>
+#endif
+
+
+#define cpu_spinwait()		SPINLOCK_PAUSE()
+
+
+#endif /* _FBSD_COMPAT_MACHINE_CPU_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpufunc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpufunc.h
new file mode 100644
index 0000000000..8535a451fc
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/cpufunc.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2009, Colin Gnther. All rights reserved.
+ * Copyright 2007, Hugo Santos. All rights reserved.
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT license.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_CPUFUNC_H_
+#define _FBSD_COMPAT_MACHINE_CPUFUNC_H_
+
+#include <sys/cdefs.h>
+
+#if defined(__i386__)
+#  include <machine/x86/cpufunc.h>
+#elif defined(__x86_64__)
+#  include <machine/x86_64/cpufunc.h>
+#elif defined(__riscv)
+#  include <machine/riscv64/cpufunc.h>
+#else
+#  error Need a cpufunc.h for this arch!
+#endif
+
+#endif /* _FBSD_COMPAT_MACHINE_CPUFUNC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/endian.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/endian.h
new file mode 100644
index 0000000000..52861ac4bd
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/endian.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_ENDIAN_H_
+#define _FBSD_COMPAT_MACHINE_ENDIAN_H_
+
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/in_cksum.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/in_cksum.h
new file mode 100644
index 0000000000..f174d3021e
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/in_cksum.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2007, Axel Drfler, axeld@pinc-software.de. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_IN_CKSUM_H_
+#define _FBSD_COMPAT_MACHINE_IN_CKSUM_H_
+
+
+#include <stdint.h>
+
+
+#define in_cksum(m, len)	in_cksum_skip(m, len, 0)
+
+
+static inline u_short
+in_pseudo(u_int sum, u_int b, u_int c)
+{
+	// should never be called
+	panic("in_pseudo() called");
+	return 0;
+}
+
+
+static inline u_short
+in_cksum_skip(struct mbuf* m, int len, int skip)
+{
+	// should never be called
+	panic("in_cksum_skip() called");
+	return 0;
+}
+
+#endif	/* _FBSD_COMPAT_MACHINE_IN_CKSUM_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/md_var.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/md_var.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/ofw_machdep.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/ofw_machdep.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/resource.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/resource.h
new file mode 100644
index 0000000000..f9d9d43b4e
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/resource.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_RESOURCE_H_
+#define _FBSD_COMPAT_MACHINE_RESOURCE_H_
+
+
+#define SYS_RES_IRQ		0x1
+#define SYS_RES_DRQ		0x2
+#define SYS_RES_MEMORY	0x3
+#define SYS_RES_IOPORT	0x4
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/bus.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/bus.h
new file mode 100644
index 0000000000..907eb8a519
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/bus.h
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2021, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ */
+
+#ifndef _RISCV_BUS_H_
+#define _RISCV_BUS_H_
+
+#include <machine/_bus.h>
+#include <machine/cpufunc.h>
+#include <machine/bus_dma.h>
+
+#warning "riscv64/bus.h included"
+
+/*
+ * Values for the x86 bus space tag, not to be used directly by MI code.
+ */
+#define	X86_BUS_SPACE_IO	0	/* space is i/o space */
+#define	X86_BUS_SPACE_MEM	1	/* space is mem space */
+
+#define BUS_SPACE_MAXSIZE_24BIT	0xFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT 0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE	0xFFFFFFFF
+#define BUS_SPACE_MAXADDR_24BIT	0xFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT 0xFFFFFFFF
+#define BUS_SPACE_MAXADDR	0xFFFFFFFFFFFFFFFFULL
+
+#define BUS_SPACE_INVALID_DATA	(~0)
+#define BUS_SPACE_UNRESTRICTED	(~0)
+
+
+static __inline u_int8_t bus_space_read_1(bus_space_tag_t tag,
+					  bus_space_handle_t handle,
+					  bus_size_t offset);
+
+static __inline u_int16_t bus_space_read_2(bus_space_tag_t tag,
+					   bus_space_handle_t handle,
+					   bus_size_t offset);
+
+static __inline u_int32_t bus_space_read_4(bus_space_tag_t tag,
+					   bus_space_handle_t handle,
+					   bus_size_t offset);
+
+static __inline uint64_t bus_space_read_8(bus_space_tag_t tag,
+					  bus_space_handle_t handle,
+					  bus_size_t offset);
+
+static __inline void bus_space_write_1(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, u_int8_t value);
+
+static __inline void bus_space_write_2(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, u_int16_t value);
+
+static __inline void bus_space_write_4(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, u_int32_t value);
+
+static __inline void bus_space_write_8(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, uint64_t value);
+
+
+static __inline u_int8_t
+bus_space_read_1(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return BUS_SPACE_INVALID_DATA; // TODO: implement
+	return (*(volatile u_int8_t *)(handle + offset));
+}
+
+static __inline u_int16_t
+bus_space_read_2(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return BUS_SPACE_INVALID_DATA; // TODO: implement
+	return (*(volatile u_int16_t *)(handle + offset));
+}
+
+static __inline u_int32_t
+bus_space_read_4(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return BUS_SPACE_INVALID_DATA; // TODO: implement
+	return (*(volatile u_int32_t *)(handle + offset));
+}
+
+static __inline uint64_t
+bus_space_read_8(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO) /* No 8 byte IO space access on x86 */
+		return (BUS_SPACE_INVALID_DATA);
+	return (*(volatile uint64_t *)(handle + offset));
+}
+
+
+static __inline void
+bus_space_write_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int8_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return; // TODO: implement
+	else
+		*(volatile u_int8_t *)(bsh + offset) = value;
+}
+
+static __inline void
+bus_space_write_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int16_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return; // TODO: implement
+	else
+		*(volatile u_int16_t *)(bsh + offset) = value;
+}
+
+static __inline void
+bus_space_write_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int32_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return; // TODO: implement
+	else
+		*(volatile u_int32_t *)(bsh + offset) = value;
+}
+
+static __inline void
+bus_space_write_8(bus_space_tag_t tag, bus_space_handle_t bsh,
+		  bus_size_t offset, uint64_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return; // TODO: implement
+	else
+		*(volatile uint64_t *)(bsh + offset) = value;
+}
+
+
+#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
+#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */
+
+static __inline void
+bus_space_barrier(bus_space_tag_t tag __unused, bus_space_handle_t bsh __unused,
+		  bus_size_t offset __unused, bus_size_t len __unused, int flags)
+{
+	__compiler_membar();
+}
+
+#include <machine/bus_dma.h>
+
+/*
+ * Stream accesses are the same as normal accesses on x86; there are no
+ * supported bus systems with an endianess different from the host one.
+ */
+#define	bus_space_read_stream_1(t, h, o)	bus_space_read_1((t), (h), (o))
+#define	bus_space_read_stream_2(t, h, o)	bus_space_read_2((t), (h), (o))
+#define	bus_space_read_stream_4(t, h, o)	bus_space_read_4((t), (h), (o))
+
+#define	bus_space_read_multi_stream_1(t, h, o, a, c) \
+	bus_space_read_multi_1((t), (h), (o), (a), (c))
+#define	bus_space_read_multi_stream_2(t, h, o, a, c) \
+	bus_space_read_multi_2((t), (h), (o), (a), (c))
+#define	bus_space_read_multi_stream_4(t, h, o, a, c) \
+	bus_space_read_multi_4((t), (h), (o), (a), (c))
+
+#define	bus_space_write_stream_1(t, h, o, v) \
+	bus_space_write_1((t), (h), (o), (v))
+#define	bus_space_write_stream_2(t, h, o, v) \
+	bus_space_write_2((t), (h), (o), (v))
+#define	bus_space_write_stream_4(t, h, o, v) \
+	bus_space_write_4((t), (h), (o), (v))
+
+#define	bus_space_write_multi_stream_1(t, h, o, a, c) \
+	bus_space_write_multi_1((t), (h), (o), (a), (c))
+#define	bus_space_write_multi_stream_2(t, h, o, a, c) \
+	bus_space_write_multi_2((t), (h), (o), (a), (c))
+#define	bus_space_write_multi_stream_4(t, h, o, a, c) \
+	bus_space_write_multi_4((t), (h), (o), (a), (c))
+
+#define	bus_space_set_multi_stream_1(t, h, o, v, c) \
+	bus_space_set_multi_1((t), (h), (o), (v), (c))
+#define	bus_space_set_multi_stream_2(t, h, o, v, c) \
+	bus_space_set_multi_2((t), (h), (o), (v), (c))
+#define	bus_space_set_multi_stream_4(t, h, o, v, c) \
+	bus_space_set_multi_4((t), (h), (o), (v), (c))
+
+#define	bus_space_read_region_stream_1(t, h, o, a, c) \
+	bus_space_read_region_1((t), (h), (o), (a), (c))
+#define	bus_space_read_region_stream_2(t, h, o, a, c) \
+	bus_space_read_region_2((t), (h), (o), (a), (c))
+#define	bus_space_read_region_stream_4(t, h, o, a, c) \
+	bus_space_read_region_4((t), (h), (o), (a), (c))
+
+#define	bus_space_write_region_stream_1(t, h, o, a, c) \
+	bus_space_write_region_1((t), (h), (o), (a), (c))
+#define	bus_space_write_region_stream_2(t, h, o, a, c) \
+	bus_space_write_region_2((t), (h), (o), (a), (c))
+#define	bus_space_write_region_stream_4(t, h, o, a, c) \
+	bus_space_write_region_4((t), (h), (o), (a), (c))
+
+#define	bus_space_set_region_stream_1(t, h, o, v, c) \
+	bus_space_set_region_1((t), (h), (o), (v), (c))
+#define	bus_space_set_region_stream_2(t, h, o, v, c) \
+	bus_space_set_region_2((t), (h), (o), (v), (c))
+#define	bus_space_set_region_stream_4(t, h, o, v, c) \
+	bus_space_set_region_4((t), (h), (o), (v), (c))
+
+#define	bus_space_copy_region_stream_1(t, h1, o1, h2, o2, c) \
+	bus_space_copy_region_1((t), (h1), (o1), (h2), (o2), (c))
+#define	bus_space_copy_region_stream_2(t, h1, o1, h2, o2, c) \
+	bus_space_copy_region_2((t), (h1), (o1), (h2), (o2), (c))
+#define	bus_space_copy_region_stream_4(t, h1, o1, h2, o2, c) \
+	bus_space_copy_region_4((t), (h1), (o1), (h2), (o2), (c))
+
+
+#endif /* _RISCV_BUS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/cpufunc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/cpufunc.h
new file mode 100644
index 0000000000..5f19d15006
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/riscv64/cpufunc.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2021, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _MACHINE_CPUFUNC_H_
+#define	_MACHINE_CPUFUNC_H_
+
+#define	HAVE_INLINE_FLS
+
+static __inline int
+fls(int mask)
+{
+	int bit;
+	if (mask == 0)
+		return 0;
+	for (bit = 1; mask != 1; bit++)
+		mask = (unsigned int) mask >> 1;
+	return bit;
+}
+
+static __inline int
+ffsl(long mask)
+{
+	int bit;
+
+	if (mask == 0)
+		return (0);
+	for (bit = 1; !(mask & 1); bit++)
+		mask = (unsigned long)mask >> 1;
+	return (bit);
+}
+  
+#endif /* !_MACHINE_CPUFUNC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/smp.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/smp.h
new file mode 100644
index 0000000000..3285153d39
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/smp.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT license.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_SMP_H_
+#define _FBSD_COMPAT_MACHINE_SMP_H_
+
+
+#include <sys/smp.h>
+
+
+#endif /* _FBSD_COMPAT_MACHINE_SMP_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/stdarg.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/stdarg.h
new file mode 100644
index 0000000000..75961678b4
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/stdarg.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_MACHINE_STDARG_H_
+#define _FBSD_COMPAT_MACHINE_STDARG_H_
+
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+
+#endif /* _FBSD_COMPAT_MACHINE_STDARG_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/bus.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/bus.h
new file mode 100644
index 0000000000..3d18f028a5
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/bus.h
@@ -0,0 +1,1104 @@
+/*-
+ * Copyright (c) KATO Takenori, 1999.
+ *
+ * All rights reserved.  Unpublished rights reserved under the copyright
+ * laws of Japan.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer as
+ *    the first lines of this file unmodified.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: releng/11.1/sys/x86/include/bus.h 286667 2015-08-12 15:26:32Z marcel $
+ */
+
+/*	$NetBSD: bus.h,v 1.12 1997/10/01 08:25:15 fvdl Exp $	*/
+
+/*-
+ * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
+ * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Christopher G. Demetriou
+ *	for the NetBSD Project.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _X86_BUS_H_
+#define _X86_BUS_H_
+
+#include <machine/_bus.h>
+#include <machine/cpufunc.h>
+
+#ifndef __GNUCLIKE_ASM
+# ifndef lint
+#  error "no assembler code for your compiler"
+# endif
+#endif
+
+/*
+ * Values for the x86 bus space tag, not to be used directly by MI code.
+ */
+#define	X86_BUS_SPACE_IO	0	/* space is i/o space */
+#define	X86_BUS_SPACE_MEM	1	/* space is mem space */
+
+#define BUS_SPACE_MAXSIZE_24BIT	0xFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT 0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE	0xFFFFFFFF
+#define BUS_SPACE_MAXADDR_24BIT	0xFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT 0xFFFFFFFF
+#if defined(__amd64__) || defined(PAE)
+#define BUS_SPACE_MAXADDR	0xFFFFFFFFFFFFFFFFULL
+#else
+#define BUS_SPACE_MAXADDR	0xFFFFFFFF
+#endif
+
+#define BUS_SPACE_INVALID_DATA	(~0)
+#define BUS_SPACE_UNRESTRICTED	(~0)
+
+/*
+ * Map a region of device bus space into CPU virtual address space.
+ */
+
+int bus_space_map(bus_space_tag_t tag, bus_addr_t addr, bus_size_t size,
+    int flags, bus_space_handle_t *bshp);
+
+/*
+ * Unmap a region of device bus space.
+ */
+
+void bus_space_unmap(bus_space_tag_t tag, bus_space_handle_t bsh,
+    bus_size_t size);
+
+/*
+ * Get a new handle for a subregion of an already-mapped area of bus space.
+ */
+
+static __inline int bus_space_subregion(bus_space_tag_t t,
+					bus_space_handle_t bsh,
+					bus_size_t offset, bus_size_t size,
+					bus_space_handle_t *nbshp);
+
+static __inline int
+bus_space_subregion(bus_space_tag_t t __unused, bus_space_handle_t bsh,
+		    bus_size_t offset, bus_size_t size __unused,
+		    bus_space_handle_t *nbshp)
+{
+
+	*nbshp = bsh + offset;
+	return (0);
+}
+
+/*
+ * Allocate a region of memory that is accessible to devices in bus space.
+ */
+
+int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
+			bus_addr_t rend, bus_size_t size, bus_size_t align,
+			bus_size_t boundary, int flags, bus_addr_t *addrp,
+			bus_space_handle_t *bshp);
+
+/*
+ * Free a region of bus space accessible memory.
+ */
+
+static __inline void bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
+				    bus_size_t size);
+
+static __inline void
+bus_space_free(bus_space_tag_t t __unused, bus_space_handle_t bsh __unused,
+	       bus_size_t size __unused)
+{
+}
+
+
+/*
+ * Read a 1, 2, 4, or 8 byte quantity from bus space
+ * described by tag/handle/offset.
+ */
+static __inline u_int8_t bus_space_read_1(bus_space_tag_t tag,
+					  bus_space_handle_t handle,
+					  bus_size_t offset);
+
+static __inline u_int16_t bus_space_read_2(bus_space_tag_t tag,
+					   bus_space_handle_t handle,
+					   bus_size_t offset);
+
+static __inline u_int32_t bus_space_read_4(bus_space_tag_t tag,
+					   bus_space_handle_t handle,
+					   bus_size_t offset);
+
+#ifdef __amd64__
+static __inline uint64_t bus_space_read_8(bus_space_tag_t tag,
+					  bus_space_handle_t handle,
+					  bus_size_t offset);
+#endif
+
+static __inline u_int8_t
+bus_space_read_1(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return (inb(handle + offset));
+	return (*(volatile u_int8_t *)(handle + offset));
+}
+
+static __inline u_int16_t
+bus_space_read_2(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return (inw(handle + offset));
+	return (*(volatile u_int16_t *)(handle + offset));
+}
+
+static __inline u_int32_t
+bus_space_read_4(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		return (inl(handle + offset));
+	return (*(volatile u_int32_t *)(handle + offset));
+}
+
+#ifdef __amd64__
+static __inline uint64_t
+bus_space_read_8(bus_space_tag_t tag, bus_space_handle_t handle,
+		 bus_size_t offset)
+{
+
+	if (tag == X86_BUS_SPACE_IO) /* No 8 byte IO space access on x86 */
+		return (BUS_SPACE_INVALID_DATA);
+	return (*(volatile uint64_t *)(handle + offset));
+}
+#endif
+
+/*
+ * Read `count' 1, 2, 4, or 8 byte quantities from bus space
+ * described by tag/handle/offset and copy into buffer provided.
+ */
+static __inline void bus_space_read_multi_1(bus_space_tag_t tag,
+					    bus_space_handle_t bsh,
+					    bus_size_t offset, u_int8_t *addr,
+					    size_t count);
+
+static __inline void bus_space_read_multi_2(bus_space_tag_t tag,
+					    bus_space_handle_t bsh,
+					    bus_size_t offset, u_int16_t *addr,
+					    size_t count);
+
+static __inline void bus_space_read_multi_4(bus_space_tag_t tag,
+					    bus_space_handle_t bsh,
+					    bus_size_t offset, u_int32_t *addr,
+					    size_t count);
+
+static __inline void
+bus_space_read_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int8_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		insb(bsh + offset, addr, count);
+	else {
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	movb (%2),%%al				\n\
+			stosb					\n\
+			loop 1b"				:
+		    "=D" (addr), "=c" (count)			:
+		    "r" (bsh + offset), "0" (addr), "1" (count)	:
+		    "%eax", "memory");
+#endif
+	}
+}
+
+static __inline void
+bus_space_read_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int16_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		insw(bsh + offset, addr, count);
+	else {
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	movw (%2),%%ax				\n\
+			stosw					\n\
+			loop 1b"				:
+		    "=D" (addr), "=c" (count)			:
+		    "r" (bsh + offset), "0" (addr), "1" (count)	:
+		    "%eax", "memory");
+#endif
+	}
+}
+
+static __inline void
+bus_space_read_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int32_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		insl(bsh + offset, addr, count);
+	else {
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	movl (%2),%%eax				\n\
+			stosl					\n\
+			loop 1b"				:
+		    "=D" (addr), "=c" (count)			:
+		    "r" (bsh + offset), "0" (addr), "1" (count)	:
+		    "%eax", "memory");
+#endif
+	}
+}
+
+#if 0	/* Cause a link error for bus_space_read_multi_8 */
+#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 unimplemented !!!
+#endif
+
+/*
+ * Read `count' 1, 2, 4, or 8 byte quantities from bus space
+ * described by tag/handle and starting at `offset' and copy into
+ * buffer provided.
+ */
+static __inline void bus_space_read_region_1(bus_space_tag_t tag,
+					     bus_space_handle_t bsh,
+					     bus_size_t offset, u_int8_t *addr,
+					     size_t count);
+
+static __inline void bus_space_read_region_2(bus_space_tag_t tag,
+					     bus_space_handle_t bsh,
+					     bus_size_t offset, u_int16_t *addr,
+					     size_t count);
+
+static __inline void bus_space_read_region_4(bus_space_tag_t tag,
+					     bus_space_handle_t bsh,
+					     bus_size_t offset, u_int32_t *addr,
+					     size_t count);
+
+
+static __inline void
+bus_space_read_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+			bus_size_t offset, u_int8_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO) {
+		int _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	inb %w2,%%al				\n\
+			stosb					\n\
+			incl %2					\n\
+			loop 1b"				:
+		    "=D" (addr), "=c" (count), "=d" (_port_)	:
+		    "0" (addr), "1" (count), "2" (_port_)	:
+		    "%eax", "memory", "cc");
+#endif
+	} else {
+		bus_space_handle_t _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+			repne					\n\
+			movsb"					:
+		    "=D" (addr), "=c" (count), "=S" (_port_)	:
+		    "0" (addr), "1" (count), "2" (_port_)	:
+		    "memory", "cc");
+#endif
+	}
+}
+
+static __inline void
+bus_space_read_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+			bus_size_t offset, u_int16_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO) {
+		int _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	inw %w2,%%ax				\n\
+			stosw					\n\
+			addl $2,%2				\n\
+			loop 1b"				:
+		    "=D" (addr), "=c" (count), "=d" (_port_)	:
+		    "0" (addr), "1" (count), "2" (_port_)	:
+		    "%eax", "memory", "cc");
+#endif
+	} else {
+		bus_space_handle_t _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+			repne					\n\
+			movsw"					:
+		    "=D" (addr), "=c" (count), "=S" (_port_)	:
+		    "0" (addr), "1" (count), "2" (_port_)	:
+		    "memory", "cc");
+#endif
+	}
+}
+
+static __inline void
+bus_space_read_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+			bus_size_t offset, u_int32_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO) {
+		int _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	inl %w2,%%eax				\n\
+			stosl					\n\
+			addl $4,%2				\n\
+			loop 1b"				:
+		    "=D" (addr), "=c" (count), "=d" (_port_)	:
+		    "0" (addr), "1" (count), "2" (_port_)	:
+		    "%eax", "memory", "cc");
+#endif
+	} else {
+		bus_space_handle_t _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+			repne					\n\
+			movsl"					:
+		    "=D" (addr), "=c" (count), "=S" (_port_)	:
+		    "0" (addr), "1" (count), "2" (_port_)	:
+		    "memory", "cc");
+#endif
+	}
+}
+
+#if 0	/* Cause a link error for bus_space_read_region_8 */
+#define	bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!
+#endif
+
+/*
+ * Write the 1, 2, 4, or 8 byte value `value' to bus space
+ * described by tag/handle/offset.
+ */
+
+static __inline void bus_space_write_1(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, u_int8_t value);
+
+static __inline void bus_space_write_2(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, u_int16_t value);
+
+static __inline void bus_space_write_4(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, u_int32_t value);
+
+#ifdef __amd64__
+static __inline void bus_space_write_8(bus_space_tag_t tag,
+				       bus_space_handle_t bsh,
+				       bus_size_t offset, uint64_t value);
+#endif
+
+static __inline void
+bus_space_write_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int8_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		outb(bsh + offset, value);
+	else
+		*(volatile u_int8_t *)(bsh + offset) = value;
+}
+
+static __inline void
+bus_space_write_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int16_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		outw(bsh + offset, value);
+	else
+		*(volatile u_int16_t *)(bsh + offset) = value;
+}
+
+static __inline void
+bus_space_write_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int32_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		outl(bsh + offset, value);
+	else
+		*(volatile u_int32_t *)(bsh + offset) = value;
+}
+
+#ifdef __amd64__
+static __inline void
+bus_space_write_8(bus_space_tag_t tag, bus_space_handle_t bsh,
+		  bus_size_t offset, uint64_t value)
+{
+
+	if (tag == X86_BUS_SPACE_IO) /* No 8 byte IO space access on x86 */
+		return;
+	else
+		*(volatile uint64_t *)(bsh + offset) = value;
+}
+#endif
+
+/*
+ * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
+ * provided to bus space described by tag/handle/offset.
+ */
+
+static __inline void bus_space_write_multi_1(bus_space_tag_t tag,
+					     bus_space_handle_t bsh,
+					     bus_size_t offset,
+					     const u_int8_t *addr,
+					     size_t count);
+static __inline void bus_space_write_multi_2(bus_space_tag_t tag,
+					     bus_space_handle_t bsh,
+					     bus_size_t offset,
+					     const u_int16_t *addr,
+					     size_t count);
+
+static __inline void bus_space_write_multi_4(bus_space_tag_t tag,
+					     bus_space_handle_t bsh,
+					     bus_size_t offset,
+					     const u_int32_t *addr,
+					     size_t count);
+
+static __inline void
+bus_space_write_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+			bus_size_t offset, const u_int8_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		outsb(bsh + offset, addr, count);
+	else {
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	lodsb					\n\
+			movb %%al,(%2)				\n\
+			loop 1b"				:
+		    "=S" (addr), "=c" (count)			:
+		    "r" (bsh + offset), "0" (addr), "1" (count)	:
+		    "%eax", "memory", "cc");
+#endif
+	}
+}
+
+static __inline void
+bus_space_write_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+			bus_size_t offset, const u_int16_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		outsw(bsh + offset, addr, count);
+	else {
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	lodsw					\n\
+			movw %%ax,(%2)				\n\
+			loop 1b"				:
+		    "=S" (addr), "=c" (count)			:
+		    "r" (bsh + offset), "0" (addr), "1" (count)	:
+		    "%eax", "memory", "cc");
+#endif
+	}
+}
+
+static __inline void
+bus_space_write_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+			bus_size_t offset, const u_int32_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO)
+		outsl(bsh + offset, addr, count);
+	else {
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	lodsl					\n\
+			movl %%eax,(%2)				\n\
+			loop 1b"				:
+		    "=S" (addr), "=c" (count)			:
+		    "r" (bsh + offset), "0" (addr), "1" (count)	:
+		    "%eax", "memory", "cc");
+#endif
+	}
+}
+
+#if 0	/* Cause a link error for bus_space_write_multi_8 */
+#define	bus_space_write_multi_8(t, h, o, a, c)				\
+			!!! bus_space_write_multi_8 unimplemented !!!
+#endif
+
+/*
+ * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
+ * to bus space described by tag/handle starting at `offset'.
+ */
+
+static __inline void bus_space_write_region_1(bus_space_tag_t tag,
+					      bus_space_handle_t bsh,
+					      bus_size_t offset,
+					      const u_int8_t *addr,
+					      size_t count);
+static __inline void bus_space_write_region_2(bus_space_tag_t tag,
+					      bus_space_handle_t bsh,
+					      bus_size_t offset,
+					      const u_int16_t *addr,
+					      size_t count);
+static __inline void bus_space_write_region_4(bus_space_tag_t tag,
+					      bus_space_handle_t bsh,
+					      bus_size_t offset,
+					      const u_int32_t *addr,
+					      size_t count);
+
+static __inline void
+bus_space_write_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+			 bus_size_t offset, const u_int8_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO) {
+		int _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	lodsb					\n\
+			outb %%al,%w0				\n\
+			incl %0					\n\
+			loop 1b"				:
+		    "=d" (_port_), "=S" (addr), "=c" (count)	:
+		    "0" (_port_), "1" (addr), "2" (count)	:
+		    "%eax", "memory", "cc");
+#endif
+	} else {
+		bus_space_handle_t _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+			repne					\n\
+			movsb"					:
+		    "=D" (_port_), "=S" (addr), "=c" (count)	:
+		    "0" (_port_), "1" (addr), "2" (count)	:
+		    "memory", "cc");
+#endif
+	}
+}
+
+static __inline void
+bus_space_write_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+			 bus_size_t offset, const u_int16_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO) {
+		int _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	lodsw					\n\
+			outw %%ax,%w0				\n\
+			addl $2,%0				\n\
+			loop 1b"				:
+		    "=d" (_port_), "=S" (addr), "=c" (count)	:
+		    "0" (_port_), "1" (addr), "2" (count)	:
+		    "%eax", "memory", "cc");
+#endif
+	} else {
+		bus_space_handle_t _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+			repne					\n\
+			movsw"					:
+		    "=D" (_port_), "=S" (addr), "=c" (count)	:
+		    "0" (_port_), "1" (addr), "2" (count)	:
+		    "memory", "cc");
+#endif
+	}
+}
+
+static __inline void
+bus_space_write_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+			 bus_size_t offset, const u_int32_t *addr, size_t count)
+{
+
+	if (tag == X86_BUS_SPACE_IO) {
+		int _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+		1:	lodsl					\n\
+			outl %%eax,%w0				\n\
+			addl $4,%0				\n\
+			loop 1b"				:
+		    "=d" (_port_), "=S" (addr), "=c" (count)	:
+		    "0" (_port_), "1" (addr), "2" (count)	:
+		    "%eax", "memory", "cc");
+#endif
+	} else {
+		bus_space_handle_t _port_ = bsh + offset;
+#ifdef __GNUCLIKE_ASM
+		__asm __volatile("				\n\
+			cld					\n\
+			repne					\n\
+			movsl"					:
+		    "=D" (_port_), "=S" (addr), "=c" (count)	:
+		    "0" (_port_), "1" (addr), "2" (count)	:
+		    "memory", "cc");
+#endif
+	}
+}
+
+#if 0	/* Cause a link error for bus_space_write_region_8 */
+#define	bus_space_write_region_8					\
+			!!! bus_space_write_region_8 unimplemented !!!
+#endif
+
+/*
+ * Write the 1, 2, 4, or 8 byte value `val' to bus space described
+ * by tag/handle/offset `count' times.
+ */
+
+static __inline void bus_space_set_multi_1(bus_space_tag_t tag,
+					   bus_space_handle_t bsh,
+					   bus_size_t offset,
+					   u_int8_t value, size_t count);
+static __inline void bus_space_set_multi_2(bus_space_tag_t tag,
+					   bus_space_handle_t bsh,
+					   bus_size_t offset,
+					   u_int16_t value, size_t count);
+static __inline void bus_space_set_multi_4(bus_space_tag_t tag,
+					   bus_space_handle_t bsh,
+					   bus_size_t offset,
+					   u_int32_t value, size_t count);
+
+static __inline void
+bus_space_set_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+		      bus_size_t offset, u_int8_t value, size_t count)
+{
+	bus_space_handle_t addr = bsh + offset;
+
+	if (tag == X86_BUS_SPACE_IO)
+		while (count--)
+			outb(addr, value);
+	else
+		while (count--)
+			*(volatile u_int8_t *)(addr) = value;
+}
+
+static __inline void
+bus_space_set_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+		     bus_size_t offset, u_int16_t value, size_t count)
+{
+	bus_space_handle_t addr = bsh + offset;
+
+	if (tag == X86_BUS_SPACE_IO)
+		while (count--)
+			outw(addr, value);
+	else
+		while (count--)
+			*(volatile u_int16_t *)(addr) = value;
+}
+
+static __inline void
+bus_space_set_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+		      bus_size_t offset, u_int32_t value, size_t count)
+{
+	bus_space_handle_t addr = bsh + offset;
+
+	if (tag == X86_BUS_SPACE_IO)
+		while (count--)
+			outl(addr, value);
+	else
+		while (count--)
+			*(volatile u_int32_t *)(addr) = value;
+}
+
+#if 0	/* Cause a link error for bus_space_set_multi_8 */
+#define	bus_space_set_multi_8 !!! bus_space_set_multi_8 unimplemented !!!
+#endif
+
+/*
+ * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
+ * by tag/handle starting at `offset'.
+ */
+
+static __inline void bus_space_set_region_1(bus_space_tag_t tag,
+					    bus_space_handle_t bsh,
+					    bus_size_t offset, u_int8_t value,
+					    size_t count);
+static __inline void bus_space_set_region_2(bus_space_tag_t tag,
+					    bus_space_handle_t bsh,
+					    bus_size_t offset, u_int16_t value,
+					    size_t count);
+static __inline void bus_space_set_region_4(bus_space_tag_t tag,
+					    bus_space_handle_t bsh,
+					    bus_size_t offset, u_int32_t value,
+					    size_t count);
+
+static __inline void
+bus_space_set_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int8_t value, size_t count)
+{
+	bus_space_handle_t addr = bsh + offset;
+
+	if (tag == X86_BUS_SPACE_IO)
+		for (; count != 0; count--, addr++)
+			outb(addr, value);
+	else
+		for (; count != 0; count--, addr++)
+			*(volatile u_int8_t *)(addr) = value;
+}
+
+static __inline void
+bus_space_set_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int16_t value, size_t count)
+{
+	bus_space_handle_t addr = bsh + offset;
+
+	if (tag == X86_BUS_SPACE_IO)
+		for (; count != 0; count--, addr += 2)
+			outw(addr, value);
+	else
+		for (; count != 0; count--, addr += 2)
+			*(volatile u_int16_t *)(addr) = value;
+}
+
+static __inline void
+bus_space_set_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int32_t value, size_t count)
+{
+	bus_space_handle_t addr = bsh + offset;
+
+	if (tag == X86_BUS_SPACE_IO)
+		for (; count != 0; count--, addr += 4)
+			outl(addr, value);
+	else
+		for (; count != 0; count--, addr += 4)
+			*(volatile u_int32_t *)(addr) = value;
+}
+
+#if 0	/* Cause a link error for bus_space_set_region_8 */
+#define	bus_space_set_region_8	!!! bus_space_set_region_8 unimplemented !!!
+#endif
+
+/*
+ * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
+ * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
+ */
+
+static __inline void bus_space_copy_region_1(bus_space_tag_t tag,
+					     bus_space_handle_t bsh1,
+					     bus_size_t off1,
+					     bus_space_handle_t bsh2,
+					     bus_size_t off2, size_t count);
+
+static __inline void bus_space_copy_region_2(bus_space_tag_t tag,
+					     bus_space_handle_t bsh1,
+					     bus_size_t off1,
+					     bus_space_handle_t bsh2,
+					     bus_size_t off2, size_t count);
+
+static __inline void bus_space_copy_region_4(bus_space_tag_t tag,
+					     bus_space_handle_t bsh1,
+					     bus_size_t off1,
+					     bus_space_handle_t bsh2,
+					     bus_size_t off2, size_t count);
+
+static __inline void
+bus_space_copy_region_1(bus_space_tag_t tag, bus_space_handle_t bsh1,
+			bus_size_t off1, bus_space_handle_t bsh2,
+			bus_size_t off2, size_t count)
+{
+	bus_space_handle_t addr1 = bsh1 + off1;
+	bus_space_handle_t addr2 = bsh2 + off2;
+
+	if (tag == X86_BUS_SPACE_IO) {
+		if (addr1 >= addr2) {
+			/* src after dest: copy forward */
+			for (; count != 0; count--, addr1++, addr2++)
+				outb(addr2, inb(addr1));
+		} else {
+			/* dest after src: copy backwards */
+			for (addr1 += (count - 1), addr2 += (count - 1);
+			    count != 0; count--, addr1--, addr2--)
+				outb(addr2, inb(addr1));
+		}
+	} else {
+		if (addr1 >= addr2) {
+			/* src after dest: copy forward */
+			for (; count != 0; count--, addr1++, addr2++)
+				*(volatile u_int8_t *)(addr2) =
+				    *(volatile u_int8_t *)(addr1);
+		} else {
+			/* dest after src: copy backwards */
+			for (addr1 += (count - 1), addr2 += (count - 1);
+			    count != 0; count--, addr1--, addr2--)
+				*(volatile u_int8_t *)(addr2) =
+				    *(volatile u_int8_t *)(addr1);
+		}
+	}
+}
+
+static __inline void
+bus_space_copy_region_2(bus_space_tag_t tag, bus_space_handle_t bsh1,
+			bus_size_t off1, bus_space_handle_t bsh2,
+			bus_size_t off2, size_t count)
+{
+	bus_space_handle_t addr1 = bsh1 + off1;
+	bus_space_handle_t addr2 = bsh2 + off2;
+
+	if (tag == X86_BUS_SPACE_IO) {
+		if (addr1 >= addr2) {
+			/* src after dest: copy forward */
+			for (; count != 0; count--, addr1 += 2, addr2 += 2)
+				outw(addr2, inw(addr1));
+		} else {
+			/* dest after src: copy backwards */
+			for (addr1 += 2 * (count - 1), addr2 += 2 * (count - 1);
+			    count != 0; count--, addr1 -= 2, addr2 -= 2)
+				outw(addr2, inw(addr1));
+		}
+	} else {
+		if (addr1 >= addr2) {
+			/* src after dest: copy forward */
+			for (; count != 0; count--, addr1 += 2, addr2 += 2)
+				*(volatile u_int16_t *)(addr2) =
+				    *(volatile u_int16_t *)(addr1);
+		} else {
+			/* dest after src: copy backwards */
+			for (addr1 += 2 * (count - 1), addr2 += 2 * (count - 1);
+			    count != 0; count--, addr1 -= 2, addr2 -= 2)
+				*(volatile u_int16_t *)(addr2) =
+				    *(volatile u_int16_t *)(addr1);
+		}
+	}
+}
+
+static __inline void
+bus_space_copy_region_4(bus_space_tag_t tag, bus_space_handle_t bsh1,
+			bus_size_t off1, bus_space_handle_t bsh2,
+			bus_size_t off2, size_t count)
+{
+	bus_space_handle_t addr1 = bsh1 + off1;
+	bus_space_handle_t addr2 = bsh2 + off2;
+
+	if (tag == X86_BUS_SPACE_IO) {
+		if (addr1 >= addr2) {
+			/* src after dest: copy forward */
+			for (; count != 0; count--, addr1 += 4, addr2 += 4)
+				outl(addr2, inl(addr1));
+		} else {
+			/* dest after src: copy backwards */
+			for (addr1 += 4 * (count - 1), addr2 += 4 * (count - 1);
+			    count != 0; count--, addr1 -= 4, addr2 -= 4)
+				outl(addr2, inl(addr1));
+		}
+	} else {
+		if (addr1 >= addr2) {
+			/* src after dest: copy forward */
+			for (; count != 0; count--, addr1 += 4, addr2 += 4)
+				*(volatile u_int32_t *)(addr2) =
+				    *(volatile u_int32_t *)(addr1);
+		} else {
+			/* dest after src: copy backwards */
+			for (addr1 += 4 * (count - 1), addr2 += 4 * (count - 1);
+			    count != 0; count--, addr1 -= 4, addr2 -= 4)
+				*(volatile u_int32_t *)(addr2) =
+				    *(volatile u_int32_t *)(addr1);
+		}
+	}
+}
+
+#if 0	/* Cause a link error for bus_space_copy_8 */
+#define	bus_space_copy_region_8	!!! bus_space_copy_region_8 unimplemented !!!
+#endif
+
+/*
+ * Bus read/write barrier methods.
+ *
+ *	void bus_space_barrier(bus_space_tag_t tag, bus_space_handle_t bsh,
+ *			       bus_size_t offset, bus_size_t len, int flags);
+ *
+ *
+ * Note that BUS_SPACE_BARRIER_WRITE doesn't do anything other than
+ * prevent reordering by the compiler; all Intel x86 processors currently
+ * retire operations outside the CPU in program order.
+ */
+#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
+#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */
+
+static __inline void
+bus_space_barrier(bus_space_tag_t tag __unused, bus_space_handle_t bsh __unused,
+		  bus_size_t offset __unused, bus_size_t len __unused, int flags)
+{
+#ifdef __GNUCLIKE_ASM
+	if (flags & BUS_SPACE_BARRIER_READ)
+#ifdef __amd64__
+		__asm __volatile("lock; addl $0,0(%%rsp)" : : : "memory");
+#else
+		__asm __volatile("lock; addl $0,0(%%esp)" : : : "memory");
+#endif
+	else
+		__compiler_membar();
+#endif
+}
+
+#ifdef BUS_SPACE_NO_LEGACY
+#undef inb
+#undef outb
+#define inb(a) compiler_error
+#define inw(a) compiler_error
+#define inl(a) compiler_error
+#define outb(a, b) compiler_error
+#define outw(a, b) compiler_error
+#define outl(a, b) compiler_error
+#endif
+
+#include <machine/bus_dma.h>
+
+/*
+ * Stream accesses are the same as normal accesses on x86; there are no
+ * supported bus systems with an endianess different from the host one.
+ */
+#define	bus_space_read_stream_1(t, h, o)	bus_space_read_1((t), (h), (o))
+#define	bus_space_read_stream_2(t, h, o)	bus_space_read_2((t), (h), (o))
+#define	bus_space_read_stream_4(t, h, o)	bus_space_read_4((t), (h), (o))
+
+#define	bus_space_read_multi_stream_1(t, h, o, a, c) \
+	bus_space_read_multi_1((t), (h), (o), (a), (c))
+#define	bus_space_read_multi_stream_2(t, h, o, a, c) \
+	bus_space_read_multi_2((t), (h), (o), (a), (c))
+#define	bus_space_read_multi_stream_4(t, h, o, a, c) \
+	bus_space_read_multi_4((t), (h), (o), (a), (c))
+
+#define	bus_space_write_stream_1(t, h, o, v) \
+	bus_space_write_1((t), (h), (o), (v))
+#define	bus_space_write_stream_2(t, h, o, v) \
+	bus_space_write_2((t), (h), (o), (v))
+#define	bus_space_write_stream_4(t, h, o, v) \
+	bus_space_write_4((t), (h), (o), (v))
+
+#define	bus_space_write_multi_stream_1(t, h, o, a, c) \
+	bus_space_write_multi_1((t), (h), (o), (a), (c))
+#define	bus_space_write_multi_stream_2(t, h, o, a, c) \
+	bus_space_write_multi_2((t), (h), (o), (a), (c))
+#define	bus_space_write_multi_stream_4(t, h, o, a, c) \
+	bus_space_write_multi_4((t), (h), (o), (a), (c))
+
+#define	bus_space_set_multi_stream_1(t, h, o, v, c) \
+	bus_space_set_multi_1((t), (h), (o), (v), (c))
+#define	bus_space_set_multi_stream_2(t, h, o, v, c) \
+	bus_space_set_multi_2((t), (h), (o), (v), (c))
+#define	bus_space_set_multi_stream_4(t, h, o, v, c) \
+	bus_space_set_multi_4((t), (h), (o), (v), (c))
+
+#define	bus_space_read_region_stream_1(t, h, o, a, c) \
+	bus_space_read_region_1((t), (h), (o), (a), (c))
+#define	bus_space_read_region_stream_2(t, h, o, a, c) \
+	bus_space_read_region_2((t), (h), (o), (a), (c))
+#define	bus_space_read_region_stream_4(t, h, o, a, c) \
+	bus_space_read_region_4((t), (h), (o), (a), (c))
+
+#define	bus_space_write_region_stream_1(t, h, o, a, c) \
+	bus_space_write_region_1((t), (h), (o), (a), (c))
+#define	bus_space_write_region_stream_2(t, h, o, a, c) \
+	bus_space_write_region_2((t), (h), (o), (a), (c))
+#define	bus_space_write_region_stream_4(t, h, o, a, c) \
+	bus_space_write_region_4((t), (h), (o), (a), (c))
+
+#define	bus_space_set_region_stream_1(t, h, o, v, c) \
+	bus_space_set_region_1((t), (h), (o), (v), (c))
+#define	bus_space_set_region_stream_2(t, h, o, v, c) \
+	bus_space_set_region_2((t), (h), (o), (v), (c))
+#define	bus_space_set_region_stream_4(t, h, o, v, c) \
+	bus_space_set_region_4((t), (h), (o), (v), (c))
+
+#define	bus_space_copy_region_stream_1(t, h1, o1, h2, o2, c) \
+	bus_space_copy_region_1((t), (h1), (o1), (h2), (o2), (c))
+#define	bus_space_copy_region_stream_2(t, h1, o1, h2, o2, c) \
+	bus_space_copy_region_2((t), (h1), (o1), (h2), (o2), (c))
+#define	bus_space_copy_region_stream_4(t, h1, o1, h2, o2, c) \
+	bus_space_copy_region_4((t), (h1), (o1), (h2), (o2), (c))
+
+#endif /* _X86_BUS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/cpufunc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/cpufunc.h
new file mode 100644
index 0000000000..50591e5ea0
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86/cpufunc.h
@@ -0,0 +1,805 @@
+/*-
+ * Copyright (c) 1993 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: releng/11.1/sys/i386/include/cpufunc.h 313148 2017-02-03 12:03:10Z kib $
+ */
+
+/*
+ * Functions to provide access to special i386 instructions.
+ * This in included in sys/systm.h, and that file should be
+ * used in preference to this.
+ */
+
+#ifndef _MACHINE_CPUFUNC_H_
+#define	_MACHINE_CPUFUNC_H_
+
+struct region_descriptor;
+
+#define readb(va)	(*(volatile uint8_t *) (va))
+#define readw(va)	(*(volatile uint16_t *) (va))
+#define readl(va)	(*(volatile uint32_t *) (va))
+
+#define writeb(va, d)	(*(volatile uint8_t *) (va) = (d))
+#define writew(va, d)	(*(volatile uint16_t *) (va) = (d))
+#define writel(va, d)	(*(volatile uint32_t *) (va) = (d))
+
+#if defined(__GNUCLIKE_ASM) && defined(__CC_SUPPORTS___INLINE)
+
+static __inline void
+breakpoint(void)
+{
+	__asm __volatile("int $3");
+}
+
+static __inline u_int
+bsfl(u_int mask)
+{
+	u_int	result;
+
+	__asm("bsfl %1,%0" : "=r" (result) : "rm" (mask) : "cc");
+	return (result);
+}
+
+static __inline u_int
+bsrl(u_int mask)
+{
+	u_int	result;
+
+	__asm("bsrl %1,%0" : "=r" (result) : "rm" (mask) : "cc");
+	return (result);
+}
+
+static __inline void
+clflush(u_long addr)
+{
+
+	__asm __volatile("clflush %0" : : "m" (*(char *)addr));
+}
+
+static __inline void
+clflushopt(u_long addr)
+{
+
+	__asm __volatile(".byte 0x66;clflush %0" : : "m" (*(char *)addr));
+}
+
+static __inline void
+clts(void)
+{
+
+	__asm __volatile("clts");
+}
+
+static __inline void
+disable_intr(void)
+{
+
+	__asm __volatile("cli" : : : "memory");
+}
+
+static __inline void
+do_cpuid(u_int ax, u_int *p)
+{
+	__asm __volatile("cpuid"
+			 : "=a" (p[0]), "=b" (p[1]), "=c" (p[2]), "=d" (p[3])
+			 :  "0" (ax));
+}
+
+static __inline void
+cpuid_count(u_int ax, u_int cx, u_int *p)
+{
+	__asm __volatile("cpuid"
+			 : "=a" (p[0]), "=b" (p[1]), "=c" (p[2]), "=d" (p[3])
+			 :  "0" (ax), "c" (cx));
+}
+
+static __inline void
+enable_intr(void)
+{
+
+	__asm __volatile("sti");
+}
+
+static __inline void
+cpu_monitor(const void *addr, u_long extensions, u_int hints)
+{
+
+	__asm __volatile("monitor"
+	    : : "a" (addr), "c" (extensions), "d" (hints));
+}
+
+static __inline void
+cpu_mwait(u_long extensions, u_int hints)
+{
+
+	__asm __volatile("mwait" : : "a" (hints), "c" (extensions));
+}
+
+static __inline void
+lfence(void)
+{
+
+	__asm __volatile("lfence" : : : "memory");
+}
+
+static __inline void
+mfence(void)
+{
+
+	__asm __volatile("mfence" : : : "memory");
+}
+
+static __inline void
+sfence(void)
+{
+
+	__asm __volatile("sfence" : : : "memory");
+}
+
+#ifdef _KERNEL
+
+#ifndef __HAIKU__
+#define	HAVE_INLINE_FFS
+
+static __inline int
+ffs(int mask)
+{
+	/*
+	 * Note that gcc-2's builtin ffs would be used if we didn't declare
+	 * this inline or turn off the builtin.  The builtin is faster but
+	 * broken in gcc-2.4.5 and slower but working in gcc-2.5 and later
+	 * versions.
+	 */
+	 return (mask == 0 ? mask : (int)bsfl((u_int)mask) + 1);
+}
+#endif
+
+#define	HAVE_INLINE_FFSL
+
+static __inline int
+ffsl(long mask)
+{
+	return (ffs((int)mask));
+}
+
+#define	HAVE_INLINE_FLS
+
+static __inline int
+fls(int mask)
+{
+	return (mask == 0 ? mask : (int)bsrl((u_int)mask) + 1);
+}
+
+#define	HAVE_INLINE_FLSL
+
+static __inline int
+flsl(long mask)
+{
+	return (fls((int)mask));
+}
+
+#endif /* _KERNEL */
+
+static __inline void
+halt(void)
+{
+	__asm __volatile("hlt");
+}
+
+static __inline u_char
+inb(u_int port)
+{
+	u_char	data;
+
+	__asm __volatile("inb %w1, %0" : "=a" (data) : "Nd" (port));
+	return (data);
+}
+
+static __inline u_int
+inl(u_int port)
+{
+	u_int	data;
+
+	__asm __volatile("inl %w1, %0" : "=a" (data) : "Nd" (port));
+	return (data);
+}
+
+static __inline void
+insb(u_int port, void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; insb"
+			 : "+D" (addr), "+c" (count)
+			 : "d" (port)
+			 : "memory");
+}
+
+static __inline void
+insw(u_int port, void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; insw"
+			 : "+D" (addr), "+c" (count)
+			 : "d" (port)
+			 : "memory");
+}
+
+static __inline void
+insl(u_int port, void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; insl"
+			 : "+D" (addr), "+c" (count)
+			 : "d" (port)
+			 : "memory");
+}
+
+static __inline void
+invd(void)
+{
+	__asm __volatile("invd");
+}
+
+static __inline u_short
+inw(u_int port)
+{
+	u_short	data;
+
+	__asm __volatile("inw %w1, %0" : "=a" (data) : "Nd" (port));
+	return (data);
+}
+
+static __inline void
+outb(u_int port, u_char data)
+{
+	__asm __volatile("outb %0, %w1" : : "a" (data), "Nd" (port));
+}
+
+static __inline void
+outl(u_int port, u_int data)
+{
+	__asm __volatile("outl %0, %w1" : : "a" (data), "Nd" (port));
+}
+
+static __inline void
+outsb(u_int port, const void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; outsb"
+			 : "+S" (addr), "+c" (count)
+			 : "d" (port));
+}
+
+static __inline void
+outsw(u_int port, const void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; outsw"
+			 : "+S" (addr), "+c" (count)
+			 : "d" (port));
+}
+
+static __inline void
+outsl(u_int port, const void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; outsl"
+			 : "+S" (addr), "+c" (count)
+			 : "d" (port));
+}
+
+static __inline void
+outw(u_int port, u_short data)
+{
+	__asm __volatile("outw %0, %w1" : : "a" (data), "Nd" (port));
+}
+
+static __inline void
+ia32_pause(void)
+{
+	__asm __volatile("pause");
+}
+
+static __inline u_int
+read_eflags(void)
+{
+	u_int	ef;
+
+	__asm __volatile("pushfl; popl %0" : "=r" (ef));
+	return (ef);
+}
+
+static __inline uint64_t
+rdmsr(u_int msr)
+{
+	uint64_t rv;
+
+	__asm __volatile("rdmsr" : "=A" (rv) : "c" (msr));
+	return (rv);
+}
+
+static __inline uint32_t
+rdmsr32(u_int msr)
+{
+	uint32_t low;
+
+	__asm __volatile("rdmsr" : "=a" (low) : "c" (msr) : "edx");
+	return (low);
+}
+
+static __inline uint64_t
+rdpmc(u_int pmc)
+{
+	uint64_t rv;
+
+	__asm __volatile("rdpmc" : "=A" (rv) : "c" (pmc));
+	return (rv);
+}
+
+static __inline uint64_t
+rdtsc(void)
+{
+	uint64_t rv;
+
+	__asm __volatile("rdtsc" : "=A" (rv));
+	return (rv);
+}
+
+static __inline uint32_t
+rdtsc32(void)
+{
+	uint32_t rv;
+
+	__asm __volatile("rdtsc" : "=a" (rv) : : "edx");
+	return (rv);
+}
+
+#ifndef wbinvd
+static __inline void
+wbinvd(void)
+{
+	__asm __volatile("wbinvd");
+}
+#endif
+
+static __inline void
+write_eflags(u_int ef)
+{
+	__asm __volatile("pushl %0; popfl" : : "r" (ef));
+}
+
+static __inline void
+wrmsr(u_int msr, uint64_t newval)
+{
+	__asm __volatile("wrmsr" : : "A" (newval), "c" (msr));
+}
+
+static __inline void
+load_cr0(u_int data)
+{
+
+	__asm __volatile("movl %0,%%cr0" : : "r" (data));
+}
+
+static __inline u_int
+rcr0(void)
+{
+	u_int	data;
+
+	__asm __volatile("movl %%cr0,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline u_int
+rcr2(void)
+{
+	u_int	data;
+
+	__asm __volatile("movl %%cr2,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_cr3(u_int data)
+{
+
+	__asm __volatile("movl %0,%%cr3" : : "r" (data) : "memory");
+}
+
+static __inline u_int
+rcr3(void)
+{
+	u_int	data;
+
+	__asm __volatile("movl %%cr3,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_cr4(u_int data)
+{
+	__asm __volatile("movl %0,%%cr4" : : "r" (data));
+}
+
+static __inline u_int
+rcr4(void)
+{
+	u_int	data;
+
+	__asm __volatile("movl %%cr4,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline uint64_t
+rxcr(u_int reg)
+{
+	u_int low, high;
+
+	__asm __volatile("xgetbv" : "=a" (low), "=d" (high) : "c" (reg));
+	return (low | ((uint64_t)high << 32));
+}
+
+static __inline void
+load_xcr(u_int reg, uint64_t val)
+{
+	u_int low, high;
+
+	low = val;
+	high = val >> 32;
+	__asm __volatile("xsetbv" : : "c" (reg), "a" (low), "d" (high));
+}
+
+/*
+ * Global TLB flush (except for thise for pages marked PG_G)
+ */
+static __inline void
+invltlb(void)
+{
+
+	load_cr3(rcr3());
+}
+
+/*
+ * TLB flush for an individual page (even if it has PG_G).
+ * Only works on 486+ CPUs (i386 does not have PG_G).
+ */
+static __inline void
+invlpg(u_int addr)
+{
+
+	__asm __volatile("invlpg %0" : : "m" (*(char *)addr) : "memory");
+}
+
+static __inline u_short
+rfs(void)
+{
+	u_short sel;
+	__asm __volatile("movw %%fs,%0" : "=rm" (sel));
+	return (sel);
+}
+
+static __inline uint64_t
+rgdt(void)
+{
+	uint64_t gdtr;
+	__asm __volatile("sgdt %0" : "=m" (gdtr));
+	return (gdtr);
+}
+
+static __inline u_short
+rgs(void)
+{
+	u_short sel;
+	__asm __volatile("movw %%gs,%0" : "=rm" (sel));
+	return (sel);
+}
+
+static __inline uint64_t
+ridt(void)
+{
+	uint64_t idtr;
+	__asm __volatile("sidt %0" : "=m" (idtr));
+	return (idtr);
+}
+
+static __inline u_short
+rldt(void)
+{
+	u_short ldtr;
+	__asm __volatile("sldt %0" : "=g" (ldtr));
+	return (ldtr);
+}
+
+static __inline u_short
+rss(void)
+{
+	u_short sel;
+	__asm __volatile("movw %%ss,%0" : "=rm" (sel));
+	return (sel);
+}
+
+static __inline u_short
+rtr(void)
+{
+	u_short tr;
+	__asm __volatile("str %0" : "=g" (tr));
+	return (tr);
+}
+
+static __inline void
+load_fs(u_short sel)
+{
+	__asm __volatile("movw %0,%%fs" : : "rm" (sel));
+}
+
+static __inline void
+load_gs(u_short sel)
+{
+	__asm __volatile("movw %0,%%gs" : : "rm" (sel));
+}
+
+static __inline void
+lidt(struct region_descriptor *addr)
+{
+	__asm __volatile("lidt (%0)" : : "r" (addr));
+}
+
+static __inline void
+lldt(u_short sel)
+{
+	__asm __volatile("lldt %0" : : "r" (sel));
+}
+
+static __inline void
+ltr(u_short sel)
+{
+	__asm __volatile("ltr %0" : : "r" (sel));
+}
+
+static __inline u_int
+rdr0(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr0,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr0(u_int dr0)
+{
+	__asm __volatile("movl %0,%%dr0" : : "r" (dr0));
+}
+
+static __inline u_int
+rdr1(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr1,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr1(u_int dr1)
+{
+	__asm __volatile("movl %0,%%dr1" : : "r" (dr1));
+}
+
+static __inline u_int
+rdr2(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr2,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr2(u_int dr2)
+{
+	__asm __volatile("movl %0,%%dr2" : : "r" (dr2));
+}
+
+static __inline u_int
+rdr3(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr3,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr3(u_int dr3)
+{
+	__asm __volatile("movl %0,%%dr3" : : "r" (dr3));
+}
+
+static __inline u_int
+rdr4(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr4,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr4(u_int dr4)
+{
+	__asm __volatile("movl %0,%%dr4" : : "r" (dr4));
+}
+
+static __inline u_int
+rdr5(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr5,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr5(u_int dr5)
+{
+	__asm __volatile("movl %0,%%dr5" : : "r" (dr5));
+}
+
+static __inline u_int
+rdr6(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr6,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr6(u_int dr6)
+{
+	__asm __volatile("movl %0,%%dr6" : : "r" (dr6));
+}
+
+static __inline u_int
+rdr7(void)
+{
+	u_int	data;
+	__asm __volatile("movl %%dr7,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr7(u_int dr7)
+{
+	__asm __volatile("movl %0,%%dr7" : : "r" (dr7));
+}
+
+static __inline u_char
+read_cyrix_reg(u_char reg)
+{
+	outb(0x22, reg);
+	return inb(0x23);
+}
+
+static __inline void
+write_cyrix_reg(u_char reg, u_char data)
+{
+	outb(0x22, reg);
+	outb(0x23, data);
+}
+
+#ifndef __HAIKU__
+static __inline register_t
+intr_disable(void)
+{
+	register_t eflags;
+
+	eflags = read_eflags();
+	disable_intr();
+	return (eflags);
+}
+
+static __inline void
+intr_restore(register_t eflags)
+{
+	write_eflags(eflags);
+}
+#endif
+
+#else /* !(__GNUCLIKE_ASM && __CC_SUPPORTS___INLINE) */
+
+int	breakpoint(void);
+u_int	bsfl(u_int mask);
+u_int	bsrl(u_int mask);
+void	clflush(u_long addr);
+void	clts(void);
+void	cpuid_count(u_int ax, u_int cx, u_int *p);
+void	disable_intr(void);
+void	do_cpuid(u_int ax, u_int *p);
+void	enable_intr(void);
+void	halt(void);
+void	ia32_pause(void);
+u_char	inb(u_int port);
+u_int	inl(u_int port);
+void	insb(u_int port, void *addr, size_t count);
+void	insl(u_int port, void *addr, size_t count);
+void	insw(u_int port, void *addr, size_t count);
+register_t	intr_disable(void);
+void	intr_restore(register_t ef);
+void	invd(void);
+void	invlpg(u_int addr);
+void	invltlb(void);
+u_short	inw(u_int port);
+void	lidt(struct region_descriptor *addr);
+void	lldt(u_short sel);
+void	load_cr0(u_int cr0);
+void	load_cr3(u_int cr3);
+void	load_cr4(u_int cr4);
+void	load_dr0(u_int dr0);
+void	load_dr1(u_int dr1);
+void	load_dr2(u_int dr2);
+void	load_dr3(u_int dr3);
+void	load_dr4(u_int dr4);
+void	load_dr5(u_int dr5);
+void	load_dr6(u_int dr6);
+void	load_dr7(u_int dr7);
+void	load_fs(u_short sel);
+void	load_gs(u_short sel);
+void	ltr(u_short sel);
+void	outb(u_int port, u_char data);
+void	outl(u_int port, u_int data);
+void	outsb(u_int port, const void *addr, size_t count);
+void	outsl(u_int port, const void *addr, size_t count);
+void	outsw(u_int port, const void *addr, size_t count);
+void	outw(u_int port, u_short data);
+u_int	rcr0(void);
+u_int	rcr2(void);
+u_int	rcr3(void);
+u_int	rcr4(void);
+uint64_t rdmsr(u_int msr);
+uint64_t rdpmc(u_int pmc);
+u_int	rdr0(void);
+u_int	rdr1(void);
+u_int	rdr2(void);
+u_int	rdr3(void);
+u_int	rdr4(void);
+u_int	rdr5(void);
+u_int	rdr6(void);
+u_int	rdr7(void);
+uint64_t rdtsc(void);
+u_char	read_cyrix_reg(u_char reg);
+u_int	read_eflags(void);
+u_int	rfs(void);
+uint64_t rgdt(void);
+u_int	rgs(void);
+uint64_t ridt(void);
+u_short	rldt(void);
+u_short	rtr(void);
+void	wbinvd(void);
+void	write_cyrix_reg(u_char reg, u_char data);
+void	write_eflags(u_int ef);
+void	wrmsr(u_int msr, uint64_t newval);
+
+#endif	/* __GNUCLIKE_ASM && __CC_SUPPORTS___INLINE */
+
+void    reset_dbregs(void);
+
+#ifdef _KERNEL
+int	rdmsr_safe(u_int msr, uint64_t *val);
+int	wrmsr_safe(u_int msr, uint64_t newval);
+#endif
+
+#endif /* !_MACHINE_CPUFUNC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86_64/cpufunc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86_64/cpufunc.h
new file mode 100644
index 0000000000..53a9a5d489
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/machine/x86_64/cpufunc.h
@@ -0,0 +1,911 @@
+/*-
+ * Copyright (c) 2003 Peter Wemm.
+ * Copyright (c) 1993 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: releng/11.1/sys/amd64/include/cpufunc.h 313148 2017-02-03 12:03:10Z kib $
+ */
+
+/*
+ * Functions to provide access to special i386 instructions.
+ * This in included in sys/systm.h, and that file should be
+ * used in preference to this.
+ */
+
+#ifndef _MACHINE_CPUFUNC_H_
+#define	_MACHINE_CPUFUNC_H_
+
+struct region_descriptor;
+
+#define readb(va)	(*(volatile uint8_t *) (va))
+#define readw(va)	(*(volatile uint16_t *) (va))
+#define readl(va)	(*(volatile uint32_t *) (va))
+#define readq(va)	(*(volatile uint64_t *) (va))
+
+#define writeb(va, d)	(*(volatile uint8_t *) (va) = (d))
+#define writew(va, d)	(*(volatile uint16_t *) (va) = (d))
+#define writel(va, d)	(*(volatile uint32_t *) (va) = (d))
+#define writeq(va, d)	(*(volatile uint64_t *) (va) = (d))
+
+#if defined(__GNUCLIKE_ASM) && defined(__CC_SUPPORTS___INLINE)
+
+static __inline void
+breakpoint(void)
+{
+	__asm __volatile("int $3");
+}
+
+static __inline u_int
+bsfl(u_int mask)
+{
+	u_int	result;
+
+	__asm __volatile("bsfl %1,%0" : "=r" (result) : "rm" (mask));
+	return (result);
+}
+
+static __inline u_long
+bsfq(u_long mask)
+{
+	u_long	result;
+
+	__asm __volatile("bsfq %1,%0" : "=r" (result) : "rm" (mask));
+	return (result);
+}
+
+static __inline u_int
+bsrl(u_int mask)
+{
+	u_int	result;
+
+	__asm __volatile("bsrl %1,%0" : "=r" (result) : "rm" (mask));
+	return (result);
+}
+
+static __inline u_long
+bsrq(u_long mask)
+{
+	u_long	result;
+
+	__asm __volatile("bsrq %1,%0" : "=r" (result) : "rm" (mask));
+	return (result);
+}
+
+static __inline void
+clflush(u_long addr)
+{
+
+	__asm __volatile("clflush %0" : : "m" (*(char *)addr));
+}
+
+static __inline void
+clflushopt(u_long addr)
+{
+
+	__asm __volatile(".byte 0x66;clflush %0" : : "m" (*(char *)addr));
+}
+
+static __inline void
+clts(void)
+{
+
+	__asm __volatile("clts");
+}
+
+static __inline void
+disable_intr(void)
+{
+	__asm __volatile("cli" : : : "memory");
+}
+
+static __inline void
+do_cpuid(u_int ax, u_int *p)
+{
+	__asm __volatile("cpuid"
+			 : "=a" (p[0]), "=b" (p[1]), "=c" (p[2]), "=d" (p[3])
+			 :  "0" (ax));
+}
+
+static __inline void
+cpuid_count(u_int ax, u_int cx, u_int *p)
+{
+	__asm __volatile("cpuid"
+			 : "=a" (p[0]), "=b" (p[1]), "=c" (p[2]), "=d" (p[3])
+			 :  "0" (ax), "c" (cx));
+}
+
+static __inline void
+enable_intr(void)
+{
+	__asm __volatile("sti");
+}
+
+#ifdef _KERNEL
+
+#define	HAVE_INLINE_FFS
+#define        ffs(x)  __builtin_ffs(x)
+
+#define	HAVE_INLINE_FFSL
+
+static __inline int
+ffsl(long mask)
+{
+	return (mask == 0 ? mask : (int)bsfq((u_long)mask) + 1);
+}
+
+#define	HAVE_INLINE_FFSLL
+
+static __inline int
+ffsll(long long mask)
+{
+	return (ffsl((long)mask));
+}
+
+#define	HAVE_INLINE_FLS
+
+static __inline int
+fls(int mask)
+{
+	return (mask == 0 ? mask : (int)bsrl((u_int)mask) + 1);
+}
+
+#define	HAVE_INLINE_FLSL
+
+static __inline int
+flsl(long mask)
+{
+	return (mask == 0 ? mask : (int)bsrq((u_long)mask) + 1);
+}
+
+#define	HAVE_INLINE_FLSLL
+
+static __inline int
+flsll(long long mask)
+{
+	return (flsl((long)mask));
+}
+
+#endif /* _KERNEL */
+
+static __inline void
+halt(void)
+{
+	__asm __volatile("hlt");
+}
+
+static __inline u_char
+inb(u_int port)
+{
+	u_char	data;
+
+	__asm __volatile("inb %w1, %0" : "=a" (data) : "Nd" (port));
+	return (data);
+}
+
+static __inline u_int
+inl(u_int port)
+{
+	u_int	data;
+
+	__asm __volatile("inl %w1, %0" : "=a" (data) : "Nd" (port));
+	return (data);
+}
+
+static __inline void
+insb(u_int port, void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; insb"
+			 : "+D" (addr), "+c" (count)
+			 : "d" (port)
+			 : "memory");
+}
+
+static __inline void
+insw(u_int port, void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; insw"
+			 : "+D" (addr), "+c" (count)
+			 : "d" (port)
+			 : "memory");
+}
+
+static __inline void
+insl(u_int port, void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; insl"
+			 : "+D" (addr), "+c" (count)
+			 : "d" (port)
+			 : "memory");
+}
+
+static __inline void
+invd(void)
+{
+	__asm __volatile("invd");
+}
+
+static __inline u_short
+inw(u_int port)
+{
+	u_short	data;
+
+	__asm __volatile("inw %w1, %0" : "=a" (data) : "Nd" (port));
+	return (data);
+}
+
+static __inline void
+outb(u_int port, u_char data)
+{
+	__asm __volatile("outb %0, %w1" : : "a" (data), "Nd" (port));
+}
+
+static __inline void
+outl(u_int port, u_int data)
+{
+	__asm __volatile("outl %0, %w1" : : "a" (data), "Nd" (port));
+}
+
+static __inline void
+outsb(u_int port, const void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; outsb"
+			 : "+S" (addr), "+c" (count)
+			 : "d" (port));
+}
+
+static __inline void
+outsw(u_int port, const void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; outsw"
+			 : "+S" (addr), "+c" (count)
+			 : "d" (port));
+}
+
+static __inline void
+outsl(u_int port, const void *addr, size_t count)
+{
+	__asm __volatile("cld; rep; outsl"
+			 : "+S" (addr), "+c" (count)
+			 : "d" (port));
+}
+
+static __inline void
+outw(u_int port, u_short data)
+{
+	__asm __volatile("outw %0, %w1" : : "a" (data), "Nd" (port));
+}
+
+static __inline u_long
+popcntq(u_long mask)
+{
+	u_long result;
+
+	__asm __volatile("popcntq %1,%0" : "=r" (result) : "rm" (mask));
+	return (result);
+}
+
+static __inline void
+lfence(void)
+{
+
+	__asm __volatile("lfence" : : : "memory");
+}
+
+static __inline void
+mfence(void)
+{
+
+	__asm __volatile("mfence" : : : "memory");
+}
+
+static __inline void
+sfence(void)
+{
+
+	__asm __volatile("sfence" : : : "memory");
+}
+
+static __inline void
+ia32_pause(void)
+{
+	__asm __volatile("pause");
+}
+
+static __inline u_long
+read_rflags(void)
+{
+	u_long	rf;
+
+	__asm __volatile("pushfq; popq %0" : "=r" (rf));
+	return (rf);
+}
+
+static __inline uint64_t
+rdmsr(u_int msr)
+{
+	uint32_t low, high;
+
+	__asm __volatile("rdmsr" : "=a" (low), "=d" (high) : "c" (msr));
+	return (low | ((uint64_t)high << 32));
+}
+
+static __inline uint32_t
+rdmsr32(u_int msr)
+{
+	uint32_t low;
+
+	__asm __volatile("rdmsr" : "=a" (low) : "c" (msr) : "rdx");
+	return (low);
+}
+
+static __inline uint64_t
+rdpmc(u_int pmc)
+{
+	uint32_t low, high;
+
+	__asm __volatile("rdpmc" : "=a" (low), "=d" (high) : "c" (pmc));
+	return (low | ((uint64_t)high << 32));
+}
+
+static __inline uint64_t
+rdtsc(void)
+{
+	uint32_t low, high;
+
+	__asm __volatile("rdtsc" : "=a" (low), "=d" (high));
+	return (low | ((uint64_t)high << 32));
+}
+
+static __inline uint32_t
+rdtsc32(void)
+{
+	uint32_t rv;
+
+	__asm __volatile("rdtsc" : "=a" (rv) : : "edx");
+	return (rv);
+}
+
+#ifndef wbinvd
+static __inline void
+wbinvd(void)
+{
+	__asm __volatile("wbinvd");
+}
+#endif
+
+static __inline void
+write_rflags(u_long rf)
+{
+	__asm __volatile("pushq %0;  popfq" : : "r" (rf));
+}
+
+static __inline void
+wrmsr(u_int msr, uint64_t newval)
+{
+	uint32_t low, high;
+
+	low = newval;
+	high = newval >> 32;
+	__asm __volatile("wrmsr" : : "a" (low), "d" (high), "c" (msr));
+}
+
+static __inline void
+load_cr0(u_long data)
+{
+
+	__asm __volatile("movq %0,%%cr0" : : "r" (data));
+}
+
+static __inline u_long
+rcr0(void)
+{
+	u_long	data;
+
+	__asm __volatile("movq %%cr0,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline u_long
+rcr2(void)
+{
+	u_long	data;
+
+	__asm __volatile("movq %%cr2,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_cr3(u_long data)
+{
+
+	__asm __volatile("movq %0,%%cr3" : : "r" (data) : "memory");
+}
+
+static __inline u_long
+rcr3(void)
+{
+	u_long	data;
+
+	__asm __volatile("movq %%cr3,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_cr4(u_long data)
+{
+	__asm __volatile("movq %0,%%cr4" : : "r" (data));
+}
+
+static __inline u_long
+rcr4(void)
+{
+	u_long	data;
+
+	__asm __volatile("movq %%cr4,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline u_long
+rxcr(u_int reg)
+{
+	u_int low, high;
+
+	__asm __volatile("xgetbv" : "=a" (low), "=d" (high) : "c" (reg));
+	return (low | ((uint64_t)high << 32));
+}
+
+static __inline void
+load_xcr(u_int reg, u_long val)
+{
+	u_int low, high;
+
+	low = val;
+	high = val >> 32;
+	__asm __volatile("xsetbv" : : "c" (reg), "a" (low), "d" (high));
+}
+
+/*
+ * Global TLB flush (except for thise for pages marked PG_G)
+ */
+static __inline void
+invltlb(void)
+{
+
+	load_cr3(rcr3());
+}
+
+#ifndef CR4_PGE
+#define	CR4_PGE	0x00000080	/* Page global enable */
+#endif
+
+/*
+ * Perform the guaranteed invalidation of all TLB entries.  This
+ * includes the global entries, and entries in all PCIDs, not only the
+ * current context.  The function works both on non-PCID CPUs and CPUs
+ * with the PCID turned off or on.  See IA-32 SDM Vol. 3a 4.10.4.1
+ * Operations that Invalidate TLBs and Paging-Structure Caches.
+ */
+static __inline void
+invltlb_glob(void)
+{
+	uint64_t cr4;
+
+	cr4 = rcr4();
+	load_cr4(cr4 & ~CR4_PGE);
+	/*
+	 * Although preemption at this point could be detrimental to
+	 * performance, it would not lead to an error.  PG_G is simply
+	 * ignored if CR4.PGE is clear.  Moreover, in case this block
+	 * is re-entered, the load_cr4() either above or below will
+	 * modify CR4.PGE flushing the TLB.
+	 */
+	load_cr4(cr4 | CR4_PGE);
+}
+
+/*
+ * TLB flush for an individual page (even if it has PG_G).
+ * Only works on 486+ CPUs (i386 does not have PG_G).
+ */
+static __inline void
+invlpg(u_long addr)
+{
+
+	__asm __volatile("invlpg %0" : : "m" (*(char *)addr) : "memory");
+}
+
+#define	INVPCID_ADDR	0
+#define	INVPCID_CTX	1
+#define	INVPCID_CTXGLOB	2
+#define	INVPCID_ALLCTX	3
+
+struct invpcid_descr {
+	uint64_t	pcid:12 __packed;
+	uint64_t	pad:52 __packed;
+	uint64_t	addr;
+} __packed;
+
+static __inline void
+invpcid(struct invpcid_descr *d, int type)
+{
+
+	__asm __volatile("invpcid (%0),%1"
+	    : : "r" (d), "r" ((u_long)type) : "memory");
+}
+
+static __inline u_short
+rfs(void)
+{
+	u_short sel;
+	__asm __volatile("movw %%fs,%0" : "=rm" (sel));
+	return (sel);
+}
+
+static __inline u_short
+rgs(void)
+{
+	u_short sel;
+	__asm __volatile("movw %%gs,%0" : "=rm" (sel));
+	return (sel);
+}
+
+static __inline u_short
+rss(void)
+{
+	u_short sel;
+	__asm __volatile("movw %%ss,%0" : "=rm" (sel));
+	return (sel);
+}
+
+static __inline void
+load_ds(u_short sel)
+{
+	__asm __volatile("movw %0,%%ds" : : "rm" (sel));
+}
+
+static __inline void
+load_es(u_short sel)
+{
+	__asm __volatile("movw %0,%%es" : : "rm" (sel));
+}
+
+static __inline void
+cpu_monitor(const void *addr, u_long extensions, u_int hints)
+{
+
+	__asm __volatile("monitor"
+	    : : "a" (addr), "c" (extensions), "d" (hints));
+}
+
+static __inline void
+cpu_mwait(u_long extensions, u_int hints)
+{
+
+	__asm __volatile("mwait" : : "a" (hints), "c" (extensions));
+}
+
+#ifdef _KERNEL
+/* This is defined in <machine/specialreg.h> but is too painful to get to */
+#ifndef	MSR_FSBASE
+#define	MSR_FSBASE	0xc0000100
+#endif
+static __inline void
+load_fs(u_short sel)
+{
+	/* Preserve the fsbase value across the selector load */
+	__asm __volatile("rdmsr; movw %0,%%fs; wrmsr"
+	    : : "rm" (sel), "c" (MSR_FSBASE) : "eax", "edx");
+}
+
+#ifndef	MSR_GSBASE
+#define	MSR_GSBASE	0xc0000101
+#endif
+static __inline void
+load_gs(u_short sel)
+{
+	/*
+	 * Preserve the gsbase value across the selector load.
+	 * Note that we have to disable interrupts because the gsbase
+	 * being trashed happens to be the kernel gsbase at the time.
+	 */
+	__asm __volatile("pushfq; cli; rdmsr; movw %0,%%gs; wrmsr; popfq"
+	    : : "rm" (sel), "c" (MSR_GSBASE) : "eax", "edx");
+}
+#else
+/* Usable by userland */
+static __inline void
+load_fs(u_short sel)
+{
+	__asm __volatile("movw %0,%%fs" : : "rm" (sel));
+}
+
+static __inline void
+load_gs(u_short sel)
+{
+	__asm __volatile("movw %0,%%gs" : : "rm" (sel));
+}
+#endif
+
+static __inline void
+bare_lgdt(struct region_descriptor *addr)
+{
+	__asm __volatile("lgdt (%0)" : : "r" (addr));
+}
+
+static __inline void
+sgdt(struct region_descriptor *addr)
+{
+	char *loc;
+
+	loc = (char *)addr;
+	__asm __volatile("sgdt %0" : "=m" (*loc) : : "memory");
+}
+
+static __inline void
+lidt(struct region_descriptor *addr)
+{
+	__asm __volatile("lidt (%0)" : : "r" (addr));
+}
+
+static __inline void
+sidt(struct region_descriptor *addr)
+{
+	char *loc;
+
+	loc = (char *)addr;
+	__asm __volatile("sidt %0" : "=m" (*loc) : : "memory");
+}
+
+static __inline void
+lldt(u_short sel)
+{
+	__asm __volatile("lldt %0" : : "r" (sel));
+}
+
+static __inline void
+ltr(u_short sel)
+{
+	__asm __volatile("ltr %0" : : "r" (sel));
+}
+
+static __inline uint32_t
+read_tr(void)
+{
+	u_short sel;
+
+	__asm __volatile("str %0" : "=r" (sel));
+	return (sel);
+}
+
+static __inline uint64_t
+rdr0(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr0,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr0(uint64_t dr0)
+{
+	__asm __volatile("movq %0,%%dr0" : : "r" (dr0));
+}
+
+static __inline uint64_t
+rdr1(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr1,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr1(uint64_t dr1)
+{
+	__asm __volatile("movq %0,%%dr1" : : "r" (dr1));
+}
+
+static __inline uint64_t
+rdr2(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr2,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr2(uint64_t dr2)
+{
+	__asm __volatile("movq %0,%%dr2" : : "r" (dr2));
+}
+
+static __inline uint64_t
+rdr3(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr3,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr3(uint64_t dr3)
+{
+	__asm __volatile("movq %0,%%dr3" : : "r" (dr3));
+}
+
+static __inline uint64_t
+rdr4(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr4,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr4(uint64_t dr4)
+{
+	__asm __volatile("movq %0,%%dr4" : : "r" (dr4));
+}
+
+static __inline uint64_t
+rdr5(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr5,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr5(uint64_t dr5)
+{
+	__asm __volatile("movq %0,%%dr5" : : "r" (dr5));
+}
+
+static __inline uint64_t
+rdr6(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr6,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr6(uint64_t dr6)
+{
+	__asm __volatile("movq %0,%%dr6" : : "r" (dr6));
+}
+
+static __inline uint64_t
+rdr7(void)
+{
+	uint64_t data;
+	__asm __volatile("movq %%dr7,%0" : "=r" (data));
+	return (data);
+}
+
+static __inline void
+load_dr7(uint64_t dr7)
+{
+	__asm __volatile("movq %0,%%dr7" : : "r" (dr7));
+}
+
+#ifndef __HAIKU__
+static __inline register_t
+intr_disable(void)
+{
+	register_t rflags;
+
+	rflags = read_rflags();
+	disable_intr();
+	return (rflags);
+}
+
+static __inline void
+intr_restore(register_t rflags)
+{
+	write_rflags(rflags);
+}
+#endif
+
+#else /* !(__GNUCLIKE_ASM && __CC_SUPPORTS___INLINE) */
+
+int	breakpoint(void);
+u_int	bsfl(u_int mask);
+u_int	bsrl(u_int mask);
+void	clflush(u_long addr);
+void	clts(void);
+void	cpuid_count(u_int ax, u_int cx, u_int *p);
+void	disable_intr(void);
+void	do_cpuid(u_int ax, u_int *p);
+void	enable_intr(void);
+void	halt(void);
+void	ia32_pause(void);
+u_char	inb(u_int port);
+u_int	inl(u_int port);
+void	insb(u_int port, void *addr, size_t count);
+void	insl(u_int port, void *addr, size_t count);
+void	insw(u_int port, void *addr, size_t count);
+register_t	intr_disable(void);
+void	intr_restore(register_t rf);
+void	invd(void);
+void	invlpg(u_int addr);
+void	invltlb(void);
+u_short	inw(u_int port);
+void	lidt(struct region_descriptor *addr);
+void	lldt(u_short sel);
+void	load_cr0(u_long cr0);
+void	load_cr3(u_long cr3);
+void	load_cr4(u_long cr4);
+void	load_dr0(uint64_t dr0);
+void	load_dr1(uint64_t dr1);
+void	load_dr2(uint64_t dr2);
+void	load_dr3(uint64_t dr3);
+void	load_dr4(uint64_t dr4);
+void	load_dr5(uint64_t dr5);
+void	load_dr6(uint64_t dr6);
+void	load_dr7(uint64_t dr7);
+void	load_fs(u_short sel);
+void	load_gs(u_short sel);
+void	ltr(u_short sel);
+void	outb(u_int port, u_char data);
+void	outl(u_int port, u_int data);
+void	outsb(u_int port, const void *addr, size_t count);
+void	outsl(u_int port, const void *addr, size_t count);
+void	outsw(u_int port, const void *addr, size_t count);
+void	outw(u_int port, u_short data);
+u_long	rcr0(void);
+u_long	rcr2(void);
+u_long	rcr3(void);
+u_long	rcr4(void);
+uint64_t rdmsr(u_int msr);
+uint32_t rdmsr32(u_int msr);
+uint64_t rdpmc(u_int pmc);
+uint64_t rdr0(void);
+uint64_t rdr1(void);
+uint64_t rdr2(void);
+uint64_t rdr3(void);
+uint64_t rdr4(void);
+uint64_t rdr5(void);
+uint64_t rdr6(void);
+uint64_t rdr7(void);
+uint64_t rdtsc(void);
+u_long	read_rflags(void);
+u_int	rfs(void);
+u_int	rgs(void);
+void	wbinvd(void);
+void	write_rflags(u_int rf);
+void	wrmsr(u_int msr, uint64_t newval);
+
+#endif	/* __GNUCLIKE_ASM && __CC_SUPPORTS___INLINE */
+
+void	reset_dbregs(void);
+
+#ifdef _KERNEL
+int	rdmsr_safe(u_int msr, uint64_t *val);
+int	wrmsr_safe(u_int msr, uint64_t newval);
+#endif
+
+#endif /* !_MACHINE_CPUFUNC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/miibus_if.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/miibus_if.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/bpf.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/bpf.h
new file mode 100644
index 0000000000..c822dc0664
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/bpf.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NET_BPF_H_
+#define _FBSD_COMPAT_NET_BPF_H_
+
+
+#define DLT_EN10MB		1		/* Ethernet (10Mb) */
+#define DLT_IEEE802_11	105		/* IEEE 802.11 wireless */
+
+
+struct bpf_if;
+
+
+#define bpf_mtap(bpf_if, mbuf) do { } while (0)
+#define BPF_MTAP(ifp, m) do { } while (0)
+#define BPF_TAP(ifp, pkt, pktlen) do { } while (0)
+#define bpf_mtap2(bpf_if, data, dlen, mbuf) do { } while (0)
+#define bpfattach(ifnet, dlt, hdrlen) do { } while (0);
+#define bpfattach2(ifnet, dlt, hdrlen, bpf_if) do { } while (0)
+#define bpfdetach(ifnet) do { } while (0);
+
+
+static inline int
+bpf_peers_present(struct bpf_if *bpf)
+{
+	return 0;
+}
+
+#endif	/* _FBSD_COMPAT_NET_BPF_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/ethernet.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/ethernet.h
new file mode 100644
index 0000000000..e80033a886
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/ethernet.h
@@ -0,0 +1,409 @@
+/*
+ * Fundamental constants relating to ethernet.
+ *
+ * $FreeBSD: src/sys/net/ethernet.h,v 1.32 2007/05/29 12:40:45 yar Exp $
+ *
+ */
+#ifndef _FBSD_COMPAT_NET_ETHERNET_H_
+#define _FBSD_COMPAT_NET_ETHERNET_H_
+
+
+/*
+ * Somce basic Ethernet constants.
+ */
+#define	ETHER_ADDR_LEN		6	/* length of an Ethernet address */
+#define	ETHER_TYPE_LEN		2	/* length of the Ethernet type field */
+#define	ETHER_CRC_LEN		4	/* length of the Ethernet CRC */
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN*2+ETHER_TYPE_LEN)
+#define	ETHER_MIN_LEN		64	/* minimum frame len, including CRC */
+#define	ETHER_MAX_LEN		1518	/* maximum frame len, including CRC */
+#define	ETHER_MAX_LEN_JUMBO	9018	/* max jumbo frame len, including CRC */
+
+#define	ETHER_VLAN_ENCAP_LEN	4	/* len of 802.1Q VLAN encapsulation */
+/*
+ * Mbuf adjust factor to force 32-bit alignment of IP header.
+ * Drivers should do m_adj(m, ETHER_ALIGN) when setting up a
+ * receive so the upper layers get the IP header properly aligned
+ * past the 14-byte Ethernet header.
+ */
+#define	ETHER_ALIGN		2	/* driver adjust for IP hdr alignment */
+
+/*
+ * Compute the maximum frame size based on ethertype (i.e. possible
+ * encapsulation) and whether or not an FCS is present.
+ */
+#define	ETHER_MAX_FRAME(ifp, etype, hasfcs)				\
+	((ifp)->if_mtu + ETHER_HDR_LEN +				\
+	 ((hasfcs) ? ETHER_CRC_LEN : 0) +				\
+	 (((etype) == ETHERTYPE_VLAN) ? ETHER_VLAN_ENCAP_LEN : 0))
+
+/*
+ * Ethernet-specific mbuf flags.
+ */
+#define	M_HASFCS	M_PROTO5	/* FCS included at end of frame */
+
+/*
+ * Ethernet CRC32 polynomials (big- and little-endian verions).
+ */
+#define	ETHER_CRC_POLY_LE	0xedb88320
+#define	ETHER_CRC_POLY_BE	0x04c11db6
+
+/*
+ * A macro to validate a length with
+ */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+static const u_char etherbroadcastaddr[ETHER_ADDR_LEN] =
+	{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
+/*
+ * Structure of a 10Mb/s Ethernet header.
+ */
+struct ether_header {
+	u_char	ether_dhost[ETHER_ADDR_LEN];
+	u_char	ether_shost[ETHER_ADDR_LEN];
+	u_short	ether_type;
+} __packed;
+
+/*
+ * Structure of a 48-bit Ethernet address.
+ */
+struct ether_addr {
+	u_char octet[ETHER_ADDR_LEN];
+} __packed;
+
+#ifdef CTASSERT
+CTASSERT(sizeof (struct ether_header) == ETHER_ADDR_LEN * 2 + 2);
+CTASSERT(sizeof (struct ether_addr) == ETHER_ADDR_LEN);
+#endif
+
+#define	ETHER_IS_MULTICAST(addr) (*(addr) & 0x01) /* is address mcast/bcast? */
+#define	ETHER_IS_BROADCAST(addr) \
+	(((addr)[0] & (addr)[1] & (addr)[2] & \
+	  (addr)[3] & (addr)[4] & (addr)[5]) == 0xff)
+
+/*
+ *  NOTE: 0x0000-0x05DC (0..1500) are generally IEEE 802.3 length fields.
+ *  However, there are some conflicts.
+ */
+
+#define	ETHERTYPE_8023		0x0004	/* IEEE 802.3 packet */
+		   /* 0x0101 .. 0x1FF	   Experimental */
+#define	ETHERTYPE_PUP		0x0200	/* Xerox PUP protocol - see 0A00 */
+#define	ETHERTYPE_PUPAT		0x0200	/* PUP Address Translation - see 0A01 */
+#define	ETHERTYPE_SPRITE	0x0500	/* ??? */
+			     /* 0x0400	   Nixdorf */
+#define	ETHERTYPE_NS		0x0600	/* XNS */
+#define	ETHERTYPE_NSAT		0x0601	/* XNS Address Translation (3Mb only) */
+#define	ETHERTYPE_DLOG1 	0x0660	/* DLOG (?) */
+#define	ETHERTYPE_DLOG2 	0x0661	/* DLOG (?) */
+#define	ETHERTYPE_IP		0x0800	/* IP protocol */
+#define	ETHERTYPE_X75		0x0801	/* X.75 Internet */
+#define	ETHERTYPE_NBS		0x0802	/* NBS Internet */
+#define	ETHERTYPE_ECMA		0x0803	/* ECMA Internet */
+#define	ETHERTYPE_CHAOS 	0x0804	/* CHAOSnet */
+#define	ETHERTYPE_X25		0x0805	/* X.25 Level 3 */
+#define	ETHERTYPE_ARP		0x0806	/* Address resolution protocol */
+#define	ETHERTYPE_NSCOMPAT	0x0807	/* XNS Compatibility */
+#define	ETHERTYPE_FRARP 	0x0808	/* Frame Relay ARP (RFC1701) */
+			     /* 0x081C	   Symbolics Private */
+		    /* 0x0888 - 0x088A	   Xyplex */
+#define	ETHERTYPE_UBDEBUG	0x0900	/* Ungermann-Bass network debugger */
+#define	ETHERTYPE_IEEEPUP	0x0A00	/* Xerox IEEE802.3 PUP */
+#define	ETHERTYPE_IEEEPUPAT	0x0A01	/* Xerox IEEE802.3 PUP Address Translation */
+#define	ETHERTYPE_VINES 	0x0BAD	/* Banyan VINES */
+#define	ETHERTYPE_VINESLOOP	0x0BAE	/* Banyan VINES Loopback */
+#define	ETHERTYPE_VINESECHO	0x0BAF	/* Banyan VINES Echo */
+
+/*		       0x1000 - 0x100F	   Berkeley Trailer */
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000	/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERTYPE_DCA		0x1234	/* DCA - Multicast */
+#define	ETHERTYPE_VALID 	0x1600	/* VALID system protocol */
+#define	ETHERTYPE_DOGFIGHT	0x1989	/* Artificial Horizons ("Aviator" dogfight simulator [on Sun]) */
+#define	ETHERTYPE_RCL		0x1995	/* Datapoint Corporation (RCL lan protocol) */
+
+					/* The following 3C0x types
+					   are unregistered: */
+#define	ETHERTYPE_NBPVCD	0x3C00	/* 3Com NBP virtual circuit datagram (like XNS SPP) not registered */
+#define	ETHERTYPE_NBPSCD	0x3C01	/* 3Com NBP System control datagram not registered */
+#define	ETHERTYPE_NBPCREQ	0x3C02	/* 3Com NBP Connect request (virtual cct) not registered */
+#define	ETHERTYPE_NBPCRSP	0x3C03	/* 3Com NBP Connect repsonse not registered */
+#define	ETHERTYPE_NBPCC		0x3C04	/* 3Com NBP Connect complete not registered */
+#define	ETHERTYPE_NBPCLREQ	0x3C05	/* 3Com NBP Close request (virtual cct) not registered */
+#define	ETHERTYPE_NBPCLRSP	0x3C06	/* 3Com NBP Close response not registered */
+#define	ETHERTYPE_NBPDG		0x3C07	/* 3Com NBP Datagram (like XNS IDP) not registered */
+#define	ETHERTYPE_NBPDGB	0x3C08	/* 3Com NBP Datagram broadcast not registered */
+#define	ETHERTYPE_NBPCLAIM	0x3C09	/* 3Com NBP Claim NetBIOS name not registered */
+#define	ETHERTYPE_NBPDLTE	0x3C0A	/* 3Com NBP Delete Netbios name not registered */
+#define	ETHERTYPE_NBPRAS	0x3C0B	/* 3Com NBP Remote adaptor status request not registered */
+#define	ETHERTYPE_NBPRAR	0x3C0C	/* 3Com NBP Remote adaptor response not registered */
+#define	ETHERTYPE_NBPRST	0x3C0D	/* 3Com NBP Reset not registered */
+
+#define	ETHERTYPE_PCS		0x4242	/* PCS Basic Block Protocol */
+#define	ETHERTYPE_IMLBLDIAG	0x424C	/* Information Modes Little Big LAN diagnostic */
+#define	ETHERTYPE_DIDDLE	0x4321	/* THD - Diddle */
+#define	ETHERTYPE_IMLBL		0x4C42	/* Information Modes Little Big LAN */
+#define	ETHERTYPE_SIMNET	0x5208	/* BBN Simnet Private */
+#define	ETHERTYPE_DECEXPER	0x6000	/* DEC Unassigned, experimental */
+#define	ETHERTYPE_MOPDL		0x6001	/* DEC MOP dump/load */
+#define	ETHERTYPE_MOPRC		0x6002	/* DEC MOP remote console */
+#define	ETHERTYPE_DECnet	0x6003	/* DEC DECNET Phase IV route */
+#define	ETHERTYPE_DN		ETHERTYPE_DECnet	/* libpcap, tcpdump */
+#define	ETHERTYPE_LAT		0x6004	/* DEC LAT */
+#define	ETHERTYPE_DECDIAG	0x6005	/* DEC diagnostic protocol (at interface initialization?) */
+#define	ETHERTYPE_DECCUST	0x6006	/* DEC customer protocol */
+#define	ETHERTYPE_SCA		0x6007	/* DEC LAVC, SCA */
+#define	ETHERTYPE_AMBER		0x6008	/* DEC AMBER */
+#define	ETHERTYPE_DECMUMPS	0x6009	/* DEC MUMPS */
+		    /* 0x6010 - 0x6014	   3Com Corporation */
+#define	ETHERTYPE_TRANSETHER	0x6558	/* Trans Ether Bridging (RFC1701)*/
+#define	ETHERTYPE_RAWFR		0x6559	/* Raw Frame Relay (RFC1701) */
+#define	ETHERTYPE_UBDL		0x7000	/* Ungermann-Bass download */
+#define	ETHERTYPE_UBNIU		0x7001	/* Ungermann-Bass NIUs */
+#define	ETHERTYPE_UBDIAGLOOP	0x7002	/* Ungermann-Bass diagnostic/loopback */
+#define	ETHERTYPE_UBNMC		0x7003	/* Ungermann-Bass ??? (NMC to/from UB Bridge) */
+#define	ETHERTYPE_UBBST		0x7005	/* Ungermann-Bass Bridge Spanning Tree */
+#define	ETHERTYPE_OS9		0x7007	/* OS/9 Microware */
+#define	ETHERTYPE_OS9NET	0x7009	/* OS/9 Net? */
+		    /* 0x7020 - 0x7029	   LRT (England) (now Sintrom) */
+#define	ETHERTYPE_RACAL		0x7030	/* Racal-Interlan */
+#define	ETHERTYPE_PRIMENTS	0x7031	/* Prime NTS (Network Terminal Service) */
+#define	ETHERTYPE_CABLETRON	0x7034	/* Cabletron */
+#define	ETHERTYPE_CRONUSVLN	0x8003	/* Cronus VLN */
+#define	ETHERTYPE_CRONUS	0x8004	/* Cronus Direct */
+#define	ETHERTYPE_HP		0x8005	/* HP Probe */
+#define	ETHERTYPE_NESTAR	0x8006	/* Nestar */
+#define	ETHERTYPE_ATTSTANFORD	0x8008	/* AT&T/Stanford (local use) */
+#define	ETHERTYPE_EXCELAN	0x8010	/* Excelan */
+#define	ETHERTYPE_SG_DIAG	0x8013	/* SGI diagnostic type */
+#define	ETHERTYPE_SG_NETGAMES	0x8014	/* SGI network games */
+#define	ETHERTYPE_SG_RESV	0x8015	/* SGI reserved type */
+#define	ETHERTYPE_SG_BOUNCE	0x8016	/* SGI bounce server */
+#define	ETHERTYPE_APOLLODOMAIN	0x8019	/* Apollo DOMAIN */
+#define	ETHERTYPE_TYMSHARE	0x802E	/* Tymeshare */
+#define	ETHERTYPE_TIGAN		0x802F	/* Tigan, Inc. */
+#define	ETHERTYPE_REVARP	0x8035	/* Reverse addr resolution protocol */
+#define	ETHERTYPE_AEONIC	0x8036	/* Aeonic Systems */
+#define	ETHERTYPE_IPXNEW	0x8037	/* IPX (Novell Netware?) */
+#define	ETHERTYPE_LANBRIDGE	0x8038	/* DEC LANBridge */
+#define	ETHERTYPE_DSMD	0x8039	/* DEC DSM/DDP */
+#define	ETHERTYPE_ARGONAUT	0x803A	/* DEC Argonaut Console */
+#define	ETHERTYPE_VAXELN	0x803B	/* DEC VAXELN */
+#define	ETHERTYPE_DECDNS	0x803C	/* DEC DNS Naming Service */
+#define	ETHERTYPE_ENCRYPT	0x803D	/* DEC Ethernet Encryption */
+#define	ETHERTYPE_DECDTS	0x803E	/* DEC Distributed Time Service */
+#define	ETHERTYPE_DECLTM	0x803F	/* DEC LAN Traffic Monitor */
+#define	ETHERTYPE_DECNETBIOS	0x8040	/* DEC PATHWORKS DECnet NETBIOS Emulation */
+#define	ETHERTYPE_DECLAST	0x8041	/* DEC Local Area System Transport */
+			     /* 0x8042	   DEC Unassigned */
+#define	ETHERTYPE_PLANNING	0x8044	/* Planning Research Corp. */
+		    /* 0x8046 - 0x8047	   AT&T */
+#define	ETHERTYPE_DECAM		0x8048	/* DEC Availability Manager for Distributed Systems DECamds (but someone at DEC says not) */
+#define	ETHERTYPE_EXPERDATA	0x8049	/* ExperData */
+#define	ETHERTYPE_VEXP		0x805B	/* Stanford V Kernel exp. */
+#define	ETHERTYPE_VPROD		0x805C	/* Stanford V Kernel prod. */
+#define	ETHERTYPE_ES		0x805D	/* Evans & Sutherland */
+#define	ETHERTYPE_LITTLE	0x8060	/* Little Machines */
+#define	ETHERTYPE_COUNTERPOINT	0x8062	/* Counterpoint Computers */
+		    /* 0x8065 - 0x8066	   Univ. of Mass @ Amherst */
+#define	ETHERTYPE_VEECO		0x8067	/* Veeco Integrated Auto. */
+#define	ETHERTYPE_GENDYN	0x8068	/* General Dynamics */
+#define	ETHERTYPE_ATT		0x8069	/* AT&T */
+#define	ETHERTYPE_AUTOPHON	0x806A	/* Autophon */
+#define	ETHERTYPE_COMDESIGN	0x806C	/* ComDesign */
+#define	ETHERTYPE_COMPUGRAPHIC	0x806D	/* Compugraphic Corporation */
+		    /* 0x806E - 0x8077	   Landmark Graphics Corp. */
+#define	ETHERTYPE_MATRA		0x807A	/* Matra */
+#define	ETHERTYPE_DDE		0x807B	/* Dansk Data Elektronik */
+#define	ETHERTYPE_MERIT		0x807C	/* Merit Internodal (or Univ of Michigan?) */
+		    /* 0x807D - 0x807F	   Vitalink Communications */
+#define	ETHERTYPE_VLTLMAN	0x8080	/* Vitalink TransLAN III Management */
+		    /* 0x8081 - 0x8083	   Counterpoint Computers */
+		    /* 0x8088 - 0x808A	   Xyplex */
+#define	ETHERTYPE_ATALK		0x809B	/* AppleTalk */
+#define	ETHERTYPE_AT		ETHERTYPE_ATALK		/* old NetBSD */
+#define	ETHERTYPE_APPLETALK	ETHERTYPE_ATALK		/* HP-UX */
+		    /* 0x809C - 0x809E	   Datability */
+#define	ETHERTYPE_SPIDER	0x809F	/* Spider Systems Ltd. */
+			     /* 0x80A3	   Nixdorf */
+		    /* 0x80A4 - 0x80B3	   Siemens Gammasonics Inc. */
+		    /* 0x80C0 - 0x80C3	   DCA (Digital Comm. Assoc.) Data Exchange Cluster */
+		    /* 0x80C4 - 0x80C5	   Banyan Systems */
+#define	ETHERTYPE_PACER		0x80C6	/* Pacer Software */
+#define	ETHERTYPE_APPLITEK	0x80C7	/* Applitek Corporation */
+		    /* 0x80C8 - 0x80CC	   Intergraph Corporation */
+		    /* 0x80CD - 0x80CE	   Harris Corporation */
+		    /* 0x80CF - 0x80D2	   Taylor Instrument */
+		    /* 0x80D3 - 0x80D4	   Rosemount Corporation */
+#define	ETHERTYPE_SNA		0x80D5	/* IBM SNA Services over Ethernet */
+#define	ETHERTYPE_VARIAN	0x80DD	/* Varian Associates */
+		    /* 0x80DE - 0x80DF	   TRFS (Integrated Solutions Transparent Remote File System) */
+		    /* 0x80E0 - 0x80E3	   Allen-Bradley */
+		    /* 0x80E4 - 0x80F0	   Datability */
+#define	ETHERTYPE_RETIX		0x80F2	/* Retix */
+#define	ETHERTYPE_AARP		0x80F3	/* AppleTalk AARP */
+		    /* 0x80F4 - 0x80F5	   Kinetics */
+#define	ETHERTYPE_APOLLO	0x80F7	/* Apollo Computer */
+#define ETHERTYPE_VLAN		0x8100	/* IEEE 802.1Q VLAN tagging (XXX conflicts) */
+		    /* 0x80FF - 0x8101	   Wellfleet Communications (XXX conflicts) */
+#define	ETHERTYPE_BOFL		0x8102	/* Wellfleet; BOFL (Breath OF Life) pkts [every 5-10 secs.] */
+#define	ETHERTYPE_WELLFLEET	0x8103	/* Wellfleet Communications */
+		    /* 0x8107 - 0x8109	   Symbolics Private */
+#define	ETHERTYPE_TALARIS	0x812B	/* Talaris */
+#define	ETHERTYPE_WATERLOO	0x8130	/* Waterloo Microsystems Inc. (XXX which?) */
+#define	ETHERTYPE_HAYES		0x8130	/* Hayes Microcomputers (XXX which?) */
+#define	ETHERTYPE_VGLAB		0x8131	/* VG Laboratory Systems */
+		    /* 0x8132 - 0x8137	   Bridge Communications */
+#define	ETHERTYPE_IPX		0x8137	/* Novell (old) NetWare IPX (ECONFIG E option) */
+#define	ETHERTYPE_NOVELL	0x8138	/* Novell, Inc. */
+		    /* 0x8139 - 0x813D	   KTI */
+#define	ETHERTYPE_MUMPS		0x813F	/* M/MUMPS data sharing */
+#define	ETHERTYPE_AMOEBA	0x8145	/* Vrije Universiteit (NL) Amoeba 4 RPC (obsolete) */
+#define	ETHERTYPE_FLIP		0x8146	/* Vrije Universiteit (NL) FLIP (Fast Local Internet Protocol) */
+#define	ETHERTYPE_VURESERVED	0x8147	/* Vrije Universiteit (NL) [reserved] */
+#define	ETHERTYPE_LOGICRAFT	0x8148	/* Logicraft */
+#define	ETHERTYPE_NCD		0x8149	/* Network Computing Devices */
+#define	ETHERTYPE_ALPHA		0x814A	/* Alpha Micro */
+#define	ETHERTYPE_SNMP		0x814C	/* SNMP over Ethernet (see RFC1089) */
+		    /* 0x814D - 0x814E	   BIIN */
+#define	ETHERTYPE_TEC	0x814F	/* Technically Elite Concepts */
+#define	ETHERTYPE_RATIONAL	0x8150	/* Rational Corp */
+		    /* 0x8151 - 0x8153	   Qualcomm */
+		    /* 0x815C - 0x815E	   Computer Protocol Pty Ltd */
+		    /* 0x8164 - 0x8166	   Charles River Data Systems */
+#define	ETHERTYPE_XTP		0x817D	/* Protocol Engines XTP */
+#define	ETHERTYPE_SGITW		0x817E	/* SGI/Time Warner prop. */
+#define	ETHERTYPE_HIPPI_FP	0x8180	/* HIPPI-FP encapsulation */
+#define	ETHERTYPE_STP		0x8181	/* Scheduled Transfer STP, HIPPI-ST */
+		    /* 0x8182 - 0x8183	   Reserved for HIPPI-6400 */
+		    /* 0x8184 - 0x818C	   SGI prop. */
+#define	ETHERTYPE_MOTOROLA	0x818D	/* Motorola */
+#define	ETHERTYPE_NETBEUI	0x8191	/* PowerLAN NetBIOS/NetBEUI (PC) */
+		    /* 0x819A - 0x81A3	   RAD Network Devices */
+		    /* 0x81B7 - 0x81B9	   Xyplex */
+		    /* 0x81CC - 0x81D5	   Apricot Computers */
+		    /* 0x81D6 - 0x81DD	   Artisoft Lantastic */
+		    /* 0x81E6 - 0x81EF	   Polygon */
+		    /* 0x81F0 - 0x81F2	   Comsat Labs */
+		    /* 0x81F3 - 0x81F5	   SAIC */
+		    /* 0x81F6 - 0x81F8	   VG Analytical */
+		    /* 0x8203 - 0x8205	   QNX Software Systems Ltd. */
+		    /* 0x8221 - 0x8222	   Ascom Banking Systems */
+		    /* 0x823E - 0x8240	   Advanced Encryption Systems */
+		    /* 0x8263 - 0x826A	   Charles River Data Systems */
+		    /* 0x827F - 0x8282	   Athena Programming */
+		    /* 0x829A - 0x829B	   Inst Ind Info Tech */
+		    /* 0x829C - 0x82AB	   Taurus Controls */
+		    /* 0x82AC - 0x8693	   Walker Richer & Quinn */
+#define	ETHERTYPE_ACCTON	0x8390	/* Accton Technologies (unregistered) */
+#define	ETHERTYPE_TALARISMC	0x852B	/* Talaris multicast */
+#define	ETHERTYPE_KALPANA	0x8582	/* Kalpana */
+		    /* 0x8694 - 0x869D	   Idea Courier */
+		    /* 0x869E - 0x86A1	   Computer Network Tech */
+		    /* 0x86A3 - 0x86AC	   Gateway Communications */
+#define	ETHERTYPE_SECTRA	0x86DB	/* SECTRA */
+#define	ETHERTYPE_IPV6		0x86DD	/* IP protocol version 6 */
+#define	ETHERTYPE_DELTACON	0x86DE	/* Delta Controls */
+#define	ETHERTYPE_ATOMIC	0x86DF	/* ATOMIC */
+		    /* 0x86E0 - 0x86EF	   Landis & Gyr Powers */
+		    /* 0x8700 - 0x8710	   Motorola */
+#define	ETHERTYPE_RDP		0x8739	/* Control Technology Inc. RDP Without IP */
+#define	ETHERTYPE_MICP		0x873A	/* Control Technology Inc. Mcast Industrial Ctrl Proto. */
+		    /* 0x873B - 0x873C	   Control Technology Inc. Proprietary */
+#define	ETHERTYPE_TCPCOMP	0x876B	/* TCP/IP Compression (RFC1701) */
+#define	ETHERTYPE_IPAS		0x876C	/* IP Autonomous Systems (RFC1701) */
+#define	ETHERTYPE_SECUREDATA	0x876D	/* Secure Data (RFC1701) */
+#define	ETHERTYPE_FLOWCONTROL	0x8808	/* 802.3x flow control packet */
+#define	ETHERTYPE_SLOW		0x8809	/* 802.3ad link aggregation (LACP) */
+#define	ETHERTYPE_PPP		0x880B	/* PPP (obsolete by PPPOE) */
+#define	ETHERTYPE_HITACHI	0x8820	/* Hitachi Cable (Optoelectronic Systems Laboratory) */
+#define	ETHERTYPE_MPLS		0x8847	/* MPLS Unicast */
+#define	ETHERTYPE_MPLS_MCAST	0x8848	/* MPLS Multicast */
+#define	ETHERTYPE_AXIS		0x8856	/* Axis Communications AB proprietary bootstrap/config */
+#define	ETHERTYPE_PPPOEDISC	0x8863	/* PPP Over Ethernet Discovery Stage */
+#define	ETHERTYPE_PPPOE		0x8864	/* PPP Over Ethernet Session Stage */
+#define	ETHERTYPE_LANPROBE	0x8888	/* HP LanProbe test? */
+#define	ETHERTYPE_PAE		0x888e	/* EAPOL PAE/802.1x */
+#define	ETHERTYPE_LOOPBACK	0x9000	/* Loopback: used to test interfaces */
+#define	ETHERTYPE_LBACK		ETHERTYPE_LOOPBACK	/* DEC MOP loopback */
+#define	ETHERTYPE_XNSSM		0x9001	/* 3Com (Formerly Bridge Communications), XNS Systems Management */
+#define	ETHERTYPE_TCPSM		0x9002	/* 3Com (Formerly Bridge Communications), TCP/IP Systems Management */
+#define	ETHERTYPE_BCLOOP	0x9003	/* 3Com (Formerly Bridge Communications), loopback detection */
+#define	ETHERTYPE_DEBNI		0xAAAA	/* DECNET? Used by VAX 6220 DEBNI */
+#define	ETHERTYPE_SONIX		0xFAF5	/* Sonix Arpeggio */
+#define	ETHERTYPE_VITAL		0xFF00	/* BBN VITAL-LanBridge cache wakeups */
+		    /* 0xFF00 - 0xFFOF	   ISC Bunker Ramo */
+
+#define	ETHERTYPE_MAX		0xFFFF	/* Maximum valid ethernet type, reserved */
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	(ETHER_MAX_LEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
+#define	ETHERMIN	(ETHER_MIN_LEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
+#define	ETHERMTU_JUMBO	(ETHER_MAX_LEN_JUMBO - ETHER_HDR_LEN - ETHER_CRC_LEN)
+/*
+ * The ETHER_BPF_MTAP macro should be used by drivers which support hardware
+ * offload for VLAN tag processing.  It will check the mbuf to see if it has
+ * M_VLANTAG set, and if it does, will pass the packet along to
+ * ether_vlan_mtap.  This function will re-insert VLAN tags for the duration
+ * of the tap, so they show up properly for network analyzers.
+ */
+#define ETHER_BPF_MTAP(_ifp, _m) do { \
+	} while (0)
+
+#ifdef _KERNEL
+
+struct ifnet;
+struct mbuf;
+struct route;
+struct sockaddr;
+struct bpf_if;
+
+extern	uint32_t ether_crc32_le(const uint8_t *, size_t);
+extern	uint32_t ether_crc32_be(const uint8_t *, size_t);
+extern	void ether_demux(struct ifnet *, struct mbuf *);
+extern	void ether_ifattach(struct ifnet *, const u_int8_t *);
+extern	void ether_ifdetach(struct ifnet *);
+extern	int  ether_ioctl(struct ifnet *, u_long, caddr_t);
+extern	int  ether_output(struct ifnet *,
+		   struct mbuf *, struct sockaddr *, struct route *);
+extern	int  ether_output_frame(struct ifnet *, struct mbuf *);
+extern	char *ether_sprintf(const u_int8_t *);
+void	ether_vlan_mtap(struct bpf_if *, struct mbuf *,
+	    void *, u_int);
+struct mbuf *ether_vlanencap(struct mbuf *, uint16_t);
+
+#else /* _KERNEL */
+
+#include <sys/cdefs.h>
+
+/*
+ * Ethernet address conversion/parsing routines.
+ */
+__BEGIN_DECLS
+struct	ether_addr *ether_aton(const char *);
+struct	ether_addr *ether_aton_r(const char *, struct ether_addr *);
+int	ether_hostton(const char *, struct ether_addr *);
+int	ether_line(const char *, struct ether_addr *, char *);
+char 	*ether_ntoa(const struct ether_addr *);
+char 	*ether_ntoa_r(const struct ether_addr *, char *);
+int	ether_ntohost(char *, const struct ether_addr *);
+__END_DECLS
+
+#endif /* !_KERNEL */
+
+#endif /* !_FBSD_COMPAT_NET_ETHERNET_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if.h
new file mode 100644
index 0000000000..552073a9b6
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NET_IF_H_
+#define _FBSD_COMPAT_NET_IF_H_
+
+
+#include <posix/net/if.h>
+
+#include <sys/cdefs.h>
+#include <sys/queue.h>
+#include <sys/time.h>
+
+
+#define IF_Kbps(x)				((uintmax_t)(x) * 1000)
+#define IF_Mbps(x)				(IF_Kbps((x) * 1000))
+#define IF_Gbps(x)				(IF_Mbps((x) * 1000))
+
+/* Capabilities that interfaces can advertise. */
+#define	IFCAP_RXCSUM		0x00001  /* can offload checksum on RX */
+#define	IFCAP_TXCSUM		0x00002  /* can offload checksum on TX */
+#define	IFCAP_NETCONS		0x00004  /* can be a network console */
+#define	IFCAP_VLAN_MTU		0x00008	/* VLAN-compatible MTU */
+#define	IFCAP_VLAN_HWTAGGING	0x00010	/* hardware VLAN tag support */
+#define	IFCAP_JUMBO_MTU		0x00020	/* 9000 byte MTU supported */
+#define	IFCAP_POLLING		0x00040	/* driver supports polling */
+#define	IFCAP_VLAN_HWCSUM	0x00080	/* can do IFCAP_HWCSUM on VLANs */
+#define	IFCAP_TSO4		0x00100	/* can do TCP Segmentation Offload */
+#define	IFCAP_TSO6		0x00200	/* can do TCP6 Segmentation Offload */
+#define	IFCAP_LRO		0x00400	/* can do Large Receive Offload */
+#define	IFCAP_WOL_UCAST		0x00800	/* wake on any unicast frame */
+#define	IFCAP_WOL_MCAST		0x01000	/* wake on any multicast frame */
+#define	IFCAP_WOL_MAGIC		0x02000	/* wake on any Magic Packet */
+#define	IFCAP_TOE4		0x04000	/* interface can offload TCP */
+#define	IFCAP_TOE6		0x08000	/* interface can offload TCP6 */
+#define	IFCAP_VLAN_HWFILTER	0x10000 /* interface hw can filter vlan tag */
+#define	IFCAP_POLLING_NOCOUNT	0x20000 /* polling ticks cannot be fragmented */
+#define	IFCAP_VLAN_HWTSO	0x40000 /* can do IFCAP_TSO on VLANs */
+#define	IFCAP_LINKSTATE		0x80000 /* the runtime link state is dynamic */
+#define	IFCAP_NETMAP		0x100000 /* netmap mode supported/enabled */
+#define	IFCAP_RXCSUM_IPV6	0x200000  /* can offload checksum on IPv6 RX */
+#define	IFCAP_TXCSUM_IPV6	0x400000  /* can offload checksum on IPv6 TX */
+#define	IFCAP_HWSTATS		0x800000 /* manages counters internally */
+
+#define IFCAP_HWCSUM_IPV6	(IFCAP_RXCSUM_IPV6 | IFCAP_TXCSUM_IPV6)
+
+#define IFCAP_HWCSUM	(IFCAP_RXCSUM | IFCAP_TXCSUM)
+#define	IFCAP_TSO	(IFCAP_TSO4 | IFCAP_TSO6)
+#define	IFCAP_WOL	(IFCAP_WOL_UCAST | IFCAP_WOL_MCAST | IFCAP_WOL_MAGIC)
+#define	IFCAP_TOE	(IFCAP_TOE4 | IFCAP_TOE6)
+
+#define	IFCAP_CANTCHANGE	(IFCAP_NETMAP)
+
+/* interface flags -- these extend the Haiku-native ones from posix/net/if.h */
+#define IFF_DRV_RUNNING		0x00010000
+#define IFF_DRV_OACTIVE		0x00020000
+#define IFF_LINK0			0x00040000		/* per link layer defined bit */
+#define	IFF_LINK1			0x00080000		/* per link layer defined bit */
+#define	IFF_LINK2			0x00100000		/* per link layer defined bit */
+#define IFF_DEBUG			0x00200000
+#define	IFF_MONITOR			0x00400000		/* (n) user-requested monitor mode */
+#define	IFF_PPROMISC		0x00800000		/* (n) user-requested promisc mode */
+#define	IFF_NOGROUP			0x01000000		/* (n) interface is not part of any groups */
+
+#define LINK_STATE_UNKNOWN	0
+#define LINK_STATE_DOWN		1
+#define LINK_STATE_UP		2
+
+#define IFQ_MAXLEN			50
+
+
+/*
+ * Structure describing information about an interface
+ * which may be of interest to management entities.
+ */
+struct if_data {
+	/* generic interface information */
+	uint8_t	ifi_type;			/* ethernet, tokenring, etc */
+	uint8_t	ifi_physical;		/* e.g., AUI, Thinnet, 10base-T, etc */
+	uint8_t	ifi_addrlen;		/* media address length */
+	uint8_t	ifi_hdrlen;			/* media header length */
+	uint8_t	ifi_link_state;		/* current link state */
+	uint8_t	ifi_recvquota;		/* polling quota for receive intrs */
+	uint8_t	ifi_xmitquota;		/* polling quota for xmit intrs */
+	uint16_t	ifi_datalen;		/* length of this data struct */
+	uint32_t	ifi_mtu;			/* maximum transmission unit */
+	uint32_t	ifi_metric;			/* routing metric (external only) */
+	uint64_t	ifi_baudrate;		/* linespeed */
+	/* volatile statistics */
+	uint64_t	ifi_ipackets;		/* packets received on interface */
+	uint64_t	ifi_ierrors;		/* input errors on interface */
+	uint64_t	ifi_opackets;		/* packets sent on interface */
+	uint64_t	ifi_oerrors;		/* output errors on interface */
+	uint64_t	ifi_collisions;		/* collisions on csma interfaces */
+	uint64_t	ifi_ibytes;			/* total number of octets received */
+	uint64_t	ifi_obytes;			/* total number of octets sent */
+	uint64_t	ifi_imcasts;		/* packets received via multicast */
+	uint64_t	ifi_omcasts;		/* packets sent via multicast */
+	uint64_t	ifi_iqdrops;		/* dropped on input, this interface */
+	uint64_t	ifi_oqdrops;		/* dropped on output, this interface */
+	uint64_t	ifi_noproto;		/* destined for unsupported protocol */
+	uint64_t	ifi_hwassist;		/* HW offload capabilities */
+	time_t	ifi_epoch;			/* uptime at attach or stat reset */
+#ifdef __alpha__
+	u_int	ifi_timepad;		/* time_t is int, not long on alpha */
+#endif
+	struct	timeval ifi_lastchange;	/* time of last administrative change */
+};
+
+struct  ifdrv {
+	char			ifd_name[IFNAMSIZ];     /* if name, e.g. "en0" */
+	unsigned long	ifd_cmd;
+	size_t			ifd_len;
+	void*			ifd_data;
+};
+
+/*
+ * Structure used to request i2c data
+ * from interface transceivers.
+ */
+struct ifi2creq {
+	uint8_t dev_addr;	/* i2c address (0xA0, 0xA2) */
+	uint8_t offset;		/* read offset */
+	uint8_t len;		/* read length */
+	uint8_t spare0;
+	uint32_t spare1;
+	uint8_t data[8];	/* read buffer */
+};
+
+#ifdef _KERNEL
+/* TODO: this should go away soon. */
+#	include <net/if_var.h>
+#endif
+
+
+#endif	/* _FBSD_COMPAT_NET_IF_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_arp.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_arp.h
new file mode 100644
index 0000000000..2be137aebb
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_arp.h
@@ -0,0 +1,115 @@
+/*-
+ * Copyright (c) 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_arp.h	8.1 (Berkeley) 6/10/93
+ * $FreeBSD: src/sys/net/if_arp.h,v 1.22 2005/06/10 16:49:18 brooks Exp $
+ */
+
+#ifndef _FBSD_COMPAT_NET_IF_ARP_H_
+#define	_FBSD_COMPAT_NET_IF_ARP_H_
+
+/*
+ * Address Resolution Protocol.
+ *
+ * See RFC 826 for protocol description.  ARP packets are variable
+ * in size; the arphdr structure defines the fixed-length portion.
+ * Protocol type values are the same as those for 10 Mb/s Ethernet.
+ * It is followed by the variable-sized fields ar_sha, arp_spa,
+ * arp_tha and arp_tpa in that order, according to the lengths
+ * specified.  Field names used correspond to RFC 826.
+ */
+struct	arphdr {
+	u_short	ar_hrd;		/* format of hardware address */
+#define ARPHRD_ETHER 	1	/* ethernet hardware format */
+#define ARPHRD_IEEE802	6	/* token-ring hardware format */
+#define ARPHRD_ARCNET	7	/* arcnet hardware format */
+#define ARPHRD_FRELAY 	15	/* frame relay hardware format */
+#define ARPHRD_IEEE1394	24	/* firewire hardware format */
+	u_short	ar_pro;		/* format of protocol address */
+	u_char	ar_hln;		/* length of hardware address */
+	u_char	ar_pln;		/* length of protocol address */
+	u_short	ar_op;		/* one of: */
+#define	ARPOP_REQUEST	1	/* request to resolve address */
+#define	ARPOP_REPLY	2	/* response to previous request */
+#define	ARPOP_REVREQUEST 3	/* request protocol address given hardware */
+#define	ARPOP_REVREPLY	4	/* response giving protocol address */
+#define ARPOP_INVREQUEST 8 	/* request to identify peer */
+#define ARPOP_INVREPLY	9	/* response identifying peer */
+/*
+ * The remaining fields are variable in size,
+ * according to the sizes above.
+ */
+#ifdef COMMENT_ONLY
+	u_char	ar_sha[];	/* sender hardware address */
+	u_char	ar_spa[];	/* sender protocol address */
+	u_char	ar_tha[];	/* target hardware address */
+	u_char	ar_tpa[];	/* target protocol address */
+#endif
+};
+
+#define ar_sha(ap)	(((caddr_t)((ap)+1)) +   0)
+#define ar_spa(ap)	(((caddr_t)((ap)+1)) +   (ap)->ar_hln)
+#define ar_tha(ap)	(((caddr_t)((ap)+1)) +   (ap)->ar_hln + (ap)->ar_pln)
+#define ar_tpa(ap)	(((caddr_t)((ap)+1)) + 2*(ap)->ar_hln + (ap)->ar_pln)
+
+#define arphdr_len2(ar_hln, ar_pln)					\
+	(sizeof(struct arphdr) + 2*(ar_hln) + 2*(ar_pln))
+#define arphdr_len(ap)	(arphdr_len2((ap)->ar_hln, (ap)->ar_pln))
+
+/*
+ * ARP ioctl request
+ */
+struct arpreq {
+	struct	sockaddr arp_pa;		/* protocol address */
+	struct	sockaddr arp_ha;		/* hardware address */
+	int	arp_flags;			/* flags */
+};
+/*  arp_flags and at_flags field values */
+#define	ATF_INUSE	0x01	/* entry in use */
+#define ATF_COM		0x02	/* completed entry (enaddr valid) */
+#define	ATF_PERM	0x04	/* permanent entry */
+#define	ATF_PUBL	0x08	/* publish entry (respond for other host) */
+#define	ATF_USETRAILERS	0x10	/* has requested trailers */
+
+#ifdef _KERNEL
+/*
+ * Structure shared between the ethernet driver modules and
+ * the address resolution code.
+ */
+struct	arpcom {
+	struct 	ifnet *ac_ifp;		/* network-visible interface */
+	u_char	_ac_enaddr[6];		/* ethernet hardware address */
+	void	*ac_netgraph;		/* ng_ether(4) netgraph node info */
+};
+#define IFP2AC(ifp) ((struct arpcom *)(ifp->if_l2com))
+#define IFP2ENADDR(ifp) (IFP2AC(ifp)->_ac_enaddr)
+#define AC2IFP(ac) ((ac)->ac_ifp)
+
+#endif
+
+#endif /* _FBSD_COMPAT_NET_IF_ARP_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_llc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_llc.h
new file mode 100644
index 0000000000..ec4427fb47
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_llc.h
@@ -0,0 +1,161 @@
+/*	$NetBSD: if_llc.h,v 1.12 1999/11/19 20:41:19 thorpej Exp $	*/
+
+/*-
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_llc.h	8.1 (Berkeley) 6/10/93
+ * $FreeBSD: src/sys/net/if_llc.h,v 1.13 2006/12/01 17:50:11 imp Exp $
+ */
+
+#ifndef _NET_IF_LLC_H_
+#define _NET_IF_LLC_H_
+
+/*
+ * IEEE 802.2 Link Level Control headers, for use in conjunction with
+ * 802.{3,4,5} media access control methods.
+ *
+ * Headers here do not use bit fields due to shortcommings in many
+ * compilers.
+ */
+
+struct llc {
+	u_int8_t llc_dsap;
+	u_int8_t llc_ssap;
+	union {
+	    struct {
+		u_int8_t control;
+		u_int8_t format_id;
+		u_int8_t class;
+		u_int8_t window_x2;
+	    } __packed type_u;
+	    struct {
+		u_int8_t num_snd_x2;
+		u_int8_t num_rcv_x2;
+	    } __packed type_i;
+	    struct {
+		u_int8_t control;
+		u_int8_t num_rcv_x2;
+	    } __packed type_s;
+	    struct {
+	        u_int8_t control;
+		/*
+		 * We cannot put the following fields in a structure because
+		 * the structure rounding might cause padding.
+		 */
+		u_int8_t frmr_rej_pdu0;
+		u_int8_t frmr_rej_pdu1;
+		u_int8_t frmr_control;
+		u_int8_t frmr_control_ext;
+		u_int8_t frmr_cause;
+	    } __packed type_frmr;
+	    struct {
+		u_int8_t  control;
+		u_int8_t  org_code[3];
+		u_int16_t ether_type;
+	    } __packed type_snap;
+	    struct {
+		u_int8_t control;
+		u_int8_t control_ext;
+	    } __packed type_raw;
+	} __packed llc_un;
+} __packed;
+
+struct frmrinfo {
+	u_int8_t frmr_rej_pdu0;
+	u_int8_t frmr_rej_pdu1;
+	u_int8_t frmr_control;
+	u_int8_t frmr_control_ext;
+	u_int8_t frmr_cause;
+} __packed;
+
+#define	llc_control		llc_un.type_u.control
+#define	llc_control_ext		llc_un.type_raw.control_ext
+#define	llc_fid			llc_un.type_u.format_id
+#define	llc_class		llc_un.type_u.class
+#define	llc_window		llc_un.type_u.window_x2
+#define	llc_frmrinfo 		llc_un.type_frmr.frmr_rej_pdu0
+#define	llc_frmr_pdu0		llc_un.type_frmr.frmr_rej_pdu0
+#define	llc_frmr_pdu1		llc_un.type_frmr.frmr_rej_pdu1
+#define	llc_frmr_control	llc_un.type_frmr.frmr_control
+#define	llc_frmr_control_ext	llc_un.type_frmr.frmr_control_ext
+#define	llc_frmr_cause		llc_un.type_frmr.frmr_cause
+#define	llc_snap		llc_un.type_snap
+
+/*
+ * Don't use sizeof(struct llc_un) for LLC header sizes
+ */
+#define LLC_ISFRAMELEN 4
+#define LLC_UFRAMELEN  3
+#define LLC_FRMRLEN    7
+#define LLC_SNAPFRAMELEN 8
+
+#ifdef CTASSERT
+CTASSERT(sizeof (struct llc) == LLC_SNAPFRAMELEN);
+#endif
+
+/*
+ * Unnumbered LLC format commands
+ */
+#define LLC_UI		0x3
+#define LLC_UI_P	0x13
+#define LLC_DISC	0x43
+#define	LLC_DISC_P	0x53
+#define LLC_UA		0x63
+#define LLC_UA_P	0x73
+#define LLC_TEST	0xe3
+#define LLC_TEST_P	0xf3
+#define LLC_FRMR	0x87
+#define	LLC_FRMR_P	0x97
+#define LLC_DM		0x0f
+#define	LLC_DM_P	0x1f
+#define LLC_XID		0xaf
+#define LLC_XID_P	0xbf
+#define LLC_SABME	0x6f
+#define LLC_SABME_P	0x7f
+
+/*
+ * Supervisory LLC commands
+ */
+#define	LLC_RR		0x01
+#define	LLC_RNR		0x05
+#define	LLC_REJ		0x09
+
+/*
+ * Info format - dummy only
+ */
+#define	LLC_INFO	0x00
+
+/*
+ * ISO PDTR 10178 contains among others
+ */
+#define LLC_8021D_LSAP	0x42
+#define LLC_X25_LSAP	0x7e
+#define LLC_SNAP_LSAP	0xaa
+#define LLC_ISO_LSAP	0xfe
+
+#endif /* _NET_IF_LLC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_media.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_media.h
new file mode 100644
index 0000000000..6d6631f523
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_media.h
@@ -0,0 +1,940 @@
+/*	$NetBSD: if_media.h,v 1.3 1997/03/26 01:19:27 thorpej Exp $	*/
+/* $FreeBSD: head/sys/net/if_media.h 338208 2018-08-22 18:19:56Z erj $ */
+
+/*-
+ * SPDX-License-Identifier: BSD-4-Clause
+ *
+ * Copyright (c) 1997
+ *	Jonathan Stone and Jason R. Thorpe.  All rights reserved.
+ *
+ * This software is derived from information provided by Matt Thomas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Jonathan Stone
+ *	and Jason R. Thorpe for the NetBSD Project.
+ * 4. The names of the authors may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _FBSD_COMPAT_NET_IF_MEDIA_H_
+#define	_FBSD_COMPAT_NET_IF_MEDIA_H_
+
+/*
+ * Prototypes and definitions for BSD/OS-compatible network interface
+ * media selection.
+ *
+ * Where it is safe to do so, this code strays slightly from the BSD/OS
+ * design.  Software which uses the API (device drivers, basically)
+ * shouldn't notice any difference.
+ *
+ * Many thanks to Matt Thomas for providing the information necessary
+ * to implement this interface.
+ */
+
+#ifdef _KERNEL
+
+#include <sys/queue.h>
+
+struct ifnet;
+
+/*
+ * Driver callbacks for media status and change requests.
+ */
+typedef	int (*ifm_change_cb_t)(struct ifnet *);
+typedef	void (*ifm_stat_cb_t)(struct ifnet *, struct ifmediareq *req);
+
+/*
+ * In-kernel representation of a single supported media type.
+ */
+struct ifmedia_entry {
+	LIST_ENTRY(ifmedia_entry) ifm_list;
+	int	ifm_media;	/* description of this media attachment */
+	int	ifm_data;	/* for driver-specific use */
+	void	*ifm_aux;	/* for driver-specific use */
+};
+
+/*
+ * One of these goes into a network interface's softc structure.
+ * It is used to keep general media state.
+ */
+struct ifmedia {
+	int	ifm_mask;	/* mask of changes we don't care about */
+	int	ifm_media;	/* current user-set media word */
+	struct ifmedia_entry *ifm_cur;	/* currently selected media */
+	LIST_HEAD(, ifmedia_entry) ifm_list; /* list of all supported media */
+	ifm_change_cb_t	ifm_change;	/* media change driver callback */
+	ifm_stat_cb_t	ifm_status;	/* media status driver callback */
+};
+
+/* Initialize an interface's struct if_media field. */
+void	ifmedia_init(struct ifmedia *ifm, int dontcare_mask,
+	    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback);
+
+/* Remove all mediums from a struct ifmedia.  */
+void	ifmedia_removeall( struct ifmedia *ifm);
+
+/* Add one supported medium to a struct ifmedia. */
+void	ifmedia_add(struct ifmedia *ifm, int mword, int data, void *aux);
+
+/* Add an array (of ifmedia_entry) media to a struct ifmedia. */
+void	ifmedia_list_add(struct ifmedia *mp, struct ifmedia_entry *lp,
+	    int count);
+
+/* Set default media type on initialization. */
+void	ifmedia_set(struct ifmedia *ifm, int mword);
+
+/* Common ioctl function for getting/setting media, called by driver. */
+int	ifmedia_ioctl(struct ifnet *ifp, struct ifreq *ifr,
+	    struct ifmedia *ifm, u_long cmd);
+
+
+/* Compute baudrate for a given media. */
+uint64_t	ifmedia_baudrate(int);
+
+#endif /*_KERNEL */
+
+/*
+ * if_media Options word:
+ *	Bits	Use
+ *	----	-------
+ *	0-4	Media variant
+ *	5-7	Media type
+ *	8-15	Type specific options (includes added variant bits on Ethernet)
+ *	16-18	Mode (for multi-mode devices)
+ *	19	RFU
+ *	20-27	Shared (global) options
+ *	28-31	Instance
+ */
+
+/*
+ * Ethernet
+ * In order to use more than 31 subtypes, Ethernet uses some of the option
+ * bits as part of the subtype field.  See the options section below for
+ * relevant definitions
+ */
+#define	IFM_ETHER	0x00000020
+#define	IFM_ETHER_SUBTYPE(x) (((x) & IFM_TMASK) | \
+	(((x) & (IFM_ETH_XTYPE >> IFM_ETH_XSHIFT)) << IFM_ETH_XSHIFT))
+#define	IFM_X(x) IFM_ETHER_SUBTYPE(x)	/* internal shorthand */
+#define	IFM_ETHER_SUBTYPE_SET(x) (IFM_ETHER_SUBTYPE(x) | IFM_ETHER)
+#define	IFM_ETHER_SUBTYPE_GET(x) ((x) & (IFM_TMASK|IFM_ETH_XTYPE))
+#define	IFM_ETHER_IS_EXTENDED(x)	((x) & IFM_ETH_XTYPE)
+
+#define	IFM_10_T	3		/* 10BaseT - RJ45 */
+#define	IFM_10_2	4		/* 10Base2 - Thinnet */
+#define	IFM_10_5	5		/* 10Base5 - AUI */
+#define	IFM_100_TX	6		/* 100BaseTX - RJ45 */
+#define	IFM_100_FX	7		/* 100BaseFX - Fiber */
+#define	IFM_100_T4	8		/* 100BaseT4 - 4 pair cat 3 */
+#define	IFM_100_VG	9		/* 100VG-AnyLAN */
+#define	IFM_100_T2	10		/* 100BaseT2 */
+#define	IFM_1000_SX	11		/* 1000BaseSX - multi-mode fiber */
+#define	IFM_10_STP	12		/* 10BaseT over shielded TP */
+#define	IFM_10_FL	13		/* 10BaseFL - Fiber */
+#define	IFM_1000_LX	14		/* 1000baseLX - single-mode fiber */
+#define	IFM_1000_CX	15		/* 1000baseCX - 150ohm STP */
+#define	IFM_1000_T	16		/* 1000baseT - 4 pair cat 5 */
+#define	IFM_HPNA_1	17		/* HomePNA 1.0 (1Mb/s) */
+#define	IFM_10G_LR	18		/* 10GBase-LR 1310nm Single-mode */
+#define	IFM_10G_SR	19		/* 10GBase-SR 850nm Multi-mode */
+#define	IFM_10G_CX4	20		/* 10GBase CX4 copper */
+#define	IFM_2500_SX	21		/* 2500BaseSX - multi-mode fiber */
+#define	IFM_10G_TWINAX	22		/* 10GBase Twinax copper */
+#define	IFM_10G_TWINAX_LONG	23	/* 10GBase Twinax Long copper */
+#define	IFM_10G_LRM	24		/* 10GBase-LRM 850nm Multi-mode */
+#define	IFM_UNKNOWN	25		/* media types not defined yet */
+#define	IFM_10G_T	26		/* 10GBase-T - RJ45 */
+#define	IFM_40G_CR4	27		/* 40GBase-CR4 */
+#define	IFM_40G_SR4	28		/* 40GBase-SR4 */
+#define	IFM_40G_LR4	29		/* 40GBase-LR4 */
+#define	IFM_1000_KX	30		/* 1000Base-KX backplane */
+#define	IFM_OTHER	31		/* Other: one of the following */
+
+/* following types are not visible to old binaries using only IFM_TMASK */
+#define	IFM_10G_KX4	IFM_X(32)	/* 10GBase-KX4 backplane */
+#define	IFM_10G_KR	IFM_X(33)	/* 10GBase-KR backplane */
+#define	IFM_10G_CR1	IFM_X(34)	/* 10GBase-CR1 Twinax splitter */
+#define	IFM_20G_KR2	IFM_X(35)	/* 20GBase-KR2 backplane */
+#define	IFM_2500_KX	IFM_X(36)	/* 2500Base-KX backplane */
+#define	IFM_2500_T	IFM_X(37)	/* 2500Base-T - RJ45 (NBaseT) */
+#define	IFM_5000_T	IFM_X(38)	/* 5000Base-T - RJ45 (NBaseT) */
+#define	IFM_50G_PCIE	IFM_X(39)	/* 50G Ethernet over PCIE */
+#define	IFM_25G_PCIE	IFM_X(40)	/* 25G Ethernet over PCIE */
+#define	IFM_1000_SGMII	IFM_X(41)	/* 1G media interface */
+#define	IFM_10G_SFI	IFM_X(42)	/* 10G media interface */
+#define	IFM_40G_XLPPI	IFM_X(43)	/* 40G media interface */
+#define	IFM_1000_CX_SGMII IFM_X(44)	/* 1000Base-CX-SGMII */
+#define	IFM_40G_KR4	IFM_X(45)	/* 40GBase-KR4 */
+#define	IFM_10G_ER	IFM_X(46)	/* 10GBase-ER */
+#define	IFM_100G_CR4	IFM_X(47)	/* 100GBase-CR4 */
+#define	IFM_100G_SR4	IFM_X(48)	/* 100GBase-SR4 */
+#define	IFM_100G_KR4	IFM_X(49)	/* 100GBase-KR4 */
+#define	IFM_100G_LR4	IFM_X(50)	/* 100GBase-LR4 */
+#define	IFM_56G_R4	IFM_X(51)	/* 56GBase-R4 */
+#define	IFM_100_T	IFM_X(52)	/* 100BaseT - RJ45 */
+#define	IFM_25G_CR	IFM_X(53)	/* 25GBase-CR */
+#define	IFM_25G_KR	IFM_X(54)	/* 25GBase-KR */
+#define	IFM_25G_SR	IFM_X(55)	/* 25GBase-SR */
+#define	IFM_50G_CR2	IFM_X(56)	/* 50GBase-CR2 */
+#define	IFM_50G_KR2	IFM_X(57)	/* 50GBase-KR2 */
+#define	IFM_25G_LR	IFM_X(58)	/* 25GBase-LR */
+#define	IFM_10G_AOC	IFM_X(59)	/* 10G active optical cable */
+#define	IFM_25G_ACC	IFM_X(60)	/* 25G active copper cable */
+#define	IFM_25G_AOC	IFM_X(61)	/* 25G active optical cable */
+#define	IFM_100_SGMII	IFM_X(62)	/* 100M media interface */
+#define	IFM_2500_X	IFM_X(63)	/* 2500BaseX */
+#define	IFM_5000_KR	IFM_X(64)	/* 5GBase-KR backplane */
+#define	IFM_25G_T	IFM_X(65)	/* 25GBase-T - RJ45 */
+#define	IFM_25G_CR_S	IFM_X(66)	/* 25GBase-CR (short) */
+#define	IFM_25G_CR1	IFM_X(67)	/* 25GBase-CR1 DA cable */
+#define	IFM_25G_KR_S	IFM_X(68)	/* 25GBase-KR (short) */
+#define	IFM_5000_KR_S	IFM_X(69)	/* 5GBase-KR backplane (short) */
+#define	IFM_5000_KR1	IFM_X(70)	/* 5GBase-KR backplane */
+#define	IFM_25G_AUI	IFM_X(71)	/* 25G-AUI-C2C (chip to chip) */
+#define	IFM_40G_XLAUI	IFM_X(72)	/* 40G-XLAUI */
+#define	IFM_40G_XLAUI_AC IFM_X(73)	/* 40G active copper/optical */
+#define	IFM_40G_ER4	IFM_X(74)	/* 40GBase-ER4 */
+#define	IFM_50G_SR2	IFM_X(75)	/* 50GBase-SR2 */
+#define	IFM_50G_LR2	IFM_X(76)	/* 50GBase-LR2 */
+#define	IFM_50G_LAUI2_AC IFM_X(77)	/* 50G active copper/optical */
+#define	IFM_50G_LAUI2	IFM_X(78)	/* 50G-LAUI2 */
+#define	IFM_50G_AUI2_AC	IFM_X(79)	/* 50G active copper/optical */
+#define	IFM_50G_AUI2	IFM_X(80)	/* 50G-AUI2 */
+#define	IFM_50G_CP	IFM_X(81)	/* 50GBase-CP */
+#define	IFM_50G_SR	IFM_X(82)	/* 50GBase-SR */
+#define	IFM_50G_LR	IFM_X(83)	/* 50GBase-LR */
+#define	IFM_50G_FR	IFM_X(84)	/* 50GBase-FR */
+#define	IFM_50G_KR_PAM4	IFM_X(85)	/* 50GBase-KR PAM4 */
+#define	IFM_25G_KR1	IFM_X(86)	/* 25GBase-KR1 */
+#define	IFM_50G_AUI1_AC	IFM_X(87)	/* 50G active copper/optical */
+#define	IFM_50G_AUI1	IFM_X(88)	/* 50G-AUI1 */
+#define	IFM_100G_CAUI4_AC IFM_X(89)	/* 100G-CAUI4 active copper/optical */
+#define	IFM_100G_CAUI4 IFM_X(90)	/* 100G-CAUI4 */
+#define	IFM_100G_AUI4_AC IFM_X(91)	/* 100G-AUI4 active copper/optical */
+#define	IFM_100G_AUI4	IFM_X(92)	/* 100G-AUI4 */
+#define	IFM_100G_CR_PAM4 IFM_X(93)	/* 100GBase-CR PAM4 */
+#define	IFM_100G_KR_PAM4 IFM_X(94)	/* 100GBase-CR PAM4 */
+#define	IFM_100G_CP2	IFM_X(95)	/* 100GBase-CP2 */
+#define	IFM_100G_SR2	IFM_X(96)	/* 100GBase-SR2 */
+#define	IFM_100G_DR	IFM_X(97)	/* 100GBase-DR */
+#define	IFM_100G_KR2_PAM4 IFM_X(98)	/* 100GBase-KR2 PAM4 */
+#define	IFM_100G_CAUI2_AC IFM_X(99)	/* 100G-CAUI2 active copper/optical */
+#define	IFM_100G_CAUI2	IFM_X(100)	/* 100G-CAUI2 */
+#define	IFM_100G_AUI2_AC IFM_X(101)	/* 100G-AUI2 active copper/optical */
+#define	IFM_100G_AUI2	IFM_X(102)	/* 100G-AUI2 */
+#define	IFM_200G_CR4_PAM4 IFM_X(103)	/* 200GBase-CR4 PAM4 */
+#define	IFM_200G_SR4	IFM_X(104)	/* 200GBase-SR4 */
+#define	IFM_200G_FR4	IFM_X(105)	/* 200GBase-FR4 */
+#define	IFM_200G_LR4	IFM_X(106)	/* 200GBase-LR4 */
+#define	IFM_200G_DR4	IFM_X(107)	/* 200GBase-DR4 */
+#define	IFM_200G_KR4_PAM4 IFM_X(108)	/* 200GBase-KR4 PAM4 */
+#define	IFM_200G_AUI4_AC IFM_X(109)	/* 200G-AUI4 active copper/optical */
+#define	IFM_200G_AUI4	IFM_X(110)	/* 200G-AUI4 */
+#define	IFM_200G_AUI8_AC IFM_X(111)	/* 200G-AUI8 active copper/optical */
+#define	IFM_200G_AUI8	IFM_X(112)	/* 200G-AUI8 */
+#define	IFM_400G_FR8	IFM_X(113)	/* 400GBase-FR8 */
+#define	IFM_400G_LR8	IFM_X(114)	/* 400GBase-LR8 */
+#define	IFM_400G_DR4	IFM_X(115)	/* 400GBase-DR4 */
+#define	IFM_400G_AUI8_AC IFM_X(116)	/* 400G-AUI8 active copper/optical */
+#define	IFM_400G_AUI8	IFM_X(117)	/* 400G-AUI8 */
+
+/*
+ * Please update ieee8023ad_lacp.c:lacp_compose_key()
+ * after adding new Ethernet media types.
+ */
+/* Note IFM_X(511) is the max! */
+
+/* Ethernet option values; includes bits used for extended variant field */
+#define	IFM_ETH_MASTER	0x00000100	/* master mode (1000baseT) */
+#define	IFM_ETH_RXPAUSE	0x00000200	/* receive PAUSE frames */
+#define	IFM_ETH_TXPAUSE	0x00000400	/* transmit PAUSE frames */
+#define	IFM_ETH_XTYPE	0x00007800	/* extended media variants */
+#define	IFM_ETH_XSHIFT	6		/* shift XTYPE next to TMASK */
+
+/*
+ * IEEE 802.11 Wireless
+ */
+#define	IFM_IEEE80211	0x00000080
+/* NB: 0,1,2 are auto, manual, none defined below */
+#define	IFM_IEEE80211_FH1	3	/* Frequency Hopping 1Mbps */
+#define	IFM_IEEE80211_FH2	4	/* Frequency Hopping 2Mbps */
+#define	IFM_IEEE80211_DS1	5	/* Direct Sequence 1Mbps */
+#define	IFM_IEEE80211_DS2	6	/* Direct Sequence 2Mbps */
+#define	IFM_IEEE80211_DS5	7	/* Direct Sequence 5.5Mbps */
+#define	IFM_IEEE80211_DS11	8	/* Direct Sequence 11Mbps */
+#define	IFM_IEEE80211_DS22	9	/* Direct Sequence 22Mbps */
+#define	IFM_IEEE80211_OFDM6	10	/* OFDM 6Mbps */
+#define	IFM_IEEE80211_OFDM9	11	/* OFDM 9Mbps */
+#define	IFM_IEEE80211_OFDM12	12	/* OFDM 12Mbps */
+#define	IFM_IEEE80211_OFDM18	13	/* OFDM 18Mbps */
+#define	IFM_IEEE80211_OFDM24	14	/* OFDM 24Mbps */
+#define	IFM_IEEE80211_OFDM36	15	/* OFDM 36Mbps */
+#define	IFM_IEEE80211_OFDM48	16	/* OFDM 48Mbps */
+#define	IFM_IEEE80211_OFDM54	17	/* OFDM 54Mbps */
+#define	IFM_IEEE80211_OFDM72	18	/* OFDM 72Mbps */
+#define	IFM_IEEE80211_DS354k	19	/* Direct Sequence 354Kbps */
+#define	IFM_IEEE80211_DS512k	20	/* Direct Sequence 512Kbps */
+#define	IFM_IEEE80211_OFDM3	21	/* OFDM 3Mbps */
+#define	IFM_IEEE80211_OFDM4	22	/* OFDM 4.5Mbps */
+#define	IFM_IEEE80211_OFDM27	23	/* OFDM 27Mbps */
+/* NB: not enough bits to express MCS fully */
+#define	IFM_IEEE80211_MCS	24	/* HT MCS rate */
+#define	IFM_IEEE80211_VHT	25	/* VHT MCS rate */
+
+#define	IFM_IEEE80211_ADHOC	0x00000100	/* Operate in Adhoc mode */
+#define	IFM_IEEE80211_HOSTAP	0x00000200	/* Operate in Host AP mode */
+#define	IFM_IEEE80211_IBSS	0x00000400	/* Operate in IBSS mode */
+#define	IFM_IEEE80211_WDS	0x00000800	/* Operate in WDS mode */
+#define	IFM_IEEE80211_TURBO	0x00001000	/* Operate in turbo mode */
+#define	IFM_IEEE80211_MONITOR	0x00002000	/* Operate in monitor mode */
+#define	IFM_IEEE80211_MBSS	0x00004000	/* Operate in MBSS mode */
+
+/* operating mode for multi-mode devices */
+#define	IFM_IEEE80211_11A	0x00010000	/* 5Ghz, OFDM mode */
+#define	IFM_IEEE80211_11B	0x00020000	/* Direct Sequence mode */
+#define	IFM_IEEE80211_11G	0x00030000	/* 2Ghz, CCK mode */
+#define	IFM_IEEE80211_FH	0x00040000	/* 2Ghz, GFSK mode */
+#define	IFM_IEEE80211_11NA	0x00050000	/* 5Ghz, HT mode */
+#define	IFM_IEEE80211_11NG	0x00060000	/* 2Ghz, HT mode */
+#define	IFM_IEEE80211_VHT5G	0x00070000	/* 5Ghz, VHT mode */
+#define	IFM_IEEE80211_VHT2G	0x00080000	/* 2Ghz, VHT mode */
+
+/*
+ * ATM
+ */
+#define	IFM_ATM	0x000000a0
+#define	IFM_ATM_UNKNOWN		3
+#define	IFM_ATM_UTP_25		4
+#define	IFM_ATM_TAXI_100	5
+#define	IFM_ATM_TAXI_140	6
+#define	IFM_ATM_MM_155		7
+#define	IFM_ATM_SM_155		8
+#define	IFM_ATM_UTP_155		9
+#define	IFM_ATM_MM_622		10
+#define	IFM_ATM_SM_622		11
+#define	IFM_ATM_VIRTUAL		12
+#define	IFM_ATM_SDH		0x00000100	/* SDH instead of SONET */
+#define	IFM_ATM_NOSCRAMB	0x00000200	/* no scrambling */
+#define	IFM_ATM_UNASSIGNED	0x00000400	/* unassigned cells */
+
+/*
+ * Shared media sub-types
+ */
+#define	IFM_AUTO	0		/* Autoselect best media */
+#define	IFM_MANUAL	1		/* Jumper/dipswitch selects media */
+#define	IFM_NONE	2		/* Deselect all media */
+
+/*
+ * Shared options
+ */
+#define	IFM_FDX		0x00100000	/* Force full duplex */
+#define	IFM_HDX		0x00200000	/* Force half duplex */
+#define	IFM_FLOW	0x00400000	/* enable hardware flow control */
+#define	IFM_FLAG0	0x01000000	/* Driver defined flag */
+#define	IFM_FLAG1	0x02000000	/* Driver defined flag */
+#define	IFM_FLAG2	0x04000000	/* Driver defined flag */
+#define	IFM_LOOP	0x08000000	/* Put hardware in loopback */
+
+/*
+ * Masks
+ */
+#define	IFM_NMASK	0x000000e0	/* Network type */
+#define	IFM_TMASK	0x0000001f	/* Media sub-type */
+#define	IFM_IMASK	0xf0000000	/* Instance */
+#define	IFM_ISHIFT	28		/* Instance shift */
+#define	IFM_OMASK	0x0000ff00	/* Type specific options */
+#define	IFM_MMASK	0x00070000	/* Mode */
+#define	IFM_MSHIFT	16		/* Mode shift */
+#define	IFM_GMASK	0x0ff00000	/* Global options */
+
+/* Ethernet flow control mask */
+#define	IFM_ETH_FMASK	(IFM_FLOW | IFM_ETH_RXPAUSE | IFM_ETH_TXPAUSE)
+
+/*
+ * Status bits
+ */
+#ifndef __HAIKU__
+#define	IFM_AVALID	0x00000001	/* Active bit valid */
+#define	IFM_ACTIVE	0x00000002	/* Interface attached to working net */
+#else
+#define IFM_AVALID	0x10000000	/* Active bit valid */
+#define IFM_ACTIVE	0x00800000	/* same as Haiku's */
+#endif
+
+/* Mask of "status valid" bits, for ifconfig(8). */
+#define	IFM_STATUS_VALID	IFM_AVALID
+
+/* List of "status valid" bits, for ifconfig(8). */
+#define	IFM_STATUS_VALID_LIST {						\
+	IFM_AVALID,							\
+	0								\
+}
+
+/*
+ * Macros to extract various bits of information from the media word.
+ */
+#define	IFM_TYPE(x)		((x) & IFM_NMASK)
+#define	IFM_SUBTYPE(x)	\
+  (IFM_TYPE(x) == IFM_ETHER ? IFM_ETHER_SUBTYPE_GET(x) : ((x) & IFM_TMASK))
+#define	IFM_TYPE_MATCH(x,y) \
+  (IFM_TYPE(x) == IFM_TYPE(y) && IFM_SUBTYPE(x) == IFM_SUBTYPE(y))
+#define	IFM_TYPE_OPTIONS(x)	((x) & IFM_OMASK)
+#define	IFM_INST(x)		(((x) & IFM_IMASK) >> IFM_ISHIFT)
+#define	IFM_OPTIONS(x)		((x) & (IFM_OMASK | IFM_GMASK))
+#define	IFM_MODE(x)		((x) & IFM_MMASK)
+
+#define	IFM_INST_MAX		IFM_INST(IFM_IMASK)
+
+/*
+ * Macro to create a media word.
+ */
+#define	IFM_MAKEWORD(type, subtype, options, instance)			\
+	((type) | (subtype) | (options) | ((instance) << IFM_ISHIFT))
+#define	IFM_MAKEMODE(mode) \
+	(((mode) << IFM_MSHIFT) & IFM_MMASK)
+
+/*
+ * NetBSD extension not defined in the BSDI API.  This is used in various
+ * places to get the canonical description for a given type/subtype.
+ *
+ * NOTE: all but the top-level type descriptions must contain NO whitespace!
+ * Otherwise, parsing these in ifconfig(8) would be a nightmare.
+ */
+struct ifmedia_description {
+	int	ifmt_word;		/* word value; may be masked */
+	const char *ifmt_string;	/* description */
+};
+
+#define	IFM_TYPE_DESCRIPTIONS {						\
+	{ IFM_ETHER,		"Ethernet" },				\
+	{ IFM_IEEE80211,	"IEEE 802.11 Wireless Ethernet" },	\
+	{ IFM_ATM,		"ATM" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_ETHERNET_DESCRIPTIONS {				\
+	{ IFM_10_T,	"10baseT/UTP" },				\
+	{ IFM_10_2,	"10base2/BNC" },				\
+	{ IFM_10_5,	"10base5/AUI" },				\
+	{ IFM_100_TX,	"100baseTX" },					\
+	{ IFM_100_FX,	"100baseFX" },					\
+	{ IFM_100_T4,	"100baseT4" },					\
+	{ IFM_100_VG,	"100baseVG" },					\
+	{ IFM_100_T2,	"100baseT2" },					\
+	{ IFM_10_STP,	"10baseSTP" },					\
+	{ IFM_10_FL,	"10baseFL" },					\
+	{ IFM_1000_SX,	"1000baseSX" },					\
+	{ IFM_1000_LX,	"1000baseLX" },					\
+	{ IFM_1000_CX,	"1000baseCX" },					\
+	{ IFM_1000_T,	"1000baseT" },					\
+	{ IFM_HPNA_1,	"homePNA" },					\
+	{ IFM_10G_LR,	"10Gbase-LR" },					\
+	{ IFM_10G_SR,	"10Gbase-SR" },					\
+	{ IFM_10G_CX4,	"10Gbase-CX4" },				\
+	{ IFM_2500_SX,	"2500BaseSX" },					\
+	{ IFM_10G_LRM,	"10Gbase-LRM" },				\
+	{ IFM_10G_TWINAX,	"10Gbase-Twinax" },			\
+	{ IFM_10G_TWINAX_LONG,	"10Gbase-Twinax-Long" },		\
+	{ IFM_UNKNOWN,	"Unknown" },					\
+	{ IFM_10G_T,	"10Gbase-T" },					\
+	{ IFM_40G_CR4,	"40Gbase-CR4" },				\
+	{ IFM_40G_SR4,	"40Gbase-SR4" },				\
+	{ IFM_40G_LR4,	"40Gbase-LR4" },				\
+	{ IFM_1000_KX,	"1000Base-KX" },				\
+	{ IFM_OTHER,	"Other" },					\
+	{ IFM_10G_KX4,	"10GBase-KX4" },				\
+	{ IFM_10G_KR,	"10GBase-KR" },					\
+	{ IFM_10G_CR1,	"10GBase-CR1" },				\
+	{ IFM_20G_KR2,	"20GBase-KR2" },				\
+	{ IFM_2500_KX,	"2500Base-KX" },				\
+	{ IFM_2500_T,	"2500Base-T" },					\
+	{ IFM_5000_T,	"5000Base-T" },					\
+	{ IFM_50G_PCIE,	"PCIExpress-50G" },				\
+	{ IFM_25G_PCIE,	"PCIExpress-25G" },				\
+	{ IFM_1000_SGMII,	"1000Base-SGMII" },			\
+	{ IFM_10G_SFI,	"10GBase-SFI" },				\
+	{ IFM_40G_XLPPI,	"40GBase-XLPPI" },			\
+	{ IFM_1000_CX_SGMII,	"1000Base-CX-SGMII" },			\
+	{ IFM_40G_KR4,	"40GBase-KR4" },				\
+	{ IFM_10G_ER,	"10GBase-ER" },					\
+	{ IFM_100G_CR4,	"100GBase-CR4" },				\
+	{ IFM_100G_SR4,	"100GBase-SR4" },				\
+	{ IFM_100G_KR4,	"100GBase-KR4" },				\
+	{ IFM_100G_LR4, "100GBase-LR4" },				\
+	{ IFM_56G_R4,	"56GBase-R4" },					\
+	{ IFM_100_T,	"100BaseT" },					\
+	{ IFM_25G_CR,	"25GBase-CR" },					\
+	{ IFM_25G_KR,	"25GBase-KR" },					\
+	{ IFM_25G_SR,	"25GBase-SR" },					\
+	{ IFM_50G_CR2,	"50GBase-CR2" },				\
+	{ IFM_50G_KR2,	"50GBase-KR2" },				\
+	{ IFM_25G_LR,	"25GBase-LR" },					\
+	{ IFM_10G_AOC,	"10GBase-AOC" },				\
+	{ IFM_25G_ACC,	"25GBase-ACC" },				\
+	{ IFM_25G_AOC,	"25GBase-AOC" },				\
+	{ IFM_100_SGMII,	"100M-SGMII" },				\
+	{ IFM_2500_X,	"2500Base-X" },					\
+	{ IFM_5000_KR,	"5000Base-KR" },				\
+	{ IFM_25G_T,	"25GBase-T" },					\
+	{ IFM_25G_CR_S,	"25GBase-CR-S" },				\
+	{ IFM_25G_CR1,	"25GBase-CR1" },				\
+	{ IFM_25G_KR_S,	"25GBase-KR-S" },				\
+	{ IFM_5000_KR_S,	"5000Base-KR-S" },			\
+	{ IFM_5000_KR1,	"5000Base-KR1" },				\
+	{ IFM_25G_AUI,	"25G-AUI" },					\
+	{ IFM_40G_XLAUI,	"40G-XLAUI" },				\
+	{ IFM_40G_XLAUI_AC,	"40G-XLAUI-AC" },			\
+	{ IFM_40G_ER4,	"40GBase-ER4" },				\
+	{ IFM_50G_SR2,	"50GBase-SR2" },				\
+	{ IFM_50G_LR2,	"50GBase-LR2" },				\
+	{ IFM_50G_LAUI2_AC,	"50G-LAUI2-AC" },			\
+	{ IFM_50G_LAUI2,	"50G-LAUI2" },				\
+	{ IFM_50G_AUI2_AC,	"50G-AUI2-AC" },			\
+	{ IFM_50G_AUI2,	"50G-AUI2" },					\
+	{ IFM_50G_CP,	"50GBase-CP" },					\
+	{ IFM_50G_SR,	"50GBase-SR" },					\
+	{ IFM_50G_LR,	"50GBase-LR" },					\
+	{ IFM_50G_FR,	"50GBase-FR" },					\
+	{ IFM_50G_KR_PAM4,	"50GBase-KR-PAM4" },			\
+	{ IFM_25G_KR1,	"25GBase-KR1" },				\
+	{ IFM_50G_AUI1_AC,	"50G-AUI1-AC" },			\
+	{ IFM_50G_AUI1,	"50G-AUI1" },					\
+	{ IFM_100G_CAUI4_AC,	"100G-CAUI4-AC" },			\
+	{ IFM_100G_CAUI4,	"100G-CAUI4" },				\
+	{ IFM_100G_AUI4_AC,	"100G-AUI4-AC" },			\
+	{ IFM_100G_AUI4,	"100G-AUI4" },				\
+	{ IFM_100G_CR_PAM4,	"100GBase-CR-PAM4" },			\
+	{ IFM_100G_KR_PAM4,	"100GBase-KR-PAM4" },			\
+	{ IFM_100G_CP2,	"100GBase-CP2" },				\
+	{ IFM_100G_SR2,	"100GBase-SR2" },				\
+	{ IFM_100G_DR,	"100GBase-DR" },				\
+	{ IFM_100G_KR2_PAM4,	"100GBase-KR2-PAM4" },			\
+	{ IFM_100G_CAUI2_AC,	"100G-CAUI2-AC" },			\
+	{ IFM_100G_CAUI2,	"100G-CAUI2" },				\
+	{ IFM_100G_AUI2_AC,	"100G-AUI2-AC" },			\
+	{ IFM_100G_AUI2,	"100G-AUI2" },				\
+	{ IFM_200G_CR4_PAM4,	"200GBase-CR4-PAM4" },			\
+	{ IFM_200G_SR4,	"200GBase-SR4" },				\
+	{ IFM_200G_FR4,	"200GBase-FR4" },				\
+	{ IFM_200G_LR4,	"200GBase-LR4" },				\
+	{ IFM_200G_DR4,	"200GBase-DR4" },				\
+	{ IFM_200G_KR4_PAM4,	"200GBase-KR4-PAM4" },			\
+	{ IFM_200G_AUI4_AC,	"200G-AUI4-AC" },			\
+	{ IFM_200G_AUI4,	"200G-AUI4" },				\
+	{ IFM_200G_AUI8_AC,	"200G-AUI8-AC" },			\
+	{ IFM_200G_AUI8,	"200G-AUI8" },				\
+	{ IFM_400G_FR8,	"400GBase-FR8" },				\
+	{ IFM_400G_LR8,	"400GBase-LR8" },				\
+	{ IFM_400G_DR4,	"400GBase-DR4" },				\
+	{ IFM_400G_AUI8_AC,	"400G-AUI8-AC" },			\
+	{ IFM_400G_AUI8,	"400G-AUI8" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_ETHERNET_ALIASES {					\
+	{ IFM_10_T,	"10baseT" },					\
+	{ IFM_10_T,	"UTP" },					\
+	{ IFM_10_T,	"10UTP" },					\
+	{ IFM_10_2,	"BNC" },					\
+	{ IFM_10_2,	"10BNC" },					\
+	{ IFM_10_5,	"AUI" },					\
+	{ IFM_10_5,	"10AUI" },					\
+	{ IFM_100_TX,	"100TX" },					\
+	{ IFM_100_T4,	"100T4" },					\
+	{ IFM_100_VG,	"100VG" },					\
+	{ IFM_100_T2,	"100T2" },					\
+	{ IFM_10_STP,	"10STP" },					\
+	{ IFM_10_FL,	"10FL" },					\
+	{ IFM_1000_SX,	"1000SX" },					\
+	{ IFM_1000_LX,	"1000LX" },					\
+	{ IFM_1000_CX,	"1000CX" },					\
+	{ IFM_1000_T,	"1000baseTX" },					\
+	{ IFM_1000_T,	"1000TX" },					\
+	{ IFM_1000_T,	"1000T" },					\
+	{ IFM_2500_SX,	"2500SX" },					\
+									\
+	/*								\
+	 * Shorthands for common media+option combinations as announced	\
+	 * by miibus(4)							\
+	 */								\
+	{ IFM_10_T | IFM_FDX,			"10baseT-FDX" },	\
+	{ IFM_10_T | IFM_FDX | IFM_FLOW,	"10baseT-FDX-flow" },	\
+	{ IFM_100_TX | IFM_FDX,			"100baseTX-FDX" },	\
+	{ IFM_100_TX | IFM_FDX | IFM_FLOW,	"100baseTX-FDX-flow" },	\
+	{ IFM_1000_T | IFM_FDX,			"1000baseT-FDX" },	\
+	{ IFM_1000_T | IFM_FDX | IFM_FLOW,	"1000baseT-FDX-flow" },	\
+	{ IFM_1000_T | IFM_FDX | IFM_FLOW | IFM_ETH_MASTER,		\
+	    "1000baseT-FDX-flow-master" },				\
+	{ IFM_1000_T | IFM_FDX | IFM_ETH_MASTER,			\
+	    "1000baseT-FDX-master" },					\
+	{ IFM_1000_T | IFM_ETH_MASTER,		"1000baseT-master" },	\
+									\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_ETHERNET_OPTION_DESCRIPTIONS {			\
+	{ IFM_ETH_MASTER,	"master" },				\
+	{ IFM_ETH_RXPAUSE,	"rxpause" },				\
+	{ IFM_ETH_TXPAUSE,	"txpause" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_IEEE80211_DESCRIPTIONS {				\
+	{ IFM_IEEE80211_FH1, "FH/1Mbps" },				\
+	{ IFM_IEEE80211_FH2, "FH/2Mbps" },				\
+	{ IFM_IEEE80211_DS1, "DS/1Mbps" },				\
+	{ IFM_IEEE80211_DS2, "DS/2Mbps" },				\
+	{ IFM_IEEE80211_DS5, "DS/5.5Mbps" },				\
+	{ IFM_IEEE80211_DS11, "DS/11Mbps" },				\
+	{ IFM_IEEE80211_DS22, "DS/22Mbps" },				\
+	{ IFM_IEEE80211_OFDM6, "OFDM/6Mbps" },				\
+	{ IFM_IEEE80211_OFDM9, "OFDM/9Mbps" },				\
+	{ IFM_IEEE80211_OFDM12, "OFDM/12Mbps" },			\
+	{ IFM_IEEE80211_OFDM18, "OFDM/18Mbps" },			\
+	{ IFM_IEEE80211_OFDM24, "OFDM/24Mbps" },			\
+	{ IFM_IEEE80211_OFDM36, "OFDM/36Mbps" },			\
+	{ IFM_IEEE80211_OFDM48, "OFDM/48Mbps" },			\
+	{ IFM_IEEE80211_OFDM54, "OFDM/54Mbps" },			\
+	{ IFM_IEEE80211_OFDM72, "OFDM/72Mbps" },			\
+	{ IFM_IEEE80211_DS354k, "DS/354Kbps" },				\
+	{ IFM_IEEE80211_DS512k, "DS/512Kbps" },				\
+	{ IFM_IEEE80211_OFDM3, "OFDM/3Mbps" },				\
+	{ IFM_IEEE80211_OFDM4, "OFDM/4.5Mbps" },			\
+	{ IFM_IEEE80211_OFDM27, "OFDM/27Mbps" },			\
+	{ IFM_IEEE80211_MCS, "MCS" },					\
+	{ IFM_IEEE80211_VHT, "VHT" },					\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_IEEE80211_ALIASES {					\
+	{ IFM_IEEE80211_FH1, "FH1" },					\
+	{ IFM_IEEE80211_FH2, "FH2" },					\
+	{ IFM_IEEE80211_FH1, "FrequencyHopping/1Mbps" },		\
+	{ IFM_IEEE80211_FH2, "FrequencyHopping/2Mbps" },		\
+	{ IFM_IEEE80211_DS1, "DS1" },					\
+	{ IFM_IEEE80211_DS2, "DS2" },					\
+	{ IFM_IEEE80211_DS5, "DS5.5" },					\
+	{ IFM_IEEE80211_DS11, "DS11" },					\
+	{ IFM_IEEE80211_DS22, "DS22" },					\
+	{ IFM_IEEE80211_DS1, "DirectSequence/1Mbps" },			\
+	{ IFM_IEEE80211_DS2, "DirectSequence/2Mbps" },			\
+	{ IFM_IEEE80211_DS5, "DirectSequence/5.5Mbps" },		\
+	{ IFM_IEEE80211_DS11, "DirectSequence/11Mbps" },		\
+	{ IFM_IEEE80211_DS22, "DirectSequence/22Mbps" },		\
+	{ IFM_IEEE80211_OFDM6, "OFDM6" },				\
+	{ IFM_IEEE80211_OFDM9, "OFDM9" },				\
+	{ IFM_IEEE80211_OFDM12, "OFDM12" },				\
+	{ IFM_IEEE80211_OFDM18, "OFDM18" },				\
+	{ IFM_IEEE80211_OFDM24, "OFDM24" },				\
+	{ IFM_IEEE80211_OFDM36, "OFDM36" },				\
+	{ IFM_IEEE80211_OFDM48, "OFDM48" },				\
+	{ IFM_IEEE80211_OFDM54, "OFDM54" },				\
+	{ IFM_IEEE80211_OFDM72, "OFDM72" },				\
+	{ IFM_IEEE80211_DS1, "CCK1" },					\
+	{ IFM_IEEE80211_DS2, "CCK2" },					\
+	{ IFM_IEEE80211_DS5, "CCK5.5" },				\
+	{ IFM_IEEE80211_DS11, "CCK11" },				\
+	{ IFM_IEEE80211_DS354k, "DS354K" },				\
+	{ IFM_IEEE80211_DS354k, "DirectSequence/354Kbps" },		\
+	{ IFM_IEEE80211_DS512k, "DS512K" },				\
+	{ IFM_IEEE80211_DS512k, "DirectSequence/512Kbps" },		\
+	{ IFM_IEEE80211_OFDM3, "OFDM3" },				\
+	{ IFM_IEEE80211_OFDM4, "OFDM4.5" },				\
+	{ IFM_IEEE80211_OFDM27, "OFDM27" },				\
+	{ IFM_IEEE80211_MCS, "MCS" },					\
+	{ IFM_IEEE80211_VHT, "VHT" },					\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_IEEE80211_OPTION_DESCRIPTIONS {			\
+	{ IFM_IEEE80211_ADHOC, "adhoc" },				\
+	{ IFM_IEEE80211_HOSTAP, "hostap" },				\
+	{ IFM_IEEE80211_IBSS, "ibss" },					\
+	{ IFM_IEEE80211_WDS, "wds" },					\
+	{ IFM_IEEE80211_TURBO, "turbo" },				\
+	{ IFM_IEEE80211_MONITOR, "monitor" },				\
+	{ IFM_IEEE80211_MBSS, "mesh" },					\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_IEEE80211_MODE_DESCRIPTIONS {			\
+	{ IFM_AUTO, "autoselect" },					\
+	{ IFM_IEEE80211_11A, "11a" },					\
+	{ IFM_IEEE80211_11B, "11b" },					\
+	{ IFM_IEEE80211_11G, "11g" },					\
+	{ IFM_IEEE80211_FH, "fh" },					\
+	{ IFM_IEEE80211_11NA, "11na" },					\
+	{ IFM_IEEE80211_11NG, "11ng" },					\
+	{ IFM_IEEE80211_VHT5G, "11ac" },				\
+	{ IFM_IEEE80211_VHT2G, "11ac2" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_IEEE80211_MODE_ALIASES {				\
+	{ IFM_AUTO, "auto" },						\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_ATM_DESCRIPTIONS {					\
+	{ IFM_ATM_UNKNOWN,	"Unknown" },				\
+	{ IFM_ATM_UTP_25,	"UTP/25.6MBit" },			\
+	{ IFM_ATM_TAXI_100,	"Taxi/100MBit" },			\
+	{ IFM_ATM_TAXI_140,	"Taxi/140MBit" },			\
+	{ IFM_ATM_MM_155,	"Multi-mode/155MBit" },			\
+	{ IFM_ATM_SM_155,	"Single-mode/155MBit" },		\
+	{ IFM_ATM_UTP_155,	"UTP/155MBit" },			\
+	{ IFM_ATM_MM_622,	"Multi-mode/622MBit" },			\
+	{ IFM_ATM_SM_622,	"Single-mode/622MBit" },		\
+	{ IFM_ATM_VIRTUAL,	"Virtual" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_ATM_ALIASES {					\
+	{ IFM_ATM_UNKNOWN,	"UNKNOWN" },				\
+	{ IFM_ATM_UTP_25,	"UTP-25" },				\
+	{ IFM_ATM_TAXI_100,	"TAXI-100" },				\
+	{ IFM_ATM_TAXI_140,	"TAXI-140" },				\
+	{ IFM_ATM_MM_155,	"MM-155" },				\
+	{ IFM_ATM_SM_155,	"SM-155" },				\
+	{ IFM_ATM_UTP_155,	"UTP-155" },				\
+	{ IFM_ATM_MM_622,	"MM-622" },				\
+	{ IFM_ATM_SM_622,	"SM-622" },				\
+	{ IFM_ATM_VIRTUAL,	"VIRTUAL" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_ATM_OPTION_DESCRIPTIONS {				\
+	{ IFM_ATM_SDH, "SDH" },						\
+	{ IFM_ATM_NOSCRAMB, "Noscramb" },				\
+	{ IFM_ATM_UNASSIGNED, "Unassigned" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_SHARED_DESCRIPTIONS {				\
+	{ IFM_AUTO,	"autoselect" },					\
+	{ IFM_MANUAL,	"manual" },					\
+	{ IFM_NONE,	"none" },					\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SUBTYPE_SHARED_ALIASES {					\
+	{ IFM_AUTO,	"auto" },					\
+									\
+	/*								\
+	 * Shorthands for common media+option combinations as announced	\
+	 * by miibus(4)							\
+	 */								\
+	{ IFM_AUTO | IFM_FLOW,	"auto-flow" },				\
+									\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SHARED_OPTION_DESCRIPTIONS {				\
+	{ IFM_FDX,	"full-duplex" },				\
+	{ IFM_HDX,	"half-duplex" },				\
+	{ IFM_FLOW,	"flowcontrol" },				\
+	{ IFM_FLAG0,	"flag0" },					\
+	{ IFM_FLAG1,	"flag1" },					\
+	{ IFM_FLAG2,	"flag2" },					\
+	{ IFM_LOOP,	"hw-loopback" },				\
+	{ 0, NULL },							\
+}
+
+#define	IFM_SHARED_OPTION_ALIASES {					\
+	{ IFM_FDX,	"fdx" },					\
+	{ IFM_HDX,	"hdx" },					\
+	{ IFM_FLOW,	"flow" },					\
+	{ IFM_LOOP,	"loop" },					\
+	{ IFM_LOOP,	"loopback" },					\
+	{ 0, NULL },							\
+}
+
+/*
+ * Baudrate descriptions for the various media types.
+ */
+struct ifmedia_baudrate {
+	int		ifmb_word;		/* media word */
+	uint64_t	ifmb_baudrate;		/* corresponding baudrate */
+};
+
+#define	IFM_BAUDRATE_DESCRIPTIONS {					\
+	{ IFM_ETHER | IFM_10_T,		IF_Mbps(10) },			\
+	{ IFM_ETHER | IFM_10_2,		IF_Mbps(10) },			\
+	{ IFM_ETHER | IFM_10_5,		IF_Mbps(10) },			\
+	{ IFM_ETHER | IFM_100_TX,	IF_Mbps(100) },			\
+	{ IFM_ETHER | IFM_100_FX,	IF_Mbps(100) },			\
+	{ IFM_ETHER | IFM_100_T4,	IF_Mbps(100) },			\
+	{ IFM_ETHER | IFM_100_VG,	IF_Mbps(100) },			\
+	{ IFM_ETHER | IFM_100_T2,	IF_Mbps(100) },			\
+	{ IFM_ETHER | IFM_1000_SX,	IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_10_STP,	IF_Mbps(10) },			\
+	{ IFM_ETHER | IFM_10_FL,	IF_Mbps(10) },			\
+	{ IFM_ETHER | IFM_1000_LX,	IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_1000_CX,	IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_1000_T,	IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_HPNA_1,	IF_Mbps(1) },			\
+	{ IFM_ETHER | IFM_10G_LR,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_10G_SR,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_10G_CX4,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_2500_SX,	IF_Mbps(2500ULL) },		\
+	{ IFM_ETHER | IFM_10G_TWINAX,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_10G_TWINAX_LONG,	IF_Gbps(10ULL) },	\
+	{ IFM_ETHER | IFM_10G_LRM,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_10G_T,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_40G_CR4,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_40G_SR4,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_40G_LR4,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_1000_KX,	IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_10G_KX4,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_10G_KR,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_10G_CR1,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_20G_KR2,	IF_Gbps(20ULL) },		\
+	{ IFM_ETHER | IFM_2500_KX,	IF_Mbps(2500) },		\
+	{ IFM_ETHER | IFM_2500_T,	IF_Mbps(2500) },		\
+	{ IFM_ETHER | IFM_5000_T,	IF_Mbps(5000) },		\
+	{ IFM_ETHER | IFM_50G_PCIE,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_25G_PCIE,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_1000_SGMII,	IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_10G_SFI,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_40G_XLPPI,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_1000_CX_SGMII, IF_Mbps(1000) },		\
+	{ IFM_ETHER | IFM_40G_KR4,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_10G_ER,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_100G_CR4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_SR4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_KR4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_LR4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_56G_R4,	IF_Gbps(56ULL) },		\
+	{ IFM_ETHER | IFM_100_T,	IF_Mbps(100ULL) },		\
+	{ IFM_ETHER | IFM_25G_CR,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_25G_KR,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_25G_SR,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_50G_CR2,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_KR2,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_25G_LR,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_10G_AOC,	IF_Gbps(10ULL) },		\
+	{ IFM_ETHER | IFM_25G_ACC,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_25G_AOC,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_100_SGMII,	IF_Mbps(100) },			\
+	{ IFM_ETHER | IFM_2500_X,	IF_Mbps(2500ULL) },		\
+	{ IFM_ETHER | IFM_5000_KR,	IF_Mbps(5000ULL) },		\
+	{ IFM_ETHER | IFM_25G_T,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_25G_CR_S,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_25G_CR1,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_25G_KR_S,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_5000_KR_S,	IF_Mbps(5000ULL) },		\
+	{ IFM_ETHER | IFM_5000_KR1,	IF_Mbps(5000ULL) },		\
+	{ IFM_ETHER | IFM_25G_AUI,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_40G_XLAUI,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_40G_XLAUI_AC,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_40G_ER4,	IF_Gbps(40ULL) },		\
+	{ IFM_ETHER | IFM_50G_SR2,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_LR2,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_LAUI2_AC,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_LAUI2,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_AUI2_AC,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_AUI2,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_CP,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_SR,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_LR,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_FR,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_KR_PAM4,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_25G_KR1,	IF_Gbps(25ULL) },		\
+	{ IFM_ETHER | IFM_50G_AUI1_AC,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_50G_AUI1,	IF_Gbps(50ULL) },		\
+	{ IFM_ETHER | IFM_100G_CAUI4_AC, IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_CAUI4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_AUI4_AC,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_AUI4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_CR_PAM4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_KR_PAM4,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_CP2,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_SR2,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_DR,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_KR2_PAM4, IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_CAUI2_AC, IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_CAUI2,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_AUI2_AC,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_100G_AUI2,	IF_Gbps(100ULL) },		\
+	{ IFM_ETHER | IFM_200G_CR4_PAM4, IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_SR4,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_FR4,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_LR4,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_DR4,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_KR4_PAM4, IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_AUI4_AC,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_AUI4,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_AUI8_AC,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_200G_AUI8,	IF_Gbps(200ULL) },		\
+	{ IFM_ETHER | IFM_400G_FR8,	IF_Gbps(400ULL) },		\
+	{ IFM_ETHER | IFM_400G_LR8,	IF_Gbps(400ULL) },		\
+	{ IFM_ETHER | IFM_400G_DR4,	IF_Gbps(400ULL) },		\
+	{ IFM_ETHER | IFM_400G_AUI8_AC,	IF_Gbps(400ULL) },		\
+	{ IFM_ETHER | IFM_400G_AUI8,	IF_Gbps(400ULL) },		\
+									\
+	{ IFM_IEEE80211 | IFM_IEEE80211_FH1,	IF_Mbps(1) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_FH2,	IF_Mbps(2) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_DS2,	IF_Mbps(2) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_DS5,	IF_Kbps(5500) },	\
+	{ IFM_IEEE80211 | IFM_IEEE80211_DS11,	IF_Mbps(11) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_DS1,	IF_Mbps(1) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_DS22,	IF_Mbps(22) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM6,	IF_Mbps(6) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM9,	IF_Mbps(9) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM12,	IF_Mbps(12) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM18,	IF_Mbps(18) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM24,	IF_Mbps(24) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM36,	IF_Mbps(36) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM48,	IF_Mbps(48) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM54,	IF_Mbps(54) },		\
+	{ IFM_IEEE80211 | IFM_IEEE80211_OFDM72,	IF_Mbps(72) },		\
+									\
+	{ 0, 0 },							\
+}
+
+/*
+ * Status descriptions for the various media types.
+ */
+struct ifmedia_status_description {
+	int	   ifms_type;
+	int	   ifms_valid;
+	int	   ifms_bit;
+	const char *ifms_string[2];
+};
+
+#define	IFM_STATUS_DESC(ifms, bit)					\
+	(ifms)->ifms_string[((ifms)->ifms_bit & (bit)) ? 1 : 0]
+
+#define	IFM_STATUS_DESCRIPTIONS {					\
+	{ IFM_ETHER,		IFM_AVALID,	IFM_ACTIVE,		\
+	    { "no carrier", "active" } },				\
+	{ IFM_IEEE80211,	IFM_AVALID,	IFM_ACTIVE,		\
+	    { "no network", "active" } },				\
+	{ IFM_ATM,		IFM_AVALID,	IFM_ACTIVE,		\
+	    { "no network", "active" } },				\
+	{ 0,			0,		0,			\
+	    { NULL, NULL } }						\
+}
+
+#endif	/* _FBSD_COMPAT_NET_IF_MEDIA_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_types.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_types.h
new file mode 100644
index 0000000000..3e2f73000f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_types.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NET_IF_TYPES_H_
+#define _FBSD_COMPAT_NET_IF_TYPES_H_
+
+
+#include <posix/net/if_types.h>
+
+
+#endif /* _FBSD_COMPAT_NET_IF_TYPES_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_var.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_var.h
new file mode 100644
index 0000000000..9f64a0db01
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_var.h
@@ -0,0 +1,1017 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	From: @(#)if.h	8.1 (Berkeley) 6/10/93
+ * $FreeBSD: src/sys/net/if_var.h,v 1.98.2.6 2006/10/06 20:26:05 andre Exp $
+ */
+
+#ifndef	_FBSD_COMPAT_NET_IF_VAR_H_
+#define	_FBSD_COMPAT_NET_IF_VAR_H_
+
+/*
+ * Structures defining a network interface, providing a packet
+ * transport mechanism (ala level 0 of the PUP protocols).
+ *
+ * Each interface accepts output datagrams of a specified maximum
+ * length, and provides higher level routines with input datagrams
+ * received from its medium.
+ *
+ * Output occurs when the routine if_output is called, with three parameters:
+ *	(*ifp->if_output)(ifp, m, dst, rt)
+ * Here m is the mbuf chain to be sent and dst is the destination address.
+ * The output routine encapsulates the supplied datagram if necessary,
+ * and then transmits it on its medium.
+ *
+ * On input, each interface unwraps the data received by it, and either
+ * places it on the input queue of an internetwork datagram routine
+ * and posts the associated software interrupt, or passes the datagram to a raw
+ * packet input routine.
+ *
+ * Routines exist for locating interfaces by their addresses
+ * or for locating an interface on a certain network, as well as more general
+ * routing and gateway routines maintaining information used to locate
+ * interfaces.  These routines live in the files if.c and route.c
+ */
+
+#ifdef __STDC__
+/*
+ * Forward structure declarations for function prototypes [sic].
+ */
+struct	mbuf;
+struct	thread;
+struct	rtentry;
+struct	rt_addrinfo;
+struct	socket;
+struct	ether_header;
+struct	carp_if;
+struct	route;
+#endif
+
+#include <posix/net/if_dl.h>
+
+#include <sys/queue.h>		/* get TAILQ macros */
+
+#ifdef _KERNEL
+#include <sys/mbuf.h>
+#include <sys/eventhandler.h>
+#endif /* _KERNEL */
+#include <sys/counter.h>
+#include <sys/lock.h>		/* XXX */
+#include <sys/mutex.h>		/* XXX */
+#include <sys/event.h>		/* XXX */
+#include <sys/buf_ring.h>
+#include <sys/_task.h>
+
+#define	IF_DUNIT_NONE	-1
+
+#include <altq/if_altq.h>
+
+typedef enum {
+	IFCOUNTER_IPACKETS = 0,
+	IFCOUNTER_IERRORS,
+	IFCOUNTER_OPACKETS,
+	IFCOUNTER_OERRORS,
+	IFCOUNTER_COLLISIONS,
+	IFCOUNTER_IBYTES,
+	IFCOUNTER_OBYTES,
+	IFCOUNTER_IMCASTS,
+	IFCOUNTER_OMCASTS,
+	IFCOUNTER_IQDROPS,
+	IFCOUNTER_OQDROPS,
+	IFCOUNTER_NOPROTO,
+	IFCOUNTERS /* Array size. */
+} ift_counter;
+
+TAILQ_HEAD(ifnethead, ifnet);	/* we use TAILQs so that the order of */
+TAILQ_HEAD(ifaddrhead, ifaddr);	/* instantiation is preserved in the list */
+TAILQ_HEAD(ifprefixhead, ifprefix);
+TAILQ_HEAD(ifmultihead, ifmultiaddr);
+
+typedef struct ifnet * if_t;
+
+typedef	void (*if_start_fn_t)(if_t);
+typedef	int (*if_ioctl_fn_t)(if_t, u_long, caddr_t);
+typedef	void (*if_init_fn_t)(void *);
+typedef void (*if_qflush_fn_t)(if_t);
+typedef int (*if_transmit_fn_t)(if_t, struct mbuf *);
+typedef	uint64_t (*if_get_counter_t)(if_t, ift_counter);
+
+struct ifnet_hw_tsomax {
+	u_int	tsomaxbytes;	/* TSO total burst length limit in bytes */
+	u_int	tsomaxsegcount;	/* TSO maximum segment count */
+	u_int	tsomaxsegsize;	/* TSO maximum segment size in bytes */
+};
+
+/* Interface encap request types */
+typedef enum {
+	IFENCAP_LL = 1			/* pre-calculate link-layer header */
+} ife_type;
+
+/*
+ * The structure below allows to request various pre-calculated L2/L3 headers
+ * for different media. Requests varies by type (rtype field).
+ *
+ * IFENCAP_LL type: pre-calculates link header based on address family
+ *   and destination lladdr.
+ *
+ *   Input data fields:
+ *     buf: pointer to destination buffer
+ *     bufsize: buffer size
+ *     flags: IFENCAP_FLAG_BROADCAST if destination is broadcast
+ *     family: address family defined by AF_ constant.
+ *     lladdr: pointer to link-layer address
+ *     lladdr_len: length of link-layer address
+ *     hdata: pointer to L3 header (optional, used for ARP requests).
+ *   Output data fields:
+ *     buf: encap data is stored here
+ *     bufsize: resulting encap length is stored here
+ *     lladdr_off: offset of link-layer address from encap hdr start
+ *     hdata: L3 header may be altered if necessary
+ */
+
+struct if_encap_req {
+	u_char		*buf;		/* Destination buffer (w) */
+	size_t		bufsize;	/* size of provided buffer (r) */
+	ife_type	rtype;		/* request type (r) */
+	uint32_t	flags;		/* Request flags (r) */
+	int		family;		/* Address family AF_* (r) */
+	int		lladdr_off;	/* offset from header start (w) */
+	int		lladdr_len;	/* lladdr length (r) */
+	char		*lladdr;	/* link-level address pointer (r) */
+	char		*hdata;		/* Upper layer header data (rw) */
+};
+
+
+/*
+ * Structure defining a queue for a network interface.
+ */
+struct	ifqueue {
+	struct	mbuf *ifq_head;
+	struct	mbuf *ifq_tail;
+	int	ifq_len;
+	int	ifq_maxlen;
+	int	ifq_drops;
+	struct	mtx ifq_mtx;
+};
+
+struct device;
+
+/*
+ * Structure defining a network interface.
+ *
+ * (Would like to call this struct ``if'', but C isn't PL/1.)
+ */
+
+struct ifnet {
+	void	*if_softc;		/* pointer to driver state */
+	void	*if_l2com;		/* pointer to protocol bits */
+	TAILQ_ENTRY(ifnet) if_link; 	/* all struct ifnets are chained */
+	char	if_xname[IFNAMSIZ];	/* external name (name + unit) */
+	const char *if_dname;		/* driver name */
+	int	if_dunit;		/* unit or IF_DUNIT_NONE */
+	struct	ifaddrhead if_addrhead;	/* linked list of addresses per if */
+		/*
+		 * if_addrhead is the list of all addresses associated to
+		 * an interface.
+		 * Some code in the kernel assumes that first element
+		 * of the list has type AF_LINK, and contains sockaddr_dl
+		 * addresses which store the link-level address and the name
+		 * of the interface.
+		 * However, access to the AF_LINK address through this
+		 * field is deprecated. Use ifaddr_byindex() instead.
+		 */
+	struct	knlist if_klist;	/* events attached to this if */
+	int	if_pcount;		/* number of promiscuous listeners */
+	struct	carp_if *if_carp;	/* carp interface structure */
+	struct	bpf_if *if_bpf;		/* packet filter structure */
+	u_short	if_index;		/* numeric abbreviation for this if  */
+	short	if_timer;		/* time 'til if_watchdog called */
+	struct  ifvlantrunk *if_vlantrunk; /* pointer to 802.1q data */
+	int	if_flags;		/* up/down, broadcast, etc. */
+	int	if_capabilities;	/* interface capabilities */
+	int	if_capenable;		/* enabled features */
+	void	*if_linkmib;		/* link-type-specific MIB data */
+	size_t	if_linkmiblen;		/* length of above data */
+	struct	if_data if_data;
+	struct	ifmultihead if_multiaddrs; /* multicast addresses configured */
+	int	if_amcount;		/* number of all-multicast requests */
+	struct	ifaddr	*if_addr;	/* pointer to link-level address */
+/* procedure handles */
+	int	(*if_output)		/* output routine (enqueue) */
+		(struct ifnet *, struct mbuf *, struct sockaddr *,
+		     struct route *);
+	void	(*if_input)		/* input routine (from h/w driver) */
+		(struct ifnet *, struct mbuf *);
+	void	(*if_start)		/* initiate output routine */
+		(struct ifnet *);
+	int	(*if_ioctl)		/* ioctl routine */
+		(struct ifnet *, u_long, caddr_t);
+	void	(*if_watchdog)		/* timer routine */
+		(struct ifnet *);
+	void	(*if_init)		/* Init routine */
+		(void *);
+	int	(*if_resolvemulti)	/* validate/resolve multicast */
+		(struct ifnet *, struct sockaddr **, struct sockaddr *);
+	int	(*if_transmit)		/* initiate output routine */
+		(struct ifnet *, struct mbuf *);
+	void	*if_spare1;		/* spare pointer 1 */
+	void	*if_spare2;		/* spare pointer 2 */
+	void	*if_spare3;		/* spare pointer 3 */
+	int	if_drv_flags;		/* driver-managed status flags */
+	u_int	if_spare_flags2;	/* spare flags 2 */
+	struct  ifaltq if_snd;		/* output queue (includes altq) */
+	const u_int8_t *if_broadcastaddr; /* linklevel broadcast bytestring */
+
+	void	*if_bridge;		/* bridge glue */
+
+	struct	lltable *lltables;	/* list of L3-L2 resolution tables */
+
+	struct	label *if_label;	/* interface MAC label */
+
+	/* these are only used by IPv6 */
+	struct	ifprefixhead if_prefixhead; /* list of prefixes per if */
+	void	*if_afdata[AF_MAX];
+	int	if_afdata_initialized;
+	struct	mtx if_afdata_mtx;
+	struct	task if_starttask;	/* task for IFF_NEEDSGIANT */
+	struct	task if_linktask;	/* task for link change events */
+	struct	mtx if_addr_mtx;	/* mutex to protect address lists */
+
+	if_qflush_fn_t	if_qflush;	/* flush any queue */
+	if_get_counter_t if_get_counter; /* get counter values */
+	int	(*if_requestencap)	/* make link header from request */
+		(struct ifnet *, struct if_encap_req *);
+
+	/*
+	 * Network adapter TSO limits:
+	 * ===========================
+	 *
+	 * If the "if_hw_tsomax" field is zero the maximum segment
+	 * length limit does not apply. If the "if_hw_tsomaxsegcount"
+	 * or the "if_hw_tsomaxsegsize" field is zero the TSO segment
+	 * count limit does not apply. If all three fields are zero,
+	 * there is no TSO limit.
+	 *
+	 * NOTE: The TSO limits should reflect the values used in the
+	 * BUSDMA tag a network adapter is using to load a mbuf chain
+	 * for transmission. The TCP/IP network stack will subtract
+	 * space for all linklevel and protocol level headers and
+	 * ensure that the full mbuf chain passed to the network
+	 * adapter fits within the given limits.
+	 */
+	u_int	if_hw_tsomax;		/* TSO maximum size in bytes */
+	u_int	if_hw_tsomaxsegcount;	/* TSO maximum segment count */
+	u_int	if_hw_tsomaxsegsize;	/* TSO maximum segment size in bytes */
+
+	/* Haiku additions */
+	struct sockaddr_dl	if_lladdr;
+	char				device_name[128];
+	struct device		*root_device;
+	struct ifqueue		receive_queue;
+	sem_id				receive_sem;
+	sem_id				link_state_sem;
+	int32				open_count;
+	int32				flags;
+
+	/* WLAN specific additions */
+	sem_id				scan_done_sem;
+};
+
+typedef void if_init_f_t(void *);
+
+/*
+ * XXX These aliases are terribly dangerous because they could apply
+ * to anything.
+ */
+#define	if_mtu		if_data.ifi_mtu
+#define	if_type		if_data.ifi_type
+#define if_physical	if_data.ifi_physical
+#define	if_addrlen	if_data.ifi_addrlen
+#define	if_hdrlen	if_data.ifi_hdrlen
+#define	if_metric	if_data.ifi_metric
+#define	if_link_state	if_data.ifi_link_state
+#define	if_baudrate	if_data.ifi_baudrate
+#define	if_hwassist	if_data.ifi_hwassist
+#define	if_ipackets	if_data.ifi_ipackets
+#define	if_ierrors	if_data.ifi_ierrors
+#define	if_opackets	if_data.ifi_opackets
+#define	if_oerrors	if_data.ifi_oerrors
+#define	if_collisions	if_data.ifi_collisions
+#define	if_ibytes	if_data.ifi_ibytes
+#define	if_obytes	if_data.ifi_obytes
+#define	if_imcasts	if_data.ifi_imcasts
+#define	if_omcasts	if_data.ifi_omcasts
+#define	if_iqdrops	if_data.ifi_iqdrops
+#define	if_oqdrops	if_data.ifi_oqdrops
+#define	if_noproto	if_data.ifi_noproto
+#define	if_lastchange	if_data.ifi_lastchange
+#define if_recvquota	if_data.ifi_recvquota
+#define	if_xmitquota	if_data.ifi_xmitquota
+#define if_rawoutput(if, m, sa) if_output(if, m, sa, (struct route *)NULL)
+
+/* for compatibility with other BSDs */
+#define	if_addrlist	if_addrhead
+#define	if_list		if_link
+
+/*
+ * Locks for address lists on the network interface.
+ */
+#define	IF_ADDR_LOCK_INIT(if)	mtx_init(&(if)->if_addr_mtx,		\
+				    "if_addr_mtx", NULL, MTX_DEF)
+#define	IF_ADDR_LOCK_DESTROY(if)	mtx_destroy(&(if)->if_addr_mtx)
+#define	IF_ADDR_LOCK(if)	mtx_lock(&(if)->if_addr_mtx)
+#define	IF_ADDR_UNLOCK(if)	mtx_unlock(&(if)->if_addr_mtx)
+#define	IF_ADDR_LOCK_ASSERT(if)	mtx_assert(&(if)->if_addr_mtx, MA_OWNED)
+
+void	if_addr_rlock(struct ifnet *ifp);	/* if_addrhead */
+void	if_addr_runlock(struct ifnet *ifp);	/* if_addrhead */
+void	if_maddr_rlock(struct ifnet *ifp);	/* if_multiaddrs */
+void	if_maddr_runlock(struct ifnet *ifp);	/* if_multiaddrs */
+
+/*
+ * Output queues (ifp->if_snd) and slow device input queues (*ifp->if_slowq)
+ * are queues of messages stored on ifqueue structures
+ * (defined above).  Entries are added to and deleted from these structures
+ * by these macros, which should be called with ipl raised to splimp().
+ */
+#define IF_LOCK(ifq)		mtx_lock(&(ifq)->ifq_mtx)
+#define IF_UNLOCK(ifq)		mtx_unlock(&(ifq)->ifq_mtx)
+#define	IF_LOCK_ASSERT(ifq)	mtx_assert(&(ifq)->ifq_mtx, MA_OWNED)
+#define	_IF_QFULL(ifq)		((ifq)->ifq_len >= (ifq)->ifq_maxlen)
+#define	_IF_DROP(ifq)		((ifq)->ifq_drops++)
+#define	_IF_QLEN(ifq)		((ifq)->ifq_len)
+
+#define	_IF_ENQUEUE(ifq, m) do { 				\
+	(m)->m_nextpkt = NULL;					\
+	if ((ifq)->ifq_tail == NULL) 				\
+		(ifq)->ifq_head = m; 				\
+	else 							\
+		(ifq)->ifq_tail->m_nextpkt = m; 		\
+	(ifq)->ifq_tail = m; 					\
+	(ifq)->ifq_len++; 					\
+} while (0)
+
+#define IF_ENQUEUE(ifq, m) do {					\
+	IF_LOCK(ifq); 						\
+	_IF_ENQUEUE(ifq, m); 					\
+	IF_UNLOCK(ifq); 					\
+} while (0)
+
+#define	_IF_PREPEND(ifq, m) do {				\
+	(m)->m_nextpkt = (ifq)->ifq_head; 			\
+	if ((ifq)->ifq_tail == NULL) 				\
+		(ifq)->ifq_tail = (m); 				\
+	(ifq)->ifq_head = (m); 					\
+	(ifq)->ifq_len++; 					\
+} while (0)
+
+#define IF_PREPEND(ifq, m) do {		 			\
+	IF_LOCK(ifq); 						\
+	_IF_PREPEND(ifq, m); 					\
+	IF_UNLOCK(ifq); 					\
+} while (0)
+
+#define	_IF_DEQUEUE(ifq, m) do { 				\
+	(m) = (ifq)->ifq_head; 					\
+	if (m) { 						\
+		if (((ifq)->ifq_head = (m)->m_nextpkt) == NULL)	\
+			(ifq)->ifq_tail = NULL; 		\
+		(m)->m_nextpkt = NULL; 				\
+		(ifq)->ifq_len--; 				\
+	} 							\
+} while (0)
+
+#define IF_DEQUEUE(ifq, m) do { 				\
+	IF_LOCK(ifq); 						\
+	_IF_DEQUEUE(ifq, m); 					\
+	IF_UNLOCK(ifq); 					\
+} while (0)
+
+#define	_IF_POLL(ifq, m)	((m) = (ifq)->ifq_head)
+#define	IF_POLL(ifq, m)		_IF_POLL(ifq, m)
+
+#define _IF_DRAIN(ifq) do { 					\
+	struct mbuf *m; 					\
+	for (;;) { 						\
+		_IF_DEQUEUE(ifq, m); 				\
+		if (m == NULL) 					\
+			break; 					\
+		m_freem(m); 					\
+	} 							\
+} while (0)
+
+#define IF_DRAIN(ifq) do {					\
+	IF_LOCK(ifq);						\
+	_IF_DRAIN(ifq);						\
+	IF_UNLOCK(ifq);						\
+} while(0)
+
+#ifdef _KERNEL
+/* interface address change event */
+typedef void (*ifaddr_event_handler_t)(void *, struct ifnet *);
+EVENTHANDLER_DECLARE(ifaddr_event, ifaddr_event_handler_t);
+/* new interface arrival event */
+typedef void (*ifnet_arrival_event_handler_t)(void *, struct ifnet *);
+EVENTHANDLER_DECLARE(ifnet_arrival_event, ifnet_arrival_event_handler_t);
+/* interface departure event */
+typedef void (*ifnet_departure_event_handler_t)(void *, struct ifnet *);
+EVENTHANDLER_DECLARE(ifnet_departure_event, ifnet_departure_event_handler_t);
+
+#define	IF_AFDATA_LOCK_INIT(ifp)	\
+    mtx_init(&(ifp)->if_afdata_mtx, "if_afdata", NULL, MTX_DEF)
+#define	IF_AFDATA_LOCK(ifp)	mtx_lock(&(ifp)->if_afdata_mtx)
+#define	IF_AFDATA_TRYLOCK(ifp)	mtx_trylock(&(ifp)->if_afdata_mtx)
+#define	IF_AFDATA_UNLOCK(ifp)	mtx_unlock(&(ifp)->if_afdata_mtx)
+#define	IF_AFDATA_DESTROY(ifp)	mtx_destroy(&(ifp)->if_afdata_mtx)
+
+#define	IFF_LOCKGIANT(ifp) do {						\
+	if ((ifp)->if_flags & IFF_NEEDSGIANT)				\
+		mtx_lock(&Giant);					\
+} while (0)
+
+#define	IFF_UNLOCKGIANT(ifp) do {					\
+	if ((ifp)->if_flags & IFF_NEEDSGIANT)				\
+		mtx_unlock(&Giant);					\
+} while (0)
+
+int	if_handoff(struct ifqueue *ifq, struct mbuf *m, struct ifnet *ifp,
+	    int adjust);
+#define	IF_HANDOFF(ifq, m, ifp)			\
+	if_handoff((struct ifqueue *)ifq, m, ifp, 0)
+#define	IF_HANDOFF_ADJ(ifq, m, ifp, adj)	\
+	if_handoff((struct ifqueue *)ifq, m, ifp, adj)
+
+void	if_start(struct ifnet *);
+
+#define	IFQ_ENQUEUE(ifq, m, err)					\
+do {									\
+	IF_LOCK(ifq);							\
+	if (ALTQ_IS_ENABLED(ifq))					\
+		ALTQ_ENQUEUE(ifq, m, NULL, err);			\
+	else {								\
+		if (_IF_QFULL(ifq)) {					\
+			m_freem(m);					\
+			(err) = ENOBUFS;				\
+		} else {						\
+			_IF_ENQUEUE(ifq, m);				\
+			(err) = 0;					\
+		}							\
+	}								\
+	if (err)							\
+		(ifq)->ifq_drops++;					\
+	IF_UNLOCK(ifq);							\
+} while (0)
+
+#define	IFQ_DEQUEUE_NOLOCK(ifq, m)					\
+do {									\
+	if (TBR_IS_ENABLED(ifq))					\
+		(m) = tbr_dequeue_ptr(ifq, ALTDQ_REMOVE);		\
+	else if (ALTQ_IS_ENABLED(ifq))					\
+		ALTQ_DEQUEUE(ifq, m);					\
+	else								\
+		_IF_DEQUEUE(ifq, m);					\
+} while (0)
+
+#define	IFQ_DEQUEUE(ifq, m)						\
+do {									\
+	IF_LOCK(ifq);							\
+	IFQ_DEQUEUE_NOLOCK(ifq, m);					\
+	IF_UNLOCK(ifq);							\
+} while (0)
+
+#define	IFQ_POLL_NOLOCK(ifq, m)						\
+do {									\
+	if (TBR_IS_ENABLED(ifq))					\
+		(m) = tbr_dequeue_ptr(ifq, ALTDQ_POLL);			\
+	else if (ALTQ_IS_ENABLED(ifq))					\
+		ALTQ_POLL(ifq, m);					\
+	else								\
+		_IF_POLL(ifq, m);					\
+} while (0)
+
+#define	IFQ_POLL(ifq, m)						\
+do {									\
+	IF_LOCK(ifq);							\
+	IFQ_POLL_NOLOCK(ifq, m);					\
+	IF_UNLOCK(ifq);							\
+} while (0)
+
+#define	IFQ_PURGE_NOLOCK(ifq)						\
+do {									\
+	if (ALTQ_IS_ENABLED(ifq)) {					\
+		ALTQ_PURGE(ifq);					\
+	} else								\
+		_IF_DRAIN(ifq);						\
+} while (0)
+
+#define	IFQ_PURGE(ifq)							\
+do {									\
+	IF_LOCK(ifq);							\
+	IFQ_PURGE_NOLOCK(ifq);						\
+	IF_UNLOCK(ifq);							\
+} while (0)
+
+#define	IFQ_SET_READY(ifq)						\
+	do { ((ifq)->altq_flags |= ALTQF_READY); } while (0)
+
+#define	IFQ_LOCK(ifq)			IF_LOCK(ifq)
+#define	IFQ_UNLOCK(ifq)			IF_UNLOCK(ifq)
+#define	IFQ_LOCK_ASSERT(ifq)		IF_LOCK_ASSERT(ifq)
+#define	IFQ_IS_EMPTY(ifq)		((ifq)->ifq_len == 0)
+#define	IFQ_INC_LEN(ifq)		((ifq)->ifq_len++)
+#define	IFQ_DEC_LEN(ifq)		(--(ifq)->ifq_len)
+#define	IFQ_INC_DROPS(ifq)		((ifq)->ifq_drops++)
+#define	IFQ_SET_MAXLEN(ifq, len)	((ifq)->ifq_maxlen = (len))
+
+/*
+ * The IFF_DRV_OACTIVE test should really occur in the device driver, not in
+ * the handoff logic, as that flag is locked by the device driver.
+ */
+#define	IFQ_HANDOFF_ADJ(ifp, m, adj, err)				\
+do {									\
+	int len;							\
+	short mflags;							\
+									\
+	len = (m)->m_pkthdr.len;					\
+	mflags = (m)->m_flags;						\
+	IFQ_ENQUEUE(&(ifp)->if_snd, m, err);				\
+	if ((err) == 0) {						\
+		(ifp)->if_obytes += len + (adj);			\
+		if (mflags & M_MCAST)					\
+			(ifp)->if_omcasts++;				\
+		if (((ifp)->if_drv_flags & IFF_DRV_OACTIVE) == 0)	\
+			if_start(ifp);					\
+	}								\
+} while (0)
+
+#define	IFQ_HANDOFF(ifp, m, err)					\
+	IFQ_HANDOFF_ADJ(ifp, m, 0, err)
+
+#define	IFQ_DRV_DEQUEUE(ifq, m)						\
+do {									\
+	(m) = (ifq)->ifq_drv_head;					\
+	if (m) {							\
+		if (((ifq)->ifq_drv_head = (m)->m_nextpkt) == NULL)	\
+			(ifq)->ifq_drv_tail = NULL;			\
+		(m)->m_nextpkt = NULL;					\
+		(ifq)->ifq_drv_len--;					\
+	} else {							\
+		IFQ_LOCK(ifq);						\
+		IFQ_DEQUEUE_NOLOCK(ifq, m);				\
+		while ((ifq)->ifq_drv_len < (ifq)->ifq_drv_maxlen) {	\
+			struct mbuf *m0;				\
+			IFQ_DEQUEUE_NOLOCK(ifq, m0);			\
+			if (m0 == NULL)					\
+				break;					\
+			m0->m_nextpkt = NULL;				\
+			if ((ifq)->ifq_drv_tail == NULL)		\
+				(ifq)->ifq_drv_head = m0;		\
+			else						\
+				(ifq)->ifq_drv_tail->m_nextpkt = m0;	\
+			(ifq)->ifq_drv_tail = m0;			\
+			(ifq)->ifq_drv_len++;				\
+		}							\
+		IFQ_UNLOCK(ifq);					\
+	}								\
+} while (0)
+
+#define	IFQ_DRV_PREPEND(ifq, m)						\
+do {									\
+	(m)->m_nextpkt = (ifq)->ifq_drv_head;				\
+	if ((ifq)->ifq_drv_tail == NULL)				\
+		(ifq)->ifq_drv_tail = (m);				\
+	(ifq)->ifq_drv_head = (m);					\
+	(ifq)->ifq_drv_len++;						\
+} while (0)
+
+#define	IFQ_DRV_IS_EMPTY(ifq)						\
+	(((ifq)->ifq_drv_len == 0) && ((ifq)->ifq_len == 0))
+
+#define	IFQ_DRV_PURGE(ifq)						\
+do {									\
+	struct mbuf *m, *n = (ifq)->ifq_drv_head;			\
+	while((m = n) != NULL) {					\
+		n = m->m_nextpkt;					\
+		m_freem(m);						\
+	}								\
+	(ifq)->ifq_drv_head = (ifq)->ifq_drv_tail = NULL;		\
+	(ifq)->ifq_drv_len = 0;						\
+	IFQ_PURGE(ifq);							\
+} while (0)
+
+/*
+ * 72 was chosen below because it is the size of a TCP/IP
+ * header (40) + the minimum mss (32).
+ */
+#define	IF_MINMTU	72
+#define	IF_MAXMTU	65535
+
+#endif /* _KERNEL */
+
+/*
+ * The ifaddr structure contains information about one address
+ * of an interface.  They are maintained by the different address families,
+ * are allocated and attached when an address is set, and are linked
+ * together so all addresses for an interface can be located.
+ *
+ * NOTE: a 'struct ifaddr' is always at the beginning of a larger
+ * chunk of malloc'ed memory, where we store the three addresses
+ * (ifa_addr, ifa_dstaddr and ifa_netmask) referenced here.
+ */
+struct ifaddr {
+	struct	sockaddr *ifa_addr;	/* address of interface */
+	struct	sockaddr *ifa_dstaddr;	/* other end of p-to-p link */
+#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
+	struct	sockaddr *ifa_netmask;	/* used to determine subnet */
+	struct	if_data if_data;	/* not all members are meaningful */
+	struct	ifnet *ifa_ifp;		/* back-pointer to interface */
+	TAILQ_ENTRY(ifaddr) ifa_link;	/* queue macro glue */
+	void	(*ifa_rtrequest)	/* check or clean routes (+ or -)'d */
+		(int, struct rtentry *, struct rt_addrinfo *);
+	u_short	ifa_flags;		/* mostly rt_flags for cloning */
+	u_int	ifa_refcnt;		/* references to this structure */
+	int	ifa_metric;		/* cost of going out this interface */
+	int (*ifa_claim_addr)		/* check if an addr goes to this if */
+		(struct ifaddr *, struct sockaddr *);
+	struct mtx ifa_mtx;
+};
+#define	IFA_ROUTE	RTF_UP		/* route installed */
+
+/* for compatibility with other BSDs */
+#define	ifa_list	ifa_link
+
+
+struct ifaddr *	ifa_alloc(size_t size, int flags);
+void	ifa_free(struct ifaddr *ifa);
+void	ifa_ref(struct ifaddr *ifa);
+
+
+#define	IFA_LOCK_INIT(ifa)	\
+    mtx_init(&(ifa)->ifa_mtx, "ifaddr", NULL, MTX_DEF)
+#define	IFA_LOCK(ifa)		mtx_lock(&(ifa)->ifa_mtx)
+#define	IFA_UNLOCK(ifa)		mtx_unlock(&(ifa)->ifa_mtx)
+#define	IFA_DESTROY(ifa)	mtx_destroy(&(ifa)->ifa_mtx)
+
+/*
+ * The prefix structure contains information about one prefix
+ * of an interface.  They are maintained by the different address families,
+ * are allocated and attached when a prefix or an address is set,
+ * and are linked together so all prefixes for an interface can be located.
+ */
+struct ifprefix {
+	struct	sockaddr *ifpr_prefix;	/* prefix of interface */
+	struct	ifnet *ifpr_ifp;	/* back-pointer to interface */
+	TAILQ_ENTRY(ifprefix) ifpr_list; /* queue macro glue */
+	u_char	ifpr_plen;		/* prefix length in bits */
+	u_char	ifpr_type;		/* protocol dependent prefix type */
+};
+
+/*
+ * Multicast address structure.  This is analogous to the ifaddr
+ * structure except that it keeps track of multicast addresses.
+ * Also, the reference count here is a count of requests for this
+ * address, not a count of pointers to this structure.
+ */
+struct ifmultiaddr {
+	TAILQ_ENTRY(ifmultiaddr) ifma_link; /* queue macro glue */
+	struct	sockaddr *ifma_addr; 	/* address this membership is for */
+	struct	sockaddr *ifma_lladdr;	/* link-layer translation, if any */
+	struct	ifnet *ifma_ifp;	/* back-pointer to interface */
+	u_int	ifma_refcount;		/* reference count */
+	void	*ifma_protospec;	/* protocol-specific state, if any */
+
+	/* haiku additions, save a allocation -hugo */
+	struct sockaddr_dl ifma_addr_storage;
+};
+
+#ifdef _KERNEL
+#define	IFA_LOCK(ifa)		mtx_lock(&(ifa)->ifa_mtx)
+#define	IFA_UNLOCK(ifa)		mtx_unlock(&(ifa)->ifa_mtx)
+
+extern	struct rw_lock ifnet_rwlock;
+#define	IFNET_LOCK_INIT()		rw_lock_init(&ifnet_rwlock, "ifnet rwlock")
+#define	IFNET_WLOCK()			rw_lock_write_lock(&ifnet_rwlock)
+#define	IFNET_WUNLOCK()			rw_lock_write_unlock(&ifnet_rwlock)
+#define	IFNET_RLOCK()			rw_lock_read_lock(&ifnet_rwlock)
+#define	IFNET_RLOCK_NOSLEEP()	rw_lock_read_lock(&ifnet_rwlock)
+#define	IFNET_RUNLOCK()			rw_lock_read_unlock(&ifnet_rwlock)
+#define	IFNET_RUNLOCK_NOSLEEP()	rw_lock_read_unlock(&ifnet_rwlock)
+
+struct ifnet	*ifnet_byindex(u_short idx);
+struct ifnet	*ifnet_byindex_locked(u_short idx);
+
+extern	struct ifnethead ifnet;
+extern	int ifqmaxlen;
+extern	struct ifnet *loif;	/* first loopback interface */
+extern	int if_index;
+
+int	if_addmulti(struct ifnet *, struct sockaddr *, struct ifmultiaddr **);
+int	if_allmulti(struct ifnet *, int);
+struct	ifnet* if_alloc(u_char);
+void	if_attach(struct ifnet *);
+int	if_delmulti(struct ifnet *, struct sockaddr *);
+void	if_detach(struct ifnet *);
+void	if_purgeaddrs(struct ifnet *);
+void    if_delallmulti(struct ifnet *);
+void	if_purgemaddrs(struct ifnet *);
+void	if_down(struct ifnet *);
+void	if_free(struct ifnet *);
+void	if_free_type(struct ifnet *, u_char);
+void	if_initname(struct ifnet *, const char *, int);
+void	if_link_state_change(struct ifnet *, int);
+int	if_printf(struct ifnet *, const char *, ...) __printflike(2, 3);
+int	if_setlladdr(struct ifnet *, const u_char *, int);
+void	if_up(struct ifnet *);
+/*void	ifinit(void);*/ /* declared in systm.h for main() */
+int	ifioctl(struct socket *, u_long, caddr_t, struct thread *);
+int	ifpromisc(struct ifnet *, int);
+struct	ifnet *ifunit(const char *);
+
+struct	ifaddr *ifa_ifwithaddr(struct sockaddr *);
+struct	ifaddr *ifa_ifwithbroadaddr(struct sockaddr *);
+struct	ifaddr *ifa_ifwithdstaddr(struct sockaddr *);
+struct	ifaddr *ifa_ifwithnet(struct sockaddr *);
+struct	ifaddr *ifa_ifwithroute(int, struct sockaddr *, struct sockaddr *);
+struct	ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
+
+int	if_simloop(struct ifnet *ifp, struct mbuf *m, int af, int hlen);
+
+typedef	void *if_com_alloc_t(u_char type, struct ifnet *ifp);
+typedef	void if_com_free_t(void *com, u_char type);
+void	if_register_com_alloc(u_char type, if_com_alloc_t *a, if_com_free_t *f);
+void	if_deregister_com_alloc(u_char type);
+void	if_data_copy(struct ifnet *, struct if_data *);
+uint64_t if_get_counter_default(struct ifnet *, ift_counter);
+void	if_inc_counter(struct ifnet *, ift_counter, int64_t);
+
+#define IF_LLADDR(ifp)							\
+    LLADDR((struct sockaddr_dl *)((ifp)->if_addr->ifa_addr))
+
+uint64_t if_setbaudrate(if_t ifp, uint64_t baudrate);
+uint64_t if_getbaudrate(if_t ifp);
+int if_setcapabilities(if_t ifp, int capabilities);
+int if_setcapabilitiesbit(if_t ifp, int setbit, int clearbit);
+int if_getcapabilities(if_t ifp);
+int if_togglecapenable(if_t ifp, int togglecap);
+int if_setcapenable(if_t ifp, int capenable);
+int if_setcapenablebit(if_t ifp, int setcap, int clearcap);
+int if_getcapenable(if_t ifp);
+const char *if_getdname(if_t ifp);
+int if_setdev(if_t ifp, void *dev);
+int if_setdrvflagbits(if_t ifp, int if_setflags, int clear_flags);
+int if_getdrvflags(if_t ifp);
+int if_setdrvflags(if_t ifp, int flags);
+int if_clearhwassist(if_t ifp);
+int if_sethwassistbits(if_t ifp, int toset, int toclear);
+int if_sethwassist(if_t ifp, int hwassist_bit);
+int if_gethwassist(if_t ifp);
+int if_setsoftc(if_t ifp, void *softc);
+void *if_getsoftc(if_t ifp);
+int if_setflags(if_t ifp, int flags);
+int if_gethwaddr(if_t ifp, struct ifreq *);
+int if_setmtu(if_t ifp, int mtu);
+int if_getmtu(if_t ifp);
+int if_getmtu_family(if_t ifp, int family);
+int if_setflagbits(if_t ifp, int set, int clear);
+int if_getflags(if_t ifp);
+int if_sendq_empty(if_t ifp);
+int if_setsendqready(if_t ifp);
+int if_setsendqlen(if_t ifp, int tx_desc_count);
+int if_input(if_t ifp, struct mbuf* sendmp);
+int if_sendq_prepend(if_t ifp, struct mbuf *m);
+struct mbuf *if_dequeue(if_t ifp);
+int if_setifheaderlen(if_t ifp, int len);
+void if_setrcvif(struct mbuf *m, if_t ifp);
+
+void if_setvtag(struct mbuf *m, u_int16_t tag);
+u_int16_t if_getvtag(struct mbuf *m);
+int if_vlantrunkinuse(if_t ifp);
+caddr_t if_getlladdr(if_t ifp);
+void *if_gethandle(u_char);
+void if_bpfmtap(if_t ifp, struct mbuf *m);
+void if_etherbpfmtap(if_t ifp, struct mbuf *m);
+void if_vlancap(if_t ifp);
+
+int if_setupmultiaddr(if_t ifp, void *mta, int *cnt, int max);
+int if_multiaddr_array(if_t ifp, void *mta, int *cnt, int max);
+int if_multiaddr_count(if_t ifp, int max);
+
+struct sockaddr_dl;
+typedef u_int iflladdr_cb_t(void *, struct sockaddr_dl *, u_int);
+u_int if_foreach_lladdr(if_t, iflladdr_cb_t, void *);
+u_int if_foreach_llmaddr(if_t, iflladdr_cb_t, void *);
+int if_multiaddr_count(if_t ifp, int max);
+
+/* Functions */
+void if_setinitfn(if_t ifp, void (*)(void *));
+void if_setioctlfn(if_t ifp, int (*)(if_t, u_long, caddr_t));
+void if_setstartfn(if_t ifp, void (*)(if_t));
+void if_settransmitfn(if_t ifp, if_transmit_fn_t);
+void if_setqflushfn(if_t ifp, if_qflush_fn_t);
+void if_setgetcounterfn(if_t ifp, if_get_counter_t);
+
+/* accessors for struct ifreq */
+static inline void*
+ifr_data_get_ptr(void* ifrp)
+{
+	struct ifreq* ifr = (struct ifreq *)ifrp;
+	return ifr->ifr_data;
+}
+
+#ifdef DEVICE_POLLING
+enum poll_cmd {	POLL_ONLY, POLL_AND_CHECK_STATUS };
+
+typedef	void poll_handler_t(struct ifnet *ifp, enum poll_cmd cmd, int count);
+int    ether_poll_register(poll_handler_t *h, struct ifnet *ifp);
+int    ether_poll_deregister(struct ifnet *ifp);
+#endif /* DEVICE_POLLING */
+
+static __inline int
+drbr_enqueue(struct ifnet *ifp, struct buf_ring *br, struct mbuf *m)
+{
+	int error = 0;
+
+#ifdef ALTQ
+	if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
+		IFQ_ENQUEUE(&ifp->if_snd, m, error);
+		if (error)
+			if_inc_counter((ifp), IFCOUNTER_OQDROPS, 1);
+		return (error);
+	}
+#endif
+	error = buf_ring_enqueue(br, m);
+	if (error)
+		m_freem(m);
+
+	return (error);
+}
+
+static __inline void
+drbr_putback(struct ifnet *ifp, struct buf_ring *br, struct mbuf *_new)
+{
+	/*
+	 * The top of the list needs to be swapped
+	 * for this one.
+	 */
+#ifdef ALTQ
+	if (ifp != NULL && ALTQ_IS_ENABLED(&ifp->if_snd)) {
+		/*
+		 * Peek in altq case dequeued it
+		 * so put it back.
+		 */
+		IFQ_DRV_PREPEND(&ifp->if_snd, _new);
+		return;
+	}
+#endif
+	buf_ring_putback_sc(br, _new);
+}
+
+static __inline struct mbuf *
+drbr_peek(struct ifnet *ifp, struct buf_ring *br)
+{
+#ifdef ALTQ
+	struct mbuf *m;
+	if (ifp != NULL && ALTQ_IS_ENABLED(&ifp->if_snd)) {
+		/*
+		 * Pull it off like a dequeue
+		 * since drbr_advance() does nothing
+		 * for altq and drbr_putback() will
+		 * use the old prepend function.
+		 */
+		IFQ_DEQUEUE(&ifp->if_snd, m);
+		return (m);
+	}
+#endif
+	return (struct mbuf*)buf_ring_peek_clear_sc(br);
+}
+
+static __inline void
+drbr_flush(struct ifnet *ifp, struct buf_ring *br)
+{
+	struct mbuf *m;
+
+#ifdef ALTQ
+	if (ifp != NULL && ALTQ_IS_ENABLED(&ifp->if_snd))
+		IFQ_PURGE(&ifp->if_snd);
+#endif
+	while ((m = (struct mbuf*)buf_ring_dequeue_sc(br)) != NULL)
+		m_freem(m);
+}
+
+static __inline void
+drbr_free(struct buf_ring *br, struct malloc_type *type)
+{
+
+	drbr_flush(NULL, br);
+	buf_ring_free(br, type);
+}
+
+static __inline struct mbuf *
+drbr_dequeue(struct ifnet *ifp, struct buf_ring *br)
+{
+#ifdef ALTQ
+	struct mbuf *m;
+
+	if (ifp != NULL && ALTQ_IS_ENABLED(&ifp->if_snd)) {
+		IFQ_DEQUEUE(&ifp->if_snd, m);
+		return (m);
+	}
+#endif
+	return (struct mbuf*)buf_ring_dequeue_sc(br);
+}
+
+static __inline void
+drbr_advance(struct ifnet *ifp, struct buf_ring *br)
+{
+#ifdef ALTQ
+	/* Nothing to do here since peek dequeues in altq case */
+	if (ifp != NULL && ALTQ_IS_ENABLED(&ifp->if_snd))
+		return;
+#endif
+	return (buf_ring_advance_sc(br));
+}
+
+
+static __inline struct mbuf *
+drbr_dequeue_cond(struct ifnet *ifp, struct buf_ring *br,
+    int (*func) (struct mbuf *, void *), void *arg)
+{
+	struct mbuf *m;
+#ifdef ALTQ
+	if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
+		IFQ_LOCK(&ifp->if_snd);
+		IFQ_POLL_NOLOCK(&ifp->if_snd, m);
+		if (m != NULL && func(m, arg) == 0) {
+			IFQ_UNLOCK(&ifp->if_snd);
+			return (NULL);
+		}
+		IFQ_DEQUEUE_NOLOCK(&ifp->if_snd, m);
+		IFQ_UNLOCK(&ifp->if_snd);
+		return (m);
+	}
+#endif
+	m = (struct mbuf*)buf_ring_peek(br);
+	if (m == NULL || func(m, arg) == 0)
+		return (NULL);
+
+	return (struct mbuf*)buf_ring_dequeue_sc(br);
+}
+
+static __inline int
+drbr_empty(struct ifnet *ifp, struct buf_ring *br)
+{
+#ifdef ALTQ
+	if (ALTQ_IS_ENABLED(&ifp->if_snd))
+		return (IFQ_IS_EMPTY(&ifp->if_snd));
+#endif
+	return (buf_ring_empty(br));
+}
+
+static __inline int
+drbr_needs_enqueue(struct ifnet *ifp, struct buf_ring *br)
+{
+#ifdef ALTQ
+	if (ALTQ_IS_ENABLED(&ifp->if_snd))
+		return (1);
+#endif
+	return (!buf_ring_empty(br));
+}
+
+static __inline int
+drbr_inuse(struct ifnet *ifp, struct buf_ring *br)
+{
+#ifdef ALTQ
+	if (ALTQ_IS_ENABLED(&ifp->if_snd))
+		return (ifp->if_snd.ifq_len);
+#endif
+	return (buf_ring_count(br));
+}
+
+#endif /* _KERNEL */
+
+#endif /* _FBSD_COMPAT_NET_IF_VAR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_vlan_var.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_vlan_var.h
new file mode 100644
index 0000000000..b230df10e7
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/if_vlan_var.h
@@ -0,0 +1,137 @@
+/*-
+ * Copyright 1998 Massachusetts Institute of Technology
+ *
+ * Permission to use, copy, modify, and distribute this software and
+ * its documentation for any purpose and without fee is hereby
+ * granted, provided that both the above copyright notice and this
+ * permission notice appear in all copies, that both the above
+ * copyright notice and this permission notice appear in all
+ * supporting documentation, and that the name of M.I.T. not be used
+ * in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.  M.I.T. makes
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS
+ * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
+ * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/net/if_vlan_var.h,v 1.26 2007/02/28 22:05:30 bms Exp $
+ */
+
+#ifndef _FBSD_COMPAT_NET_IF_VLAN_VAR_H_
+#define	_FBSD_COMPAT_NET_IF_VLAN_VAR_H_	1
+
+#include <net/if.h>
+
+struct	ether_vlan_header {
+	u_char	evl_dhost[ETHER_ADDR_LEN];
+	u_char	evl_shost[ETHER_ADDR_LEN];
+	u_int16_t evl_encap_proto;
+	u_int16_t evl_tag;
+	u_int16_t evl_proto;
+};
+
+#define	EVL_VLID_MASK		0x0FFF
+#define	EVL_PRI_MASK		0xE000
+#define	EVL_VLANOFTAG(tag)	((tag) & EVL_VLID_MASK)
+#define	EVL_PRIOFTAG(tag)	(((tag) >> 13) & 7)
+#define	EVL_CFIOFTAG(tag)	(((tag) >> 12) & 1)
+#define	EVL_MAKETAG(vlid, pri, cfi)					\
+	((((((pri) & 7) << 1) | ((cfi) & 1)) << 12) | ((vlid) & EVL_VLID_MASK))
+
+/* Set the VLAN ID in an mbuf packet header non-destructively. */
+#define EVL_APPLY_VLID(m, vlid)						\
+	do {								\
+		if ((m)->m_flags & M_VLANTAG) {				\
+			(m)->m_pkthdr.ether_vtag &= EVL_VLID_MASK;	\
+			(m)->m_pkthdr.ether_vtag |= (vlid);		\
+		} else {						\
+			(m)->m_pkthdr.ether_vtag = (vlid);		\
+			(m)->m_flags |= M_VLANTAG;			\
+		}							\
+	} while (0)
+
+/* Set the priority ID in an mbuf packet header non-destructively. */
+#define EVL_APPLY_PRI(m, pri)						\
+	do {								\
+		if ((m)->m_flags & M_VLANTAG) {				\
+			uint16_t __vlantag = (m)->m_pkthdr.ether_vtag;	\
+			(m)->m_pkthdr.ether_vtag |= EVL_MAKETAG(	\
+			    EVL_VLANOFTAG(__vlantag), (pri),		\
+			    EVL_CFIOFTAG(__vlantag));			\
+		} else {						\
+			(m)->m_pkthdr.ether_vtag =			\
+			    EVL_MAKETAG(0, (pri), 0);			\
+			(m)->m_flags |= M_VLANTAG;			\
+		}							\
+	} while (0)
+
+/* sysctl(3) tags, for compatibility purposes */
+#define	VLANCTL_PROTO	1
+#define	VLANCTL_MAX	2
+
+/*
+ * Configuration structure for SIOCSETVLAN and SIOCGETVLAN ioctls.
+ */
+struct	vlanreq {
+	char	vlr_parent[IFNAMSIZ];
+	u_short	vlr_tag;
+};
+#define	SIOCSETVLAN	SIOCSIFGENERIC
+#define	SIOCGETVLAN	SIOCGIFGENERIC
+
+#ifdef _KERNEL
+/*
+ * Drivers that are capable of adding and removing the VLAN header
+ * in hardware indicate they support this by marking IFCAP_VLAN_HWTAGGING
+ * in if_capabilities.  Drivers for hardware that is capable
+ * of handling larger MTU's that may include a software-appended
+ * VLAN header w/o lowering the normal MTU should mark IFCAP_VLAN_MTU
+ * in if_capabilities; this notifies the VLAN code it can leave the
+ * MTU on the vlan interface at the normal setting.
+ */
+
+/*
+ * VLAN tags are stored in host byte order.  Byte swapping may be
+ * necessary.
+ *
+ * Drivers that support hardware VLAN tag stripping fill in the
+ * received VLAN tag (containing both vlan and priority information)
+ * into the ether_vtag mbuf packet header field:
+ *
+ *	m->m_pkthdr.ether_vtag = vlan_id;	// ntohs()?
+ *	m->m_flags |= M_VLANTAG;
+ *
+ * to mark the packet m with the specified VLAN tag.
+ *
+ * On output the driver should check the mbuf for the M_VLANTAG
+ * flag to see if a VLAN tag is present and valid:
+ *
+ *	if (m->m_flags & M_VLANTAG) {
+ *		... = m->m_pkthdr.ether_vtag;	// htons()?
+ *		... pass tag to hardware ...
+ *	}
+ *
+ * Note that a driver must indicate it supports hardware VLAN
+ * stripping/insertion by marking IFCAP_VLAN_HWTAGGING in
+ * if_capabilities.
+ */
+
+#define	VLAN_CAPABILITIES(_ifp) do { \
+	} while (0)
+
+extern	void (*vlan_trunk_cap_p)(struct ifnet *);
+#endif /* _KERNEL */
+
+#endif /* _FBSD_COMPAT_NET_IF_VLAN_VAR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/route.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/route.h
new file mode 100644
index 0000000000..4109ead3f3
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/route.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NET_ROUTE_H_
+#define _FBSD_COMPAT_NET_ROUTE_H_
+
+
+#include <posix/net/route.h>
+
+
+/*
+ * A route consists of a destination address, a reference
+ * to a routing entry, and a reference to an llentry.
+ * These are often held by protocols in their control
+ * blocks, e.g. inpcb.
+ */
+struct route {
+	struct	rtentry *ro_rt;
+	struct	llentry *ro_lle;
+	struct	sockaddr ro_dst;
+};
+
+#endif /* _FBSD_COMPAT_NET_ROUTE_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/vnet.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/vnet.h
new file mode 100644
index 0000000000..ab2aa97a70
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/net/vnet.h
@@ -0,0 +1,496 @@
+/*-
+ * Copyright (c) 2006-2009 University of Zagreb
+ * Copyright (c) 2006-2009 FreeBSD Foundation
+ * All rights reserved.
+ *
+ * This software was developed by the University of Zagreb and the
+ * FreeBSD Foundation under sponsorship by the Stichting NLnet and the
+ * FreeBSD Foundation.
+ *
+ * Copyright (c) 2009 Jeffrey Roberson <jeff@freebsd.org>
+ * Copyright (c) 2009 Robert N. M. Watson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*-
+ * This header file defines several sets of interfaces supporting virtualized
+ * network stacks:
+ *
+ * - Definition of 'struct vnet' and functions and macros to allocate/free/
+ *   manipulate it.
+ *
+ * - A virtual network stack memory allocator, which provides support for
+ *   virtualized global variables via a special linker set, set_vnet.
+ *
+ * - Virtualized sysinits/sysuninits, which allow constructors and
+ *   destructors to be run for each network stack subsystem as virtual
+ *   instances are created and destroyed.
+ *
+ * If VIMAGE isn't compiled into the kernel, virtualized global variables
+ * compile to normal global variables, and virtualized sysinits to regular
+ * sysinits.
+ */
+
+#ifndef _FBSD_COMPAT_NET_VNET_H_
+#define	_FBSD_COMPAT_NET_VNET_H_
+
+/*
+ * struct vnet describes a virtualized network stack, and is primarily a
+ * pointer to storage for virtualized global variables.  Expose to userspace
+ * as required for libkvm.
+ */
+#if defined(_KERNEL) || defined(_WANT_VNET)
+#include <sys/queue.h>
+
+struct vnet {
+	LIST_ENTRY(vnet)	 vnet_le;	/* all vnets list */
+	u_int			 vnet_magic_n;
+	u_int			 vnet_ifcnt;
+	u_int			 vnet_sockcnt;
+	void			*vnet_data_mem;
+	uintptr_t		 vnet_data_base;
+};
+#define	VNET_MAGIC_N	0x3e0d8f29
+
+/*
+ * These two virtual network stack allocator definitions are also required
+ * for libkvm so that it can evaluate virtualized global variables.
+ */
+#define	VNET_SETNAME		"set_vnet"
+#define	VNET_SYMPREFIX		"vnet_entry_"
+#endif
+
+#ifdef _KERNEL
+
+#define	VNET_PCPUSTAT_DECLARE(type, name)	\
+    VNET_DECLARE(counter_u64_t, name[sizeof(type) / sizeof(uint64_t)])
+
+#define	VNET_PCPUSTAT_DEFINE(type, name)	\
+    VNET_DEFINE(counter_u64_t, name[sizeof(type) / sizeof(uint64_t)])
+
+#define	VNET_PCPUSTAT_ALLOC(name, wait)	\
+    COUNTER_ARRAY_ALLOC(VNET(name), \
+	sizeof(VNET(name)) / sizeof(counter_u64_t), (wait))
+
+#define	VNET_PCPUSTAT_FREE(name)	\
+    COUNTER_ARRAY_FREE(VNET(name), sizeof(VNET(name)) / sizeof(counter_u64_t))
+
+#define	VNET_PCPUSTAT_ADD(type, name, f, v)	\
+    counter_u64_add(VNET(name)[offsetof(type, f) / sizeof(uint64_t)], (v))
+
+#define	VNET_PCPUSTAT_SYSINIT(name)	\
+static void				\
+vnet_##name##_init(const void *unused)	\
+{					\
+	VNET_PCPUSTAT_ALLOC(name, M_WAITOK);	\
+}					\
+VNET_SYSINIT(vnet_ ## name ## _init, SI_SUB_PROTO_IFATTACHDOMAIN,	\
+    SI_ORDER_ANY, vnet_ ## name ## _init, NULL)
+
+#define	VNET_PCPUSTAT_SYSUNINIT(name)					\
+static void								\
+vnet_##name##_uninit(const void *unused)				\
+{									\
+	VNET_PCPUSTAT_FREE(name);					\
+}									\
+VNET_SYSUNINIT(vnet_ ## name ## _uninit, SI_SUB_PROTO_IFATTACHDOMAIN,	\
+    SI_ORDER_ANY, vnet_ ## name ## _uninit, NULL)
+
+#define	SYSCTL_VNET_PCPUSTAT(parent, nbr, name, type, array, desc)	\
+static int								\
+array##_sysctl(SYSCTL_HANDLER_ARGS)					\
+{									\
+	type s;								\
+	CTASSERT((sizeof(type) / sizeof(uint64_t)) ==			\
+	    (sizeof(VNET(array)) / sizeof(counter_u64_t)));		\
+	COUNTER_ARRAY_COPY(VNET(array), &s, sizeof(type) / sizeof(uint64_t));\
+	if (req->newptr)						\
+		COUNTER_ARRAY_ZERO(VNET(array),				\
+		    sizeof(type) / sizeof(uint64_t));			\
+	return (SYSCTL_OUT(req, &s, sizeof(type)));			\
+}									\
+SYSCTL_VNET_PROC(parent, nbr, name, CTLTYPE_OPAQUE | CTLFLAG_RW, NULL,	\
+    0, array ## _sysctl, "I", desc)
+
+#ifdef VIMAGE
+#include <sys/lock.h>
+#include <sys/proc.h>			/* for struct thread */
+#include <sys/rwlock.h>
+#include <sys/sx.h>
+
+/*
+ * Location of the kernel's 'set_vnet' linker set.
+ */
+extern uintptr_t	*__start_set_vnet;
+__GLOBL(__start_set_vnet);
+extern uintptr_t	*__stop_set_vnet;
+__GLOBL(__stop_set_vnet);
+
+#define	VNET_START	(uintptr_t)&__start_set_vnet
+#define	VNET_STOP	(uintptr_t)&__stop_set_vnet
+
+/*
+ * Functions to allocate and destroy virtual network stacks.
+ */
+struct vnet *vnet_alloc(void);
+void	vnet_destroy(struct vnet *vnet);
+
+/*
+ * The current virtual network stack -- we may wish to move this to struct
+ * pcpu in the future.
+ */
+#define	curvnet	curthread->td_vnet
+
+/*
+ * Various macros -- get and set the current network stack, but also
+ * assertions.
+ */
+#if defined(INVARIANTS) || defined(VNET_DEBUG)
+#define	VNET_ASSERT(exp, msg)	do {					\
+	if (!(exp))							\
+		panic msg;						\
+} while (0)
+#else
+#define	VNET_ASSERT(exp, msg)	do {					\
+} while (0)
+#endif
+
+#ifdef VNET_DEBUG
+void vnet_log_recursion(struct vnet *, const char *, int);
+
+#define	CURVNET_SET_QUIET(arg)						\
+	VNET_ASSERT((arg) != NULL && (arg)->vnet_magic_n == VNET_MAGIC_N, \
+	    ("CURVNET_SET at %s:%d %s() curvnet=%p vnet=%p",		\
+	    __FILE__, __LINE__, __func__, curvnet, (arg)));		\
+	struct vnet *saved_vnet = curvnet;				\
+	const char *saved_vnet_lpush = curthread->td_vnet_lpush;	\
+	curvnet = arg;							\
+	curthread->td_vnet_lpush = __func__;
+ 
+#define	CURVNET_SET_VERBOSE(arg)					\
+	CURVNET_SET_QUIET(arg)						\
+	if (saved_vnet)							\
+		vnet_log_recursion(saved_vnet, saved_vnet_lpush, __LINE__);
+
+#define	CURVNET_SET(arg)	CURVNET_SET_VERBOSE(arg)
+ 
+#define	CURVNET_RESTORE()						\
+	VNET_ASSERT(curvnet != NULL && (saved_vnet == NULL ||		\
+	    saved_vnet->vnet_magic_n == VNET_MAGIC_N),			\
+	    ("CURVNET_RESTORE at %s:%d %s() curvnet=%p saved_vnet=%p",	\
+	    __FILE__, __LINE__, __func__, curvnet, saved_vnet));	\
+	curvnet = saved_vnet;						\
+	curthread->td_vnet_lpush = saved_vnet_lpush;
+#else /* !VNET_DEBUG */
+
+#define	CURVNET_SET_QUIET(arg)						\
+	VNET_ASSERT((arg) != NULL && (arg)->vnet_magic_n == VNET_MAGIC_N, \
+	    ("CURVNET_SET at %s:%d %s() curvnet=%p vnet=%p",		\
+	    __FILE__, __LINE__, __func__, curvnet, (arg)));		\
+	struct vnet *saved_vnet = curvnet;				\
+	curvnet = arg;	
+ 
+#define	CURVNET_SET_VERBOSE(arg)					\
+	CURVNET_SET_QUIET(arg)
+
+#define	CURVNET_SET(arg)	CURVNET_SET_VERBOSE(arg)
+ 
+#define	CURVNET_RESTORE()						\
+	VNET_ASSERT(curvnet != NULL && (saved_vnet == NULL ||		\
+	    saved_vnet->vnet_magic_n == VNET_MAGIC_N),			\
+	    ("CURVNET_RESTORE at %s:%d %s() curvnet=%p saved_vnet=%p",	\
+	    __FILE__, __LINE__, __func__, curvnet, saved_vnet));	\
+	curvnet = saved_vnet;
+#endif /* VNET_DEBUG */
+
+extern struct vnet *vnet0;
+#define	IS_DEFAULT_VNET(arg)	((arg) == vnet0)
+
+#define	CRED_TO_VNET(cr)	(cr)->cr_prison->pr_vnet
+#define	TD_TO_VNET(td)		CRED_TO_VNET((td)->td_ucred)
+#define	P_TO_VNET(p)		CRED_TO_VNET((p)->p_ucred)
+
+/*
+ * Global linked list of all virtual network stacks, along with read locks to
+ * access it.  If a caller may sleep while accessing the list, it must use
+ * the sleepable lock macros.
+ */
+LIST_HEAD(vnet_list_head, vnet);
+extern struct vnet_list_head vnet_head;
+extern struct rwlock vnet_rwlock;
+extern struct sx vnet_sxlock;
+
+#define	VNET_LIST_RLOCK()		sx_slock(&vnet_sxlock)
+#define	VNET_LIST_RLOCK_NOSLEEP()	rw_rlock(&vnet_rwlock)
+#define	VNET_LIST_RUNLOCK()		sx_sunlock(&vnet_sxlock)
+#define	VNET_LIST_RUNLOCK_NOSLEEP()	rw_runlock(&vnet_rwlock)
+
+/*
+ * Iteration macros to walk the global list of virtual network stacks.
+ */
+#define	VNET_ITERATOR_DECL(arg)	struct vnet *arg
+#define	VNET_FOREACH(arg)	LIST_FOREACH((arg), &vnet_head, vnet_le)
+
+/*
+ * Virtual network stack memory allocator, which allows global variables to
+ * be automatically instantiated for each network stack instance.
+ */
+#define	VNET_NAME(n)		vnet_entry_##n
+#define	VNET_DECLARE(t, n)	extern t VNET_NAME(n)
+#define	VNET_DEFINE(t, n)	t VNET_NAME(n) __section(VNET_SETNAME) __used
+#define	_VNET_PTR(b, n)		(__typeof(VNET_NAME(n))*)		\
+				    ((b) + (uintptr_t)&VNET_NAME(n))
+
+#define	_VNET(b, n)		(*_VNET_PTR(b, n))
+
+/*
+ * Virtualized global variable accessor macros.
+ */
+#define	VNET_VNET_PTR(vnet, n)		_VNET_PTR((vnet)->vnet_data_base, n)
+#define	VNET_VNET(vnet, n)		(*VNET_VNET_PTR((vnet), n))
+
+#define	VNET_PTR(n)		VNET_VNET_PTR(curvnet, n)
+#define	VNET(n)			VNET_VNET(curvnet, n)
+
+/*
+ * Virtual network stack allocator interfaces from the kernel linker.
+ */
+void	*vnet_data_alloc(int size);
+void	 vnet_data_copy(void *start, int size);
+void	 vnet_data_free(void *start_arg, int size);
+
+/*
+ * Sysctl variants for vnet-virtualized global variables.  Include
+ * <sys/sysctl.h> to expose these definitions.
+ *
+ * Note: SYSCTL_PROC() handler functions will need to resolve pointer
+ * arguments themselves, if required.
+ */
+#ifdef SYSCTL_OID
+int	vnet_sysctl_handle_int(SYSCTL_HANDLER_ARGS);
+int	vnet_sysctl_handle_opaque(SYSCTL_HANDLER_ARGS);
+int	vnet_sysctl_handle_string(SYSCTL_HANDLER_ARGS);
+int	vnet_sysctl_handle_uint(SYSCTL_HANDLER_ARGS);
+
+#define	SYSCTL_VNET_INT(parent, nbr, name, access, ptr, val, descr)	\
+	SYSCTL_OID(parent, nbr, name,					\
+	    CTLTYPE_INT|CTLFLAG_MPSAFE|CTLFLAG_VNET|(access),		\
+	    ptr, val, vnet_sysctl_handle_int, "I", descr)
+#define	SYSCTL_VNET_PROC(parent, nbr, name, access, ptr, arg, handler,	\
+	    fmt, descr)							\
+	CTASSERT(((access) & CTLTYPE) != 0);				\
+	SYSCTL_OID(parent, nbr, name, CTLFLAG_VNET|(access), ptr, arg, 	\
+	    handler, fmt, descr)
+#define	SYSCTL_VNET_OPAQUE(parent, nbr, name, access, ptr, len, fmt,    \
+	    descr)							\
+	SYSCTL_OID(parent, nbr, name,					\
+	    CTLTYPE_OPAQUE|CTLFLAG_VNET|(access), ptr, len, 		\
+	    vnet_sysctl_handle_opaque, fmt, descr)
+#define	SYSCTL_VNET_STRING(parent, nbr, name, access, arg, len, descr)	\
+	SYSCTL_OID(parent, nbr, name,					\
+	    CTLTYPE_STRING|CTLFLAG_VNET|(access),			\
+	    arg, len, vnet_sysctl_handle_string, "A", descr)
+#define	SYSCTL_VNET_STRUCT(parent, nbr, name, access, ptr, type, descr)	\
+	SYSCTL_OID(parent, nbr, name,					\
+	    CTLTYPE_OPAQUE|CTLFLAG_VNET|(access), ptr,			\
+	    sizeof(struct type), vnet_sysctl_handle_opaque, "S," #type,	\
+	    descr)
+#define	SYSCTL_VNET_UINT(parent, nbr, name, access, ptr, val, descr)	\
+	SYSCTL_OID(parent, nbr, name,					\
+	    CTLTYPE_UINT|CTLFLAG_MPSAFE|CTLFLAG_VNET|(access),		\
+	    ptr, val, vnet_sysctl_handle_uint, "IU", descr)
+#define	VNET_SYSCTL_ARG(req, arg1) do {					\
+	if (arg1 != NULL)						\
+		arg1 = (void *)(TD_TO_VNET((req)->td)->vnet_data_base +	\
+		    (uintptr_t)(arg1));					\
+} while (0)
+#endif /* SYSCTL_OID */
+
+/*
+ * Virtual sysinit mechanism, allowing network stack components to declare
+ * startup and shutdown methods to be run when virtual network stack
+ * instances are created and destroyed.
+ */
+#include <sys/kernel.h>
+
+/*
+ * SYSINIT/SYSUNINIT variants that provide per-vnet constructors and
+ * destructors.
+ */
+struct vnet_sysinit {
+	enum sysinit_sub_id	subsystem;
+	enum sysinit_elem_order	order;
+	sysinit_cfunc_t		func;
+	const void		*arg;
+	TAILQ_ENTRY(vnet_sysinit) link;
+};
+
+#define	VNET_SYSINIT(ident, subsystem, order, func, arg)		\
+	static struct vnet_sysinit ident ## _vnet_init = {		\
+		subsystem,						\
+		order,							\
+		(sysinit_cfunc_t)(sysinit_nfunc_t)func,			\
+		(arg)							\
+	};								\
+	SYSINIT(vnet_init_ ## ident, subsystem, order,			\
+	    vnet_register_sysinit, &ident ## _vnet_init);		\
+	SYSUNINIT(vnet_init_ ## ident, subsystem, order,		\
+	    vnet_deregister_sysinit, &ident ## _vnet_init)
+
+#define	VNET_SYSUNINIT(ident, subsystem, order, func, arg)		\
+	static struct vnet_sysinit ident ## _vnet_uninit = {		\
+		subsystem,						\
+		order,							\
+		(sysinit_cfunc_t)(sysinit_nfunc_t)func,			\
+		(arg)							\
+	};								\
+	SYSINIT(vnet_uninit_ ## ident, subsystem, order,		\
+	    vnet_register_sysuninit, &ident ## _vnet_uninit);		\
+	SYSUNINIT(vnet_uninit_ ## ident, subsystem, order,		\
+	    vnet_deregister_sysuninit, &ident ## _vnet_uninit)
+
+/*
+ * Run per-vnet sysinits or sysuninits during vnet creation/destruction.
+ */
+void	 vnet_sysinit(void);
+void	 vnet_sysuninit(void);
+
+/*
+ * Interfaces for managing per-vnet constructors and destructors.
+ */
+void	vnet_register_sysinit(void *arg);
+void	vnet_register_sysuninit(void *arg);
+void	vnet_deregister_sysinit(void *arg);
+void	vnet_deregister_sysuninit(void *arg);
+
+/*
+ * EVENTHANDLER(9) extensions.
+ */
+#include <sys/eventhandler.h>
+
+void	vnet_global_eventhandler_iterator_func(void *, ...);
+#define VNET_GLOBAL_EVENTHANDLER_REGISTER_TAG(tag, name, func, arg, priority) \
+do {									\
+	if (IS_DEFAULT_VNET(curvnet)) {					\
+		(tag) = vimage_eventhandler_register(NULL, #name, func,	\
+		    arg, priority,					\
+		    vnet_global_eventhandler_iterator_func);		\
+	}								\
+} while(0)
+#define VNET_GLOBAL_EVENTHANDLER_REGISTER(name, func, arg, priority)	\
+do {									\
+	if (IS_DEFAULT_VNET(curvnet)) {					\
+		vimage_eventhandler_register(NULL, #name, func,		\
+		    arg, priority,					\
+		    vnet_global_eventhandler_iterator_func);		\
+	}								\
+} while(0)
+
+#else /* !VIMAGE */
+
+/*
+ * Various virtual network stack macros compile to no-ops without VIMAGE.
+ */
+#define	curvnet			NULL
+
+#define	VNET_ASSERT(exp, msg)
+#define	CURVNET_SET(arg)
+#define	CURVNET_SET_QUIET(arg)
+#define	CURVNET_RESTORE()
+
+#define	VNET_LIST_RLOCK()
+#define	VNET_LIST_RLOCK_NOSLEEP()
+#define	VNET_LIST_RUNLOCK()
+#define	VNET_LIST_RUNLOCK_NOSLEEP()
+#define	VNET_ITERATOR_DECL(arg)
+#define	VNET_FOREACH(arg)
+
+#define	IS_DEFAULT_VNET(arg)	1
+#define	CRED_TO_VNET(cr)	NULL
+#define	TD_TO_VNET(td)		NULL
+#define	P_TO_VNET(p)		NULL
+
+/*
+ * Versions of the VNET macros that compile to normal global variables and
+ * standard sysctl definitions.
+ */
+#define	VNET_NAME(n)		n
+#define	VNET_DECLARE(t, n)	extern t n
+#define	VNET_DEFINE(t, n)	t n
+#define	_VNET_PTR(b, n)		&VNET_NAME(n)
+
+/*
+ * Virtualized global variable accessor macros.
+ */
+#define	VNET_VNET_PTR(vnet, n)		(&(n))
+#define	VNET_VNET(vnet, n)		(n)
+
+#define	VNET_PTR(n)		(&(n))
+#define	VNET(n)			(n)
+
+/*
+ * When VIMAGE isn't compiled into the kernel, virtaulized SYSCTLs simply
+ * become normal SYSCTLs.
+ */
+#ifdef SYSCTL_OID
+#define	SYSCTL_VNET_INT(parent, nbr, name, access, ptr, val, descr)	\
+	SYSCTL_INT(parent, nbr, name, access, ptr, val, descr)
+#define	SYSCTL_VNET_PROC(parent, nbr, name, access, ptr, arg, handler,	\
+	    fmt, descr)							\
+	SYSCTL_PROC(parent, nbr, name, access, ptr, arg, handler, fmt,	\
+	    descr)
+#define	SYSCTL_VNET_OPAQUE(parent, nbr, name, access, ptr, len, fmt,    \
+	    descr)							\
+	SYSCTL_OPAQUE(parent, nbr, name, access, ptr, len, fmt, descr)
+#define	SYSCTL_VNET_STRING(parent, nbr, name, access, arg, len, descr)	\
+	SYSCTL_STRING(parent, nbr, name, access, arg, len, descr)
+#define	SYSCTL_VNET_STRUCT(parent, nbr, name, access, ptr, type, descr)	\
+	SYSCTL_STRUCT(parent, nbr, name, access, ptr, type, descr)
+#define	SYSCTL_VNET_UINT(parent, nbr, name, access, ptr, val, descr)	\
+	SYSCTL_UINT(parent, nbr, name, access, ptr, val, descr)
+#define	VNET_SYSCTL_ARG(req, arg1)
+#endif /* SYSCTL_OID */
+
+/*
+ * When VIMAGE isn't compiled into the kernel, VNET_SYSINIT/VNET_SYSUNINIT
+ * map into normal sysinits, which have the same ordering properties.
+ */
+#define	VNET_SYSINIT(ident, subsystem, order, func, arg)		\
+	SYSINIT(ident, subsystem, order, func, arg)
+#define	VNET_SYSUNINIT(ident, subsystem, order, func, arg)		\
+	SYSUNINIT(ident, subsystem, order, func, arg)
+
+/*
+ * Without VIMAGE revert to the default implementation.
+ */
+#define VNET_GLOBAL_EVENTHANDLER_REGISTER_TAG(tag, name, func, arg, priority) \
+	(tag) = eventhandler_register(NULL, #name, func, arg, priority)
+#define VNET_GLOBAL_EVENTHANDLER_REGISTER(name, func, arg, priority)	\
+	eventhandler_register(NULL, #name, func, arg, priority)
+#endif /* VIMAGE */
+#endif /* _KERNEL */
+
+#endif /* !_FBSD_COMPAT_NET_VNET_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/if_ether.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/if_ether.h
new file mode 100644
index 0000000000..06e32a198a
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/if_ether.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NETINET_IF_ETHER_H_
+#define _FBSD_COMPAT_NETINET_IF_ETHER_H_
+
+
+/* Haiku does it's own ARP management */
+
+#define arp_ifinit(ifp, ifa)
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_systm.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_systm.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_var.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_var.h
new file mode 100644
index 0000000000..bb732d6c5d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/in_var.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NETINET_IN_VAR_H_
+#define _FBSD_COMPAT_NETINET_IN_VAR_H_
+
+
+#include <sys/queue.h>
+
+#endif /* _FBSD_COMPAT_NETINET_IN_VAR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/netdump/netdump.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/netdump/netdump.h
new file mode 100644
index 0000000000..ef07076098
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/netinet/netdump/netdump.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2018, Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_NETINET_NETDUMP_H_
+#define _FBSD_COMPAT_NETINET_NETDUMP_H_
+
+
+#define	NETDUMP_DEFINE(driver)
+#define	NETDUMP_REINIT(ifp)
+#define	NETDUMP_SET(ifp, driver)
+
+
+#endif /* _FBSD_COMPAT_NETINET_NETDUMP_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/security/mac/mac_framework.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/security/mac/mac_framework.h
new file mode 100644
index 0000000000..6172e82247
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/security/mac/mac_framework.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef FBSD_COMPAT_SECURITY_MAC_MAC_FRAMEWORK_H_
+#define FBSD_COMPAT_SECURITY_MAC_MAC_FRAMEWORK_H_
+
+
+#endif /* FBSD_COMPAT_SECURITY_MAC_MAC_FRAMEWORK_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_bus_dma.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_bus_dma.h
new file mode 100644
index 0000000000..5aa4482f05
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_bus_dma.h
@@ -0,0 +1,62 @@
+/*-
+ * Copyright 2006 John-Mark Gurney.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/sys/_bus_dma.h,v 1.1 2006/09/03 00:26:17 jmg Exp $
+ *
+ */
+#ifndef _SYS__BUS_DMA_H_
+#define _SYS__BUS_DMA_H_
+
+typedef int bus_dmasync_op_t;
+
+/*
+ *	bus_dma_tag_t
+ *
+ *	A machine-dependent opaque type describing the characteristics
+ *	of how to perform DMA mappings.  This structure encapsultes
+ *	information concerning address and alignment restrictions, number
+ *	of S/G segments, amount of data per S/G segment, etc.
+ */
+typedef struct bus_dma_tag	*bus_dma_tag_t;
+
+/*
+ *	bus_dmamap_t
+ *
+ *	DMA mapping instance information.
+ */
+typedef struct bus_dmamap	*bus_dmamap_t;
+
+/*
+ * A function that performs driver-specific synchronization on behalf of
+ * busdma.
+ */
+typedef enum {
+	BUS_DMA_LOCK	= 0x01,
+	BUS_DMA_UNLOCK	= 0x02,
+} bus_dma_lock_op_t;
+
+typedef void bus_dma_lock_t(void *, bus_dma_lock_op_t);
+
+#endif /* !_SYS__BUS_DMA_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_callout.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_callout.h
new file mode 100644
index 0000000000..b7270d7350
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_callout.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS__CALLOUT_H_
+#define _FBSD_COMPAT_SYS__CALLOUT_H_
+
+
+#include <util/list.h>
+#include <sys/queue.h>
+#include <sys/_mutex.h>
+
+
+struct callout {
+	struct list_link	link;
+	bigtime_t			due;
+	uint32				flags;
+
+	void *				c_arg;
+	void				(*c_func)(void *);
+	struct mtx *		c_mtx;
+	int					c_flags;
+};
+
+
+#endif /* _FBSD_COMPAT_SYS__CALLOUT_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_mutex.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_mutex.h
new file mode 100644
index 0000000000..109b0365b9
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_mutex.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS__MUTEX_H_
+#define _FBSD_COMPAT_SYS__MUTEX_H_
+
+
+#include <lock.h>
+#include <KernelExport.h>
+
+
+struct mtx {
+	int						type;
+	union {
+		struct {
+			mutex			lock;
+			thread_id		owner;
+		}					mutex;
+		recursive_lock		recursive;
+		struct {
+			spinlock		lock;
+			cpu_status		state;
+		}					spinlock;
+	} u;
+};
+
+
+#endif /* _FBSD_COMPAT_SYS__MUTEX_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_task.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_task.h
new file mode 100644
index 0000000000..6ce6c552ff
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_task.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS__TASK_H_
+#define _FBSD_COMPAT_SYS__TASK_H_
+
+
+/* Haiku's list management */
+#include <util/list.h>
+
+
+typedef void (*task_fn_t)(void *context, int pending);
+
+struct task {
+	int ta_priority;
+	task_fn_t ta_handler;
+	void *ta_argument;
+	int ta_pending;
+
+	struct list_link ta_link;
+};
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_timeval.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_timeval.h
new file mode 100644
index 0000000000..6ba7a53deb
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_timeval.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS__TIMEVAL_H_
+#define _FBSD_COMPAT_SYS__TIMEVAL_H_
+
+
+#include <sys/_types.h>
+
+#endif /* _FBSD_COMPAT_SYS__TIMEVAL_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_types.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_types.h
new file mode 100644
index 0000000000..790e013860
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/_types.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS__TYPES_H_
+#define _FBSD_COMPAT_SYS__TYPES_H_
+
+
+#ifdef __GNUCLIKE_BUILTIN_VARARGS
+typedef __builtin_va_list	__va_list;	/* internally known to gcc */
+#else
+typedef	char *			__va_list;
+#endif /* __GNUCLIKE_BUILTIN_VARARGS */
+#if defined(__GNUC_VA_LIST_COMPATIBILITY) && !defined(__GNUC_VA_LIST) \
+    && !defined(__NO_GNUC_VA_LIST)
+#define __GNUC_VA_LIST
+typedef __va_list		__gnuc_va_list;	/* compatibility w/GNU headers*/
+#endif
+
+#endif /* _FBSD_COMPAT_SYS__TYPES_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bitstring.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bitstring.h
new file mode 100644
index 0000000000..f0599d477f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bitstring.h
@@ -0,0 +1,304 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Paul Vixie.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Copyright (c) 2014 Spectra Logic Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $FreeBSD: head/sys/sys/bitstring.h 326023 2017-11-20 19:43:44Z pfg $
+ */
+#ifndef _SYS_BITSTRING_H_
+#define	_SYS_BITSTRING_H_
+
+#ifdef _KERNEL
+#include <sys/libkern.h>
+#include <sys/malloc.h>
+#endif
+
+#include <sys/types.h>
+
+typedef	unsigned long bitstr_t;
+
+/*---------------------- Private Implementation Details ----------------------*/
+#define	_BITSTR_MASK (~0UL)
+#define	_BITSTR_BITS (sizeof(bitstr_t) * 8)
+
+#ifdef roundup2
+#define        _bit_roundup2 roundup2
+#else
+#define        _bit_roundup2(x, y)        (((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#endif
+
+/* bitstr_t in bit string containing the bit. */
+static inline int
+_bit_idx(int _bit)
+{
+	return (_bit / _BITSTR_BITS);
+}
+
+/* bit number within bitstr_t at _bit_idx(_bit). */
+static inline int
+_bit_offset(int _bit)
+{
+	return (_bit % _BITSTR_BITS);
+}
+
+/* Mask for the bit within its long. */
+static inline bitstr_t
+_bit_mask(int _bit)
+{
+	return (1UL << _bit_offset(_bit));
+}
+
+static inline bitstr_t
+_bit_make_mask(int _start, int _stop)
+{
+	return ((_BITSTR_MASK << _bit_offset(_start)) &
+	    (_BITSTR_MASK >> (_BITSTR_BITS - _bit_offset(_stop) - 1)));
+}
+
+/*----------------------------- Public Interface -----------------------------*/
+/* Number of bytes allocated for a bit string of nbits bits */
+#define	bitstr_size(_nbits) (_bit_roundup2(_nbits, _BITSTR_BITS) / 8)
+
+/* Allocate a bit string initialized with no bits set. */
+#ifdef _KERNEL
+static inline bitstr_t *
+bit_alloc(int _nbits, struct malloc_type *type, int flags)
+{
+	return ((bitstr_t *)malloc(bitstr_size(_nbits), type, flags | M_ZERO));
+}
+#else
+static inline bitstr_t *
+bit_alloc(int _nbits)
+{
+	return ((bitstr_t *)calloc(bitstr_size(_nbits), 1));
+}
+#endif
+
+/* Allocate a bit string on the stack */
+#define	bit_decl(name, nbits) \
+	((name)[bitstr_size(nbits) / sizeof(bitstr_t)])
+
+/* Is bit N of bit string set? */
+static inline int
+bit_test(const bitstr_t *_bitstr, int _bit)
+{
+	return ((_bitstr[_bit_idx(_bit)] & _bit_mask(_bit)) != 0);
+}
+
+/* Set bit N of bit string. */
+static inline void
+bit_set(bitstr_t *_bitstr, int _bit)
+{
+	_bitstr[_bit_idx(_bit)] |= _bit_mask(_bit);
+}
+
+/* clear bit N of bit string name */
+static inline void
+bit_clear(bitstr_t *_bitstr, int _bit)
+{
+	_bitstr[_bit_idx(_bit)] &= ~_bit_mask(_bit);
+}
+
+/* Set bits start ... stop inclusive in bit string. */
+static inline void
+bit_nset(bitstr_t *_bitstr, int _start, int _stop)
+{
+	bitstr_t *_stopbitstr;
+
+	_stopbitstr = _bitstr + _bit_idx(_stop);
+	_bitstr += _bit_idx(_start);
+
+	if (_bitstr == _stopbitstr) {
+		*_bitstr |= _bit_make_mask(_start, _stop);
+	} else {
+		*_bitstr |= _bit_make_mask(_start, _BITSTR_BITS - 1);
+		while (++_bitstr < _stopbitstr)
+	    		*_bitstr = _BITSTR_MASK;
+		*_stopbitstr |= _bit_make_mask(0, _stop);
+	}
+}
+
+/* Clear bits start ... stop inclusive in bit string. */
+static inline void
+bit_nclear(bitstr_t *_bitstr, int _start, int _stop)
+{
+	bitstr_t *_stopbitstr;
+
+	_stopbitstr = _bitstr + _bit_idx(_stop);
+	_bitstr += _bit_idx(_start);
+
+	if (_bitstr == _stopbitstr) {
+		*_bitstr &= ~_bit_make_mask(_start, _stop);
+	} else {
+		*_bitstr &= ~_bit_make_mask(_start, _BITSTR_BITS - 1);
+		while (++_bitstr < _stopbitstr)
+			*_bitstr = 0;
+		*_stopbitstr &= ~_bit_make_mask(0, _stop);
+	}
+}
+
+/* Find the first bit set in bit string at or after bit start. */
+static inline void
+bit_ffs_at(bitstr_t *_bitstr, int _start, int _nbits, int *_result)
+{
+	bitstr_t *_curbitstr;
+	bitstr_t *_stopbitstr;
+	bitstr_t _test;
+	int _value, _offset;
+
+	if (_nbits > 0) {
+		_curbitstr = _bitstr + _bit_idx(_start);
+		_stopbitstr = _bitstr + _bit_idx(_nbits - 1);
+
+		_test = *_curbitstr;
+		if (_bit_offset(_start) != 0)
+			_test &= _bit_make_mask(_start, _BITSTR_BITS - 1);
+		while (_test == 0 && _curbitstr < _stopbitstr)
+			_test = *(++_curbitstr);
+
+		_offset = ffsl(_test);
+		_value = ((_curbitstr - _bitstr) * _BITSTR_BITS) + _offset - 1;
+		if (_offset == 0 || _value >= _nbits)
+			_value = -1;
+	} else {
+		_value = -1;
+	}
+	*_result = _value;
+}
+
+/* Find the first bit clear in bit string at or after bit start. */
+static inline void
+bit_ffc_at(bitstr_t *_bitstr, int _start, int _nbits, int *_result)
+{
+	bitstr_t *_curbitstr;
+	bitstr_t *_stopbitstr;
+	bitstr_t _test;
+	int _value, _offset;
+
+	if (_nbits > 0) {
+		_curbitstr = _bitstr + _bit_idx(_start);
+		_stopbitstr = _bitstr + _bit_idx(_nbits - 1);
+
+		_test = *_curbitstr;
+		if (_bit_offset(_start) != 0)
+			_test |= _bit_make_mask(0, _start - 1);
+		while (_test == _BITSTR_MASK && _curbitstr < _stopbitstr)
+			_test = *(++_curbitstr);
+
+		_offset = ffsl(~_test);
+		_value = ((_curbitstr - _bitstr) * _BITSTR_BITS) + _offset - 1;
+		if (_offset == 0 || _value >= _nbits)
+			_value = -1;
+	} else {
+		_value = -1;
+	}
+	*_result = _value;
+}
+
+/* Find the first bit set in bit string. */
+static inline void
+bit_ffs(bitstr_t *_bitstr, int _nbits, int *_result)
+{
+	bit_ffs_at(_bitstr, /*start*/0, _nbits, _result);
+}
+
+/* Find the first bit clear in bit string. */
+static inline void
+bit_ffc(bitstr_t *_bitstr, int _nbits, int *_result)
+{
+	bit_ffc_at(_bitstr, /*start*/0, _nbits, _result);
+}
+
+/* Count the number of bits set in a bitstr of size _nbits at or after _start */
+static inline void
+bit_count(bitstr_t *_bitstr, int _start, int _nbits, int *_result)
+{
+	bitstr_t *_curbitstr, mask;
+	int _value = 0, curbitstr_len;
+
+	if (_start >= _nbits)
+		goto out;
+
+	_curbitstr = _bitstr + _bit_idx(_start);
+	_nbits -= _BITSTR_BITS * _bit_idx(_start);
+	_start -= _BITSTR_BITS * _bit_idx(_start);
+
+	if (_start > 0) {
+		curbitstr_len = (int)_BITSTR_BITS < _nbits ?
+				(int)_BITSTR_BITS : _nbits;
+		mask = _bit_make_mask(_start, _bit_offset(curbitstr_len - 1));
+		_value += __bitcountl(*_curbitstr & mask);
+		_curbitstr++;
+		_nbits -= _BITSTR_BITS;
+	}
+	while (_nbits >= (int)_BITSTR_BITS) {
+		_value += __bitcountl(*_curbitstr);
+		_curbitstr++;
+		_nbits -= _BITSTR_BITS;
+	}
+	if (_nbits > 0) {
+		mask = _bit_make_mask(0, _bit_offset(_nbits - 1));
+		_value += __bitcountl(*_curbitstr & mask);
+	}
+
+out:
+	*_result = _value;
+}
+
+#endif	/* _SYS_BITSTRING_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/buf_ring.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/buf_ring.h
new file mode 100644
index 0000000000..b6c573fe67
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/buf_ring.h
@@ -0,0 +1,361 @@
+/*-
+ * Copyright (c) 2007-2009 Kip Macy <kmacy@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ *
+ */
+
+#ifndef	_SYS_BUF_RING_H_
+#define	_SYS_BUF_RING_H_
+
+#include <machine/cpu.h>
+#include <sys/malloc.h>
+#include <sys/systm.h>
+
+#if defined(INVARIANTS) && !defined(DEBUG_BUFRING)
+#define DEBUG_BUFRING 1
+#endif
+
+#ifdef DEBUG_BUFRING
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#endif
+
+struct buf_ring {
+	volatile uint32_t	br_prod_head;
+	volatile uint32_t	br_prod_tail;
+	int              	br_prod_size;
+	int              	br_prod_mask;
+	uint64_t		br_drops;
+	volatile uint32_t	br_cons_head;
+	volatile uint32_t	br_cons_tail;
+	int		 	br_cons_size;
+	int              	br_cons_mask;
+#ifdef DEBUG_BUFRING
+	struct mtx		*br_lock;
+#endif
+	void			*br_ring[0];
+};
+
+/*
+ * multi-producer safe lock-free ring buffer enqueue
+ *
+ */
+static __inline int
+buf_ring_enqueue(struct buf_ring *br, void *buf)
+{
+	uint32_t prod_head, prod_next, cons_tail;
+#ifdef DEBUG_BUFRING
+	uint32_t i;
+	for (i = br->br_cons_head; i != br->br_prod_head;
+	     i = ((i + 1) & br->br_cons_mask))
+		if(br->br_ring[i] == buf)
+			panic("buf=%p already enqueue at %d prod=%d cons=%d",
+			    buf, i, br->br_prod_tail, br->br_cons_tail);
+#endif
+	critical_enter();
+	do {
+		prod_head = br->br_prod_head;
+		prod_next = (prod_head + 1) & br->br_prod_mask;
+		cons_tail = br->br_cons_tail;
+
+		if (prod_next == cons_tail) {
+			rmb();
+			if (prod_head == br->br_prod_head &&
+			    cons_tail == br->br_cons_tail) {
+				br->br_drops++;
+				critical_exit();
+				return (ENOBUFS);
+			}
+			continue;
+		}
+	} while (!atomic_cmpset_acq_int(&br->br_prod_head, prod_head, prod_next));
+#ifdef DEBUG_BUFRING
+	if (br->br_ring[prod_head] != NULL)
+		panic("dangling value in enqueue");
+#endif
+	br->br_ring[prod_head] = buf;
+
+	/*
+	 * If there are other enqueues in progress
+	 * that preceded us, we need to wait for them
+	 * to complete
+	 */
+	while (br->br_prod_tail != prod_head)
+		cpu_spinwait();
+	atomic_store_rel_int(&br->br_prod_tail, prod_next);
+	critical_exit();
+	return (0);
+}
+
+/*
+ * multi-consumer safe dequeue
+ *
+ */
+static __inline void *
+buf_ring_dequeue_mc(struct buf_ring *br)
+{
+	uint32_t cons_head, cons_next;
+	void *buf;
+
+	critical_enter();
+	do {
+		cons_head = br->br_cons_head;
+		cons_next = (cons_head + 1) & br->br_cons_mask;
+
+		if (cons_head == br->br_prod_tail) {
+			critical_exit();
+			return (NULL);
+		}
+	} while (!atomic_cmpset_acq_int(&br->br_cons_head, cons_head, cons_next));
+
+	buf = br->br_ring[cons_head];
+#ifdef DEBUG_BUFRING
+	br->br_ring[cons_head] = NULL;
+#endif
+	/*
+	 * If there are other dequeues in progress
+	 * that preceded us, we need to wait for them
+	 * to complete
+	 */
+	while (br->br_cons_tail != cons_head)
+		cpu_spinwait();
+
+	atomic_store_rel_int(&br->br_cons_tail, cons_next);
+	critical_exit();
+
+	return (buf);
+}
+
+/*
+ * single-consumer dequeue
+ * use where dequeue is protected by a lock
+ * e.g. a network driver's tx queue lock
+ */
+static __inline void *
+buf_ring_dequeue_sc(struct buf_ring *br)
+{
+	uint32_t cons_head, cons_next;
+#ifdef PREFETCH_DEFINED
+	uint32_t cons_next_next;
+#endif
+	uint32_t prod_tail;
+	void *buf;
+
+	/*
+	 * This is a workaround to allow using buf_ring on ARM and ARM64.
+	 * ARM64TODO: Fix buf_ring in a generic way.
+	 * REMARKS: It is suspected that br_cons_head does not require
+	 *   load_acq operation, but this change was extensively tested
+	 *   and confirmed it's working. To be reviewed once again in
+	 *   FreeBSD-12.
+	 *
+	 * Preventing following situation:
+
+	 * Core(0) - buf_ring_enqueue()                                       Core(1) - buf_ring_dequeue_sc()
+	 * -----------------------------------------                                       ----------------------------------------------
+	 *
+	 *                                                                                cons_head = br->br_cons_head;
+	 * atomic_cmpset_acq_32(&br->br_prod_head, ...));
+	 *                                                                                buf = br->br_ring[cons_head];     <see <1>>
+	 * br->br_ring[prod_head] = buf;
+	 * atomic_store_rel_32(&br->br_prod_tail, ...);
+	 *                                                                                prod_tail = br->br_prod_tail;
+	 *                                                                                if (cons_head == prod_tail)
+	 *                                                                                        return (NULL);
+	 *                                                                                <condition is false and code uses invalid(old) buf>`
+	 *
+	 * <1> Load (on core 1) from br->br_ring[cons_head] can be reordered (speculative readed) by CPU.
+	 */
+#if defined(__arm__) || defined(__aarch64__)
+	cons_head = atomic_load_acq_32(&br->br_cons_head);
+#else
+	cons_head = br->br_cons_head;
+#endif
+	prod_tail = atomic_load_acq_32(&br->br_prod_tail);
+
+	cons_next = (cons_head + 1) & br->br_cons_mask;
+#ifdef PREFETCH_DEFINED
+	cons_next_next = (cons_head + 2) & br->br_cons_mask;
+#endif
+
+	if (cons_head == prod_tail)
+		return (NULL);
+
+#ifdef PREFETCH_DEFINED
+	if (cons_next != prod_tail) {
+		prefetch(br->br_ring[cons_next]);
+		if (cons_next_next != prod_tail)
+			prefetch(br->br_ring[cons_next_next]);
+	}
+#endif
+	br->br_cons_head = cons_next;
+	buf = br->br_ring[cons_head];
+
+#ifdef DEBUG_BUFRING
+	br->br_ring[cons_head] = NULL;
+	if (!mtx_owned(br->br_lock))
+		panic("lock not held on single consumer dequeue");
+	if (br->br_cons_tail != cons_head)
+		panic("inconsistent list cons_tail=%d cons_head=%d",
+		    br->br_cons_tail, cons_head);
+#endif
+	br->br_cons_tail = cons_next;
+	return (buf);
+}
+
+/*
+ * single-consumer advance after a peek
+ * use where it is protected by a lock
+ * e.g. a network driver's tx queue lock
+ */
+static __inline void
+buf_ring_advance_sc(struct buf_ring *br)
+{
+	uint32_t cons_head, cons_next;
+	uint32_t prod_tail;
+
+	cons_head = br->br_cons_head;
+	prod_tail = br->br_prod_tail;
+
+	cons_next = (cons_head + 1) & br->br_cons_mask;
+	if (cons_head == prod_tail)
+		return;
+	br->br_cons_head = cons_next;
+#ifdef DEBUG_BUFRING
+	br->br_ring[cons_head] = NULL;
+#endif
+	br->br_cons_tail = cons_next;
+}
+
+/*
+ * Used to return a buffer (most likely already there)
+ * to the top od the ring. The caller should *not*
+ * have used any dequeue to pull it out of the ring
+ * but instead should have used the peek() function.
+ * This is normally used where the transmit queue
+ * of a driver is full, and an mubf must be returned.
+ * Most likely whats in the ring-buffer is what
+ * is being put back (since it was not removed), but
+ * sometimes the lower transmit function may have
+ * done a pullup or other function that will have
+ * changed it. As an optimzation we always put it
+ * back (since jhb says the store is probably cheaper),
+ * if we have to do a multi-queue version we will need
+ * the compare and an atomic.
+ */
+static __inline void
+buf_ring_putback_sc(struct buf_ring *br, void *_new)
+{
+	KASSERT(br->br_cons_head != br->br_prod_tail,
+		("Buf-Ring has none in putback")) ;
+	br->br_ring[br->br_cons_head] = _new;
+}
+
+/*
+ * return a pointer to the first entry in the ring
+ * without modifying it, or NULL if the ring is empty
+ * race-prone if not protected by a lock
+ */
+static __inline void *
+buf_ring_peek(struct buf_ring *br)
+{
+
+#ifdef DEBUG_BUFRING
+	if ((br->br_lock != NULL) && !mtx_owned(br->br_lock))
+		panic("lock not held on single consumer dequeue");
+#endif
+	/*
+	 * I believe it is safe to not have a memory barrier
+	 * here because we control cons and tail is worst case
+	 * a lagging indicator so we worst case we might
+	 * return NULL immediately after a buffer has been enqueued
+	 */
+	if (br->br_cons_head == br->br_prod_tail)
+		return (NULL);
+
+	return (br->br_ring[br->br_cons_head]);
+}
+
+static __inline void *
+buf_ring_peek_clear_sc(struct buf_ring *br)
+{
+#ifdef DEBUG_BUFRING
+	void *ret;
+
+	if (!mtx_owned(br->br_lock))
+		panic("lock not held on single consumer dequeue");
+#endif
+	/*
+	 * I believe it is safe to not have a memory barrier
+	 * here because we control cons and tail is worst case
+	 * a lagging indicator so we worst case we might
+	 * return NULL immediately after a buffer has been enqueued
+	 */
+	if (br->br_cons_head == br->br_prod_tail)
+		return (NULL);
+
+#ifdef DEBUG_BUFRING
+	/*
+	 * Single consumer, i.e. cons_head will not move while we are
+	 * running, so atomic_swap_ptr() is not necessary here.
+	 */
+	ret = br->br_ring[br->br_cons_head];
+	br->br_ring[br->br_cons_head] = NULL;
+	return (ret);
+#else
+	return (br->br_ring[br->br_cons_head]);
+#endif
+}
+
+static __inline int
+buf_ring_full(struct buf_ring *br)
+{
+
+	return (((br->br_prod_head + 1) & br->br_prod_mask) == br->br_cons_tail);
+}
+
+static __inline int
+buf_ring_empty(struct buf_ring *br)
+{
+
+	return (br->br_cons_head == br->br_prod_tail);
+}
+
+static __inline int
+buf_ring_count(struct buf_ring *br)
+{
+
+	return ((br->br_prod_size + br->br_prod_tail - br->br_cons_tail)
+	    & br->br_prod_mask);
+}
+
+struct buf_ring *buf_ring_alloc(int count, struct malloc_type *type, int flags,
+    struct mtx *);
+void buf_ring_free(struct buf_ring *br, struct malloc_type *type);
+
+
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus.h
new file mode 100644
index 0000000000..26ab3f8e28
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2009, Colin Gnther. All Rights Reserved.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_BUS_H_
+#define _FBSD_COMPAT_SYS_BUS_H_
+
+
+#include <sys/haiku-module.h>
+
+#include <sys/_bus_dma.h>
+
+#include <sys/queue.h>
+
+
+// TODO per platform, these are 32-bit
+
+// oh you glorious world of macros
+#define bus_read_1(r, o) \
+	bus_space_read_1((r)->r_bustag, (r)->r_bushandle, (o))
+#define bus_read_2(r, o) \
+	bus_space_read_2((r)->r_bustag, (r)->r_bushandle, (o))
+#define bus_read_4(r, o) \
+	bus_space_read_4((r)->r_bustag, (r)->r_bushandle, (o))
+#define bus_write_1(r, o, v) \
+	bus_space_write_1((r)->r_bustag, (r)->r_bushandle, (o), (v))
+#define bus_write_2(r, o, v) \
+	bus_space_write_2((r)->r_bustag, (r)->r_bushandle, (o), (v))
+#define bus_write_4(r, o, v) \
+	bus_space_write_4((r)->r_bustag, (r)->r_bushandle, (o), (v))
+
+#define bus_barrier(r, o, l, f) \
+	bus_space_barrier((r)->r_bustag, (r)->r_bushandle, (o), (l), (f))
+
+#define bus_read_region_1(r, o, d, c) \
+	bus_space_read_region_1((r)->r_bustag, (r)->r_bushandle, (o), (d), (c))
+
+#define	FILTER_STRAY			B_UNHANDLED_INTERRUPT
+#define	FILTER_HANDLED			B_HANDLED_INTERRUPT
+#define	FILTER_SCHEDULE_THREAD	B_INVOKE_SCHEDULER
+
+/* Note that we reversed the original order, so whenever actual (negative)
+   numbers are used in a driver, we have to change it. */
+#define BUS_PROBE_SPECIFIC		0
+#define BUS_PROBE_LOW_PRIORITY	10
+#define BUS_PROBE_DEFAULT		20
+#define BUS_PROBE_GENERIC		100
+
+#define __BUS_ACCESSOR(varp, var, ivarp, ivar, type)						\
+																			\
+static __inline type varp ## _get_ ## var(device_t dev)                 \
+{                                                                       \
+	return 0;														\
+}                                                                       \
+																			\
+static __inline void varp ## _set_ ## var(device_t dev, type t)				\
+{																			\
+}
+
+
+struct resource;
+
+struct resource_spec {
+	int	type;
+	int	rid;
+	int	flags;
+};
+
+enum intr_type {
+	INTR_TYPE_NET	= 4,
+	INTR_MPSAFE		= 512,
+	INTR_EXCL = 256,
+};
+
+
+int bus_generic_detach(device_t dev);
+int bus_generic_suspend(device_t dev);
+int bus_generic_resume(device_t dev);
+void bus_generic_shutdown(device_t dev);
+
+typedef int (driver_filter_t)(void *arg);
+typedef void driver_intr_t(void *);
+
+
+int resource_int_value(const char *name, int unit, const char *resname,
+	int *result);
+int resource_disabled(const char *name, int unit);
+
+struct resource *bus_alloc_resource(device_t dev, int type, int *rid,
+	unsigned long start, unsigned long end, unsigned long count, uint32 flags);
+int bus_release_resource(device_t dev, int type, int rid, struct resource *r);
+int bus_alloc_resources(device_t dev, struct resource_spec *resourceSpec,
+	struct resource **resources);
+void bus_release_resources(device_t dev,
+	const struct resource_spec *resourceSpec, struct resource **resources);
+
+int	bus_child_present(device_t child);
+void	bus_enumerate_hinted_children(device_t bus);
+
+static inline struct resource *
+bus_alloc_resource_any(device_t dev, int type, int *rid, uint32 flags)
+{
+	return bus_alloc_resource(dev, type, rid, 0, ~0, 1, flags);
+}
+
+static inline struct resource *
+bus_alloc_resource_anywhere(device_t dev, int type, int *rid,
+    unsigned long count, uint32 flags)
+{
+	return (bus_alloc_resource(dev, type, rid, 0, ~0, count, flags));
+}
+
+bus_dma_tag_t bus_get_dma_tag(device_t dev);
+
+int bus_setup_intr(device_t dev, struct resource *r, int flags,
+	driver_filter_t* filter, driver_intr_t handler, void *arg, void **_cookie);
+int bus_teardown_intr(device_t dev, struct resource *r, void *cookie);
+int bus_bind_intr(device_t dev, struct resource *r, int cpu);
+int bus_describe_intr(device_t dev, struct resource *irq, void *cookie,
+	const char* fmt, ...);
+
+const char *device_get_name(device_t dev);
+const char *device_get_nameunit(device_t dev);
+int device_get_unit(device_t dev);
+void *device_get_softc(device_t dev);
+void device_set_softc(device_t dev, void *softc);
+int device_printf(device_t dev, const char *, ...) __printflike(2, 3);
+void device_set_desc(device_t dev, const char *desc);
+void device_set_desc_copy(device_t dev, const char *desc);
+const char *device_get_desc(device_t dev);
+device_t device_get_parent(device_t dev);
+u_int32_t device_get_flags(device_t dev);
+devclass_t device_get_devclass(device_t dev);
+int device_get_children(device_t dev, device_t **devlistp, int *devcountp);
+
+void device_set_ivars(device_t dev, void *);
+void *device_get_ivars(device_t dev);
+
+device_t device_add_child(device_t dev, const char* name, int unit);
+device_t device_add_child_driver(device_t dev, const char* name, driver_t* driver,
+	int unit);
+int device_delete_child(device_t dev, device_t child);
+int device_is_attached(device_t dev);
+int device_attach(device_t dev);
+int device_detach(device_t dev);
+int bus_print_child_header(device_t dev, device_t child);
+int bus_print_child_footer(device_t dev, device_t child);
+int bus_generic_print_child(device_t dev, device_t child);
+void bus_generic_driver_added(device_t dev, driver_t *driver);
+int bus_generic_attach(device_t dev);
+int device_set_driver(device_t dev, driver_t *driver);
+int device_is_alive(device_t dev);
+
+
+static inline struct sysctl_ctx_list *
+device_get_sysctl_ctx(device_t dev)
+{
+	return NULL;
+}
+
+
+static inline void *
+device_get_sysctl_tree(device_t dev)
+{
+	return NULL;
+}
+
+devclass_t devclass_find(const char *classname);
+device_t devclass_get_device(devclass_t dc, int unit);
+int devclass_get_maxunit(devclass_t dc);
+
+#endif	/* _FBSD_COMPAT_SYS_BUS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus_dma.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus_dma.h
new file mode 100644
index 0000000000..d24753ac23
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/bus_dma.h
@@ -0,0 +1,263 @@
+/*	$NetBSD: bus.h,v 1.12 1997/10/01 08:25:15 fvdl Exp $	*/
+
+/*-
+ * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the NetBSD
+ *	Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
+ * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Christopher G. Demetriou
+ *	for the NetBSD Project.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* $FreeBSD: src/sys/sys/bus_dma.h,v 1.30 2006/09/03 00:26:17 jmg Exp $ */
+#ifndef _BUS_DMA_H_
+#define _BUS_DMA_H_
+
+#include <sys/_bus_dma.h>
+
+
+/*
+ * Machine independent interface for mapping physical addresses to peripheral
+ * bus 'physical' addresses, and assisting with DMA operations.
+ *
+ * XXX This file is always included from <machine/bus_dma.h> and should not
+ *     (yet) be included directly.
+ */
+
+/*
+ * Flags used in various bus DMA methods.
+ */
+#define	BUS_DMA_WAITOK		0x00	/* safe to sleep (pseudo-flag) */
+#define	BUS_DMA_NOWAIT		0x01	/* not safe to sleep */
+#define	BUS_DMA_ALLOCNOW	0x02	/* perform resource allocation now */
+#define	BUS_DMA_COHERENT	0x04	/* hint: map memory in a coherent way */
+#define	BUS_DMA_ZERO		0x08	/* allocate zero'ed memory */
+#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
+#define	BUS_DMA_BUS2		0x20
+#define	BUS_DMA_BUS3		0x40
+#define	BUS_DMA_BUS4		0x80
+
+/*
+ * The following two flags are non-standard or specific to only certain
+ * architectures
+ */
+#define	BUS_DMA_NOWRITE		0x100
+#define	BUS_DMA_NOCACHE		0x200
+#define	BUS_DMA_ISA		0x400	/* map memory for AXP ISA dma */
+
+/* Forwards needed by prototypes below. */
+struct mbuf;
+struct uio;
+
+/*
+ * Operations performed by bus_dmamap_sync().
+ */
+#define	BUS_DMASYNC_PREREAD	1
+#define	BUS_DMASYNC_POSTREAD	2
+#define	BUS_DMASYNC_PREWRITE	4
+#define	BUS_DMASYNC_POSTWRITE	8
+
+/*
+ *	bus_dma_segment_t
+ *
+ *	Describes a single contiguous DMA transaction.  Values
+ *	are suitable for programming into DMA registers.
+ */
+typedef struct bus_dma_segment {
+	bus_addr_t	ds_addr;	/* DMA address */
+	bus_size_t	ds_len;		/* length of transfer */
+} bus_dma_segment_t;
+
+/*
+ * A function that returns 1 if the address cannot be accessed by
+ * a device and 0 if it can be.
+ */
+typedef int bus_dma_filter_t(void *, bus_addr_t);
+
+/*
+ * Generic helper function for manipulating mutexes.
+ */
+void busdma_lock_mutex(void *arg, bus_dma_lock_op_t op);
+
+/*
+ * Allocate a device specific dma_tag encapsulating the constraints of
+ * the parent tag in addition to other restrictions specified:
+ *
+ *	alignment:	Alignment for segments.
+ *	boundary:	Boundary that segments cannot cross.
+ *	lowaddr:	Low restricted address that cannot appear in a mapping.
+ *	highaddr:	High restricted address that cannot appear in a mapping.
+ *	filtfunc:	An optional function to further test if an address
+ *			within the range of lowaddr and highaddr cannot appear
+ *			in a mapping.
+ *	filtfuncarg:	An argument that will be passed to filtfunc in addition
+ *			to the address to test.
+ *	maxsize:	Maximum mapping size supported by this tag.
+ *	nsegments:	Number of discontinuities allowed in maps.
+ *	maxsegsz:	Maximum size of a segment in the map.
+ *	flags:		Bus DMA flags.
+ *	lockfunc:	An optional function to handle driver-defined lock
+ *			operations.
+ *	lockfuncarg:	An argument that will be passed to lockfunc in addition
+ *			to the lock operation.
+ *	dmat:		A pointer to set to a valid dma tag should the return
+ *			value of this function indicate success.
+ */
+/* XXX Should probably allow specification of alignment */
+int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment,
+		       bus_size_t boundary, bus_addr_t lowaddr,
+		       bus_addr_t highaddr, bus_dma_filter_t *filtfunc,
+		       void *filtfuncarg, bus_size_t maxsize, int nsegments,
+		       bus_size_t maxsegsz, int flags, bus_dma_lock_t *lockfunc,
+		       void *lockfuncarg, bus_dma_tag_t *dmat);
+
+int bus_dma_tag_destroy(bus_dma_tag_t dmat);
+
+/*
+ * A function that processes a successfully loaded dma map or an error
+ * from a delayed load map.
+ */
+typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
+
+/*
+ * Like bus_dmamap_callback but includes map size in bytes.  This is
+ * defined as a separate interface to maintain compatibility for users
+ * of bus_dmamap_callback_t--at some point these interfaces should be merged.
+ */
+typedef void bus_dmamap_callback2_t(void *, bus_dma_segment_t *, int, bus_size_t, int);
+
+/*
+ * Allocate a handle for mapping from kva/uva/physical
+ * address space into bus device space.
+ */
+int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp);
+
+/*
+ * Destroy a handle for mapping from kva/uva/physical
+ * address space into bus device space.
+ */
+int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map);
+
+/*
+ * Allocate a piece of memory that can be efficiently mapped into
+ * bus device space based on the constraints listed in the dma tag.
+ * A dmamap to for use with dmamap_load is also allocated.
+ */
+int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags,
+		     bus_dmamap_t *mapp);
+
+/*
+ * Free a piece of memory and its allocated dmamap, that was allocated
+ * via bus_dmamem_alloc.
+ */
+void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map);
+
+/*
+ * Map the buffer buf into bus space using the dmamap map.
+ */
+int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf,
+		    bus_size_t buflen, bus_dmamap_callback_t *callback,
+		    void *callback_arg, int flags);
+
+/*
+ * Like bus_dmamap_load but for mbufs.  Note the use of the
+ * bus_dmamap_callback2_t interface.
+ */
+int bus_dmamap_load_mbuf(bus_dma_tag_t dmat, bus_dmamap_t map,
+			 struct mbuf *mbuf,
+			 bus_dmamap_callback2_t *callback, void *callback_arg,
+			 int flags);
+
+int bus_dmamap_load_mbuf_sg(bus_dma_tag_t dmat, bus_dmamap_t map,
+			    struct mbuf *mbuf, bus_dma_segment_t *segs,
+			    int *nsegs, int flags);
+
+/*
+ * Like bus_dmamap_load but for uios.  Note the use of the
+ * bus_dmamap_callback2_t interface.
+ */
+int bus_dmamap_load_uio(bus_dma_tag_t dmat, bus_dmamap_t map,
+			struct uio *ui,
+			bus_dmamap_callback2_t *callback, void *callback_arg,
+			int flags);
+
+/*
+ * Perform a synchronization operation on the given map.
+ */
+void _bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t);
+#define bus_dmamap_sync(dmat, dmamap, op) 			\
+	do {							\
+		if ((dmamap) != NULL)				\
+			_bus_dmamap_sync(dmat, dmamap, op);	\
+	} while (0)
+
+/*
+ * Release the mapping held by map.
+ */
+void _bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map);
+#define bus_dmamap_unload(dmat, dmamap) 			\
+	do {							\
+		if ((dmamap) != NULL)				\
+			_bus_dmamap_unload(dmat, dmamap);	\
+	} while (0)
+
+
+#endif /* _BUS_DMA_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/callout.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/callout.h
new file mode 100644
index 0000000000..35e18707e9
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/callout.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010, Axel Drfler, axeld@pinc-software.de.
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_CALLOUT_H_
+#define _FBSD_COMPAT_SYS_CALLOUT_H_
+
+
+#include <sys/haiku-module.h>
+#include <sys/_callout.h>
+
+
+#define	CALLOUT_MPSAFE			0x0008 /* deprecated */
+#define	CALLOUT_RETURNUNLOCKED	0x0010 /* handler returns with mtx unlocked */
+
+
+void callout_init(struct callout *c, int mpsafe);
+void callout_init_mtx(struct callout *c, struct mtx *mutex, int flags);
+int callout_schedule(struct callout *c, int _ticks);
+int callout_reset(struct callout *c, int _ticks, void (*func)(void *), void *arg);
+int callout_pending(struct callout *c);
+int callout_active(struct callout *c);
+
+#define callout_reset_on(c, to_ticks, fn, arg, cpu) \
+	callout_reset(c, to_ticks, fn, arg)
+
+#define	callout_drain(c)	_callout_stop_safe(c, 1)
+#define	callout_stop(c)		_callout_stop_safe(c, 0)
+int	_callout_stop_safe(struct callout *c, int safe);
+
+
+
+#endif	/* _FBSD_COMPAT_SYS_CALLOUT_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/cdefs.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/cdefs.h
new file mode 100644
index 0000000000..3f9fbbb77c
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/cdefs.h
@@ -0,0 +1,373 @@
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Berkeley Software Design, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
+ * $FreeBSD$
+ */
+#ifndef _FBSD_COMPAT_SYS_CDEFS_H_
+#define _FBSD_COMPAT_SYS_CDEFS_H_
+
+
+#include <posix/sys/cdefs.h>
+
+
+#if 0
+#define __FBSDID(str)	static const char __fbsdid[] = str
+#else
+#define __FBSDID(str)
+#endif
+
+/*
+ * This code has been put in place to help reduce the addition of
+ * compiler specific defines in FreeBSD code.  It helps to aid in
+ * having a compiler-agnostic source tree.
+ */
+
+#if defined(__GNUC__) || defined(__INTEL_COMPILER)
+
+#if __GNUC__ >= 3 || defined(__INTEL_COMPILER)
+#define __GNUCLIKE_ASM 3
+#define __GNUCLIKE_MATH_BUILTIN_CONSTANTS
+#else
+#define __GNUCLIKE_ASM 2
+#endif
+#define __GNUCLIKE___TYPEOF 1
+#define __GNUCLIKE___OFFSETOF 1
+#define __GNUCLIKE___SECTION 1
+
+#define __GNUCLIKE_ATTRIBUTE_MODE_DI 1
+
+#ifndef __INTEL_COMPILER
+# define __GNUCLIKE_CTOR_SECTION_HANDLING 1
+#endif
+
+#define __GNUCLIKE_BUILTIN_CONSTANT_P 1
+# if defined(__INTEL_COMPILER) && defined(__cplusplus) \
+    && __INTEL_COMPILER < 800
+#  undef __GNUCLIKE_BUILTIN_CONSTANT_P
+# endif
+
+#if (__GNUC_MINOR__ > 95 || __GNUC__ >= 3) && !defined(__INTEL_COMPILER)
+# define __GNUCLIKE_BUILTIN_VARARGS 1
+# define __GNUCLIKE_BUILTIN_STDARG 1
+# define __GNUCLIKE_BUILTIN_VAALIST 1
+#endif
+
+#if defined(__GNUC__)
+# define __GNUC_VA_LIST_COMPATIBILITY 1
+#endif
+
+/*
+ * Compiler memory barriers, specific to gcc and clang.
+ */
+#if defined(__GNUC__)
+#define	__compiler_membar()	__asm __volatile(" " : : : "memory")
+#endif
+
+#ifndef __INTEL_COMPILER
+# define __GNUCLIKE_BUILTIN_NEXT_ARG 1
+# define __GNUCLIKE_MATH_BUILTIN_RELOPS
+#endif
+
+#define __GNUCLIKE_BUILTIN_MEMCPY 1
+
+/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
+#define __CC_SUPPORTS_INLINE 1
+#define __CC_SUPPORTS___INLINE 1
+#define __CC_SUPPORTS___INLINE__ 1
+
+#define __CC_SUPPORTS___FUNC__ 1
+#define __CC_SUPPORTS_WARNING 1
+
+#define __CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */
+
+#define __CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
+
+#endif /* __GNUC__ || __INTEL_COMPILER */
+
+
+/*
+ * Macro to test if we're using a specific version of gcc or later.
+ */
+#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
+#define	__GNUC_PREREQ__(ma, mi)	\
+	(__GNUC__ > (ma) || __GNUC__ == (ma) && __GNUC_MINOR__ >= (mi))
+#else
+#define	__GNUC_PREREQ__(ma, mi)	0
+#endif
+
+/*
+ * GNU C version 2.96 adds explicit branch prediction so that
+ * the CPU back-end can hint the processor and also so that
+ * code blocks can be reordered such that the predicted path
+ * sees a more linear flow, thus improving cache behavior, etc.
+ *
+ * The following two macros provide us with a way to utilize this
+ * compiler feature.  Use __predict_true() if you expect the expression
+ * to evaluate to true, and __predict_false() if you expect the
+ * expression to evaluate to false.
+ *
+ * A few notes about usage:
+ *
+ *	* Generally, __predict_false() error condition checks (unless
+ *	  you have some _strong_ reason to do otherwise, in which case
+ *	  document it), and/or __predict_true() `no-error' condition
+ *	  checks, assuming you want to optimize for the no-error case.
+ *
+ *	* Other than that, if you don't know the likelihood of a test
+ *	  succeeding from empirical or other `hard' evidence, don't
+ *	  make predictions.
+ *
+ *	* These are meant to be used in places that are run `a lot'.
+ *	  It is wasteful to make predictions in code that is run
+ *	  seldomly (e.g. at subsystem initialization time) as the
+ *	  basic block reordering that this affects can often generate
+ *	  larger code.
+ */
+#if __GNUC_PREREQ__(2, 96)
+#define __predict_true(exp)     __builtin_expect((exp), 1)
+#define __predict_false(exp)    __builtin_expect((exp), 0)
+#else
+#define __predict_true(exp)     (exp)
+#define __predict_false(exp)    (exp)
+#endif
+
+/*
+ * We define this here since <stddef.h>, <sys/queue.h>, and <sys/types.h>
+ * require it.
+ */
+#if __GNUC_PREREQ__(4, 1)
+#define __offsetof(type, field)	 __builtin_offsetof(type, field)
+#else
+#ifndef __cplusplus
+#define	__offsetof(type, field)	((size_t)(&((type *)0)->field))
+#else
+#define __offsetof(type, field)					\
+  ((reinterpret_cast <size_t>			\
+                 (&reinterpret_cast <const volatile char &>	\
+                  (static_cast<type *> (0)->field))))
+#endif
+#endif
+#define	__rangeof(type, start, end) \
+	(__offsetof(type, end) - __offsetof(type, start))
+
+/*
+ * Given the pointer x to the member m of the struct s, return
+ * a pointer to the containing structure.  When using GCC, we first
+ * assign pointer x to a local variable, to check that its type is
+ * compatible with member m.
+ */
+#if __GNUC_PREREQ__(3, 1)
+#define	__containerof(x, s, m) ({					\
+	const volatile __typeof(((s *)0)->m) *__x = (x);		\
+	__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));\
+})
+#else
+#define	__containerof(x, s, m)						\
+	__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
+#endif
+
+/*
+ * Compiler-dependent macros to help declare dead (non-returning) and
+ * pure (no side effects) functions, and unused variables.  They are
+ * null except for versions of gcc that are known to support the features
+ * properly (old versions of gcc-2 supported the dead and pure features
+ * in a different (wrong) way).  If we do not provide an implementation
+ * for a given compiler, let the compile fail if it is told to use
+ * a feature that we cannot live without.
+ */
+/*
+ * Compiler-dependent macros to help declare dead (non-returning) and
+ * pure (no side effects) functions, and unused variables.  They are
+ * null except for versions of gcc that are known to support the features
+ * properly (old versions of gcc-2 supported the dead and pure features
+ * in a different (wrong) way).  If we do not provide an implementation
+ * for a given compiler, let the compile fail if it is told to use
+ * a feature that we cannot live without.
+ */
+#define	__weak_symbol	__attribute__((__weak__))
+#if !__GNUC_PREREQ__(2, 5) && !defined(__INTEL_COMPILER)
+#define	__dead2
+#define	__pure2
+#define	__unused
+#endif
+#if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !defined(__INTEL_COMPILER)
+#define	__dead2		__attribute__((__noreturn__))
+#define	__pure2		__attribute__((__const__))
+#define	__unused
+/* XXX Find out what to do for __packed, __aligned and __section */
+#endif
+#if __GNUC_PREREQ__(2, 7) || defined(__INTEL_COMPILER)
+#undef __dead2
+#define	__dead2		__attribute__((__noreturn__))
+#define	__pure2		__attribute__((__const__))
+#define	__unused	__attribute__((__unused__))
+#define	__used		__attribute__((__used__))
+#define	__packed	__attribute__((__packed__))
+#define	__aligned(x)	__attribute__((__aligned__(x)))
+#define	__section(x)	__attribute__((__section__(x)))
+#endif
+#if __GNUC_PREREQ__(4, 3)
+#define	__alloc_size(x)	__attribute__((__alloc_size__(x)))
+#define	__alloc_size2(n, x)	__attribute__((__alloc_size__(n, x)))
+#else
+#define	__alloc_size(x)
+#define	__alloc_size2(n, x)
+#endif
+#if __GNUC_PREREQ__(4, 9)
+#define	__alloc_align(x)	__attribute__((__alloc_align__(x)))
+#else
+#define	__alloc_align(x)
+#endif
+
+/*
+ * Compiler-dependent macros to declare that functions take printf-like
+ * or scanf-like arguments.  They are null except for versions of gcc
+ * that are known to support the features properly (old versions of gcc-2
+ * didn't permit keeping the keywords out of the application namespace).
+ */
+#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
+#define	__printflike(fmtarg, firstvararg)
+#define	__scanflike(fmtarg, firstvararg)
+#define	__format_arg(fmtarg)
+#else
+#define	__printflike(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
+#define	__scanflike(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
+#define	__format_arg(fmtarg)	__attribute__((__format_arg__ (fmtarg)))
+#endif
+
+/*
+ * C99 Static array indices in function parameter declarations.  Syntax such as:
+ * void bar(int myArray[static 10]);
+ * is allowed in C99 but not in C++.  Define __min_size appropriately so
+ * headers using it can be compiled in either language.  Use like this:
+ * void bar(int myArray[__min_size(10)]);
+ */
+#if !defined(__cplusplus) && \
+    (defined(__clang__) || __GNUC_PREREQ__(4, 6)) && \
+    (!defined(__STDC_VERSION__) || (__STDC_VERSION__ >= 199901))
+#define __min_size(x)	static (x)
+#else
+#define __min_size(x)	(x)
+#endif
+
+#if __GNUC_PREREQ__(3, 1)
+#define	__noinline	__attribute__ ((__noinline__))
+#else
+#define	__noinline
+#endif
+
+#if __GNUC_PREREQ__(3, 3)
+#define __nonnull(x)	__attribute__((__nonnull__(x)))
+#else
+#define __nonnull(x)
+#endif
+
+/*
+ * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
+ * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
+ * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
+ * mode -- there must be no spaces between its arguments, and for nested
+ * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
+ * concatenate double-quoted strings produced by the __STRING macro, but
+ * this only works with ANSI C.
+ *
+ * __XSTRING is like __STRING, but it expands any macros in its argument
+ * first.  It is only available with ANSI C.
+ */
+#if defined(__STDC__) || defined(__cplusplus)
+#define	__XSTRING(x)	__STRING(x)	/* expand x, then stringify */
+
+#define	__const		const		/* define reserved names to standard */
+#define	__signed	signed
+#define	__volatile	volatile
+#if defined(__cplusplus)
+#define	__inline	inline		/* convert to C++ keyword */
+#else
+#if !(defined(__CC_SUPPORTS___INLINE))
+#define	__inline			/* delete GCC keyword */
+#endif /* ! __CC_SUPPORTS___INLINE */
+#endif /* !__cplusplus */
+
+#else	/* !(__STDC__ || __cplusplus) */
+
+#if !defined(__CC_SUPPORTS___INLINE)
+#define	__const				/* delete pseudo-ANSI C keywords */
+#define	__inline
+#define	__signed
+#define	__volatile
+/*
+ * In non-ANSI C environments, new programs will want ANSI-only C keywords
+ * deleted from the program and old programs will want them left alone.
+ * When using a compiler other than gcc, programs using the ANSI C keywords
+ * const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
+ * When using "gcc -traditional", we assume that this is the intent; if
+ * __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.
+ */
+#ifndef	NO_ANSI_KEYWORDS
+#define	const				/* delete ANSI C keywords */
+#define	inline
+#define	signed
+#define	volatile
+#endif	/* !NO_ANSI_KEYWORDS */
+#endif	/* !__CC_SUPPORTS___INLINE */
+#endif	/* !(__STDC__ || __cplusplus) */
+
+#ifndef	__DECONST
+#define	__DECONST(type, var)	((type)(uintptr_t)(const void *)(var))
+#endif
+
+#ifndef	__UNCONST
+#define	__UNCONST(var)	((void*)(uintptr_t)(const void *)(var))
+#endif
+
+#ifndef	__DEVOLATILE
+#define	__DEVOLATILE(type, var)	((type)(uintptr_t)(volatile void *)(var))
+#endif
+
+#ifndef	__DEQUALIFY
+#define	__DEQUALIFY(type, var)	((type)(uintptr_t)(const volatile void *)(var))
+#endif
+
+#if __GNUC_PREREQ__(4,6) && !defined(__cplusplus)
+/* Nothing, gcc 4.6 and higher has _Static_assert built-in */
+#elif defined(__COUNTER__)
+#define	_Static_assert(x, y)	__Static_assert(x, __COUNTER__)
+#define	__Static_assert(x, y)	___Static_assert(x, y)
+#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] \
+				__unused
+#else
+#define	_Static_assert(x, y)
+#endif
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/condvar.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/condvar.h
new file mode 100644
index 0000000000..55b96a816b
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/condvar.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_CONDVAR_H_
+#define _FBSD_COMPAT_SYS_CONDVAR_H_
+
+
+#include <sys/queue.h>
+
+#ifdef __cplusplus
+} /* extern "C" */
+#include <kernel_c++_structs.h>
+extern "C" {
+#else
+#include <kernel_c++_structs.h>
+#endif
+
+
+struct cv {
+	struct ConditionVariable condition;
+};
+
+
+void cv_init(struct cv*, const char*);
+void cv_destroy(struct cv*);
+void cv_wait(struct cv*, struct mtx*);
+int cv_timedwait(struct cv*, struct mtx*, int);
+void cv_signal(struct cv*);
+
+#endif /* _FBSD_COMPAT_SYS_CONDVAR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/conf.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/conf.h
new file mode 100644
index 0000000000..3053583c76
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/conf.h
@@ -0,0 +1 @@
+/* nothing here */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/counter.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/counter.h
new file mode 100644
index 0000000000..3f0dd04701
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/counter.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2017-2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_COUNTER_H_
+#define _FBSD_COMPAT_SYS_COUNTER_H_
+
+#include <machine/atomic.h>
+#include <sys/malloc.h>
+
+
+/* FreeBSD does not use atomics: it has a per-CPU data storage structure
+ * that it adds to whenever someone calls add(), and then only locks and
+ * coalesces it whenever fetch() is called. This means that on some
+ * architectures (e.g. x86_64), adding to the counter is one instruction.
+ *
+ * However, this seems to be for the most part overengineering, as its
+ * only uses seem to be statistical counting in semi-performance-critical paths.
+ * Axel noted in #12328 that there's a potential way to implement FreeBSD's
+ * method on Haiku using cpu_ent, but that atomics were "perfectly fine",
+ * so we will go with that for now.
+ */
+
+
+typedef uint64_t* counter_u64_t;
+
+
+static inline counter_u64_t
+counter_u64_alloc(int wait)
+{
+	return (counter_u64_t)_kernel_malloc(sizeof(uint64_t), wait | M_ZERO);
+}
+
+
+static inline void
+counter_u64_free(counter_u64_t c)
+{
+	_kernel_free(c);
+}
+
+
+static inline void
+counter_u64_add(counter_u64_t c, int64_t v)
+{
+	atomic_add64((int64*)c, v);
+}
+
+
+static inline uint64_t
+counter_u64_fetch(counter_u64_t c)
+{
+	return atomic_get64((int64*)c);
+}
+
+
+static inline void
+counter_u64_zero(counter_u64_t c)
+{
+	atomic_set64((int64*)c, 0);
+}
+
+
+static inline void
+counter_enter()
+{
+	// unneeded; counters are atomic
+}
+
+
+static inline void
+counter_exit()
+{
+	// unneeded; counters are atomic
+}
+
+
+static inline void
+counter_u64_add_protected(counter_u64_t c, int64_t v)
+{
+	// counters are atomic
+	counter_u64_add(c, v);
+}
+
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ctype.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ctype.h
new file mode 100644
index 0000000000..60cc664acf
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ctype.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_CTYPE_H_
+#define _FBSD_COMPAT_SYS_CTYPE_H_
+
+
+#define isprint(c) ((c) >= ' ' && (c) <= '~')
+
+#endif /* _FBSD_COMPAT_SYS_CTYPE_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/endian.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/endian.h
new file mode 100644
index 0000000000..6261634319
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/endian.h
@@ -0,0 +1,197 @@
+/*-
+ * Copyright (c) 2002 Thomas Moestl <tmm@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/sys/endian.h,v 1.6 2003/10/15 20:05:57 obrien Exp $
+ */
+#ifndef _FBSD_COMPAT_SYS_ENDIAN_H_
+#define _FBSD_COMPAT_SYS_ENDIAN_H_
+
+#include <stdint.h>
+#include <posix/endian.h>
+
+#include <support/ByteOrder.h>
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+#include <machine/endian.h>
+
+#define _BYTE_ORDER		BYTE_ORDER
+#define _LITTLE_ENDIAN	LITTLE_ENDIAN
+#define _BIG_ENDIAN		BIG_ENDIAN
+
+#define __bswap16(x)	__swap_int16(x)
+#define __bswap32(x)	__swap_int32(x)
+#define __bswap64(x)	__swap_int64(x)
+
+/*
+ * General byte order swapping functions.
+ */
+#define	bswap16(x)	__bswap16(x)
+#define	bswap32(x)	__bswap32(x)
+#define	bswap64(x)	__bswap64(x)
+
+/*
+ * Host to big endian, host to little endian, big endian to host, and little
+ * endian to host byte order functions as detailed in byteorder(9).
+ */
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define	htobe16(x)	bswap16((x))
+#define	htobe32(x)	bswap32((x))
+#define	htobe64(x)	bswap64((x))
+#define	htole16(x)	((uint16_t)(x))
+#define	htole32(x)	((uint32_t)(x))
+#define	htole64(x)	((uint64_t)(x))
+
+#define	be16toh(x)	bswap16((x))
+#define	be32toh(x)	bswap32((x))
+#define	be64toh(x)	bswap64((x))
+#define	le16toh(x)	((uint16_t)(x))
+#define	le32toh(x)	((uint32_t)(x))
+#define	le64toh(x)	((uint64_t)(x))
+#else /* _BYTE_ORDER != _LITTLE_ENDIAN */
+#define	htobe16(x)	((uint16_t)(x))
+#define	htobe32(x)	((uint32_t)(x))
+#define	htobe64(x)	((uint64_t)(x))
+#define	htole16(x)	bswap16((x))
+#define	htole32(x)	bswap32((x))
+#define	htole64(x)	bswap64((x))
+
+#define	be16toh(x)	((uint16_t)(x))
+#define	be32toh(x)	((uint32_t)(x))
+#define	be64toh(x)	((uint64_t)(x))
+#define	le16toh(x)	bswap16((x))
+#define	le32toh(x)	bswap32((x))
+#define	le64toh(x)	bswap64((x))
+#endif /* _BYTE_ORDER == _LITTLE_ENDIAN */
+
+/* Alignment-agnostic encode/decode bytestream to/from little/big endian. */
+
+static __inline uint16_t
+be16dec(const void *pp)
+{
+	unsigned char const *p = (unsigned char const *)pp;
+
+	return ((p[0] << 8) | p[1]);
+}
+
+static __inline uint32_t
+be32dec(const void *pp)
+{
+	unsigned char const *p = (unsigned char const *)pp;
+
+	return ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
+}
+
+static __inline uint64_t
+be64dec(const void *pp)
+{
+	unsigned char const *p = (unsigned char const *)pp;
+
+	return (((uint64_t)be32dec(p) << 32) | be32dec(p + 4));
+}
+
+static __inline uint16_t
+le16dec(const void *pp)
+{
+	unsigned char const *p = (unsigned char const *)pp;
+
+	return ((p[1] << 8) | p[0]);
+}
+
+static __inline uint32_t
+le32dec(const void *pp)
+{
+	unsigned char const *p = (unsigned char const *)pp;
+
+	return ((p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
+}
+
+static __inline uint64_t
+le64dec(const void *pp)
+{
+	unsigned char const *p = (unsigned char const *)pp;
+
+	return (((uint64_t)le32dec(p + 4) << 32) | le32dec(p));
+}
+
+static __inline void
+be16enc(void *pp, uint16_t u)
+{
+	unsigned char *p = (unsigned char *)pp;
+
+	p[0] = (u >> 8) & 0xff;
+	p[1] = u & 0xff;
+}
+
+static __inline void
+be32enc(void *pp, uint32_t u)
+{
+	unsigned char *p = (unsigned char *)pp;
+
+	p[0] = (u >> 24) & 0xff;
+	p[1] = (u >> 16) & 0xff;
+	p[2] = (u >> 8) & 0xff;
+	p[3] = u & 0xff;
+}
+
+static __inline void
+be64enc(void *pp, uint64_t u)
+{
+	unsigned char *p = (unsigned char *)pp;
+
+	be32enc(p, u >> 32);
+	be32enc(p + 4, u & 0xffffffff);
+}
+
+static __inline void
+le16enc(void *pp, uint16_t u)
+{
+	unsigned char *p = (unsigned char *)pp;
+
+	p[0] = u & 0xff;
+	p[1] = (u >> 8) & 0xff;
+}
+
+static __inline void
+le32enc(void *pp, uint32_t u)
+{
+	unsigned char *p = (unsigned char *)pp;
+
+	p[0] = u & 0xff;
+	p[1] = (u >> 8) & 0xff;
+	p[2] = (u >> 16) & 0xff;
+	p[3] = (u >> 24) & 0xff;
+}
+
+static __inline void
+le64enc(void *pp, uint64_t u)
+{
+	unsigned char *p = (unsigned char *)pp;
+
+	le32enc(p, u & 0xffffffff);
+	le32enc(p + 4, u >> 32);
+}
+
+#endif	/* _SYS_ENDIAN_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/errno.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/errno.h
new file mode 100644
index 0000000000..34b559f3f1
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/errno.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_ERRNO_H_
+#define _FBSD_COMPAT_SYS_ERRNO_H_
+
+
+#include <posix/errno.h>
+
+
+#define EDOOFUS 		EINVAL
+
+/* pseudo-errors returned inside freebsd compat layer to modify return to process */
+#define	ERESTART		(B_ERRORS_END + 1)		/* restart syscall */
+#define EJUSTRETURN		(B_ERRORS_END + 2)		/* don't modify regs, just return */
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/event.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/event.h
new file mode 100644
index 0000000000..642f49cd45
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/event.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_EVENT_H_
+#define _FBSD_COMPAT_SYS_EVENT_H_
+
+
+struct knlist {
+	int	_dummy;
+};
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/eventhandler.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/eventhandler.h
new file mode 100644
index 0000000000..9a53c98760
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/eventhandler.h
@@ -0,0 +1,176 @@
+/*-
+ * Copyright (c) 1999 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/sys/eventhandler.h,v 1.33.2.1 2006/05/16 07:27:49 ps Exp $
+ */
+#ifndef SYS_EVENTHANDLER_H
+#define SYS_EVENTHANDLER_H
+
+#include <sys/lock.h>
+#include <sys/ktr.h>
+#include <sys/mutex.h>
+#include <sys/queue.h>
+
+struct eventhandler_entry {
+	TAILQ_ENTRY(eventhandler_entry)	ee_link;
+	int				ee_priority;
+#define	EHE_DEAD_PRIORITY	(-1)
+	void				*ee_arg;
+};
+
+struct eventhandler_list {
+	char				*el_name;
+	int				el_flags;
+#define EHL_INITTED	(1<<0)
+	u_int				el_runcount;
+	struct mtx			el_lock;
+	TAILQ_ENTRY(eventhandler_list)	el_link;
+	TAILQ_HEAD(,eventhandler_entry)	el_entries;
+};
+
+typedef struct eventhandler_entry	*eventhandler_tag;
+
+#define	EHL_LOCK(p)		mtx_lock(&(p)->el_lock)
+#define	EHL_UNLOCK(p)		mtx_unlock(&(p)->el_lock)
+#define	EHL_LOCK_ASSERT(p, x)	mtx_assert(&(p)->el_lock, x)
+
+/*
+ * Macro to invoke the handlers for a given event.
+ */
+#define _EVENTHANDLER_INVOKE(name, list, ...) do {			\
+	struct eventhandler_entry *_ep;					\
+	struct eventhandler_entry_ ## name *_t;				\
+									\
+	KASSERT((list)->el_flags & EHL_INITTED,				\
+ 	   ("eventhandler_invoke: running non-inited list"));		\
+	EHL_LOCK_ASSERT((list), MA_OWNED);				\
+	(list)->el_runcount++;						\
+	KASSERT((list)->el_runcount > 0,				\
+	    ("eventhandler_invoke: runcount overflow"));		\
+	CTR0(KTR_EVH, "eventhandler_invoke(\"" __STRING(name) "\")");	\
+	TAILQ_FOREACH(_ep, &((list)->el_entries), ee_link) {		\
+		if (_ep->ee_priority != EHE_DEAD_PRIORITY) {		\
+			EHL_UNLOCK((list));				\
+			_t = (struct eventhandler_entry_ ## name *)_ep;	\
+			CTR1(KTR_EVH, "eventhandler_invoke: executing %p", \
+ 			    (void *)_t->eh_func);			\
+			_t->eh_func(_ep->ee_arg , ## __VA_ARGS__);	\
+			EHL_LOCK((list));				\
+		}							\
+	}								\
+	KASSERT((list)->el_runcount > 0,				\
+	    ("eventhandler_invoke: runcount underflow"));		\
+	(list)->el_runcount--;						\
+	if ((list)->el_runcount == 0)					\
+		eventhandler_prune_list(list);				\
+	EHL_UNLOCK((list));						\
+} while (0)
+
+/*
+ * Slow handlers are entirely dynamic; lists are created
+ * when entries are added to them, and thus have no concept of "owner",
+ *
+ * Slow handlers need to be declared, but do not need to be defined. The
+ * declaration must be in scope wherever the handler is to be invoked.
+ */
+#define EVENTHANDLER_DECLARE(name, type)				\
+struct eventhandler_entry_ ## name 					\
+{									\
+	struct eventhandler_entry	ee;				\
+	type				eh_func;			\
+};									\
+struct __hack
+
+#define EVENTHANDLER_INVOKE(name, ...)					\
+do {									\
+	struct eventhandler_list *_el;					\
+									\
+	if ((_el = eventhandler_find_list(#name)) != NULL) 		\
+		_EVENTHANDLER_INVOKE(name, _el , ## __VA_ARGS__);	\
+} while (0)
+
+#define EVENTHANDLER_REGISTER(name, func, arg, priority)		\
+	eventhandler_register(NULL, #name, func, arg, priority)
+
+#define EVENTHANDLER_DEREGISTER(name, tag) 				\
+do {									\
+	struct eventhandler_list *_el;					\
+									\
+	if ((_el = eventhandler_find_list(#name)) != NULL)		\
+		eventhandler_deregister(_el, tag);			\
+} while(0)
+	
+
+eventhandler_tag eventhandler_register(struct eventhandler_list *list, 
+	    const char *name, void *func, void *arg, int priority);
+void	eventhandler_deregister(struct eventhandler_list *list,
+	    eventhandler_tag tag);
+struct eventhandler_list *eventhandler_find_list(const char *name);
+void	eventhandler_prune_list(struct eventhandler_list *list);
+
+/*
+ * Standard system event queues.
+ */
+
+/* Generic priority levels */
+#define	EVENTHANDLER_PRI_FIRST	0
+#define	EVENTHANDLER_PRI_ANY	10000
+#define	EVENTHANDLER_PRI_LAST	20000
+
+/* Shutdown events */
+typedef void (*shutdown_fn)(void *, int);
+
+#define	SHUTDOWN_PRI_FIRST	EVENTHANDLER_PRI_FIRST
+#define	SHUTDOWN_PRI_DEFAULT	EVENTHANDLER_PRI_ANY
+#define	SHUTDOWN_PRI_LAST	EVENTHANDLER_PRI_LAST
+
+EVENTHANDLER_DECLARE(shutdown_pre_sync, shutdown_fn);	/* before fs sync */
+EVENTHANDLER_DECLARE(shutdown_post_sync, shutdown_fn);	/* after fs sync */
+EVENTHANDLER_DECLARE(shutdown_final, shutdown_fn);
+
+/* Low memory event */
+typedef void (*vm_lowmem_handler_t)(void *, int);
+#define	LOWMEM_PRI_DEFAULT	EVENTHANDLER_PRI_FIRST
+EVENTHANDLER_DECLARE(vm_lowmem, vm_lowmem_handler_t);
+
+/*
+ * Process events
+ * process_fork and exit handlers are called without Giant.
+ * exec handlers are called with Giant, but that is by accident.
+ */
+struct proc;
+
+typedef void (*exitlist_fn)(void *, struct proc *);
+typedef void (*forklist_fn)(void *, struct proc *, struct proc *, int);
+typedef void (*execlist_fn)(void *, struct proc *);
+
+EVENTHANDLER_DECLARE(process_exit, exitlist_fn);
+EVENTHANDLER_DECLARE(process_fork, forklist_fn);
+EVENTHANDLER_DECLARE(process_exec, execlist_fn);
+
+typedef void (*uma_zone_chfn)(void *);
+EVENTHANDLER_DECLARE(nmbclusters_change, uma_zone_chfn);
+EVENTHANDLER_DECLARE(maxsockets_change, uma_zone_chfn);
+#endif /* SYS_EVENTHANDLER_H */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/firmware.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/firmware.h
new file mode 100644
index 0000000000..bfc52b26b1
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/firmware.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_FIRMWARE_H_
+#define _FBSD_COMPAT_SYS_FIRMWARE_H_
+
+
+#define FIRMWARE_UNLOAD 0x0001
+
+
+struct firmware {
+	const char*		name;		// system-wide name
+	const void*		data;		// location of image
+	size_t			datasize;	// size of image in bytes
+	unsigned int	version;	// version of the image
+};
+
+
+const struct firmware* firmware_get(const char*);
+void firmware_put(const struct firmware*, int);
+
+#endif /* _FBSD_COMPAT_SYS_FIRMWARE_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/haiku-module.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/haiku-module.h
new file mode 100644
index 0000000000..ef28192c2a
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/haiku-module.h
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2009, Colin Gnther. All Rights Reserved.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_HAIKU_MODULE_H_
+#define _FBSD_COMPAT_SYS_HAIKU_MODULE_H_
+
+
+#include <Drivers.h>
+#include <KernelExport.h>
+
+#include <kernel/lock.h>
+#include <sys/method-ids.h>
+
+#undef __unused
+#define __unused
+
+#undef ASSERT
+	/* private/kernel/debug.h sets it */
+
+typedef struct device *device_t;
+typedef struct devclass *devclass_t;
+
+typedef int (*device_method_signature_t)(device_t dev);
+
+typedef int device_probe_t(device_t dev);
+typedef int device_attach_t(device_t dev);
+typedef int device_detach_t(device_t dev);
+typedef int device_resume_t(device_t dev);
+typedef int device_shutdown_t(device_t dev);
+typedef int device_suspend_t(device_t dev);
+
+typedef int bus_child_location_str_t(device_t dev __unused, device_t child,
+	char *buf, size_t buflen);
+typedef int bus_child_pnpinfo_str_t(device_t dev __unused, device_t child,
+	char *buf, size_t buflen);
+typedef void bus_hinted_child_t(device_t dev, const char *name, int unit);
+typedef int bus_print_child_t(device_t dev, device_t child);
+typedef int bus_read_ivar_t(device_t dev, device_t child __unused, int which,
+    uintptr_t *result);
+
+typedef int miibus_readreg_t(device_t dev, int phy, int reg);
+typedef int miibus_writereg_t(device_t dev, int phy, int reg, int data);
+typedef void miibus_statchg_t(device_t dev);
+typedef void miibus_linkchg_t(device_t dev);
+typedef void miibus_mediainit_t(device_t dev);
+
+
+struct device_method {
+	const char* name;
+	const int32 id;
+		/* interfaces w/o function pointer structs use IDs for method lookups */
+	device_method_signature_t method;
+};
+
+typedef struct device_method device_method_t;
+
+#define DEVMETHOD(name, func) { #name, ID_##name, (device_method_signature_t)&func }
+#define DEVMETHOD_END 		  { 0, 0 }
+
+
+typedef struct {
+	const char* name;
+	device_method_t* methods;
+	size_t size; /* softc size */
+} driver_t;
+
+#define DEFINE_CLASS_0(name, driver, methods, size) \
+	driver_t driver = { #name, methods, size }
+
+#define DRIVER_MODULE(name, busname, driver, devclass, evh, arg) \
+	driver_t *DRIVER_MODULE_NAME(name, busname) = &(driver); \
+	devclass_t *__class_ ## name ## _ ## busname ## _ ## devclass = &(devclass)
+
+#define DRIVER_MODULE_ORDERED(name, busname, driver, devclass, evh, arg, order) \
+	DRIVER_MODULE(name, busname, driver, devclass, evh, arg)
+
+#define DRIVER_MODULE_NAME(name, busname) \
+	__fbsd_ ## name ## _ ## busname
+
+
+status_t _fbsd_init_hardware(driver_t *driver[]);
+status_t _fbsd_init_drivers(driver_t *driver[]);
+status_t _fbsd_uninit_drivers(driver_t *driver[]);
+
+extern const char *gDriverName;
+driver_t *__haiku_select_miibus_driver(device_t dev);
+driver_t *__haiku_probe_miibus(device_t dev, driver_t *drivers[]);
+status_t __haiku_handle_fbsd_drivers_list(status_t (*handler)(driver_t *[]));
+
+status_t init_wlan_stack(void);
+void uninit_wlan_stack(void);
+status_t start_wlan(device_t);
+status_t stop_wlan(device_t);
+status_t wlan_control(void*, uint32, void*, size_t);
+status_t wlan_close(void*);
+
+/* we define the driver methods with HAIKU_FBSD_DRIVERS_GLUE to
+ * force the rest of the stuff to be linked back with the driver.
+ * While gcc 2.95 packs everything from the static library onto
+ * the final binary, gcc 4.x rightfuly doesn't. */
+
+#define HAIKU_FBSD_DRIVERS_CORE_GLUE(publicname)						\
+	extern const char *gDeviceNameList[];								\
+	extern device_hooks gDeviceHooks;									\
+	const char *gDriverName = #publicname;								\
+	int32 api_version = B_CUR_DRIVER_API_VERSION;						\
+	status_t init_hardware()											\
+	{																	\
+		return __haiku_handle_fbsd_drivers_list(_fbsd_init_hardware);	\
+	}																	\
+	status_t init_driver()												\
+	{																	\
+		return __haiku_handle_fbsd_drivers_list(_fbsd_init_drivers);	\
+	}																	\
+	void uninit_driver()												\
+	{																	\
+		__haiku_handle_fbsd_drivers_list(_fbsd_uninit_drivers);			\
+	}																	\
+	const char **publish_devices()										\
+		{ return gDeviceNameList; }										\
+	device_hooks *find_device(const char *name)							\
+		{ return &gDeviceHooks; }
+
+#define HAIKU_FBSD_DRIVERS_GLUE(publicname)								\
+	HAIKU_FBSD_DRIVERS_CORE_GLUE(publicname)							\
+	status_t init_wlan_stack(void)										\
+		{ return B_OK; } 												\
+	void uninit_wlan_stack(void) {}										\
+	status_t start_wlan(device_t dev)									\
+		{ return B_OK; }												\
+	status_t stop_wlan(device_t dev)									\
+		{ return B_OK; }												\
+	status_t wlan_control(void *cookie, uint32 op, void *arg, 			\
+		size_t length)													\
+		{ return B_BAD_VALUE; }											\
+	status_t wlan_close(void* cookie)									\
+		{ return B_OK; }
+
+#define HAIKU_FBSD_DRIVER_GLUE(publicname, name, busname)				\
+	extern driver_t* DRIVER_MODULE_NAME(name, busname);					\
+	status_t __haiku_handle_fbsd_drivers_list(status_t (*proc)(driver_t *[])) {\
+		driver_t *drivers[] = {											\
+			DRIVER_MODULE_NAME(name, busname),							\
+			NULL														\
+		};																\
+		return (*proc)(drivers);										\
+	}																	\
+	HAIKU_FBSD_DRIVERS_GLUE(publicname);
+
+#define HAIKU_FBSD_WLAN_DRIVERS_GLUE(publicname)						\
+	HAIKU_FBSD_DRIVERS_CORE_GLUE(publicname)
+
+#define HAIKU_FBSD_WLAN_DRIVER_GLUE(publicname, name, busname)			\
+	extern driver_t *DRIVER_MODULE_NAME(name, busname);					\
+	status_t __haiku_handle_fbsd_drivers_list(status_t (*proc)(driver_t *[])) {\
+		driver_t *drivers[] = {											\
+			DRIVER_MODULE_NAME(name, busname),							\
+			NULL														\
+		};																\
+		return (*proc)(drivers);										\
+	}																	\
+	HAIKU_FBSD_WLAN_DRIVERS_GLUE(publicname);
+
+#define HAIKU_FBSD_RETURN_MII_DRIVER(drivers)					\
+	driver_t *__haiku_select_miibus_driver(device_t dev)		\
+	{															\
+		return __haiku_probe_miibus(dev, drivers);				\
+	}
+
+#define HAIKU_FBSD_MII_DRIVER(name)								\
+	extern driver_t *DRIVER_MODULE_NAME(name, miibus);			\
+	driver_t *__haiku_select_miibus_driver(device_t dev)		\
+	{															\
+		driver_t *drivers[] = {									\
+			DRIVER_MODULE_NAME(name, miibus),					\
+			NULL												\
+		};														\
+		return __haiku_probe_miibus(dev, drivers);				\
+	}
+
+#define NO_HAIKU_FBSD_MII_DRIVER()								\
+	HAIKU_FBSD_RETURN_MII_DRIVER(NULL)
+
+extern spinlock __haiku_intr_spinlock;
+extern int __haiku_disable_interrupts(device_t dev);
+extern void __haiku_reenable_interrupts(device_t dev);
+
+#define HAIKU_CHECK_DISABLE_INTERRUPTS		__haiku_disable_interrupts
+#define HAIKU_REENABLE_INTERRUPTS			__haiku_reenable_interrupts
+
+#define NO_HAIKU_CHECK_DISABLE_INTERRUPTS()				\
+	int HAIKU_CHECK_DISABLE_INTERRUPTS(device_t dev) {	\
+		panic("should never be called.");				\
+		return -1; \
+	}
+
+#define NO_HAIKU_REENABLE_INTERRUPTS() \
+	void HAIKU_REENABLE_INTERRUPTS(device_t dev) {}
+
+extern int __haiku_driver_requirements;
+
+enum {
+	FBSD_TASKQUEUES			= 1 << 0,
+	FBSD_FAST_TASKQUEUE		= 1 << 1,
+	FBSD_SWI_TASKQUEUE		= 1 << 2,
+	FBSD_THREAD_TASKQUEUE	= 1 << 3,
+	FBSD_WLAN_FEATURE		= 1 << 4,
+	FBSD_WLAN				= FBSD_WLAN_FEATURE | FBSD_TASKQUEUES
+								| FBSD_THREAD_TASKQUEUE,
+};
+
+#define HAIKU_DRIVER_REQUIREMENTS(flags) \
+	int __haiku_driver_requirements = (flags)
+
+#define HAIKU_DRIVER_REQUIRES(flag) (__haiku_driver_requirements & (flag))
+
+
+/* #pragma mark - firmware loading */
+
+
+/*
+ * Only needed to be specified in the glue code of drivers which actually need
+ * to load firmware. See iprowifi2100 for an example.
+ */
+
+extern const uint __haiku_firmware_version;
+
+/* Use 0 if driver doesn't care about firmware version. */
+#define HAIKU_FIRMWARE_VERSION(version) \
+	const uint __haiku_firmware_version = (version)
+
+extern const uint __haiku_firmware_parts_count;
+extern const char* __haiku_firmware_name_map[][2];
+
+/*
+ * Provide a firmware name mapping as a multi-dimentional const char* array.
+ *
+ * HAIKU_FIRMWARE_NAME_MAP({
+ *   {"name-used-by-driver", "actual-name-of-firmware-file-on-disk"},
+ *   ...
+ * });
+ */
+#define HAIKU_FIRMWARE_NAME_MAP(...) \
+	const char* __haiku_firmware_name_map[][2] = __VA_ARGS__; \
+	const uint __haiku_firmware_parts_count = B_COUNT_OF(__haiku_firmware_name_map)
+
+#define NO_HAIKU_FIRMWARE_NAME_MAP() \
+	const uint __haiku_firmware_parts_count = 0; \
+	const char* __haiku_firmware_name_map[0][2] = {}
+
+
+/* #pragma mark - synchronization */
+
+
+#define HAIKU_INTR_REGISTER_STATE \
+	cpu_status __haiku_cpu_state = 0
+
+#define HAIKU_INTR_REGISTER_ENTER() do {		\
+	__haiku_cpu_state = disable_interrupts();	\
+	acquire_spinlock(&__haiku_intr_spinlock);	\
+} while (0)
+
+#define HAIKU_INTR_REGISTER_LEAVE() do {		\
+	release_spinlock(&__haiku_intr_spinlock);	\
+	restore_interrupts(__haiku_cpu_state);		\
+} while (0)
+
+#define HAIKU_PROTECT_INTR_REGISTER(x) do {		\
+	HAIKU_INTR_REGISTER_STATE;					\
+	HAIKU_INTR_REGISTER_ENTER();				\
+	x;											\
+	HAIKU_INTR_REGISTER_LEAVE();				\
+} while (0)
+
+#define nitems(_a)     (sizeof((_a)) / sizeof((_a)[0]))
+
+#endif	/* _FBSD_COMPAT_SYS_HAIKU_MODULE_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ioccom.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ioccom.h
new file mode 100644
index 0000000000..f6ba2deb2d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ioccom.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_IOCCOM_H_
+#define _FBSD_COMPAT_SYS_IOCCOM_H_
+
+
+#define	_IOW(g,n,t)		SIOCEND + n
+#define	_IOWR(g,n,t)	SIOCEND + n
+
+#endif /* _FBSD_COMPAT_SYS_IOCCOM_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kdb.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kdb.h
new file mode 100644
index 0000000000..3053583c76
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kdb.h
@@ -0,0 +1 @@
+/* nothing here */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kernel.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kernel.h
new file mode 100644
index 0000000000..cc10cce69c
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kernel.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2007-2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_KERNEL_H_
+#define _FBSD_COMPAT_SYS_KERNEL_H_
+
+
+#include <stddef.h>
+
+#include <sys/haiku-module.h>
+
+#include <sys/linker_set.h>
+#include <sys/queue.h>
+
+
+/* The rate at which FreeBSD can generate callouts (kind of timeout mechanism).
+ * For FreeBSD 8 this is typically 1000 times per second (100 for ARM).
+ * This value is defined in a file called subr_param.c
+ *
+ * While Haiku can have a much higher granularity, it is not a good idea to have
+ * this since FreeBSD tries to do certain tasks based on ticks, for instance
+ * autonegotiation and wlan scanning.
+ * Suffixing LL prevents integer overflows during calculations.
+ * as it defines a long long constant. */
+#define hz	1000LL
+
+int32_t _get_ticks();
+#define ticks (_get_ticks())
+
+
+/* sysinit */
+enum sysinit_elem_order {
+	SI_ORDER_FIRST = 0x0000000,
+	SI_ORDER_SECOND = 0x0000001,
+	SI_ORDER_THIRD = 0x0000002,
+	SI_ORDER_FOURTH = 0x0000003,
+	SI_ORDER_MIDDLE = 0x1000000,
+	SI_ORDER_ANY = 0xfffffff	/* last */
+};
+
+typedef void (*system_init_func_t)(void *);
+
+struct sysinit {
+	const char* name;
+	enum sysinit_elem_order order;
+	system_init_func_t func;
+	const void* arg;
+};
+
+#define SYSINIT(uniquifier, subsystem, _order, _func, ident) \
+static struct sysinit sysinit_##uniquifier = { \
+	.name 		= #uniquifier,		\
+	.order 		= _order,			\
+	.func		= _func,			\
+	.arg		= ident,			\
+};									\
+DATA_SET(__freebsd_sysinit, sysinit_##uniquifier)
+
+#define SYSUNINIT(uniquifier, subsystem, _order, _func, ident) \
+static struct sysinit sysuninit_##uniquifier = { \
+	.name 		= #uniquifier,		\
+	.order 		= _order,			\
+	.func		= _func,			\
+	.arg		= ident,			\
+};									\
+DATA_SET(__freebsd_sysuninit, sysuninit_##uniquifier)
+
+
+/* confighooks */
+typedef void (*ich_func_t)(void *_arg);
+
+struct intr_config_hook {
+	TAILQ_ENTRY(intr_config_hook) ich_links;
+	ich_func_t	ich_func;
+	void		*ich_arg;
+};
+
+int config_intrhook_establish(struct intr_config_hook *hook);
+void config_intrhook_disestablish(struct intr_config_hook *hook);
+
+
+/* misc. */
+#define TUNABLE_INT(path, var)
+#define TUNABLE_INT_FETCH(path, var)
+
+
+#endif // _FBSD_COMPAT_SYS_KERNEL_H_
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kthread.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kthread.h
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/kthread.h
@@ -0,0 +1 @@
+
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ktr.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ktr.h
new file mode 100644
index 0000000000..2e817a74c8
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/ktr.h
@@ -0,0 +1,196 @@
+/*-
+ * Copyright (c) 1996 Berkeley Software Design, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Berkeley Software Design Inc's name may not be used to endorse or
+ *    promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN INC ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN INC BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	from BSDI $Id: ktr.h,v 1.10.2.7 2000/03/16 21:44:42 cp Exp $
+ * $FreeBSD: src/sys/sys/ktr.h,v 1.32.2.2 2006/01/23 14:56:33 marius Exp $
+ */
+
+/*
+ *	Wraparound kernel trace buffer support.
+ */
+#ifndef _SYS_KTR_H_
+#define _SYS_KTR_H_
+
+/*
+ * Trace classes
+ */
+#define	KTR_GEN		0x00000001		/* General (TR) */
+#define	KTR_NET		0x00000002		/* Network */
+#define	KTR_DEV		0x00000004		/* Device driver */
+#define	KTR_LOCK	0x00000008		/* MP locking */
+#define	KTR_SMP		0x00000010		/* MP general */
+#define	KTR_FS		0x00000020		/* Filesystem */
+#define KTR_PMAP	0x00000040		/* Pmap tracing */
+#define KTR_MALLOC	0x00000080		/* Malloc tracing */
+#define	KTR_TRAP	0x00000100		/* Trap processing */
+#define	KTR_INTR	0x00000200		/* Interrupt tracing */
+#define KTR_SIG		0x00000400		/* Signal processing */
+#define	KTR_CLK		0x00000800		/* hardclock verbose */
+#define	KTR_PROC	0x00001000		/* Process scheduling */
+#define	KTR_SYSC	0x00002000		/* System call */
+#define	KTR_INIT	0x00004000		/* System initialization */
+#define KTR_KGDB	0x00008000		/* Trace kgdb internals */
+#define	KTR_IO		0x00010000		/* Upper I/O  */
+#define	KTR_EVH		0x00020000		/* Eventhandler */
+#define KTR_VFS		0x00040000		/* VFS events */
+#define KTR_VOP		0x00080000		/* Auto-generated vop events */
+#define KTR_VM		0x00100000		/* The virtual memory system */
+#define KTR_WITNESS	0x00200000
+#define	KTR_RUNQ	0x00400000		/* Run queue */
+#define	KTR_CONTENTION	0x00800000		/* Lock contention */
+#define	KTR_UMA		0x01000000		/* UMA slab allocator */
+#define	KTR_CALLOUT	0x02000000		/* Callouts and timeouts */
+#define	KTR_GEOM	0x04000000		/* GEOM I/O events */
+#define	KTR_BUSDMA	0x08000000		/* busdma(9) events */
+#define	KTR_CRITICAL	0x10000000		/* Critical sections */
+#define	KTR_SCHED	0x20000000		/* Machine parsed sched info. */
+#define	KTR_BUF		0x40000000		/* Buffer cache */
+#define	KTR_ALL		0x7fffffff
+
+/*
+ * Trace classes which can be assigned to particular use at compile time
+ * These must remain in high 22 as some assembly code counts on it
+ */
+#define KTR_CT1		0x01000000
+#define KTR_CT2		0x02000000
+#define KTR_CT3		0x04000000
+#define KTR_CT4		0x08000000
+#define KTR_CT5		0x10000000
+#define KTR_CT6		0x20000000
+#define KTR_CT7		0x40000000
+#define KTR_CT8		0x80000000
+
+/* Trace classes to compile in */
+#ifdef KTR
+#ifndef KTR_COMPILE
+#define	KTR_COMPILE	(KTR_ALL)
+#endif
+#else	/* !KTR */
+#undef KTR_COMPILE
+#define KTR_COMPILE 0
+#endif	/* KTR */
+
+/* Trace classes that can not be used with KTR_ALQ */
+#define	KTR_ALQ_MASK	(KTR_WITNESS)
+
+/*
+ * Version number for ktr_entry struct.  Increment this when you break binary
+ * compatibility.
+ */
+#define	KTR_VERSION	2
+
+#define	KTR_PARMS	6
+
+#ifndef LOCORE
+
+struct ktr_entry {
+	u_int64_t ktr_timestamp;
+	int	ktr_cpu;
+	int	ktr_line;
+	const	char *ktr_file;
+	const	char *ktr_desc;
+	struct	thread *ktr_thread;
+	u_long	ktr_parms[KTR_PARMS];
+};
+
+extern int ktr_cpumask;
+extern int ktr_mask;
+extern int ktr_entries;
+extern int ktr_verbose;
+
+extern volatile int ktr_idx;
+extern struct ktr_entry ktr_buf[];
+
+#ifdef KTR
+
+#if 0
+void	ktr_tracepoint(u_int mask, const char *file, int line,
+	    const char *format, u_long arg1, u_long arg2, u_long arg3,
+	    u_long arg4, u_long arg5, u_long arg6);
+#else
+extern void driver_printf(const char *format, ...);
+#define ktr_tracepoint(mask, file, line, format, arg1, arg2, arg3, arg4, arg5, arg6) \
+	driver_printf("(%s:%i) " format "\n", file, line, arg1, arg2, arg3, arg4, arg5, arg6)
+#endif
+
+#define CTR6(m, format, p1, p2, p3, p4, p5, p6) do {			\
+	if (KTR_COMPILE & (m))						\
+		ktr_tracepoint((m), __FILE__, __LINE__, format,		\
+		    (u_long)(p1), (u_long)(p2), (u_long)(p3),		\
+		    (u_long)(p4), (u_long)(p5), (u_long)(p6));		\
+	} while(0)
+#define CTR0(m, format)			CTR6(m, format, 0, 0, 0, 0, 0, 0)
+#define CTR1(m, format, p1)		CTR6(m, format, p1, 0, 0, 0, 0, 0)
+#define	CTR2(m, format, p1, p2)		CTR6(m, format, p1, p2, 0, 0, 0, 0)
+#define	CTR3(m, format, p1, p2, p3)	CTR6(m, format, p1, p2, p3, 0, 0, 0)
+#define	CTR4(m, format, p1, p2, p3, p4)	CTR6(m, format, p1, p2, p3, p4, 0, 0)
+#define	CTR5(m, format, p1, p2, p3, p4, p5)	CTR6(m, format, p1, p2, p3, p4, p5, 0)
+#else	/* KTR */
+#define	CTR0(m, d)
+#define	CTR1(m, d, p1)
+#define	CTR2(m, d, p1, p2)
+#define	CTR3(m, d, p1, p2, p3)
+#define	CTR4(m, d, p1, p2, p3, p4)
+#define	CTR5(m, d, p1, p2, p3, p4, p5)
+#define	CTR6(m, d, p1, p2, p3, p4, p5, p6)
+#endif	/* KTR */
+
+#define	TR0(d)				CTR0(KTR_GEN, d)
+#define	TR1(d, p1)			CTR1(KTR_GEN, d, p1)
+#define	TR2(d, p1, p2)			CTR2(KTR_GEN, d, p1, p2)
+#define	TR3(d, p1, p2, p3)		CTR3(KTR_GEN, d, p1, p2, p3)
+#define	TR4(d, p1, p2, p3, p4)		CTR4(KTR_GEN, d, p1, p2, p3, p4)
+#define	TR5(d, p1, p2, p3, p4, p5)	CTR5(KTR_GEN, d, p1, p2, p3, p4, p5)
+#define	TR6(d, p1, p2, p3, p4, p5, p6)	CTR6(KTR_GEN, d, p1, p2, p3, p4, p5, p6)
+
+/*
+ * Trace initialization events, similar to CTR with KTR_INIT, but
+ * completely ifdef'ed out if KTR_INIT isn't in KTR_COMPILE (to
+ * save string space, the compiler doesn't optimize out strings
+ * for the conditional ones above).
+ */
+#if (KTR_COMPILE & KTR_INIT) != 0
+#define	ITR0(d)				CTR0(KTR_INIT, d)
+#define	ITR1(d, p1)			CTR1(KTR_INIT, d, p1)
+#define	ITR2(d, p1, p2)			CTR2(KTR_INIT, d, p1, p2)
+#define	ITR3(d, p1, p2, p3)		CTR3(KTR_INIT, d, p1, p2, p3)
+#define	ITR4(d, p1, p2, p3, p4)		CTR4(KTR_INIT, d, p1, p2, p3, p4)
+#define	ITR5(d, p1, p2, p3, p4, p5)	CTR5(KTR_INIT, d, p1, p2, p3, p4, p5)
+#define	ITR6(d, p1, p2, p3, p4, p5, p6)	CTR6(KTR_INIT, d, p1, p2, p3, p4, p5, p6)
+#else
+#define	ITR0(d)
+#define	ITR1(d, p1)
+#define	ITR2(d, p1, p2)
+#define	ITR3(d, p1, p2, p3)
+#define	ITR4(d, p1, p2, p3, p4)
+#define	ITR5(d, p1, p2, p3, p4, p5)
+#define	ITR6(d, p1, p2, p3, p4, p5, p6)
+#endif
+
+#endif /* !LOCORE */
+
+#endif /* !_SYS_KTR_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/libkern.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/libkern.h
new file mode 100644
index 0000000000..784f3abede
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/libkern.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_LIBKERN_H_
+#define _FBSD_COMPAT_SYS_LIBKERN_H_
+
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+extern int random(void);
+u_int read_random(void *, u_int);
+void arc4rand(void *ptr, u_int len, int reseed);
+uint32_t arc4random(void);
+
+static __inline int imax(int a, int b) { return (a > b ? a : b); }
+static __inline int imin(int a, int b) { return (a < b ? a : b); }
+
+extern int abs(int a);
+
+#endif /* _FBSD_COMPAT_SYS_LIBKERN_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/limits.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/limits.h
new file mode 100644
index 0000000000..492074debb
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/limits.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_LIMITS_H_
+#define _FBSD_COMPAT_SYS_LIMITS_H_
+
+
+#endif /* _FBSD_COMPAT_SYS_LIMITS_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker.h
new file mode 100644
index 0000000000..52cd150ece
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_LINKER_H_
+#define _FBSD_COMPAT_SYS_LINKER_H_
+
+
+#endif /* _FBSD_COMPAT_SYS_LINKER_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker_set.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker_set.h
new file mode 100644
index 0000000000..135d4c3e99
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/linker_set.h
@@ -0,0 +1,88 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 1999 John D. Polstra
+ * Copyright (c) 1999,2001 Peter Wemm <peter@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#ifndef _FBSD_COMPAT_SYS_LINKER_SET_H_
+#define _FBSD_COMPAT_SYS_LINKER_SET_H_
+
+
+#ifndef _FBSD_COMPAT_SYS_CDEFS_H_
+#error this file needs sys/cdefs.h as a prerequisite
+#endif
+
+/*
+ * The following macros are used to declare global sets of objects, which
+ * are collected by the linker into a `linker_set' as defined below.
+ * For ELF, this is done by constructing a separate segment for each set.
+ */
+
+/*
+ * Private macros, not to be used outside this header file.
+ */
+#ifdef __GNUCLIKE___SECTION
+#define __MAKE_SET(set, sym)						\
+	static void const * const __set_##set##_sym_##sym 		\
+	__section("set_" #set) __used = &sym
+#else /* !__GNUCLIKE___SECTION */
+#ifndef lint
+#error this file needs to be ported to your compiler
+#endif /* lint */
+#define __MAKE_SET(set, sym)	extern void const * const (__set_##set##_sym_##sym)
+#endif /* __GNUCLIKE___SECTION */
+
+/*
+ * Public macros.
+ */
+#define TEXT_SET(set, sym)	__MAKE_SET(set, sym)
+#define DATA_SET(set, sym)	__MAKE_SET(set, sym)
+#define BSS_SET(set, sym)	__MAKE_SET(set, sym)
+#define ABS_SET(set, sym)	__MAKE_SET(set, sym)
+#define SET_ENTRY(set, sym)	__MAKE_SET(set, sym)
+
+/*
+ * Initialize before referring to a given linker set.
+ */
+#define SET_DECLARE(set, ptype)						\
+	extern ptype *__CONCAT(__start_set_,set);			\
+	extern ptype *__CONCAT(__stop_set_,set)
+
+#define SET_BEGIN(set)							\
+	(&__CONCAT(__start_set_,set))
+#define SET_LIMIT(set)							\
+	(&__CONCAT(__stop_set_,set))
+
+/*
+ * Iterate over all the elements of a set.
+ *
+ * Sets always contain addresses of things, and "pvar" points to words
+ * containing those addresses.  Thus is must be declared as "type **pvar",
+ * and the address of each set item is obtained inside the loop by "*pvar".
+ */
+#define SET_FOREACH(pvar, set)						\
+	for (pvar = SET_BEGIN(set); pvar < SET_LIMIT(set); pvar++)
+
+#endif /* _FBSD_COMPAT_SYS_LINKER_SET_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/lock.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/lock.h
new file mode 100644
index 0000000000..c0b21fa0e2
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/lock.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_LOCK_H_
+#define _FBSD_COMPAT_SYS_LOCK_H_
+
+
+#define MPASS(ex)				MPASS4(ex, #ex, __FILE__, __LINE__)
+#define MPASS2(ex, what)		MPASS4(ex, what, __FILE__, __LINE__)
+#define MPASS3(ex, file, line)	MPASS4(ex, #ex, file, line)
+#define MPASS4(ex, what, file, line)					\
+	KASSERT((ex), ("assert %s failed at %s:%d", what, file, line))
+
+
+#endif /* _FBSD_COMPAT_SYS_LOCK_H_ */
\ No newline at end of file
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/malloc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/malloc.h
new file mode 100644
index 0000000000..7d211a758a
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/malloc.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_MALLOC_H_
+#define _FBSD_COMPAT_SYS_MALLOC_H_
+
+
+#include <malloc.h>
+
+#include <vm/vm.h>
+
+#include <sys/param.h>
+#include <sys/queue.h>
+#include <sys/_mutex.h>
+
+
+/*
+ * flags to malloc.
+ */
+#define M_NOWAIT		0x0001
+#define M_WAITOK		0x0002
+#define M_ZERO			0x0100
+
+#define	M_MAGIC			877983977	/* time when first defined :-) */
+
+#define M_DEVBUF		0
+
+
+struct malloc_type {
+};
+
+
+void *_kernel_malloc(size_t size, int flags);
+void _kernel_free(void *ptr);
+
+void *_kernel_contigmalloc(const char *file, int line, size_t size, int flags,
+	vm_paddr_t low, vm_paddr_t high, unsigned long alignment,
+	unsigned long boundary);
+void _kernel_contigfree(void *addr, unsigned long size);
+
+#define kernel_malloc(size, base, flags) \
+	_kernel_malloc(size, flags)
+
+#define kernel_free(ptr, base) \
+	_kernel_free(ptr)
+
+#define kernel_contigmalloc(size, type, flags, low, high, alignment, boundary) \
+	_kernel_contigmalloc(__FILE__, __LINE__, size, flags, low, high, \
+		alignment, boundary)
+
+#define kernel_contigfree(addr, size, base) \
+	_kernel_contigfree(addr, size)
+
+#ifdef FBSD_DRIVER
+#	define malloc(size, tag, flags)	kernel_malloc(size, tag, flags)
+#	define free(pointer, tag)		kernel_free(pointer, tag)
+#	define contigmalloc(size, type, flags, low, high, alignment, boundary) \
+		_kernel_contigmalloc(__FILE__, __LINE__, size, flags, low, high, \
+			alignment, boundary)
+#	define contigfree(addr, size, base) \
+		_kernel_contigfree(addr, size)
+#endif
+
+#define	MALLOC_DEFINE(type, shortdesc, longdesc)	int type[1]
+
+#define	MALLOC_DECLARE(type) \
+		extern int type[1]
+
+#endif	/* _FBSD_COMPAT_SYS_MALLOC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf-fbsd.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf-fbsd.h
new file mode 100644
index 0000000000..c970bd3ed1
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf-fbsd.h
@@ -0,0 +1,324 @@
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#ifndef _FBSD_COMPAT_SYS_MBUF_FBSD_H_
+#define _FBSD_COMPAT_SYS_MBUF_FBSD_H_
+
+/*
+ * Return the address of the start of the buffer associated with an mbuf,
+ * handling external storage, packet-header mbufs, and regular data mbufs.
+ */
+#define	M_START(m)							\
+	(((m)->m_flags & M_EXT) ? (m)->m_ext.ext_buf :			\
+	 ((m)->m_flags & M_PKTHDR) ? &(m)->m_pktdat[0] :		\
+	 &(m)->m_dat[0])
+
+/*
+ * Return the size of the buffer associated with an mbuf, handling external
+ * storage, packet-header mbufs, and regular data mbufs.
+ */
+#define	M_SIZE(m)							\
+	(((m)->m_flags & M_EXT) ? (m)->m_ext.ext_size :			\
+	 ((m)->m_flags & M_PKTHDR) ? MHLEN :				\
+	 MLEN)
+
+/*
+ * Set the m_data pointer of a newly allocated mbuf to place an object of the
+ * specified size at the end of the mbuf, longword aligned.
+ *
+ * NB: Historically, we had M_ALIGN(), MH_ALIGN(), and MEXT_ALIGN() as
+ * separate macros, each asserting that it was called at the proper moment.
+ * This required callers to themselves test the storage type and call the
+ * right one.  Rather than require callers to be aware of those layout
+ * decisions, we centralize here.
+ */
+static __inline void
+m_align(struct mbuf *m, int len)
+{
+#ifdef INVARIANTS
+	const char *msg = "%s: not a virgin mbuf";
+#endif
+	int adjust;
+
+	KASSERT(m->m_data == M_START(m), (msg, __func__));
+
+	adjust = M_SIZE(m) - len;
+	m->m_data += adjust &~ (sizeof(long)-1);
+}
+
+#define	M_ALIGN(m, len)		m_align(m, len)
+#define	MH_ALIGN(m, len)	m_align(m, len)
+#define	MEXT_ALIGN(m, len)	m_align(m, len)
+
+/*
+ * Evaluate TRUE if it's safe to write to the mbuf m's data region (this can
+ * be both the local data payload, or an external buffer area, depending on
+ * whether M_EXT is set).
+ */
+#define	M_WRITABLE(m)	(!((m)->m_flags & M_RDONLY) &&			\
+			 (!(((m)->m_flags & M_EXT)) ||			\
+			 (m_extrefcnt(m) == 1)))
+
+/*
+ * Compute the amount of space available before the current start of data in
+ * an mbuf.
+ *
+ * The M_WRITABLE() is a temporary, conservative safety measure: the burden
+ * of checking writability of the mbuf data area rests solely with the caller.
+ *
+ * NB: In previous versions, M_LEADINGSPACE() would only check M_WRITABLE()
+ * for mbufs with external storage.  We now allow mbuf-embedded data to be
+ * read-only as well.
+ */
+#define	M_LEADINGSPACE(m)						\
+	(M_WRITABLE(m) ? ((m)->m_data - M_START(m)) : 0)
+
+/*
+ * Compute the amount of space available after the end of data in an mbuf.
+ *
+ * The M_WRITABLE() is a temporary, conservative safety measure: the burden
+ * of checking writability of the mbuf data area rests solely with the caller.
+ *
+ * NB: In previous versions, M_TRAILINGSPACE() would only check M_WRITABLE()
+ * for mbufs with external storage.  We now allow mbuf-embedded data to be
+ * read-only as well.
+ */
+#define	M_TRAILINGSPACE(m)						\
+	(M_WRITABLE(m) ?						\
+		((M_START(m) + M_SIZE(m)) - ((m)->m_data + (m)->m_len)) : 0)
+
+/*
+ * Arrange to prepend space of size plen to mbuf m.
+ * If a new mbuf must be allocated, how specifies whether to wait.
+ * If the allocation fails, the original mbuf chain is freed and m is
+ * set to NULL.
+ */
+#define	M_PREPEND(m, plen, how) do {					\
+	struct mbuf **_mmp = &(m);					\
+	struct mbuf *_mm = *_mmp;					\
+	int _mplen = (plen);						\
+	int __mhow = (how);						\
+									\
+	MBUF_CHECKSLEEP(how);						\
+	if (M_LEADINGSPACE(_mm) >= _mplen) {				\
+		_mm->m_data -= _mplen;					\
+		_mm->m_len += _mplen;					\
+	} else								\
+		_mm = m_prepend(_mm, _mplen, __mhow);			\
+	if (_mm != NULL && _mm->m_flags & M_PKTHDR)			\
+		_mm->m_pkthdr.len += _mplen;				\
+	*_mmp = _mm;							\
+} while (0)
+
+static __inline void
+m_clrprotoflags(struct mbuf *m)
+{
+	while (m) {
+		m->m_flags &= ~M_PROTOFLAGS;
+		m = m->m_next;
+	}
+}
+
+static inline u_int
+m_extrefcnt(struct mbuf *m)
+{
+	KASSERT(m->m_flags & M_EXT, ("%s: M_EXT missing", __func__));
+
+	return ((m->m_ext.ext_flags & EXT_FLAG_EMBREF) ? m->m_ext.ext_count :
+		*m->m_ext.ext_cnt);
+}
+
+static __inline int
+m_gettype(int size)
+{
+	int type = 0;
+
+	switch (size) {
+	case MCLBYTES:
+		type = EXT_CLUSTER;
+		break;
+#if MJUMPAGESIZE != MCLBYTES
+	case MJUMPAGESIZE:
+		type = EXT_JUMBOP;
+		break;
+#endif
+	case MJUM9BYTES:
+		type = EXT_JUMBO9;
+		break;
+	default:
+		panic("%s: invalid cluster size %d", __func__, size);
+	}
+
+	return (type);
+}
+
+/*
+ * XXX: m_cljset() is a dangerous API.  One must attach only a new,
+ * unreferenced cluster to an mbuf(9).  It is not possible to assert
+ * that, so care can be taken only by users of the API.
+ */
+static __inline void
+m_cljset(struct mbuf *m, void *cl, int type)
+{
+	int size = 0;
+
+	switch (type) {
+	case EXT_CLUSTER:
+		size = MCLBYTES;
+		break;
+#if MJUMPAGESIZE != MCLBYTES
+	case EXT_JUMBOP:
+		size = MJUMPAGESIZE;
+		break;
+#endif
+	case EXT_JUMBO9:
+		size = MJUM9BYTES;
+		break;
+	default:
+		panic("%s: unknown cluster type %d", __func__, type);
+		break;
+	}
+
+	m->m_data = m->m_ext.ext_buf = (caddr_t)cl;
+	m->m_ext.ext_size = size;
+	m->m_ext.ext_type = type;
+	m->m_ext.ext_flags = EXT_FLAG_EMBREF;
+	m->m_ext.ext_count = 1;
+	m->m_flags |= M_EXT;
+}
+
+/* mbufq */
+
+struct mbufq {
+	STAILQ_HEAD(, mbuf)	mq_head;
+	int			mq_len;
+	int			mq_maxlen;
+};
+
+static inline void
+mbufq_init(struct mbufq *mq, int maxlen)
+{
+	STAILQ_INIT(&mq->mq_head);
+	mq->mq_maxlen = maxlen;
+	mq->mq_len = 0;
+}
+
+static inline struct mbuf *
+mbufq_flush(struct mbufq *mq)
+{
+	struct mbuf *m;
+
+	m = STAILQ_FIRST(&mq->mq_head);
+	STAILQ_INIT(&mq->mq_head);
+	mq->mq_len = 0;
+	return (m);
+}
+
+static inline void
+mbufq_drain(struct mbufq *mq)
+{
+	struct mbuf *m, *n;
+
+	n = mbufq_flush(mq);
+	while ((m = n) != NULL) {
+		n = STAILQ_NEXT(m, m_stailqpkt);
+		m_freem(m);
+	}
+}
+
+static inline struct mbuf *
+mbufq_first(const struct mbufq *mq)
+{
+	return (STAILQ_FIRST(&mq->mq_head));
+}
+
+static inline struct mbuf *
+mbufq_last(const struct mbufq *mq)
+{
+	return (STAILQ_LAST(&mq->mq_head, mbuf, m_stailqpkt));
+}
+
+static inline int
+mbufq_full(const struct mbufq *mq)
+{
+	return (mq->mq_len >= mq->mq_maxlen);
+}
+
+static inline int
+mbufq_len(const struct mbufq *mq)
+{
+	return (mq->mq_len);
+}
+
+static inline int
+mbufq_enqueue(struct mbufq *mq, struct mbuf *m)
+{
+
+	if (mbufq_full(mq))
+		return (ENOBUFS);
+	STAILQ_INSERT_TAIL(&mq->mq_head, m, m_stailqpkt);
+	mq->mq_len++;
+	return (0);
+}
+
+static inline struct mbuf *
+mbufq_dequeue(struct mbufq *mq)
+{
+	struct mbuf *m;
+
+	m = STAILQ_FIRST(&mq->mq_head);
+	if (m) {
+		STAILQ_REMOVE_HEAD(&mq->mq_head, m_stailqpkt);
+		m->m_nextpkt = NULL;
+		mq->mq_len--;
+	}
+	return (m);
+}
+
+static inline void
+mbufq_prepend(struct mbufq *mq, struct mbuf *m)
+{
+
+	STAILQ_INSERT_HEAD(&mq->mq_head, m, m_stailqpkt);
+	mq->mq_len++;
+}
+
+
+/*
+ * Note: this doesn't enforce the maximum list size for dst.
+ */
+static inline void
+mbufq_concat(struct mbufq *mq_dst, struct mbufq *mq_src)
+{
+
+	mq_dst->mq_len += mq_src->mq_len;
+	STAILQ_CONCAT(&mq_dst->mq_head, &mq_src->mq_head);
+	mq_src->mq_len = 0;
+}
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf.h
new file mode 100644
index 0000000000..3397297228
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mbuf.h
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_MBUF_H_
+#define _FBSD_COMPAT_SYS_MBUF_H_
+
+
+#include <sys/queue.h>
+#include <sys/systm.h>
+#include <vm/uma.h>
+
+
+#define MHSIZE		__offsetof(struct mbuf, m_dat)
+#define MPKTHSIZE	__offsetof(struct mbuf, m_pktdat)
+#define MLEN		((int)(MSIZE - MHSIZE))
+#define MHLEN		((int)(MSIZE - MPKTHSIZE))
+
+#define MINCLSIZE	(MHLEN + 1)
+
+#define MBTOM(how)	(how)
+#define M_DONTWAIT	M_NOWAIT
+#define M_TRYWAIT	M_WAITOK
+#define M_WAIT		M_WAITOK
+
+/* mbuf types describing the content of the mbuf (including external storage). */
+#define MT_DATA		1
+#define	MT_NOINIT	255	/* not a type, a flag to allocate a non-initialized mbuf */
+
+/*
+ * mbuf flags of global significance and layer crossing.
+ * Those of only protocol/layer specific significance are to be mapped
+ * to M_PROTO[1-12] and cleared at layer handoff boundaries.
+ * NB: Limited to the lower 24 bits.
+ */
+#define	M_EXT		0x00000001 /* has associated external storage */
+#define	M_PKTHDR	0x00000002 /* start of record */
+#define	M_EOR		0x00000004 /* end of record */
+#define	M_RDONLY	0x00000008 /* associated data is marked read-only */
+#define	M_BCAST		0x00000010 /* send/received as link-level broadcast */
+#define	M_MCAST		0x00000020 /* send/received as link-level multicast */
+#define	M_PROMISC	0x00000040 /* packet was not for us */
+#define	M_VLANTAG	0x00000080 /* ether_vtag is valid */
+#define	M_UNUSED_8	0x00000100 /* --available-- */
+#define	M_NOFREE	0x00000200 /* do not free mbuf, embedded in cluster */
+
+#define	M_PROTO1	0x00001000 /* protocol-specific */
+#define	M_PROTO2	0x00002000 /* protocol-specific */
+#define	M_PROTO3	0x00004000 /* protocol-specific */
+#define	M_PROTO4	0x00008000 /* protocol-specific */
+#define	M_PROTO5	0x00010000 /* protocol-specific */
+#define	M_PROTO6	0x00020000 /* protocol-specific */
+#define	M_PROTO7	0x00040000 /* protocol-specific */
+#define	M_PROTO8	0x00080000 /* protocol-specific */
+#define	M_PROTO9	0x00100000 /* protocol-specific */
+#define	M_PROTO10	0x00200000 /* protocol-specific */
+#define	M_PROTO11	0x00400000 /* protocol-specific */
+#define	M_PROTO12	0x00800000 /* protocol-specific */
+
+#define	M_PROTOFLAGS \
+	(M_PROTO1|M_PROTO2|M_PROTO3|M_PROTO4|M_PROTO5|M_PROTO6|M_PROTO7|M_PROTO8|\
+	 M_PROTO9|M_PROTO10|M_PROTO11|M_PROTO12)
+	// Flags to purge when crossing layers.
+
+#define M_COPYFLAGS \
+	(M_PKTHDR|M_EOR|M_RDONLY|M_BCAST|M_MCAST|M_PROMISC|M_VLANTAG| \
+	 M_PROTOFLAGS)
+	// Flags preserved when copying m_pkthdr
+
+#define M_MOVE_PKTHDR(to, from)	m_move_pkthdr((to), (from))
+#define MGET(m, how, type)		((m) = m_get((how), (type)))
+#define MGETHDR(m, how, type)	((m) = m_gethdr((how), (type)))
+#define MCLGET(m, how)			m_clget((m), (how))
+#define m_getm(m, len, how, type)					\
+    m_getm2((m), (len), (how), (type), M_PKTHDR)
+
+#define mtod(m, type)	((type)((m)->m_data))
+#define	mtodo(m, o)	((void *)(((m)->m_data) + (o)))
+
+// Check if the supplied mbuf has a packet header, or else panic.
+#define M_ASSERTPKTHDR(m) KASSERT(m != NULL && m->m_flags & M_PKTHDR, \
+	("%s: no mbuf packet header!", __func__))
+
+
+/*
+ * Network interface cards are able to hash protocol fields (such as IPv4
+ * addresses and TCP port numbers) classify packets into flows.  These flows
+ * can then be used to maintain ordering while delivering packets to the OS
+ * via parallel input queues, as well as to provide a stateless affinity
+ * model.  NIC drivers can pass up the hash via m->m_pkthdr.flowid, and set
+ * m_flag fields to indicate how the hash should be interpreted by the
+ * network stack.
+ *
+ * Most NICs support RSS, which provides ordering and explicit affinity, and
+ * use the hash m_flag bits to indicate what header fields were covered by
+ * the hash.  M_HASHTYPE_OPAQUE and M_HASHTYPE_OPAQUE_HASH can be set by non-
+ * RSS cards or configurations that provide an opaque flow identifier, allowing
+ * for ordering and distribution without explicit affinity.  Additionally,
+ * M_HASHTYPE_OPAQUE_HASH indicates that the flow identifier has hash
+ * properties.
+ */
+#define	M_HASHTYPE_HASHPROP		0x80	/* has hash properties */
+#define	M_HASHTYPE_HASH(t)		(M_HASHTYPE_HASHPROP | (t))
+/* Microsoft RSS standard hash types */
+#define	M_HASHTYPE_NONE			0
+#define	M_HASHTYPE_RSS_IPV4		M_HASHTYPE_HASH(1) /* IPv4 2-tuple */
+#define	M_HASHTYPE_RSS_TCP_IPV4		M_HASHTYPE_HASH(2) /* TCPv4 4-tuple */
+#define	M_HASHTYPE_RSS_IPV6		M_HASHTYPE_HASH(3) /* IPv6 2-tuple */
+#define	M_HASHTYPE_RSS_TCP_IPV6		M_HASHTYPE_HASH(4) /* TCPv6 4-tuple */
+#define	M_HASHTYPE_RSS_IPV6_EX		M_HASHTYPE_HASH(5) /* IPv6 2-tuple +
+							    * ext hdrs */
+#define	M_HASHTYPE_RSS_TCP_IPV6_EX	M_HASHTYPE_HASH(6) /* TCPv6 4-tuple +
+							    * ext hdrs */
+/* Non-standard RSS hash types */
+#define	M_HASHTYPE_RSS_UDP_IPV4		M_HASHTYPE_HASH(7) /* IPv4 UDP 4-tuple*/
+#define	M_HASHTYPE_RSS_UDP_IPV4_EX	M_HASHTYPE_HASH(8) /* IPv4 UDP 4-tuple +
+							    * ext hdrs */
+#define	M_HASHTYPE_RSS_UDP_IPV6		M_HASHTYPE_HASH(9) /* IPv6 UDP 4-tuple*/
+#define	M_HASHTYPE_RSS_UDP_IPV6_EX	M_HASHTYPE_HASH(10)/* IPv6 UDP 4-tuple +
+							    * ext hdrs */
+
+#define	M_HASHTYPE_OPAQUE		63	/* ordering, not affinity */
+#define	M_HASHTYPE_OPAQUE_HASH		M_HASHTYPE_HASH(M_HASHTYPE_OPAQUE)
+						/* ordering+hash, not affinity*/
+
+#define	M_HASHTYPE_CLEAR(m)	((m)->m_pkthdr.rsstype = 0)
+#define	M_HASHTYPE_GET(m)	((m)->m_pkthdr.rsstype)
+#define	M_HASHTYPE_SET(m, v)	((m)->m_pkthdr.rsstype = (v))
+#define	M_HASHTYPE_TEST(m, v)	(M_HASHTYPE_GET(m) == (v))
+#define	M_HASHTYPE_ISHASH(m)	(M_HASHTYPE_GET(m) & M_HASHTYPE_HASHPROP)
+
+#define MBUF_CHECKSLEEP(how) do { } while (0)
+
+#define MTAG_PERSISTENT	0x800
+
+#define	M_COPYALL	1000000000
+	// Length to m_copy to copy all.
+
+#define EXT_CLUSTER		1		// 2048 bytes
+#define EXT_JUMBOP		4		// Page size
+#define EXT_JUMBO9		5		// 9 * 1024 bytes
+#define EXT_NET_DRV		100		// custom ext_buf provided by net driver
+
+#define EXT_EXTREF		255		// has externally maintained ext_cnt ptr
+
+/*
+ * Flags for external mbuf buffer types.
+ * NB: limited to the lower 24 bits.
+ */
+#define EXT_FLAG_EMBREF		0x000001	/* embedded ext_count */
+#define EXT_FLAG_EXTREF		0x000002	/* external ext_cnt, notyet */
+
+/* Flags indicating checksum, segmentation and other offload work */
+#define	CSUM_IP			0x00000001	/* IP header checksum offload */
+#define	CSUM_IP_UDP		0x00000002	/* UDP checksum offload */
+#define	CSUM_IP_TCP		0x00000004	/* TCP checksum offload */
+#define	CSUM_IP_SCTP		0x00000008	/* SCTP checksum offload */
+#define	CSUM_IP_TSO		0x00000010	/* TCP segmentation offload */
+#define	CSUM_IP_ISCSI		0x00000020	/* iSCSI checksum offload */
+
+#define	CSUM_IP6_UDP		0x00000200	/* UDP checksum offload */
+#define	CSUM_IP6_TCP		0x00000400	/* TCP checksum offload */
+#define	CSUM_IP6_SCTP		0x00000800	/* SCTP checksum offload */
+#define	CSUM_IP6_TSO		0x00001000	/* TCP segmentation offload */
+#define	CSUM_IP6_ISCSI		0x00002000	/* iSCSI checksum offload */
+
+/* Inbound checksum support where the checksum was verified by hardware. */
+#define	CSUM_L3_CALC		0x01000000	/* calculated layer 3 csum */
+#define	CSUM_L3_VALID		0x02000000	/* checksum is correct */
+#define	CSUM_L4_CALC		0x04000000	/* calculated layer 4 csum */
+#define	CSUM_L4_VALID		0x08000000	/* checksum is correct */
+#define	CSUM_L5_CALC		0x10000000	/* calculated layer 5 csum */
+#define	CSUM_L5_VALID		0x20000000	/* checksum is correct */
+#define	CSUM_COALESCED		0x40000000	/* contains merged segments */
+
+/* CSUM flags compatibility mappings. */
+#define	CSUM_IP_CHECKED		CSUM_L3_CALC
+#define	CSUM_IP_VALID		CSUM_L3_VALID
+#define	CSUM_DATA_VALID		CSUM_L4_VALID
+#define	CSUM_PSEUDO_HDR		CSUM_L4_CALC
+#define	CSUM_SCTP_VALID		CSUM_L4_VALID
+#define	CSUM_DELAY_DATA		(CSUM_TCP|CSUM_UDP)
+#define	CSUM_DELAY_IP		CSUM_IP		/* Only v4, no v6 IP hdr csum */
+#define	CSUM_DELAY_DATA_IPV6	(CSUM_TCP_IPV6|CSUM_UDP_IPV6)
+#define	CSUM_DATA_VALID_IPV6	CSUM_DATA_VALID
+#define	CSUM_TCP		CSUM_IP_TCP
+#define	CSUM_UDP		CSUM_IP_UDP
+#define	CSUM_SCTP		CSUM_IP_SCTP
+#define	CSUM_TSO		(CSUM_IP_TSO|CSUM_IP6_TSO)
+#define	CSUM_UDP_IPV6		CSUM_IP6_UDP
+#define	CSUM_TCP_IPV6		CSUM_IP6_TCP
+#define	CSUM_SCTP_IPV6		CSUM_IP6_SCTP
+
+
+#define MEXTADD(m, buf, size, free, arg1, arg2, flags, type) \
+	m_extadd((m), (caddr_t)(buf), (size), (free),(arg1),(arg2),(flags), (type))
+
+
+extern int max_linkhdr;
+extern int max_protohdr;
+extern int max_hdr;
+extern int max_datalen;		// MHLEN - max_hdr
+
+
+struct pkthdr {
+	struct ifnet*					rcvif;
+	SLIST_HEAD(packet_tags, m_tag)	tags;
+	int								len;
+
+	/* Layer crossing persistent information. */
+	uint32_t	flowid;		/* packet's 4-tuple system */
+	uint64_t	csum_flags;	/* checksum and offload features */
+	int			csum_data;
+	uint8_t		rsstype;		/* hash type */
+	uint16_t	tso_segsz;
+	uint16_t	ether_vtag;
+};
+
+struct m_tag {
+	SLIST_ENTRY(m_tag)	m_tag_link;		// List of packet tags
+	u_int16_t			m_tag_id;		// Tag ID
+	u_int16_t			m_tag_len;		// Length of data
+	u_int32_t			m_tag_cookie;	// ABI/Module ID
+	void				(*m_tag_free)(struct m_tag*);
+};
+
+struct m_ext {
+	union {
+		volatile u_int	 ext_count;	/* value of ref count info */
+		volatile u_int	*ext_cnt;	/* pointer to ref count info */
+	};
+	caddr_t		 ext_buf;	 /* start of buffer */
+	uint32_t	 ext_size;	 /* size of buffer, for ext_free */
+	uint32_t	 ext_type:8, /* type of external storage */
+			 ext_flags:24;	 /* external storage mbuf flags */
+};
+
+struct mbuf {
+	union {	/* next buffer in chain */
+		struct mbuf		*m_next;
+		SLIST_ENTRY(mbuf)	m_slist;
+		STAILQ_ENTRY(mbuf)	m_stailq;
+	};
+	union {	/* next chain in queue/record */
+		struct mbuf		*m_nextpkt;
+		SLIST_ENTRY(mbuf)	m_slistpkt;
+		STAILQ_ENTRY(mbuf)	m_stailqpkt;
+	};
+	caddr_t		 m_data;	/* location of data */
+	int32_t		 m_len;		/* amount of data in this mbuf */
+	uint32_t	 m_type:8,	/* type of data in this mbuf */
+			 m_flags:24;
+
+	union {
+		struct {
+			struct pkthdr	MH_pkthdr;
+			union {
+				struct m_ext	MH_ext;
+				char			MH_databuf[0] __aligned(8);
+			} MH_dat;
+		} MH;
+		char M_databuf[0] __aligned(8);
+	} M_dat;
+};
+
+/* The reason we use these really nasty macros, instead of naming the
+ * structs and unions properly like FreeBSD does ... is because of a
+ * GCC2 compiler bug. Specifically a parser bug: adding -O0 has no
+ * effect on this problem. */
+#define m_pkthdr	M_dat.MH.MH_pkthdr
+#define m_ext		M_dat.MH.MH_dat.MH_ext
+#define m_pktdat	M_dat.MH.MH_dat.MH_databuf
+#define m_dat		M_dat.M_databuf
+
+int				m_init(struct mbuf *m, int how, short type, int flags);
+int				m_pkthdr_init(struct mbuf *m, int how);
+
+void			m_catpkt(struct mbuf *m, struct mbuf *n);
+void			m_adj(struct mbuf*, int);
+int				m_append(struct mbuf*, int, c_caddr_t);
+void			m_cat(struct mbuf*, struct mbuf*);
+int				m_clget(struct mbuf*, int);
+void*			m_cljget(struct mbuf*, int, int);
+struct mbuf*	m_collapse(struct mbuf*, int, int);
+void			m_copyback(struct mbuf *m0, int off, int len, c_caddr_t cp);
+void			m_copydata(const struct mbuf*, int, int, caddr_t);
+struct mbuf*	m_copypacket(struct mbuf*, int);
+struct mbuf *	m_copym(struct mbuf *m, int off0, int len, int wait);
+struct mbuf*	m_defrag(struct mbuf*, int);
+struct mbuf*	m_devget(char*, int, int, struct ifnet*,
+	void(*) (char*, caddr_t, u_int));
+
+struct mbuf*	m_dup(const struct mbuf *m, int how);
+int				m_dup_pkthdr(struct mbuf *to, const struct mbuf *from, int how);
+
+void			m_demote_pkthdr(struct mbuf *m);
+void			m_demote(struct mbuf *m0, int all, int flags);
+
+void			m_extadd(struct mbuf *mb, caddr_t buf, u_int size,
+	void (*freef)(struct mbuf *, void *, void *), void *arg1, void *arg2,
+	int flags, int type);
+
+u_int			m_fixhdr(struct mbuf*);
+struct mbuf*	m_free(struct mbuf*);
+void			m_freem(struct mbuf*);
+struct mbuf*	m_get(int, short);
+struct mbuf*	m_get2(int size, int how, short type, int flags);
+struct mbuf *	m_getm2(struct mbuf *m, int len, int how, short type, int flags);
+struct mbuf*	m_gethdr(int, short);
+struct mbuf*	m_getjcl(int, short, int, int);
+u_int			m_length(struct mbuf*, struct mbuf**);
+struct mbuf*	m_getcl(int, short, int);
+void			m_move_pkthdr(struct mbuf*, struct mbuf*);
+struct mbuf*	m_prepend(struct mbuf*, int, int);
+struct mbuf*	m_pulldown(struct mbuf*, int, int, int*);
+struct mbuf*	m_pullup(struct mbuf*, int);
+struct mbuf*	m_split(struct mbuf*, int, int);
+struct mbuf*	m_unshare(struct mbuf*, int);
+
+struct m_tag*	m_tag_alloc(u_int32_t, int, int, int);
+void			m_tag_delete(struct mbuf*, struct m_tag*);
+void			m_tag_delete_chain(struct mbuf*, struct m_tag*);
+void			m_tag_free_default(struct m_tag*);
+struct m_tag*	m_tag_locate(struct mbuf*, u_int32_t, int, struct m_tag*);
+struct m_tag*	m_tag_copy(struct m_tag*, int);
+int				m_tag_copy_chain(struct mbuf *to, const struct mbuf *from, int how);
+void			m_tag_delete_nonpersistent(struct mbuf*);
+
+
+static inline void
+m_tag_setup(struct m_tag* tagPointer, u_int32_t cookie, int type, int length)
+{
+	tagPointer->m_tag_id = type;
+	tagPointer->m_tag_len = length;
+	tagPointer->m_tag_cookie = cookie;
+}
+
+
+static inline void
+m_tag_free(struct m_tag* tag)
+{
+	(*tag->m_tag_free)(tag);
+}
+
+
+static inline void
+m_tag_prepend(struct mbuf* memoryBuffer, struct m_tag* tag)
+{
+	SLIST_INSERT_HEAD(&memoryBuffer->m_pkthdr.tags, tag, m_tag_link);
+}
+
+
+static inline void
+m_tag_unlink(struct mbuf* memoryBuffer, struct m_tag* tag)
+{
+	SLIST_REMOVE(&memoryBuffer->m_pkthdr.tags, tag, m_tag, m_tag_link);
+}
+
+
+#include <sys/mbuf-fbsd.h>
+
+#endif	/* _FBSD_COMPAT_SYS_MBUF_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/method-ids.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/method-ids.h
new file mode 100644
index 0000000000..1720558989
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/method-ids.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2019, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_METHOD_IDS_H
+#define _FBSD_COMPAT_SYS_METHOD_IDS_H
+
+
+enum device_method_ids {
+	ID_device_register = 1,
+	ID_device_probe,
+	ID_device_attach,
+	ID_device_detach,
+	ID_device_suspend,
+	ID_device_resume,
+	ID_device_shutdown,
+
+	ID_miibus_readreg,
+	ID_miibus_writereg,
+	ID_miibus_statchg,
+	ID_miibus_linkchg,
+	ID_miibus_mediainit,
+
+	ID_bus_child_location_str,
+	ID_bus_child_pnpinfo_str,
+	ID_bus_hinted_child,
+	ID_bus_print_child,
+	ID_bus_read_ivar,
+	ID_bus_get_dma_tag,
+
+	ID_ifdi_knlist_add,
+	ID_ifdi_knote_event,
+	ID_ifdi_object_info_get,
+	ID_ifdi_attach_pre,
+	ID_ifdi_attach_post,
+	ID_ifdi_reinit_pre,
+	ID_ifdi_reinit_post,
+	ID_ifdi_cloneattach,
+	ID_ifdi_detach,
+	ID_ifdi_suspend,
+	ID_ifdi_shutdown,
+	ID_ifdi_resume,
+	ID_ifdi_tx_queues_alloc,
+	ID_ifdi_rx_queues_alloc,
+	ID_ifdi_queues_free,
+	ID_ifdi_rx_clset,
+	ID_ifdi_init,
+	ID_ifdi_stop,
+	ID_ifdi_msix_intr_assign,
+	ID_ifdi_intr_enable,
+	ID_ifdi_intr_disable,
+	ID_ifdi_rx_queue_intr_enable,
+	ID_ifdi_tx_queue_intr_enable,
+	ID_ifdi_link_intr_enable,
+	ID_ifdi_multi_set,
+	ID_ifdi_mtu_set,
+	ID_ifdi_mac_set,
+	ID_ifdi_media_set,
+	ID_ifdi_promisc_set,
+	ID_ifdi_crcstrip_set,
+	ID_ifdi_vflr_handle,
+	ID_ifdi_iov_init,
+	ID_ifdi_iov_uninit,
+	ID_ifdi_iov_vf_add,
+	ID_ifdi_update_admin_status,
+	ID_ifdi_media_status,
+	ID_ifdi_media_change,
+	ID_ifdi_get_counter,
+	ID_ifdi_priv_ioctl,
+	ID_ifdi_i2c_req,
+	ID_ifdi_txq_setup,
+	ID_ifdi_rxq_setup,
+	ID_ifdi_timer,
+	ID_ifdi_watchdog_reset,
+	ID_ifdi_watchdog_reset_queue,
+	ID_ifdi_led_func,
+	ID_ifdi_vlan_register,
+	ID_ifdi_vlan_unregister,
+	ID_ifdi_sysctl_int_delay,
+	ID_ifdi_debug,
+};
+
+
+#endif /* _FBSD_COMPAT_SYS_METHOD_IDS_H */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/module.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/module.h
new file mode 100644
index 0000000000..09dfd5d8ce
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/module.h
@@ -0,0 +1,24 @@
+#ifndef _FBSD_COMPAT_SYS_MODULE_H_
+#define _FBSD_COMPAT_SYS_MODULE_H_
+
+
+#include <sys/linker_set.h>
+
+
+typedef struct module* module_t;
+
+typedef enum modeventtype {
+	MOD_LOAD,
+	MOD_UNLOAD,
+	MOD_SHUTDOWN,
+	MOD_QUIESCE
+} modeventtype_t;
+
+
+#define DECLARE_MODULE(name, data, sub, order)
+
+#define MODULE_VERSION(name, version)
+#define MODULE_DEPEND(module, mdepend, vmin, vpref, vmax)
+#define	MODULE_PNP_INFO(d, b, unique, t, n)
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mount.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mount.h
new file mode 100644
index 0000000000..4d447271f5
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mount.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_MOUNT_H_
+#define _FBSD_COMPAT_SYS_MOUNT_H_
+
+
+#endif /* _FBSD_COMPAT_SYS_MOUNT_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mutex.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mutex.h
new file mode 100644
index 0000000000..9c2ae7cb7d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/mutex.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_MUTEX_H_
+#define _FBSD_COMPAT_SYS_MUTEX_H_
+
+
+#include <sys/haiku-module.h>
+#include <kernel/int.h>
+
+#include <sys/queue.h>
+#include <sys/_mutex.h>
+#include <sys/pcpu.h>
+#include <machine/atomic.h>
+#include <machine/cpufunc.h>
+
+
+#define MA_OWNED		0x1
+#define MA_NOTOWNED		0x2
+#define MA_RECURSED		0x4
+#define MA_NOTRECURSED	0x8
+
+#define mtx_assert(mtx, what)
+
+#define	MTX_DEF			0x00000000
+#define MTX_SPIN		0x00000001
+#define MTX_RECURSE		0x00000004
+#define MTX_QUIET		0x00040000
+#define MTX_DUPOK		0x00400000
+
+
+#define MTX_NETWORK_LOCK	"network driver"
+
+
+/* on FreeBSD these are different functions */
+#define	mtx_lock_spin(x) 	mtx_lock(x)
+#define	mtx_unlock_spin(x)	mtx_unlock(x)
+
+
+extern struct mtx Giant;
+
+
+void mtx_init(struct mtx*, const char*, const char*, int);
+void mtx_sysinit(void *arg);
+void mtx_destroy(struct mtx*);
+
+
+static inline void
+mtx_lock(struct mtx* mutex)
+{
+	if (mutex->type == MTX_DEF) {
+		mutex_lock(&mutex->u.mutex.lock);
+		mutex->u.mutex.owner = find_thread(NULL);
+	} else if (mutex->type == MTX_RECURSE) {
+		recursive_lock_lock(&mutex->u.recursive);
+	} else if (mutex->type == MTX_SPIN) {
+		cpu_status status = disable_interrupts();
+		acquire_spinlock(&mutex->u.spinlock.lock);
+		mutex->u.spinlock.state = status;
+	}
+}
+
+
+static inline int
+mtx_trylock(struct mtx* mutex)
+{
+	if (mutex->type == MTX_DEF) {
+		if (mutex_trylock(&mutex->u.mutex.lock) != B_OK)
+			return 0;
+		mutex->u.mutex.owner = find_thread(NULL);
+		return 1;
+	} else if (mutex->type == MTX_RECURSE) {
+		if (recursive_lock_trylock(&mutex->u.recursive) != B_OK)
+			return 0;
+		return 1;
+	} else if (mutex->type == MTX_SPIN) {
+		return 0;
+	}
+	return 0;
+}
+
+
+static inline void
+mtx_unlock(struct mtx* mutex)
+{
+	if (mutex->type == MTX_DEF) {
+		mutex->u.mutex.owner = -1;
+		mutex_unlock(&mutex->u.mutex.lock);
+	} else if (mutex->type == MTX_RECURSE) {
+		recursive_lock_unlock(&mutex->u.recursive);
+	} else if (mutex->type == MTX_SPIN) {
+		cpu_status status = mutex->u.spinlock.state;
+		release_spinlock(&mutex->u.spinlock.lock);
+		restore_interrupts(status);
+	}
+}
+
+
+static inline int
+mtx_initialized(struct mtx* mutex)
+{
+	/* TODO */
+	return 1;
+}
+
+
+static inline int
+mtx_owned(struct mtx* mutex)
+{
+	if (mutex->type == MTX_DEF)
+		return mutex->u.mutex.owner == find_thread(NULL);
+	if (mutex->type == MTX_RECURSE) {
+#if KDEBUG
+		return mutex->u.recursive.lock.holder == find_thread(NULL);
+#else
+		return mutex->u.recursive.holder == find_thread(NULL);
+#endif
+	}
+
+	return 0;
+}
+
+
+struct mtx_args {
+	void		*ma_mtx;
+	const char 	*ma_desc;
+	int		 ma_opts;
+};
+
+#define	MTX_SYSINIT(name, mtx, desc, opts) \
+	static struct mtx_args name##_args = {	\
+		(mtx), \
+		(desc), \
+		(opts), \
+	}; \
+	SYSINIT(name##_mtx, SI_SUB_LOCK, SI_ORDER_MIDDLE, \
+		mtx_sysinit, &name##_args); \
+	SYSUNINIT(name##_mtx, SI_SUB_LOCK, SI_ORDER_MIDDLE, \
+	    (system_init_func_t)mtx_destroy, (void*)mtx)
+
+
+#endif	/* _FBSD_COMPAT_SYS_MUTEX_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/namei.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/namei.h
new file mode 100644
index 0000000000..3da8a0a778
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/namei.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_NAMEI_H_
+#define _FBSD_COMPAT_SYS_NAMEI_H_
+
+
+#endif /* _FBSD_COMPAT_SYS_NAMEI_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/param.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/param.h
new file mode 100644
index 0000000000..3adcb4c66f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/param.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_PARAM_H_
+#define _FBSD_COMPAT_SYS_PARAM_H_
+
+
+#include <posix/sys/param.h>
+#include <ByteOrder.h>
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+#include <sys/errno.h>
+#include <sys/time.h>
+#include <sys/priority.h>
+
+
+/* The version this compatibility layer is based on */
+#define __FreeBSD_version 1200086
+
+#define MAXBSIZE	0x10000
+
+#define PAGE_SHIFT	12
+#define PAGE_MASK	(B_PAGE_SIZE - 1)
+
+#define trunc_page(x)	((x) & ~PAGE_MASK)
+
+#define ptoa(x)			((unsigned long)((x) << PAGE_SHIFT))
+#define atop(x)			((unsigned long)((x) >> PAGE_SHIFT))
+
+#ifndef MSIZE
+#define MSIZE 256
+#endif
+
+#ifndef MCLSHIFT
+#define MCLSHIFT 11
+#endif
+
+#define MCLBYTES		(1 << MCLSHIFT)
+
+#define	MJUMPAGESIZE	B_PAGE_SIZE
+#define	MJUM9BYTES		(9 * 1024)
+#define	MJUM16BYTES		(16 * 1024)
+
+#define ALIGN_BYTES		(sizeof(unsigned long) - 1)
+#define ALIGN(x)		((((unsigned long)x) + ALIGN_BYTES) & ~ALIGN_BYTES)
+
+#if defined(__x86_64__) || defined(__i386__) || defined(__M68K__)
+#define	ALIGNED_POINTER(p, t)	1
+#elif defined(__powerpc__)
+#define	ALIGNED_POINTER(p, t)	((((uintptr_t)(p)) & (sizeof (t) - 1)) == 0)
+#elif defined(__arm__)
+#define	ALIGNED_POINTER(p, t)	((((unsigned)(p)) & (sizeof(t) - 1)) == 0)
+#elif defined(__mips__) || defined(__sparc__) || defined(__riscv64__) \
+	|| defined(__aarch64__) || defined(__arm64__)
+#define	ALIGNED_POINTER(p, t)	((((unsigned long)(p)) & (sizeof (t) - 1)) == 0)
+#else
+#error Need definition of ALIGNED_POINTER for this arch!
+#endif
+
+/* defined in arch_cpu.h which we can't include here as it's C++ */
+#if defined(__x86_64__) || defined(__i386__) || defined(__arm__) \
+	|| defined(__sparc__) || defined(__riscv64__) \
+	|| defined(__aarch64__) || defined(__arm64__)
+#define CACHE_LINE_SIZE 64
+#elif defined(__powerpc__)
+#define CACHE_LINE_SIZE 128
+#elif defined(__M68K__)
+#define CACHE_LINE_SIZE 16
+#else
+#error Need definition of CACHE_LINE_SIZE for this arch!
+#endif
+
+/* Macros for counting and rounding. */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif
+#define roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
+#define roundup2(x, y)	(((x) + ((y) - 1)) & (~((y) - 1)))
+#define rounddown(x, y)  (((x) / (y)) * (y))
+#define rounddown2(x, y) ((x)&(~((y)-1)))          /* if y is power of two */
+#define powerof2(x)	((((x)-1)&(x))==0)
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100
+#define	PDROP	0x200
+#define	PBDRY	0x400
+
+#define	NBBY	8		/* number of bits in a byte */
+
+/* Bit map related macros. */
+#define	setbit(a,i)	(((unsigned char *)(a))[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	(((unsigned char *)(a))[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)							\
+	(((const unsigned char *)(a))[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)							\
+	((((const unsigned char *)(a))[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* byteswap macros */
+#ifndef htonl
+#	define htonl(x) B_HOST_TO_BENDIAN_INT32(x)
+#	define ntohl(x) B_BENDIAN_TO_HOST_INT32(x)
+#	define htons(x) B_HOST_TO_BENDIAN_INT16(x)
+#	define ntohs(x) B_BENDIAN_TO_HOST_INT16(x)
+#endif
+
+#endif	/* _FBSD_COMPAT_SYS_PARAM_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/pcpu.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/pcpu.h
new file mode 100644
index 0000000000..a10975a5e5
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/pcpu.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_PCPU_H_
+#define _FBSD_COMPAT_SYS_PCPU_H_
+
+
+#include <OS.h>
+#include <sys/smp.h>
+
+
+struct thread;
+
+#define curthread ((struct thread*)NULL)
+	/* NOTE: Dereferencing curthread will crash, which is intentional. There is
+	   no FreeBSD compatible struct thread and Haiku's should not be used as it
+	   is only valid for the current thread or with proper locking. Currently
+	   only priv_check() expects a struct thread parameter and ignores it. Using
+	   NULL will show us when other uses appear. */
+
+
+#endif /* _FBSD_COMPAT_SYS_PCPU_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priority.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priority.h
new file mode 100644
index 0000000000..55d8668ad4
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priority.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2009-2018, Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_PRIORITY_H_
+#define _FBSD_COMPAT_SYS_PRIORITY_H_
+
+#include <OS.h>
+
+
+#define PI_NET			(B_REAL_TIME_DISPLAY_PRIORITY - 9)
+#define	PI_SOFT			(B_REAL_TIME_DISPLAY_PRIORITY - 1)
+
+#define PRI_MIN_KERN	(64)
+#define PZERO			(PRI_MIN_KERN + 20)
+#define	PWAIT			(PRI_MIN_KERN + 28)
+
+
+#endif /* _FBSD_COMPAT_SYS_PRIORITY_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priv.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priv.h
new file mode 100644
index 0000000000..4ba76e34c6
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/priv.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_PRIV_H_
+#define _FBSD_COMPAT_SYS_PRIV_H_
+
+
+#include <sys/cdefs.h>
+
+
+/*
+ * 802.11-related privileges.
+ */
+#define	PRIV_NET80211_GETKEY	440	/* Query 802.11 keys. */
+#define	PRIV_NET80211_MANAGE	441	/* Administer 802.11. */
+
+#define	PRIV_DRIVER		14	/* Low-level driver privilege. */
+
+
+/*
+ * Privilege check interfaces, modeled after historic suser() interfacs, but
+ * with the addition of a specific privilege name.  No flags are currently
+ * defined for the API.  Historically, flags specified using the real uid
+ * instead of the effective uid, and whether or not the check should be
+ * allowed in jail.
+ */
+struct thread;
+
+
+__BEGIN_DECLS
+
+int	priv_check(struct thread*, int);
+
+__END_DECLS
+
+
+#endif /* _FBSD_COMPAT_SYS_PRIV_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/proc.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/proc.h
new file mode 100644
index 0000000000..1eb862a86a
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/proc.h
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_PROC_H_
+#define _FBSD_COMPAT_SYS_PROC_H_
+
+
+#endif /* _FBSD_COMPAT_SYS_PROC_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/protosw.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/protosw.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/queue.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/queue.h
new file mode 100644
index 0000000000..636dbe5302
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/queue.h
@@ -0,0 +1,787 @@
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ * $FreeBSD: releng/11.1/sys/sys/queue.h 307533 2016-10-17 21:44:41Z mckusick $
+ */
+
+#ifndef _SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+#include <sys/cdefs.h>
+
+/*
+ * This file defines four types of data structures: singly-linked lists,
+ * singly-linked tail queues, lists and tail queues.
+ *
+ * A singly-linked list is headed by a single forward pointer. The elements
+ * are singly linked for minimum space and pointer manipulation overhead at
+ * the expense of O(n) removal for arbitrary elements. New elements can be
+ * added to the list after an existing element or at the head of the list.
+ * Elements being removed from the head of the list should use the explicit
+ * macro for this purpose for optimum efficiency. A singly-linked list may
+ * only be traversed in the forward direction.  Singly-linked lists are ideal
+ * for applications with large datasets and few or no removals or for
+ * implementing a LIFO queue.
+ *
+ * A singly-linked tail queue is headed by a pair of pointers, one to the
+ * head of the list and the other to the tail of the list. The elements are
+ * singly linked for minimum space and pointer manipulation overhead at the
+ * expense of O(n) removal for arbitrary elements. New elements can be added
+ * to the list after an existing element, at the head of the list, or at the
+ * end of the list. Elements being removed from the head of the tail queue
+ * should use the explicit macro for this purpose for optimum efficiency.
+ * A singly-linked tail queue may only be traversed in the forward direction.
+ * Singly-linked tail queues are ideal for applications with large datasets
+ * and few or no removals or for implementing a FIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may be traversed in either direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ *
+ * Below is a summary of implemented functions where:
+ *  +  means the macro is available
+ *  -  means the macro is not available
+ *  s  means the macro is available but is slow (runs in O(n) time)
+ *
+ *				SLIST	LIST	STAILQ	TAILQ
+ * _HEAD			+	+	+	+
+ * _CLASS_HEAD			+	+	+	+
+ * _HEAD_INITIALIZER		+	+	+	+
+ * _ENTRY			+	+	+	+
+ * _CLASS_ENTRY			+	+	+	+
+ * _INIT			+	+	+	+
+ * _EMPTY			+	+	+	+
+ * _FIRST			+	+	+	+
+ * _NEXT			+	+	+	+
+ * _PREV			-	+	-	+
+ * _LAST			-	-	+	+
+ * _FOREACH			+	+	+	+
+ * _FOREACH_FROM		+	+	+	+
+ * _FOREACH_SAFE		+	+	+	+
+ * _FOREACH_FROM_SAFE		+	+	+	+
+ * _FOREACH_REVERSE		-	-	-	+
+ * _FOREACH_REVERSE_FROM	-	-	-	+
+ * _FOREACH_REVERSE_SAFE	-	-	-	+
+ * _FOREACH_REVERSE_FROM_SAFE	-	-	-	+
+ * _INSERT_HEAD			+	+	+	+
+ * _INSERT_BEFORE		-	+	-	+
+ * _INSERT_AFTER		+	+	+	+
+ * _INSERT_TAIL			-	-	+	+
+ * _CONCAT			s	s	+	+
+ * _REMOVE_AFTER		+	-	+	-
+ * _REMOVE_HEAD			+	-	+	-
+ * _REMOVE			s	+	s	+
+ * _SWAP			+	+	+	+
+ *
+ */
+#ifdef QUEUE_MACRO_DEBUG
+/* Store the last 2 places the queue element or head was altered */
+struct qm_trace {
+	unsigned long	 lastline;
+	unsigned long	 prevline;
+	const char	*lastfile;
+	const char	*prevfile;
+};
+
+#define	TRACEBUF	struct qm_trace trace;
+#define	TRACEBUF_INITIALIZER	{ __LINE__, 0, __FILE__, NULL } ,
+#define	TRASHIT(x)	do {(x) = (void *)-1;} while (0)
+#define	QMD_SAVELINK(name, link)	void **name = (void *)&(link)
+
+#define	QMD_TRACE_HEAD(head) do {					\
+	(head)->trace.prevline = (head)->trace.lastline;		\
+	(head)->trace.prevfile = (head)->trace.lastfile;		\
+	(head)->trace.lastline = __LINE__;				\
+	(head)->trace.lastfile = __FILE__;				\
+} while (0)
+
+#define	QMD_TRACE_ELEM(elem) do {					\
+	(elem)->trace.prevline = (elem)->trace.lastline;		\
+	(elem)->trace.prevfile = (elem)->trace.lastfile;		\
+	(elem)->trace.lastline = __LINE__;				\
+	(elem)->trace.lastfile = __FILE__;				\
+} while (0)
+
+#else
+#define	QMD_TRACE_ELEM(elem)
+#define	QMD_TRACE_HEAD(head)
+#define	QMD_SAVELINK(name, link)
+#define	TRACEBUF
+#define	TRACEBUF_INITIALIZER
+#define	TRASHIT(x)
+#endif	/* QUEUE_MACRO_DEBUG */
+
+#ifdef __cplusplus
+/*
+ * In C++ there can be structure lists and class lists:
+ */
+#define	QUEUE_TYPEOF(type) type
+#else
+#define	QUEUE_TYPEOF(type) struct type
+#endif
+
+/*
+ * Singly-linked List declarations.
+ */
+#define	SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+
+#define	SLIST_CLASS_ENTRY(type)						\
+struct {								\
+	class type *sle_next;		/* next element */		\
+}
+
+/*
+ * Singly-linked List functions.
+ */
+#define SLIST_CONCAT(head1, head2, type, field) do {			\
+	QUEUE_TYPEOF(type) *curelm = SLIST_FIRST(head1);		\
+	if (curelm == NULL) {						\
+		if ((SLIST_FIRST(head1) = SLIST_FIRST(head2)) != NULL)	\
+			SLIST_INIT(head2);				\
+	} else if (SLIST_FIRST(head2) != NULL) {			\
+		while (SLIST_NEXT(curelm, field) != NULL)		\
+			curelm = SLIST_NEXT(curelm, field);		\
+		SLIST_NEXT(curelm, field) = SLIST_FIRST(head2);		\
+		SLIST_INIT(head2);					\
+	}								\
+} while (0)
+
+#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
+
+#define	SLIST_FIRST(head)	((head)->slh_first)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for ((var) = SLIST_FIRST((head));				\
+	    (var);							\
+	    (var) = SLIST_NEXT((var), field))
+
+#define	SLIST_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : SLIST_FIRST((head)));		\
+	    (var);							\
+	    (var) = SLIST_NEXT((var), field))
+
+#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SLIST_FIRST((head));				\
+	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	SLIST_FOREACH_FROM_SAFE(var, head, field, tvar)			\
+	for ((var) = ((var) ? (var) : SLIST_FIRST((head)));		\
+	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
+	for ((varp) = &SLIST_FIRST((head));				\
+	    ((var) = *(varp)) != NULL;					\
+	    (varp) = &SLIST_NEXT((var), field))
+
+#define	SLIST_INIT(head) do {						\
+	SLIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\
+	SLIST_NEXT((slistelm), field) = (elm);				\
+} while (0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\
+	SLIST_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+#define	SLIST_REMOVE(head, elm, type, field) do {			\
+	QMD_SAVELINK(oldnext, (elm)->field.sle_next);			\
+	if (SLIST_FIRST((head)) == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		QUEUE_TYPEOF(type) *curelm = SLIST_FIRST(head);		\
+		while (SLIST_NEXT(curelm, field) != (elm))		\
+			curelm = SLIST_NEXT(curelm, field);		\
+		SLIST_REMOVE_AFTER(curelm, field);			\
+	}								\
+	TRASHIT(*oldnext);						\
+} while (0)
+
+#define SLIST_REMOVE_AFTER(elm, field) do {				\
+	SLIST_NEXT(elm, field) =					\
+	    SLIST_NEXT(SLIST_NEXT(elm, field), field);			\
+} while (0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\
+} while (0)
+
+#define SLIST_SWAP(head1, head2, type) do {				\
+	QUEUE_TYPEOF(type) *swap_first = SLIST_FIRST(head1);		\
+	SLIST_FIRST(head1) = SLIST_FIRST(head2);			\
+	SLIST_FIRST(head2) = swap_first;				\
+} while (0)
+
+/*
+ * Singly-linked Tail queue declarations.
+ */
+#define	STAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *stqh_first;/* first element */			\
+	struct type **stqh_last;/* addr of last next element */		\
+}
+
+#define	STAILQ_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *stqh_first;	/* first element */			\
+	class type **stqh_last;	/* addr of last next element */		\
+}
+
+#define	STAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).stqh_first }
+
+#define	STAILQ_ENTRY(type)						\
+struct {								\
+	struct type *stqe_next;	/* next element */			\
+}
+
+#define	STAILQ_CLASS_ENTRY(type)					\
+struct {								\
+	class type *stqe_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked Tail queue functions.
+ */
+#define	STAILQ_CONCAT(head1, head2) do {				\
+	if (!STAILQ_EMPTY((head2))) {					\
+		*(head1)->stqh_last = (head2)->stqh_first;		\
+		(head1)->stqh_last = (head2)->stqh_last;		\
+		STAILQ_INIT((head2));					\
+	}								\
+} while (0)
+
+#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
+
+#define	STAILQ_FIRST(head)	((head)->stqh_first)
+
+#define	STAILQ_FOREACH(var, head, field)				\
+	for((var) = STAILQ_FIRST((head));				\
+	   (var);							\
+	   (var) = STAILQ_NEXT((var), field))
+
+#define	STAILQ_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : STAILQ_FIRST((head)));		\
+	   (var);							\
+	   (var) = STAILQ_NEXT((var), field))
+
+#define	STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = STAILQ_FIRST((head));				\
+	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	STAILQ_FOREACH_FROM_SAFE(var, head, field, tvar)		\
+	for ((var) = ((var) ? (var) : STAILQ_FIRST((head)));		\
+	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	STAILQ_INIT(head) do {						\
+	STAILQ_FIRST((head)) = NULL;					\
+	(head)->stqh_last = &STAILQ_FIRST((head));			\
+} while (0)
+
+#define	STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_NEXT((tqelm), field) = (elm);				\
+} while (0)
+
+#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
+	STAILQ_NEXT((elm), field) = NULL;				\
+	*(head)->stqh_last = (elm);					\
+	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
+} while (0)
+
+#define	STAILQ_LAST(head, type, field)				\
+	(STAILQ_EMPTY((head)) ? NULL :				\
+	    __containerof((head)->stqh_last,			\
+	    QUEUE_TYPEOF(type), field.stqe_next))
+
+#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
+
+#define	STAILQ_REMOVE(head, elm, type, field) do {			\
+	QMD_SAVELINK(oldnext, (elm)->field.stqe_next);			\
+	if (STAILQ_FIRST((head)) == (elm)) {				\
+		STAILQ_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		QUEUE_TYPEOF(type) *curelm = STAILQ_FIRST(head);	\
+		while (STAILQ_NEXT(curelm, field) != (elm))		\
+			curelm = STAILQ_NEXT(curelm, field);		\
+		STAILQ_REMOVE_AFTER(head, curelm, field);		\
+	}								\
+	TRASHIT(*oldnext);						\
+} while (0)
+
+#define STAILQ_REMOVE_AFTER(head, elm, field) do {			\
+	if ((STAILQ_NEXT(elm, field) =					\
+	     STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+} while (0)
+
+#define	STAILQ_REMOVE_HEAD(head, field) do {				\
+	if ((STAILQ_FIRST((head)) =					\
+	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
+		(head)->stqh_last = &STAILQ_FIRST((head));		\
+} while (0)
+
+#define STAILQ_SWAP(head1, head2, type) do {				\
+	QUEUE_TYPEOF(type) *swap_first = STAILQ_FIRST(head1);		\
+	QUEUE_TYPEOF(type) **swap_last = (head1)->stqh_last;		\
+	STAILQ_FIRST(head1) = STAILQ_FIRST(head2);			\
+	(head1)->stqh_last = (head2)->stqh_last;			\
+	STAILQ_FIRST(head2) = swap_first;				\
+	(head2)->stqh_last = swap_last;					\
+	if (STAILQ_EMPTY(head1))					\
+		(head1)->stqh_last = &STAILQ_FIRST(head1);		\
+	if (STAILQ_EMPTY(head2))					\
+		(head2)->stqh_last = &STAILQ_FIRST(head2);		\
+} while (0)
+
+
+/*
+ * List declarations.
+ */
+#define	LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define	LIST_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *lh_first;	/* first element */			\
+}
+
+#define	LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+#define	LIST_CLASS_ENTRY(type)						\
+struct {								\
+	class type *le_next;	/* next element */			\
+	class type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List functions.
+ */
+
+#if (defined(_KERNEL) && defined(INVARIANTS))
+#define	QMD_LIST_CHECK_HEAD(head, field) do {				\
+	if (LIST_FIRST((head)) != NULL &&				\
+	    LIST_FIRST((head))->field.le_prev !=			\
+	     &LIST_FIRST((head)))					\
+		panic("Bad list head %p first->prev != head", (head));	\
+} while (0)
+
+#define	QMD_LIST_CHECK_NEXT(elm, field) do {				\
+	if (LIST_NEXT((elm), field) != NULL &&				\
+	    LIST_NEXT((elm), field)->field.le_prev !=			\
+	     &((elm)->field.le_next))					\
+	     	panic("Bad link elm %p next->prev != elm", (elm));	\
+} while (0)
+
+#define	QMD_LIST_CHECK_PREV(elm, field) do {				\
+	if (*(elm)->field.le_prev != (elm))				\
+		panic("Bad link elm %p prev->next != elm", (elm));	\
+} while (0)
+#else
+#define	QMD_LIST_CHECK_HEAD(head, field)
+#define	QMD_LIST_CHECK_NEXT(elm, field)
+#define	QMD_LIST_CHECK_PREV(elm, field)
+#endif /* (_KERNEL && INVARIANTS) */
+
+#define LIST_CONCAT(head1, head2, type, field) do {			      \
+	QUEUE_TYPEOF(type) *curelm = LIST_FIRST(head1);			      \
+	if (curelm == NULL) {						      \
+		if ((LIST_FIRST(head1) = LIST_FIRST(head2)) != NULL) {	      \
+			LIST_FIRST(head2)->field.le_prev =		      \
+			    &LIST_FIRST((head1));			      \
+			LIST_INIT(head2);				      \
+		}							      \
+	} else if (LIST_FIRST(head2) != NULL) {				      \
+		while (LIST_NEXT(curelm, field) != NULL)		      \
+			curelm = LIST_NEXT(curelm, field);		      \
+		LIST_NEXT(curelm, field) = LIST_FIRST(head2);		      \
+		LIST_FIRST(head2)->field.le_prev = &LIST_NEXT(curelm, field); \
+		LIST_INIT(head2);					      \
+	}								      \
+} while (0)
+
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+
+#define	LIST_FIRST(head)	((head)->lh_first)
+
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = LIST_FIRST((head));				\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+
+#define	LIST_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : LIST_FIRST((head)));		\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+
+#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = LIST_FIRST((head));				\
+	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	LIST_FOREACH_FROM_SAFE(var, head, field, tvar)			\
+	for ((var) = ((var) ? (var) : LIST_FIRST((head)));		\
+	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	LIST_INIT(head) do {						\
+	LIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	QMD_LIST_CHECK_NEXT(listelm, field);				\
+	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\
+		LIST_NEXT((listelm), field)->field.le_prev =		\
+		    &LIST_NEXT((elm), field);				\
+	LIST_NEXT((listelm), field) = (elm);				\
+	(elm)->field.le_prev = &LIST_NEXT((listelm), field);		\
+} while (0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	QMD_LIST_CHECK_PREV(listelm, field);				\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	LIST_NEXT((elm), field) = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &LIST_NEXT((elm), field);		\
+} while (0)
+
+#define	LIST_INSERT_HEAD(head, elm, field) do {				\
+	QMD_LIST_CHECK_HEAD((head), field);				\
+	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
+		LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
+	LIST_FIRST((head)) = (elm);					\
+	(elm)->field.le_prev = &LIST_FIRST((head));			\
+} while (0)
+
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+
+#define	LIST_PREV(elm, head, type, field)			\
+	((elm)->field.le_prev == &LIST_FIRST((head)) ? NULL :	\
+	    __containerof((elm)->field.le_prev,			\
+	    QUEUE_TYPEOF(type), field.le_next))
+
+#define	LIST_REMOVE(elm, field) do {					\
+	QMD_SAVELINK(oldnext, (elm)->field.le_next);			\
+	QMD_SAVELINK(oldprev, (elm)->field.le_prev);			\
+	QMD_LIST_CHECK_NEXT(elm, field);				\
+	QMD_LIST_CHECK_PREV(elm, field);				\
+	if (LIST_NEXT((elm), field) != NULL)				\
+		LIST_NEXT((elm), field)->field.le_prev = 		\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = LIST_NEXT((elm), field);		\
+	TRASHIT(*oldnext);						\
+	TRASHIT(*oldprev);						\
+} while (0)
+
+#define LIST_SWAP(head1, head2, type, field) do {			\
+	QUEUE_TYPEOF(type) *swap_tmp = LIST_FIRST(head1);		\
+	LIST_FIRST((head1)) = LIST_FIRST((head2));			\
+	LIST_FIRST((head2)) = swap_tmp;					\
+	if ((swap_tmp = LIST_FIRST((head1))) != NULL)			\
+		swap_tmp->field.le_prev = &LIST_FIRST((head1));		\
+	if ((swap_tmp = LIST_FIRST((head2))) != NULL)			\
+		swap_tmp->field.le_prev = &LIST_FIRST((head2));		\
+} while (0)
+
+/*
+ * Tail queue declarations.
+ */
+#define	TAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *tqh_first;	/* first element */			\
+	struct type **tqh_last;	/* addr of last next element */		\
+	TRACEBUF							\
+}
+
+#define	TAILQ_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *tqh_first;	/* first element */			\
+	class type **tqh_last;	/* addr of last next element */		\
+	TRACEBUF							\
+}
+
+#define	TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first, TRACEBUF_INITIALIZER }
+
+#define	TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+	TRACEBUF							\
+}
+
+#define	TAILQ_CLASS_ENTRY(type)						\
+struct {								\
+	class type *tqe_next;	/* next element */			\
+	class type **tqe_prev;	/* address of previous next element */	\
+	TRACEBUF							\
+}
+
+/*
+ * Tail queue functions.
+ */
+#if (defined(_KERNEL) && defined(INVARIANTS))
+#define	QMD_TAILQ_CHECK_HEAD(head, field) do {				\
+	if (!TAILQ_EMPTY(head) &&					\
+	    TAILQ_FIRST((head))->field.tqe_prev !=			\
+	     &TAILQ_FIRST((head)))					\
+		panic("Bad tailq head %p first->prev != head", (head));	\
+} while (0)
+
+#define	QMD_TAILQ_CHECK_TAIL(head, field) do {				\
+	if (*(head)->tqh_last != NULL)					\
+	    	panic("Bad tailq NEXT(%p->tqh_last) != NULL", (head)); 	\
+} while (0)
+
+#define	QMD_TAILQ_CHECK_NEXT(elm, field) do {				\
+	if (TAILQ_NEXT((elm), field) != NULL &&				\
+	    TAILQ_NEXT((elm), field)->field.tqe_prev !=			\
+	     &((elm)->field.tqe_next))					\
+		panic("Bad link elm %p next->prev != elm", (elm));	\
+} while (0)
+
+#define	QMD_TAILQ_CHECK_PREV(elm, field) do {				\
+	if (*(elm)->field.tqe_prev != (elm))				\
+		panic("Bad link elm %p prev->next != elm", (elm));	\
+} while (0)
+#else
+#define	QMD_TAILQ_CHECK_HEAD(head, field)
+#define	QMD_TAILQ_CHECK_TAIL(head, headname)
+#define	QMD_TAILQ_CHECK_NEXT(elm, field)
+#define	QMD_TAILQ_CHECK_PREV(elm, field)
+#endif /* (_KERNEL && INVARIANTS) */
+
+#define	TAILQ_CONCAT(head1, head2, field) do {				\
+	if (!TAILQ_EMPTY(head2)) {					\
+		*(head1)->tqh_last = (head2)->tqh_first;		\
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
+		(head1)->tqh_last = (head2)->tqh_last;			\
+		TAILQ_INIT((head2));					\
+		QMD_TRACE_HEAD(head1);					\
+		QMD_TRACE_HEAD(head2);					\
+	}								\
+} while (0)
+
+#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
+
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+
+#define	TAILQ_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : TAILQ_FIRST((head)));		\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+
+#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_FROM_SAFE(var, head, field, tvar)			\
+	for ((var) = ((var) ? (var) : TAILQ_FIRST((head)));		\
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_FROM(var, head, headname, field)		\
+	for ((var) = ((var) ? (var) : TAILQ_LAST((head), headname));	\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_REVERSE_FROM_SAFE(var, head, headname, field, tvar) \
+	for ((var) = ((var) ? (var) : TAILQ_LAST((head), headname));	\
+	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
+	    (var) = (tvar))
+
+#define	TAILQ_INIT(head) do {						\
+	TAILQ_FIRST((head)) = NULL;					\
+	(head)->tqh_last = &TAILQ_FIRST((head));			\
+	QMD_TRACE_HEAD(head);						\
+} while (0)
+
+#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	QMD_TAILQ_CHECK_NEXT(listelm, field);				\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+		    &TAILQ_NEXT((elm), field);				\
+	else {								\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+		QMD_TRACE_HEAD(head);					\
+	}								\
+	TAILQ_NEXT((listelm), field) = (elm);				\
+	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);		\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+	QMD_TRACE_ELEM(&(listelm)->field);				\
+} while (0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	QMD_TAILQ_CHECK_PREV(listelm, field);				\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	TAILQ_NEXT((elm), field) = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);		\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+	QMD_TRACE_ELEM(&(listelm)->field);				\
+} while (0)
+
+#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	QMD_TAILQ_CHECK_HEAD(head, field);				\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
+		TAILQ_FIRST((head))->field.tqe_prev =			\
+		    &TAILQ_NEXT((elm), field);				\
+	else								\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+	TAILQ_FIRST((head)) = (elm);					\
+	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
+	QMD_TRACE_HEAD(head);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	QMD_TAILQ_CHECK_TAIL(head, field);				\
+	TAILQ_NEXT((elm), field) = NULL;				\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
+	QMD_TRACE_HEAD(head);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+#define	TAILQ_REMOVE(head, elm, field) do {				\
+	QMD_SAVELINK(oldnext, (elm)->field.tqe_next);			\
+	QMD_SAVELINK(oldprev, (elm)->field.tqe_prev);			\
+	QMD_TAILQ_CHECK_NEXT(elm, field);				\
+	QMD_TAILQ_CHECK_PREV(elm, field);				\
+	if ((TAILQ_NEXT((elm), field)) != NULL)				\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+		    (elm)->field.tqe_prev;				\
+	else {								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+		QMD_TRACE_HEAD(head);					\
+	}								\
+	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
+	TRASHIT(*oldnext);						\
+	TRASHIT(*oldprev);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define TAILQ_SWAP(head1, head2, type, field) do {			\
+	QUEUE_TYPEOF(type) *swap_first = (head1)->tqh_first;		\
+	QUEUE_TYPEOF(type) **swap_last = (head1)->tqh_last;		\
+	(head1)->tqh_first = (head2)->tqh_first;			\
+	(head1)->tqh_last = (head2)->tqh_last;				\
+	(head2)->tqh_first = swap_first;				\
+	(head2)->tqh_last = swap_last;					\
+	if ((swap_first = (head1)->tqh_first) != NULL)			\
+		swap_first->field.tqe_prev = &(head1)->tqh_first;	\
+	else								\
+		(head1)->tqh_last = &(head1)->tqh_first;		\
+	if ((swap_first = (head2)->tqh_first) != NULL)			\
+		swap_first->field.tqe_prev = &(head2)->tqh_first;	\
+	else								\
+		(head2)->tqh_last = &(head2)->tqh_first;		\
+} while (0)
+
+#endif /* !_SYS_QUEUE_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/random.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/random.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/rman.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/rman.h
new file mode 100644
index 0000000000..b03dd57e67
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/rman.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+/*-
+ * Copyright 1998 Massachusetts Institute of Technology
+ *
+ * Permission to use, copy, modify, and distribute this software and
+ * its documentation for any purpose and without fee is hereby
+ * granted, provided that both the above copyright notice and this
+ * permission notice appear in all copies, that both the above
+ * copyright notice and this permission notice appear in all
+ * supporting documentation, and that the name of M.I.T. not be used
+ * in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.  M.I.T. makes
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS
+ * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
+ * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+#ifndef _FBSD_COMPAT_SYS_RMAN_H_
+#define _FBSD_COMPAT_SYS_RMAN_H_
+
+
+#include <machine/_bus.h>
+#include <machine/resource.h>
+
+
+#define RF_ACTIVE		0x0002
+#define RF_SHAREABLE	0x0004
+#define RF_OPTIONAL		0x0080
+
+#define RF_ALIGNMENT_SHIFT		10 /* alignment size bit starts bit 10 */
+#define RF_ALIGNMENT_LOG2(x)	((x) << RF_ALIGNMENT_SHIFT)
+
+struct resource {
+	int					r_type;
+	bus_space_tag_t		r_bustag;		/* bus_space tag */
+	bus_space_handle_t	r_bushandle;	/* bus_space handle */
+	area_id				r_mapped_area;
+};
+
+
+bus_space_handle_t rman_get_bushandle(struct resource *);
+bus_space_tag_t rman_get_bustag(struct resource *);
+int rman_get_rid(struct resource *);
+void* rman_get_virtual(struct resource *);
+
+
+static inline u_long
+rman_get_start(struct resource *resourcePointer)
+{
+	return resourcePointer->r_bushandle;
+}
+
+
+static inline uint32_t
+rman_make_alignment_flags(uint32_t size)
+{
+	int i;
+
+	/*
+	 * Find the hightest bit set, and add one if more than one bit
+	 * set.  We're effectively computing the ceil(log2(size)) here.
+	 */
+	for (i = 31; i > 0; i--)
+		if ((1 << i) & size)
+			break;
+	if (~(1 << i) & size)
+		i++;
+
+	return RF_ALIGNMENT_LOG2(i);
+}
+#endif /* _FBSD_COMPAT_SYS_RMAN_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sbuf.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sbuf.h
new file mode 100644
index 0000000000..9513604362
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sbuf.h
@@ -0,0 +1,111 @@
+/*-
+ * Copyright (c) 2000-2008 Poul-Henning Kamp
+ * Copyright (c) 2000-2008 Dag-Erling Codan Smrgrav
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *      $FreeBSD$
+ */
+
+#ifndef _SYS_SBUF_H_
+#define	_SYS_SBUF_H_
+
+#include <sys/_types.h>
+
+struct sbuf;
+typedef int (sbuf_drain_func)(void *, const char *, int);
+
+/*
+ * Structure definition
+ */
+struct sbuf {
+	char		*s_buf;		/* storage buffer */
+	sbuf_drain_func	*s_drain_func;	/* drain function */
+	void		*s_drain_arg;	/* user-supplied drain argument */
+	int		 s_error;	/* current error code */
+	ssize_t		 s_size;	/* size of storage buffer */
+	ssize_t		 s_len;		/* current length of string */
+#define	SBUF_FIXEDLEN	0x00000000	/* fixed length buffer (default) */
+#define	SBUF_AUTOEXTEND	0x00000001	/* automatically extend buffer */
+#define	SBUF_INCLUDENUL	0x00000002	/* nulterm byte is counted in len */
+#define	SBUF_USRFLAGMSK	0x0000ffff	/* mask of flags the user may specify */
+#define	SBUF_DYNAMIC	0x00010000	/* s_buf must be freed */
+#define	SBUF_FINISHED	0x00020000	/* set by sbuf_finish() */
+#define	SBUF_DYNSTRUCT	0x00080000	/* sbuf must be freed */
+#define	SBUF_INSECTION	0x00100000	/* set by sbuf_start_section() */
+	int		 s_flags;	/* flags */
+	ssize_t		 s_sect_len;	/* current length of section */
+};
+
+#ifndef HD_COLUMN_MASK
+#define	HD_COLUMN_MASK	0xff
+#define	HD_DELIM_MASK	0xff00
+#define	HD_OMIT_COUNT	(1 << 16)
+#define	HD_OMIT_HEX	(1 << 17)
+#define	HD_OMIT_CHARS	(1 << 18)
+#endif /* HD_COLUMN_MASK */
+
+__BEGIN_DECLS
+/*
+ * API functions
+ */
+struct sbuf	*sbuf_new(struct sbuf *, char *, int, int);
+#define		 sbuf_new_auto()				\
+	sbuf_new(NULL, NULL, 0, SBUF_AUTOEXTEND)
+int		 sbuf_get_flags(struct sbuf *);
+void		 sbuf_clear_flags(struct sbuf *, int);
+void		 sbuf_set_flags(struct sbuf *, int);
+void		 sbuf_clear(struct sbuf *);
+int		 sbuf_setpos(struct sbuf *, ssize_t);
+int		 sbuf_bcat(struct sbuf *, const void *, size_t);
+int		 sbuf_bcpy(struct sbuf *, const void *, size_t);
+int		 sbuf_cat(struct sbuf *, const char *);
+int		 sbuf_cpy(struct sbuf *, const char *);
+int		 sbuf_printf(struct sbuf *, const char *, ...)
+	__printflike(2, 3);
+int		 sbuf_vprintf(struct sbuf *, const char *, __va_list)
+	__printflike(2, 0);
+int		 sbuf_putc(struct sbuf *, int);
+void		 sbuf_set_drain(struct sbuf *, sbuf_drain_func *, void *);
+int		 sbuf_trim(struct sbuf *);
+int		 sbuf_error(const struct sbuf *);
+int		 sbuf_finish(struct sbuf *);
+char		*sbuf_data(struct sbuf *);
+ssize_t		 sbuf_len(struct sbuf *);
+int		 sbuf_done(const struct sbuf *);
+void		 sbuf_delete(struct sbuf *);
+void		 sbuf_start_section(struct sbuf *, ssize_t *);
+ssize_t		 sbuf_end_section(struct sbuf *, ssize_t, size_t, int);
+void		 sbuf_hexdump(struct sbuf *, const void *, int, const char *,
+		     int);
+
+#if 0
+struct uio;
+struct sbuf	*sbuf_uionew(struct sbuf *, struct uio *, int *);
+int		 sbuf_bcopyin(struct sbuf *, const void *, size_t);
+int		 sbuf_copyin(struct sbuf *, const void *, size_t);
+#endif
+__END_DECLS
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/smp.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/smp.h
new file mode 100644
index 0000000000..eff700817c
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/smp.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2014-2019, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_SMP_H_
+#define _FBSD_COMPAT_SYS_SMP_H_
+
+
+extern u_int mp_maxid;
+extern int mp_ncpus;
+
+
+static inline int
+cpu_first(void)
+{
+	return 0;
+}
+
+static inline int
+cpu_next(int i)
+{
+	i++;
+	if (i > (int)mp_maxid)
+		i = 0;
+	return i;
+}
+
+#define	CPU_FIRST()	cpu_first()
+#define	CPU_NEXT(i)	cpu_next((i))
+
+#define MAXCPU 1
+#define curcpu 0
+
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/socket.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/socket.h
new file mode 100644
index 0000000000..1da6b72147
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/socket.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_SOCKET_H_
+#define _FBSD_COMPAT_SYS_SOCKET_H_
+
+
+#include <posix/sys/socket.h>
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+
+
+// TODO Should be incorporated into Haikus socket.h with a number below AF_MAX
+#define AF_IEEE80211 	(AF_MAX + 1) 	/* IEEE 802.11 protocol */
+
+#endif /* _FBSD_COMPAT_SYS_SOCKET_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockio.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockio.h
new file mode 100644
index 0000000000..33156af3f7
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockio.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2007-2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_SOCKIO_H_
+#define _FBSD_COMPAT_SYS_SOCKIO_H_
+
+
+#include <posix/sys/sockio.h>
+
+#include <sys/ioccom.h>
+
+
+#define SIOCSIFCAP	SIOCSPACKETCAP
+
+#define SIOCSIFLLADDR			8950	/* set linklevel addr */
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockopt.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockopt.h
new file mode 100644
index 0000000000..3053583c76
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sockopt.h
@@ -0,0 +1 @@
+/* nothing here */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sx.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sx.h
new file mode 100644
index 0000000000..92c6ac0e85
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sx.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2018, Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Augustin Cavalier <waddlesplash>
+ */
+#ifndef _FBSD_COMPAT_SYS_SX_H_
+#define _FBSD_COMPAT_SYS_SX_H_
+
+
+#include <lock.h>
+
+
+struct sx {
+	rw_lock l;
+};
+
+#define sx_init(lock, name)		rw_lock_init(&(lock)->l, name)
+#define sx_xlock(lock)			rw_lock_write_lock(&(lock)->l)
+#define sx_xunlock(lock)		rw_lock_write_unlock(&(lock)->l)
+#define sx_destroy(lock)		rw_lock_destroy(&(lock)->l)
+
+#define sx_assert(sx, what)
+
+
+#endif /* _FBSD_COMPAT_SYS_SX_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sysctl.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sysctl.h
new file mode 100644
index 0000000000..c55101c62b
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/sysctl.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_SYSCTL_H_
+#define _FBSD_COMPAT_SYS_SYSCTL_H_
+
+
+#include <sys/queue.h>
+
+
+#ifdef _KERNEL
+
+struct sysctl_req {
+	void *newptr;
+};
+
+struct sysctl_ctx_list {
+};
+
+struct sysctl_oid_list {
+};
+
+struct sysctl_oid {
+};
+
+
+#define SYSCTL_HANDLER_ARGS void *oidp, void *arg1, int arg2, \
+	struct sysctl_req *req
+
+#define OID_AUTO	(-1)
+
+#define CTLTYPE		0xf	/* Mask for the type */
+#define	CTLTYPE_NODE	1	/* name is a node */
+#define	CTLTYPE_INT	2	/* name describes an integer */
+#define	CTLTYPE_STRING	3	/* name describes a string */
+#define	CTLTYPE_QUAD	4	/* name describes a 64-bit number */
+#define	CTLTYPE_OPAQUE	5	/* name describes a structure */
+#define	CTLTYPE_STRUCT	CTLTYPE_OPAQUE	/* name describes a structure */
+#define	CTLTYPE_UINT	6	/* name describes an unsigned integer */
+#define	CTLTYPE_LONG	7	/* name describes a long */
+#define	CTLTYPE_ULONG	8	/* name describes an unsigned long */
+#define CTLTYPE_U64		9	/* name describes an unsigned 64-bit number */
+
+#define CTLFLAG_RD	0x80000000	/* Allow reads of variable */
+#define CTLFLAG_WR	0x40000000	/* Allow writes to the variable */
+#define CTLFLAG_RW	(CTLFLAG_RD|CTLFLAG_WR)
+#define CTLFLAG_NOLOCK	0x20000000	/* XXX Don't Lock */
+#define CTLFLAG_ANYBODY	0x10000000	/* All users can set this var */
+#define CTLFLAG_SECURE	0x08000000	/* Permit set only if securelevel<=0 */
+#define CTLFLAG_PRISON	0x04000000	/* Prisoned roots can fiddle */
+#define CTLFLAG_DYN	0x02000000	/* Dynamic oid - can be freed */
+#define CTLFLAG_SKIP	0x01000000	/* Skip this sysctl when listing */
+#define CTLMASK_SECURE	0x00F00000	/* Secure level */
+#define CTLFLAG_TUN	0x00080000	/* Tunable variable */
+#define	CTLFLAG_RDTUN	(CTLFLAG_RD|CTLFLAG_TUN)
+#define	CTLFLAG_RWTUN	(CTLFLAG_RW|CTLFLAG_TUN)
+#define CTLFLAG_MPSAFE  0x00040000	/* Handler is MP safe */
+#define	CTLFLAG_VNET	0x00020000	/* Prisons with vnet can fiddle */
+#define	CTLFLAG_DYING	0x00010000	/* Oid is being removed */
+#define	CTLFLAG_CAPRD	0x00008000	/* Can be read in capability mode */
+#define	CTLFLAG_CAPWR	0x00004000	/* Can be written in capability mode */
+#define	CTLFLAG_STATS	0x00002000	/* Statistics, not a tuneable */
+#define	CTLFLAG_NOFETCH	0x00001000	/* Don't fetch tunable from getenv() */
+#define	CTLFLAG_CAPRW	(CTLFLAG_CAPRD|CTLFLAG_CAPWR)
+/*
+ * This is transient flag to be used until all sysctl handlers are converted
+ * to not lock Giant.
+ * One, and only one of CTLFLAG_MPSAFE or CTLFLAG_NEEDGIANT is required
+ * for SYSCTL_PROC and SYSCTL_NODE.
+ */
+#define	CTLFLAG_NEEDGIANT 0x00000800	/* Handler require Giant */
+
+
+static inline int
+sysctl_ctx_init(struct sysctl_ctx_list *clist)
+{
+	return -1;
+}
+
+
+static inline int
+sysctl_ctx_free(struct sysctl_ctx_list *clist)
+{
+	return -1;
+}
+
+
+static inline int
+sysctl_wire_old_buffer(struct sysctl_req *req, size_t len)
+{
+	return -1;
+}
+
+
+static inline struct sbuf *
+sbuf_new_for_sysctl(struct sbuf *s, char *buf, int length,
+    struct sysctl_req *req)
+{
+	return NULL;
+}
+
+
+static inline void *
+sysctl_add_oid(struct sysctl_ctx_list *clist, void *parent, int nbr,
+	const char *name, int kind, void *arg1, int arg2,
+	int (*handler) (SYSCTL_HANDLER_ARGS), const char *fmt, const char *descr)
+{
+	return NULL;
+}
+
+
+static inline int sysctl_handle_long(SYSCTL_HANDLER_ARGS) { return -1; }
+static inline int sysctl_handle_opaque(SYSCTL_HANDLER_ARGS) { return -1; }
+static inline int sysctl_handle_quad(SYSCTL_HANDLER_ARGS) { return -1; }
+static inline int sysctl_handle_int(SYSCTL_HANDLER_ARGS) { return -1; }
+static inline int sysctl_handle_64(SYSCTL_HANDLER_ARGS) { return -1; }
+static inline int sysctl_handle_string(SYSCTL_HANDLER_ARGS) { return -1; }
+
+
+#define SYSCTL_OUT(r, p, l) -1
+
+#define __DESCR(x) ""
+
+#define SYSCTL_ADD_OID(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, descr) \
+	sysctl_add_oid(ctx, parent, nbr, name, kind, a1, a2, handler, fmt, \
+	__DESCR(descr))
+
+#define SYSCTL_ADD_NODE(ctx, parent, nbr, name, access, handler, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_NODE|(access),		\
+	0, 0, handler, "N", __DESCR(descr))
+
+#define SYSCTL_ADD_STRING(ctx, parent, nbr, name, access, arg, len, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_STRING|(access),			\
+	arg, len, sysctl_handle_string, "A", __DESCR(descr))
+
+#define SYSCTL_ADD_INT(ctx, parent, nbr, name, access, ptr, val, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_INT|(access),		\
+	ptr, val, sysctl_handle_int, "I", __DESCR(descr))
+
+#define SYSCTL_ADD_UINT(ctx, parent, nbr, name, access, ptr, val, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UINT|(access),			\
+	ptr, val, sysctl_handle_int, "IU", __DESCR(descr))
+
+#define SYSCTL_ADD_XINT(ctx, parent, nbr, name, access, ptr, val, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_UINT|(access),			\
+	ptr, val, sysctl_handle_int, "IX", __DESCR(descr))
+
+#define SYSCTL_ADD_LONG(ctx, parent, nbr, name, access, ptr, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_LONG|(access),	\
+	ptr, 0, sysctl_handle_long, "L", __DESCR(descr))
+
+#define SYSCTL_ADD_ULONG(ctx, parent, nbr, name, access, ptr, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_ULONG|(access),		\
+	ptr, 0, sysctl_handle_long, "LU", __DESCR(descr))
+
+#define SYSCTL_ADD_QUAD(ctx, parent, nbr, name, access, ptr, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_QUAD|(access),	\
+	ptr, 0, sysctl_handle_quad, "Q", __DESCR(descr))
+
+#define SYSCTL_ADD_UQUAD(ctx, parent, nbr, name, access, ptr, descr)    \
+	sysctl_add_oid(ctx, parent, nbr, name,								\
+	CTLTYPE_U64 | CTLFLAG_MPSAFE | (access),							\
+	ptr, 0, sysctl_handle_64, "QU", __DESCR(descr))
+
+#define SYSCTL_ADD_OPAQUE(ctx, parent, nbr, name, access, ptr, len, fmt, descr) \
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|(access), \
+	ptr, len, sysctl_handle_opaque, fmt, __DESCR(descr))
+
+#define SYSCTL_ADD_STRUCT(ctx, parent, nbr, name, access, ptr, type, descr)	\
+	sysctl_add_oid(ctx, parent, nbr, name, CTLTYPE_OPAQUE|(access),			\
+	ptr, sizeof(struct type), sysctl_handle_opaque, "S," #type, __DESCR(descr))
+
+#define SYSCTL_ADD_PROC(ctx, parent, nbr, name, access, ptr, arg, handler, fmt, descr) \
+	sysctl_add_oid(ctx, parent, nbr, name, (access), ptr, arg, handler, fmt, \
+	__DESCR(descr))
+
+
+static inline void *
+SYSCTL_CHILDREN(void *ptr)
+{
+	return NULL;
+}
+
+
+#define SYSCTL_STATIC_CHILDREN(...) NULL
+
+#define SYSCTL_DECL(name) \
+	extern struct sysctl_oid_list sysctl_##name##_children
+
+#define SYSCTL_NODE(...)
+#define SYSCTL_INT(...)
+#define SYSCTL_UINT(...)
+#define SYSCTL_PROC(...)
+
+#endif
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/syslog.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/syslog.h
new file mode 100644
index 0000000000..f785d64b35
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/syslog.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_SYSLOG_H_
+#define _FBSD_COMPAT_SYS_SYSLOG_H_
+
+
+#define LOG_ERR 3 /* error conditions */
+
+#endif /* _FBSD_COMPAT_SYS_SYSLOG_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/systm.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/systm.h
new file mode 100644
index 0000000000..7138300cea
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/systm.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_SYSTM_H_
+#define _FBSD_COMPAT_SYS_SYSTM_H_
+
+
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+
+#include <machine/atomic.h>
+#include <machine/cpufunc.h>
+
+#include <sys/callout.h>
+#include <sys/cdefs.h>
+#include <sys/queue.h>
+
+#include <sys/libkern.h>
+
+
+#define printf freebsd_printf
+int printf(const char *format, ...) __printflike(1, 2);
+
+
+#define ovbcopy(f, t, l) bcopy((f), (t), (l))
+
+#if KDEBUG_LEVEL_2
+#define INVARIANTS
+#endif
+
+#if KDEBUG_LEVEL_1
+#define bootverbose 1
+#else
+#define bootverbose 0
+#endif
+
+#ifdef INVARIANTS
+#define KASSERT(cond,msg) do {	\
+	if (!(cond))				\
+		panic msg;				\
+} while (0)
+#else
+#define KASSERT(exp,msg) do { \
+} while (0)
+#endif
+
+#define DELAY(n) \
+	do {				\
+		if (n < 1000)	\
+			spin(n);	\
+		else			\
+			snooze(n);	\
+	} while (0)
+
+#define	cold 0
+
+void wakeup(void *);
+void wakeup_one(void *);
+
+#ifndef CTASSERT	/* Allow lint to override */
+#define	CTASSERT(x)	_Static_assert(x, "compile-time assertion failed")
+#endif
+
+
+static inline int
+copyin(const void * __restrict udaddr, void * __restrict kaddr,
+	size_t len)
+{
+	return user_memcpy(kaddr, udaddr, len);
+}
+
+
+static inline int
+copyout(const void * __restrict kaddr, void * __restrict udaddr,
+	size_t len)
+{
+	return user_memcpy(udaddr, kaddr, len);
+}
+
+
+static inline void log(int level, const char *fmt, ...) { }
+
+
+int snprintf(char *, size_t, const char *, ...) __printflike(3, 4);
+extern int sprintf(char *buf, const char *, ...);
+
+extern int driver_vprintf(const char *format, va_list vl);
+#define vprintf(fmt, vl) driver_vprintf(fmt, vl)
+
+extern int vsnprintf(char *, size_t, const char *, __va_list)
+	__printflike(3, 0);
+
+int msleep(void *, struct mtx *, int, const char *, int);
+int _pause(const char *, int);
+#define pause(waitMessage, timeout) _pause((waitMessage), (timeout))
+#define tsleep(channel, priority, waitMessage, timeout) \
+	msleep((channel), NULL, (priority), (waitMessage), (timeout))
+#define msleep_spin(chan, mtx, wmesg, timo) \
+	msleep(chan, mtx, PZERO, wmesg, timo)
+#define mtx_sleep msleep
+
+void critical_enter(void);
+void critical_exit(void);
+
+struct unrhdr;
+struct unrhdr *new_unrhdr(int low, int high, struct mtx *mutex);
+void delete_unrhdr(struct unrhdr *);
+int alloc_unr(struct unrhdr *);
+void free_unr(struct unrhdr *, u_int);
+
+extern char *getenv(const char *name);
+extern void    freeenv(char *env);
+extern char *kern_getenv(const char *name);
+
+#endif	/* _FBSD_COMPAT_SYS_SYSTM_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/taskqueue.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/taskqueue.h
new file mode 100644
index 0000000000..f8d5c7363e
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/taskqueue.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2007-2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_TASKQUEUE_H_
+#define _FBSD_COMPAT_SYS_TASKQUEUE_H_
+
+
+#include <sys/queue.h>
+#include <sys/_task.h>
+#include <sys/callout.h>
+
+
+struct timeout_task {
+	struct taskqueue *q;
+	struct task t;
+	struct callout c;
+	int    f;
+};
+
+#define	TASKQUEUE_NAMELEN		64
+
+typedef void (*taskqueue_enqueue_fn)(void *context);
+
+
+struct taskqueue;
+struct taskqueue *taskqueue_create(const char *name, int mflags,
+	taskqueue_enqueue_fn enqueue, void *context);
+int taskqueue_start_threads(struct taskqueue **tq, int count, int pri,
+	const char *name, ...) __printflike(4, 5);
+void taskqueue_free(struct taskqueue *tq);
+void taskqueue_drain(struct taskqueue *tq, struct task *task);
+void taskqueue_drain_timeout(struct taskqueue *queue,
+	struct timeout_task *timeout_task);
+void taskqueue_drain_all(struct taskqueue *tq);
+void taskqueue_block(struct taskqueue *queue);
+void taskqueue_unblock(struct taskqueue *queue);
+int taskqueue_enqueue(struct taskqueue *tq, struct task *task);
+int taskqueue_enqueue_timeout(struct taskqueue *queue,
+	struct timeout_task *ttask, int _ticks);
+int taskqueue_cancel(struct taskqueue *queue, struct task *task,
+	u_int *pendp);
+int taskqueue_cancel_timeout(struct taskqueue *queue,
+	struct timeout_task *timeout_task, u_int *pendp);
+
+void taskqueue_thread_enqueue(void *context);
+
+extern struct taskqueue *taskqueue_fast;
+extern struct taskqueue *taskqueue_swi;
+extern struct taskqueue *taskqueue_thread;
+
+int taskqueue_enqueue_fast(struct taskqueue *queue, struct task *task);
+struct taskqueue *taskqueue_create_fast(const char *name, int mflags,
+	taskqueue_enqueue_fn enqueue, void *context);
+
+void task_init(struct task *, int prio, task_fn_t handler, void *arg);
+#define TASK_INIT(taskp, prio, hand, arg) task_init(taskp, prio, hand, arg)
+
+void timeout_task_init(struct taskqueue *queue, struct timeout_task *timeout_task,
+	int priority, task_fn_t func, void *context);
+#define	TIMEOUT_TASK_INIT(queue, timeout_task, priority, func, context) \
+	timeout_task_init(queue, timeout_task, priority, func, context);
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/time.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/time.h
new file mode 100644
index 0000000000..14265f44dd
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/time.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2020, Haiku, Inc. All rights reserved.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_TIME_H_
+#define _FBSD_COMPAT_SYS_TIME_H_
+
+
+#include <posix/sys/time.h>
+
+#include <sys/_timeval.h>
+#include <sys/types.h>
+
+
+#define TICKS_2_USEC(t) ((1000000*(bigtime_t)t) / hz)
+#define USEC_2_TICKS(t) (((bigtime_t)t*hz) / 1000000)
+
+#define TICKS_2_MSEC(t) ((1000*(bigtime_t)t) / hz)
+#define MSEC_2_TICKS(t) (((bigtime_t)t*hz) / 1000)
+
+#define time_uptime		USEC_2_TICKS(system_time())
+
+
+int	ppsratecheck(struct timeval*, int*, int);
+
+
+#endif /* _FBSD_COMPAT_SYS_TIME_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/types.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/types.h
new file mode 100644
index 0000000000..4068ac7d2c
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/sys/types.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2007 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_SYS_TYPES_H_
+#define _FBSD_COMPAT_SYS_TYPES_H_
+
+
+#include <posix/stdint.h>
+#include <posix/sys/types.h>
+
+#include <sys/cdefs.h>
+
+#include <machine/endian.h>
+#include <sys/_types.h>
+
+
+typedef int boolean_t;
+typedef __const char* c_caddr_t;
+typedef uint64_t u_quad_t;
+
+
+#ifdef __POPCNT__
+#define	__bitcount64(x)	__builtin_popcountll((u_int64_t)(x))
+#define	__bitcount32(x)	__builtin_popcount((u_int32_t)(x))
+#define	__bitcount16(x)	__builtin_popcount((u_int16_t)(x))
+#define	__bitcountl(x)	__builtin_popcountl((unsigned long)(x))
+#define	__bitcount(x)	__builtin_popcount((unsigned int)(x))
+#else
+/*
+ * Population count algorithm using SWAR approach
+ * - "SIMD Within A Register".
+ */
+static __inline u_int16_t
+__bitcount16(u_int16_t _x)
+{
+
+	_x = (_x & 0x5555) + ((_x & 0xaaaa) >> 1);
+	_x = (_x & 0x3333) + ((_x & 0xcccc) >> 2);
+	_x = (_x + (_x >> 4)) & 0x0f0f;
+	_x = (_x + (_x >> 8)) & 0x00ff;
+	return (_x);
+}
+
+static __inline u_int32_t
+__bitcount32(u_int32_t _x)
+{
+
+	_x = (_x & 0x55555555) + ((_x & 0xaaaaaaaa) >> 1);
+	_x = (_x & 0x33333333) + ((_x & 0xcccccccc) >> 2);
+	_x = (_x + (_x >> 4)) & 0x0f0f0f0f;
+	_x = (_x + (_x >> 8));
+	_x = (_x + (_x >> 16)) & 0x000000ff;
+	return (_x);
+}
+
+#ifdef __LP64__
+static __inline u_int64_t
+__bitcount64(u_int64_t _x)
+{
+
+	_x = (_x & 0x5555555555555555) + ((_x & 0xaaaaaaaaaaaaaaaa) >> 1);
+	_x = (_x & 0x3333333333333333) + ((_x & 0xcccccccccccccccc) >> 2);
+	_x = (_x + (_x >> 4)) & 0x0f0f0f0f0f0f0f0f;
+	_x = (_x + (_x >> 8));
+	_x = (_x + (_x >> 16));
+	_x = (_x + (_x >> 32)) & 0x000000ff;
+	return (_x);
+}
+
+#define	__bitcountl(x)	__bitcount64((unsigned long)(x))
+#else
+static __inline u_int64_t
+__bitcount64(u_int64_t _x)
+{
+
+	return (__bitcount32(_x >> 32) + __bitcount32(_x));
+}
+
+#define	__bitcountl(x)	__bitcount32((unsigned long)(x))
+#endif
+#define	__bitcount(x)	__bitcount32((unsigned int)(x))
+#endif
+
+
+#endif
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/pmap.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/pmap.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/uma.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/uma.h
new file mode 100644
index 0000000000..5f6b8e9915
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/uma.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_VM_UMA_H_
+#define _FBSD_COMPAT_VM_UMA_H_
+
+
+#include <sys/param.h>
+#include <sys/malloc.h>
+
+#endif /* _FBSD_COMPAT_VM_UMA_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/vm.h b/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/vm.h
new file mode 100644
index 0000000000..56eef91da4
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/compat/vm/vm.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_COMPAT_VM_VM_H_
+#define _FBSD_COMPAT_VM_VM_H_
+
+
+#include <stdint.h>
+#include <KernelExport.h>
+
+
+#ifdef B_HAIKU_64_BIT
+
+typedef uint64_t vm_offset_t;
+typedef uint64_t vm_paddr_t;
+
+#else
+
+typedef uint32_t vm_offset_t;
+typedef uint32_t vm_paddr_t;
+
+#endif
+
+typedef void *pmap_t;
+
+
+#define vmspace_pmap(...)	NULL
+#define pmap_extract(...)	NULL
+
+
+vm_paddr_t pmap_kextract(vm_offset_t virtualAddress);
+
+#define vtophys(virtualAddress) pmap_kextract((vm_offset_t)(virtualAddress))
+
+#endif	/* _FBSD_COMPAT_VM_VM_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem.c b/src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem.c
new file mode 100644
index 0000000000..4372ed4725
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem.c
@@ -0,0 +1,1984 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2012-2014 Thomas Skibo <thomasskibo@yahoo.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * A network interface driver for Cadence GEM Gigabit Ethernet
+ * interface such as the one used in Xilinx Zynq-7000 SoC.
+ *
+ * Reference: Zynq-7000 All Programmable SoC Technical Reference Manual.
+ * (v1.4) November 16, 2012.  Xilinx doc UG585.  GEM is covered in Ch. 16
+ * and register definitions are in appendix B.18.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+
+#include <machine/bus.h>
+
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/if_dl.h>
+#include <net/if_media.h>
+//#include <net/if_mib.h>
+#include <net/if_types.h>
+
+#ifdef INET
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#endif
+
+#include <net/bpf.h>
+//#include <net/bpfdesc.h>
+
+//#include <dev/fdt/fdt_common.h>
+#include <sys/kobj.h>
+#include <dev/ofw/ofw_bus.h>
+#include <dev/ofw/ofw_bus_subr.h>
+
+#include <dev/mii/mii.h>
+#include <dev/mii/miivar.h>
+
+#ifdef EXT_RESOURCES
+#include <dev/extres/clk/clk.h>
+#endif
+
+#if BUS_SPACE_MAXADDR > BUS_SPACE_MAXADDR_32BIT
+#define CGEM64
+#endif
+
+#define fdt32_to_cpu B_BENDIAN_TO_HOST_INT32
+
+#include <dev/cadence/if_cgem_hw.h>
+
+#include "miibus_if.h"
+
+#define IF_CGEM_NAME "cgem"
+
+#define CGEM_NUM_RX_DESCS	512	/* size of receive descriptor ring */
+#define CGEM_NUM_TX_DESCS	512	/* size of transmit descriptor ring */
+
+/* Default for sysctl rxbufs.  Must be < CGEM_NUM_RX_DESCS of course. */
+#define DEFAULT_NUM_RX_BUFS	256	/* number of receive bufs to queue. */
+
+#define TX_MAX_DMA_SEGS		8	/* maximum segs in a tx mbuf dma */
+
+#define CGEM_CKSUM_ASSIST	(CSUM_IP | CSUM_TCP | CSUM_UDP | \
+				 CSUM_TCP_IPV6 | CSUM_UDP_IPV6)
+
+#define HWTYPE_GENERIC_GEM	1
+#define HWTYPE_ZYNQ		2
+#define HWTYPE_ZYNQMP		3
+#define HWTYPE_SIFIVE		4
+
+static struct ofw_compat_data compat_data[] = {
+	{ "cdns,zynq-gem",		HWTYPE_ZYNQ },
+	{ "cdns,zynqmp-gem",		HWTYPE_ZYNQMP },
+	{ "sifive,fu540-c000-gem",	HWTYPE_SIFIVE },
+	{ "sifive,fu740-c000-gem",	HWTYPE_SIFIVE },
+	{ "cdns,gem",			HWTYPE_GENERIC_GEM },
+	{ "cadence,gem",		HWTYPE_GENERIC_GEM },
+	{ NULL,				0 }
+};
+
+struct cgem_softc {
+	if_t			ifp;
+	struct mtx		sc_mtx;
+	device_t		dev;
+	device_t		miibus;
+	u_int			mii_media_active;	/* last active media */
+	int			if_old_flags;
+	struct resource		*mem_res;
+	struct resource		*irq_res;
+	void			*intrhand;
+	struct callout		tick_ch;
+	uint32_t		net_ctl_shadow;
+	uint32_t		net_cfg_shadow;
+#ifdef EXT_RESOURCES
+	clk_t			ref_clk;
+#else
+	int			ref_clk_num;
+#endif
+	int			neednullqs;
+
+	bus_dma_tag_t		desc_dma_tag;
+	bus_dma_tag_t		mbuf_dma_tag;
+
+	/* receive descriptor ring */
+	struct cgem_rx_desc	*rxring;
+	bus_addr_t		rxring_physaddr;
+	struct mbuf		*rxring_m[CGEM_NUM_RX_DESCS];
+	bus_dmamap_t		rxring_m_dmamap[CGEM_NUM_RX_DESCS];
+	int			rxring_hd_ptr;	/* where to put rcv bufs */
+	int			rxring_tl_ptr;	/* where to get receives */
+	int			rxring_queued;	/* how many rcv bufs queued */
+	bus_dmamap_t		rxring_dma_map;
+	int			rxbufs;		/* tunable number rcv bufs */
+	int			rxhangwar;	/* rx hang work-around */
+	u_int			rxoverruns;	/* rx overruns */
+	u_int			rxnobufs;	/* rx buf ring empty events */
+	u_int			rxdmamapfails;	/* rx dmamap failures */
+	uint32_t		rx_frames_prev;
+
+	/* transmit descriptor ring */
+	struct cgem_tx_desc	*txring;
+	bus_addr_t		txring_physaddr;
+	struct mbuf		*txring_m[CGEM_NUM_TX_DESCS];
+	bus_dmamap_t		txring_m_dmamap[CGEM_NUM_TX_DESCS];
+	int			txring_hd_ptr;	/* where to put next xmits */
+	int			txring_tl_ptr;	/* next xmit mbuf to free */
+	int			txring_queued;	/* num xmits segs queued */
+	u_int			txfull;		/* tx ring full events */
+	u_int			txdefrags;	/* tx calls to m_defrag() */
+	u_int			txdefragfails;	/* tx m_defrag() failures */
+	u_int			txdmamapfails;	/* tx dmamap failures */
+
+	/* null descriptor rings */
+	void			*null_qs;
+	bus_addr_t		null_qs_physaddr;
+
+	/* hardware provided statistics */
+	struct cgem_hw_stats {
+		uint64_t		tx_bytes;
+		uint32_t		tx_frames;
+		uint32_t		tx_frames_bcast;
+		uint32_t		tx_frames_multi;
+		uint32_t		tx_frames_pause;
+		uint32_t		tx_frames_64b;
+		uint32_t		tx_frames_65to127b;
+		uint32_t		tx_frames_128to255b;
+		uint32_t		tx_frames_256to511b;
+		uint32_t		tx_frames_512to1023b;
+		uint32_t		tx_frames_1024to1536b;
+		uint32_t		tx_under_runs;
+		uint32_t		tx_single_collisn;
+		uint32_t		tx_multi_collisn;
+		uint32_t		tx_excsv_collisn;
+		uint32_t		tx_late_collisn;
+		uint32_t		tx_deferred_frames;
+		uint32_t		tx_carrier_sense_errs;
+
+		uint64_t		rx_bytes;
+		uint32_t		rx_frames;
+		uint32_t		rx_frames_bcast;
+		uint32_t		rx_frames_multi;
+		uint32_t		rx_frames_pause;
+		uint32_t		rx_frames_64b;
+		uint32_t		rx_frames_65to127b;
+		uint32_t		rx_frames_128to255b;
+		uint32_t		rx_frames_256to511b;
+		uint32_t		rx_frames_512to1023b;
+		uint32_t		rx_frames_1024to1536b;
+		uint32_t		rx_frames_undersize;
+		uint32_t		rx_frames_oversize;
+		uint32_t		rx_frames_jabber;
+		uint32_t		rx_frames_fcs_errs;
+		uint32_t		rx_frames_length_errs;
+		uint32_t		rx_symbol_errs;
+		uint32_t		rx_align_errs;
+		uint32_t		rx_resource_errs;
+		uint32_t		rx_overrun_errs;
+		uint32_t		rx_ip_hdr_csum_errs;
+		uint32_t		rx_tcp_csum_errs;
+		uint32_t		rx_udp_csum_errs;
+	} stats;
+};
+
+#define RD4(sc, off)		(bus_read_4((sc)->mem_res, (off)))
+#define WR4(sc, off, val)	(bus_write_4((sc)->mem_res, (off), (val)))
+#define BARRIER(sc, off, len, flags) \
+	(bus_barrier((sc)->mem_res, (off), (len), (flags))
+
+#define CGEM_LOCK(sc)		mtx_lock(&(sc)->sc_mtx)
+#define CGEM_UNLOCK(sc)		mtx_unlock(&(sc)->sc_mtx)
+#define CGEM_LOCK_INIT(sc)	mtx_init(&(sc)->sc_mtx, \
+	    device_get_nameunit((sc)->dev), MTX_NETWORK_LOCK, MTX_DEF)
+#define CGEM_LOCK_DESTROY(sc)	mtx_destroy(&(sc)->sc_mtx)
+#define CGEM_ASSERT_LOCKED(sc)	mtx_assert(&(sc)->sc_mtx, MA_OWNED)
+
+/* Allow platforms to optionally provide a way to set the reference clock. */
+int cgem_set_ref_clk(int unit, int frequency);
+
+static devclass_t cgem_devclass;
+
+static int cgem_probe(device_t dev);
+static int cgem_attach(device_t dev);
+static int cgem_detach(device_t dev);
+static void cgem_tick(void *);
+static void cgem_intr(void *);
+
+static void cgem_mediachange(struct cgem_softc *, struct mii_data *);
+
+static void
+cgem_get_mac(struct cgem_softc *sc, u_char eaddr[])
+{
+	int i;
+	uint32_t rnd;
+
+	/* See if boot loader gave us a MAC address already. */
+	for (i = 0; i < 4; i++) {
+		uint32_t low = RD4(sc, CGEM_SPEC_ADDR_LOW(i));
+		uint32_t high = RD4(sc, CGEM_SPEC_ADDR_HI(i)) & 0xffff;
+		if (low != 0 || high != 0) {
+			eaddr[0] = low & 0xff;
+			eaddr[1] = (low >> 8) & 0xff;
+			eaddr[2] = (low >> 16) & 0xff;
+			eaddr[3] = (low >> 24) & 0xff;
+			eaddr[4] = high & 0xff;
+			eaddr[5] = (high >> 8) & 0xff;
+			break;
+		}
+	}
+
+	/* No MAC from boot loader?  Assign a random one. */
+	if (i == 4) {
+		rnd = arc4random();
+
+		eaddr[0] = 'b';
+		eaddr[1] = 's';
+		eaddr[2] = 'd';
+		eaddr[3] = (rnd >> 16) & 0xff;
+		eaddr[4] = (rnd >> 8) & 0xff;
+		eaddr[5] = rnd & 0xff;
+
+		device_printf(sc->dev, "no mac address found, assigning "
+		    "random: %02x:%02x:%02x:%02x:%02x:%02x\n", eaddr[0],
+		    eaddr[1], eaddr[2], eaddr[3], eaddr[4], eaddr[5]);
+	}
+
+	/* Move address to first slot and zero out the rest. */
+	WR4(sc, CGEM_SPEC_ADDR_LOW(0), (eaddr[3] << 24) |
+	    (eaddr[2] << 16) | (eaddr[1] << 8) | eaddr[0]);
+	WR4(sc, CGEM_SPEC_ADDR_HI(0), (eaddr[5] << 8) | eaddr[4]);
+
+	for (i = 1; i < 4; i++) {
+		WR4(sc, CGEM_SPEC_ADDR_LOW(i), 0);
+		WR4(sc, CGEM_SPEC_ADDR_HI(i), 0);
+	}
+}
+
+/*
+ * cgem_mac_hash():  map 48-bit address to a 6-bit hash. The 6-bit hash
+ * corresponds to a bit in a 64-bit hash register.  Setting that bit in the
+ * hash register enables reception of all frames with a destination address
+ * that hashes to that 6-bit value.
+ *
+ * The hash function is described in sec. 16.2.3 in the Zynq-7000 Tech
+ * Reference Manual.  Bits 0-5 in the hash are the exclusive-or of
+ * every sixth bit in the destination address.
+ */
+static int
+cgem_mac_hash(u_char eaddr[])
+{
+	int hash;
+	int i, j;
+
+	hash = 0;
+	for (i = 0; i < 6; i++)
+		for (j = i; j < 48; j += 6)
+			if ((eaddr[j >> 3] & (1 << (j & 7))) != 0)
+				hash ^= (1 << i);
+
+	return hash;
+}
+
+static u_int
+cgem_hash_maddr(void *arg, struct sockaddr_dl *sdl, u_int cnt)
+{
+	uint32_t *hashes = arg;
+	int index;
+
+	index = cgem_mac_hash(LLADDR(sdl));
+	if (index > 31)
+		hashes[0] |= (1U << (index - 32));
+	else
+		hashes[1] |= (1U << index);
+
+	return (1);
+}
+
+/*
+ * After any change in rx flags or multi-cast addresses, set up hash registers
+ * and net config register bits.
+ */
+static void
+cgem_rx_filter(struct cgem_softc *sc)
+{
+	if_t ifp = sc->ifp;
+	uint32_t hashes[2] = { 0, 0 };
+
+	sc->net_cfg_shadow &= ~(CGEM_NET_CFG_MULTI_HASH_EN |
+	    CGEM_NET_CFG_NO_BCAST | CGEM_NET_CFG_COPY_ALL);
+
+	if ((if_getflags(ifp) & IFF_PROMISC) != 0)
+		sc->net_cfg_shadow |= CGEM_NET_CFG_COPY_ALL;
+	else {
+		if ((if_getflags(ifp) & IFF_BROADCAST) == 0)
+			sc->net_cfg_shadow |= CGEM_NET_CFG_NO_BCAST;
+		if ((if_getflags(ifp) & IFF_ALLMULTI) != 0) {
+			hashes[0] = 0xffffffff;
+			hashes[1] = 0xffffffff;
+		} else
+			if_foreach_llmaddr(ifp, cgem_hash_maddr, hashes);
+
+		if (hashes[0] != 0 || hashes[1] != 0)
+			sc->net_cfg_shadow |= CGEM_NET_CFG_MULTI_HASH_EN;
+	}
+
+	WR4(sc, CGEM_HASH_TOP, hashes[0]);
+	WR4(sc, CGEM_HASH_BOT, hashes[1]);
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+}
+
+/* For bus_dmamap_load() callback. */
+static void
+cgem_getaddr(void *arg, bus_dma_segment_t *segs, int nsegs, int error)
+{
+
+	if (nsegs != 1 || error != 0)
+		return;
+	*(bus_addr_t *)arg = segs[0].ds_addr;
+}
+
+/* Set up null queues for priority queues we actually can't disable. */
+static void
+cgem_null_qs(struct cgem_softc *sc)
+{
+	struct cgem_rx_desc *rx_desc;
+	struct cgem_tx_desc *tx_desc;
+	uint32_t queue_mask;
+	int n;
+
+	/* Read design config register 6 to determine number of queues. */
+	queue_mask = (RD4(sc, CGEM_DESIGN_CFG6) &
+	    CGEM_DESIGN_CFG6_DMA_PRIO_Q_MASK) >> 1;
+	if (queue_mask == 0)
+		return;
+
+	/* Create empty RX queue and empty TX buf queues. */
+	memset(sc->null_qs, 0, sizeof(struct cgem_rx_desc) +
+	    sizeof(struct cgem_tx_desc));
+	rx_desc = sc->null_qs;
+	rx_desc->addr = CGEM_RXDESC_OWN | CGEM_RXDESC_WRAP;
+	tx_desc = (struct cgem_tx_desc *)(rx_desc + 1);
+	tx_desc->ctl = CGEM_TXDESC_USED | CGEM_TXDESC_WRAP;
+
+	/* Point all valid ring base pointers to the null queues. */
+	for (n = 1; (queue_mask & 1) != 0; n++, queue_mask >>= 1) {
+		WR4(sc, CGEM_RX_QN_BAR(n), sc->null_qs_physaddr);
+		WR4(sc, CGEM_TX_QN_BAR(n), sc->null_qs_physaddr +
+		    sizeof(struct cgem_rx_desc));
+	}
+}
+
+/* Create DMA'able descriptor rings. */
+static int
+cgem_setup_descs(struct cgem_softc *sc)
+{
+	int i, err;
+	int desc_rings_size = CGEM_NUM_RX_DESCS * sizeof(struct cgem_rx_desc) +
+	    CGEM_NUM_TX_DESCS * sizeof(struct cgem_tx_desc);
+
+	if (sc->neednullqs)
+		desc_rings_size += sizeof(struct cgem_rx_desc) +
+		    sizeof(struct cgem_tx_desc);
+
+	sc->txring = NULL;
+	sc->rxring = NULL;
+
+	/* Allocate non-cached DMA space for RX and TX descriptors. */
+	err = bus_dma_tag_create(bus_get_dma_tag(sc->dev), 1,
+#ifdef CGEM64
+	    1ULL << 32,	/* Do not cross a 4G boundary. */
+#else
+	    0,
+#endif
+	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,
+	    desc_rings_size, 1, desc_rings_size, 0,
+	    busdma_lock_mutex, &sc->sc_mtx, &sc->desc_dma_tag);
+	if (err)
+		return (err);
+
+	/* Set up a bus_dma_tag for mbufs. */
+	err = bus_dma_tag_create(bus_get_dma_tag(sc->dev), 1, 0,
+	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES,
+	    TX_MAX_DMA_SEGS, MCLBYTES, 0, busdma_lock_mutex, &sc->sc_mtx,
+	    &sc->mbuf_dma_tag);
+	if (err)
+		return (err);
+
+	/*
+	 * Allocate DMA memory. We allocate transmit, receive and null
+	 * descriptor queues all at once because the hardware only provides
+	 * one register for the upper 32 bits of rx and tx descriptor queues
+	 * hardware addresses.
+	 */
+	err = bus_dmamem_alloc(sc->desc_dma_tag, (void **)&sc->rxring,
+	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT | BUS_DMA_ZERO,
+	    &sc->rxring_dma_map);
+	if (err)
+		return (err);
+
+	/* Load descriptor DMA memory. */
+	err = bus_dmamap_load(sc->desc_dma_tag, sc->rxring_dma_map,
+	    (void *)sc->rxring, desc_rings_size,
+	    cgem_getaddr, &sc->rxring_physaddr, BUS_DMA_NOWAIT);
+	if (err)
+		return (err);
+
+	/* Initialize RX descriptors. */
+	for (i = 0; i < CGEM_NUM_RX_DESCS; i++) {
+		sc->rxring[i].addr = CGEM_RXDESC_OWN;
+		sc->rxring[i].ctl = 0;
+		sc->rxring_m[i] = NULL;
+		sc->rxring_m_dmamap[i] = NULL;
+	}
+	sc->rxring[CGEM_NUM_RX_DESCS - 1].addr |= CGEM_RXDESC_WRAP;
+
+	sc->rxring_hd_ptr = 0;
+	sc->rxring_tl_ptr = 0;
+	sc->rxring_queued = 0;
+
+	sc->txring = (struct cgem_tx_desc *)(sc->rxring + CGEM_NUM_RX_DESCS);
+	sc->txring_physaddr = sc->rxring_physaddr + CGEM_NUM_RX_DESCS *
+	    sizeof(struct cgem_rx_desc);
+
+	/* Initialize TX descriptor ring. */
+	for (i = 0; i < CGEM_NUM_TX_DESCS; i++) {
+		sc->txring[i].addr = 0;
+		sc->txring[i].ctl = CGEM_TXDESC_USED;
+		sc->txring_m[i] = NULL;
+		sc->txring_m_dmamap[i] = NULL;
+	}
+	sc->txring[CGEM_NUM_TX_DESCS - 1].ctl |= CGEM_TXDESC_WRAP;
+
+	sc->txring_hd_ptr = 0;
+	sc->txring_tl_ptr = 0;
+	sc->txring_queued = 0;
+
+	if (sc->neednullqs) {
+		sc->null_qs = (void *)(sc->txring + CGEM_NUM_TX_DESCS);
+		sc->null_qs_physaddr = sc->txring_physaddr +
+		    CGEM_NUM_TX_DESCS * sizeof(struct cgem_tx_desc);
+
+		cgem_null_qs(sc);
+	}
+
+	return (0);
+}
+
+/* Fill receive descriptor ring with mbufs. */
+static void
+cgem_fill_rqueue(struct cgem_softc *sc)
+{
+	struct mbuf *m = NULL;
+	bus_dma_segment_t segs[TX_MAX_DMA_SEGS];
+	int nsegs;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	while (sc->rxring_queued < sc->rxbufs) {
+		/* Get a cluster mbuf. */
+		m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);
+		if (m == NULL)
+			break;
+
+		m->m_len = MCLBYTES;
+		m->m_pkthdr.len = MCLBYTES;
+		m->m_pkthdr.rcvif = sc->ifp;
+
+		/* Load map and plug in physical address. */
+		if (bus_dmamap_create(sc->mbuf_dma_tag, 0,
+		    &sc->rxring_m_dmamap[sc->rxring_hd_ptr])) {
+			sc->rxdmamapfails++;
+			m_free(m);
+			break;
+		}
+		if (bus_dmamap_load_mbuf_sg(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_hd_ptr], m,
+		    segs, &nsegs, BUS_DMA_NOWAIT)) {
+			sc->rxdmamapfails++;
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+				   sc->rxring_m_dmamap[sc->rxring_hd_ptr]);
+			sc->rxring_m_dmamap[sc->rxring_hd_ptr] = NULL;
+			m_free(m);
+			break;
+		}
+		sc->rxring_m[sc->rxring_hd_ptr] = m;
+
+		/* Sync cache with receive buffer. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_hd_ptr],
+		    BUS_DMASYNC_PREREAD);
+
+		/* Write rx descriptor and increment head pointer. */
+		sc->rxring[sc->rxring_hd_ptr].ctl = 0;
+#ifdef CGEM64
+		sc->rxring[sc->rxring_hd_ptr].addrhi = segs[0].ds_addr >> 32;
+#endif
+		if (sc->rxring_hd_ptr == CGEM_NUM_RX_DESCS - 1) {
+			sc->rxring[sc->rxring_hd_ptr].addr = segs[0].ds_addr |
+			    CGEM_RXDESC_WRAP;
+			sc->rxring_hd_ptr = 0;
+		} else
+			sc->rxring[sc->rxring_hd_ptr++].addr = segs[0].ds_addr;
+
+		sc->rxring_queued++;
+	}
+}
+
+/* Pull received packets off of receive descriptor ring. */
+static void
+cgem_recv(struct cgem_softc *sc)
+{
+	if_t ifp = sc->ifp;
+	struct mbuf *m, *m_hd, **m_tl;
+	uint32_t ctl;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Pick up all packets in which the OWN bit is set. */
+	m_hd = NULL;
+	m_tl = &m_hd;
+	while (sc->rxring_queued > 0 &&
+	    (sc->rxring[sc->rxring_tl_ptr].addr & CGEM_RXDESC_OWN) != 0) {
+		ctl = sc->rxring[sc->rxring_tl_ptr].ctl;
+
+		/* Grab filled mbuf. */
+		m = sc->rxring_m[sc->rxring_tl_ptr];
+		sc->rxring_m[sc->rxring_tl_ptr] = NULL;
+
+		/* Sync cache with receive buffer. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_tl_ptr],
+		    BUS_DMASYNC_POSTREAD);
+
+		/* Unload and destroy dmamap. */
+		bus_dmamap_unload(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_tl_ptr]);
+		bus_dmamap_destroy(sc->mbuf_dma_tag,
+		    sc->rxring_m_dmamap[sc->rxring_tl_ptr]);
+		sc->rxring_m_dmamap[sc->rxring_tl_ptr] = NULL;
+
+		/* Increment tail pointer. */
+		if (++sc->rxring_tl_ptr == CGEM_NUM_RX_DESCS)
+			sc->rxring_tl_ptr = 0;
+		sc->rxring_queued--;
+
+		/*
+		 * Check FCS and make sure entire packet landed in one mbuf
+		 * cluster (which is much bigger than the largest ethernet
+		 * packet).
+		 */
+		if ((ctl & CGEM_RXDESC_BAD_FCS) != 0 ||
+		    (ctl & (CGEM_RXDESC_SOF | CGEM_RXDESC_EOF)) !=
+		    (CGEM_RXDESC_SOF | CGEM_RXDESC_EOF)) {
+			/* discard. */
+			m_free(m);
+			if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);
+			continue;
+		}
+
+		/* Ready it to hand off to upper layers. */
+		m->m_data += ETHER_ALIGN;
+		m->m_len = (ctl & CGEM_RXDESC_LENGTH_MASK);
+		m->m_pkthdr.rcvif = ifp;
+		m->m_pkthdr.len = m->m_len;
+
+		/*
+		 * Are we using hardware checksumming?  Check the status in the
+		 * receive descriptor.
+		 */
+		if ((if_getcapenable(ifp) & IFCAP_RXCSUM) != 0) {
+			/* TCP or UDP checks out, IP checks out too. */
+			if ((ctl & CGEM_RXDESC_CKSUM_STAT_MASK) ==
+			    CGEM_RXDESC_CKSUM_STAT_TCP_GOOD ||
+			    (ctl & CGEM_RXDESC_CKSUM_STAT_MASK) ==
+			    CGEM_RXDESC_CKSUM_STAT_UDP_GOOD) {
+				m->m_pkthdr.csum_flags |=
+				    CSUM_IP_CHECKED | CSUM_IP_VALID |
+				    CSUM_DATA_VALID | CSUM_PSEUDO_HDR;
+				m->m_pkthdr.csum_data = 0xffff;
+			} else if ((ctl & CGEM_RXDESC_CKSUM_STAT_MASK) ==
+			    CGEM_RXDESC_CKSUM_STAT_IP_GOOD) {
+				/* Only IP checks out. */
+				m->m_pkthdr.csum_flags |=
+				    CSUM_IP_CHECKED | CSUM_IP_VALID;
+				m->m_pkthdr.csum_data = 0xffff;
+			}
+		}
+
+		/* Queue it up for delivery below. */
+		*m_tl = m;
+		m_tl = &m->m_next;
+	}
+
+	/* Replenish receive buffers. */
+	cgem_fill_rqueue(sc);
+
+	/* Unlock and send up packets. */
+	CGEM_UNLOCK(sc);
+	while (m_hd != NULL) {
+		m = m_hd;
+		m_hd = m_hd->m_next;
+		m->m_next = NULL;
+		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);
+		if_input(ifp, m);
+	}
+	CGEM_LOCK(sc);
+}
+
+/* Find completed transmits and free their mbufs. */
+static void
+cgem_clean_tx(struct cgem_softc *sc)
+{
+	struct mbuf *m;
+	uint32_t ctl;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* free up finished transmits. */
+	while (sc->txring_queued > 0 &&
+	    ((ctl = sc->txring[sc->txring_tl_ptr].ctl) &
+	    CGEM_TXDESC_USED) != 0) {
+		/* Sync cache. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_tl_ptr],
+		    BUS_DMASYNC_POSTWRITE);
+
+		/* Unload and destroy DMA map. */
+		bus_dmamap_unload(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_tl_ptr]);
+		bus_dmamap_destroy(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_tl_ptr]);
+		sc->txring_m_dmamap[sc->txring_tl_ptr] = NULL;
+
+		/* Free up the mbuf. */
+		m = sc->txring_m[sc->txring_tl_ptr];
+		sc->txring_m[sc->txring_tl_ptr] = NULL;
+		m_freem(m);
+
+		/* Check the status. */
+		if ((ctl & CGEM_TXDESC_AHB_ERR) != 0) {
+			/* Serious bus error. log to console. */
+#ifdef CGEM64
+			device_printf(sc->dev,
+			    "cgem_clean_tx: AHB error, addr=0x%x%08x\n",
+			    sc->txring[sc->txring_tl_ptr].addrhi,
+			    sc->txring[sc->txring_tl_ptr].addr);
+#else
+			device_printf(sc->dev,
+			    "cgem_clean_tx: AHB error, addr=0x%x\n",
+			    sc->txring[sc->txring_tl_ptr].addr);
+#endif
+		} else if ((ctl & (CGEM_TXDESC_RETRY_ERR |
+		    CGEM_TXDESC_LATE_COLL)) != 0) {
+			if_inc_counter(sc->ifp, IFCOUNTER_OERRORS, 1);
+		} else
+			if_inc_counter(sc->ifp, IFCOUNTER_OPACKETS, 1);
+
+		/*
+		 * If the packet spanned more than one tx descriptor, skip
+		 * descriptors until we find the end so that only
+		 * start-of-frame descriptors are processed.
+		 */
+		while ((ctl & CGEM_TXDESC_LAST_BUF) == 0) {
+			if ((ctl & CGEM_TXDESC_WRAP) != 0)
+				sc->txring_tl_ptr = 0;
+			else
+				sc->txring_tl_ptr++;
+			sc->txring_queued--;
+
+			ctl = sc->txring[sc->txring_tl_ptr].ctl;
+
+			sc->txring[sc->txring_tl_ptr].ctl =
+			    ctl | CGEM_TXDESC_USED;
+		}
+
+		/* Next descriptor. */
+		if ((ctl & CGEM_TXDESC_WRAP) != 0)
+			sc->txring_tl_ptr = 0;
+		else
+			sc->txring_tl_ptr++;
+		sc->txring_queued--;
+
+		if_setdrvflagbits(sc->ifp, 0, IFF_DRV_OACTIVE);
+	}
+}
+
+/* Start transmits. */
+static void
+cgem_start_locked(if_t ifp)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+	struct mbuf *m;
+	bus_dma_segment_t segs[TX_MAX_DMA_SEGS];
+	uint32_t ctl;
+	int i, nsegs, wrap, err;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((if_getdrvflags(ifp) & IFF_DRV_OACTIVE) != 0)
+		return;
+
+	for (;;) {
+		/* Check that there is room in the descriptor ring. */
+		if (sc->txring_queued >=
+		    CGEM_NUM_TX_DESCS - TX_MAX_DMA_SEGS * 2) {
+			/* Try to make room. */
+			cgem_clean_tx(sc);
+
+			/* Still no room? */
+			if (sc->txring_queued >=
+			    CGEM_NUM_TX_DESCS - TX_MAX_DMA_SEGS * 2) {
+				if_setdrvflagbits(ifp, IFF_DRV_OACTIVE, 0);
+				sc->txfull++;
+				break;
+			}
+		}
+
+		/* Grab next transmit packet. */
+		m = if_dequeue(ifp);
+		if (m == NULL)
+			break;
+
+		/* Create and load DMA map. */
+		if (bus_dmamap_create(sc->mbuf_dma_tag, 0,
+			&sc->txring_m_dmamap[sc->txring_hd_ptr])) {
+			m_freem(m);
+			sc->txdmamapfails++;
+			continue;
+		}
+		err = bus_dmamap_load_mbuf_sg(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_hd_ptr], m, segs, &nsegs,
+		    BUS_DMA_NOWAIT);
+		if (err == EFBIG) {
+			/* Too many segments!  defrag and try again. */
+			struct mbuf *m2 = m_defrag(m, M_NOWAIT);
+
+			if (m2 == NULL) {
+				sc->txdefragfails++;
+				m_freem(m);
+				bus_dmamap_destroy(sc->mbuf_dma_tag,
+				    sc->txring_m_dmamap[sc->txring_hd_ptr]);
+				sc->txring_m_dmamap[sc->txring_hd_ptr] = NULL;
+				continue;
+			}
+			m = m2;
+			err = bus_dmamap_load_mbuf_sg(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[sc->txring_hd_ptr], m, segs,
+			    &nsegs, BUS_DMA_NOWAIT);
+			sc->txdefrags++;
+		}
+		if (err) {
+			/* Give up. */
+			m_freem(m);
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[sc->txring_hd_ptr]);
+			sc->txring_m_dmamap[sc->txring_hd_ptr] = NULL;
+			sc->txdmamapfails++;
+			continue;
+		}
+		sc->txring_m[sc->txring_hd_ptr] = m;
+
+		/* Sync tx buffer with cache. */
+		bus_dmamap_sync(sc->mbuf_dma_tag,
+		    sc->txring_m_dmamap[sc->txring_hd_ptr],
+		    BUS_DMASYNC_PREWRITE);
+
+		/* Set wrap flag if next packet might run off end of ring. */
+		wrap = sc->txring_hd_ptr + nsegs + TX_MAX_DMA_SEGS >=
+		    CGEM_NUM_TX_DESCS;
+
+		/*
+		 * Fill in the TX descriptors back to front so that USED bit in
+		 * first descriptor is cleared last.
+		 */
+		for (i = nsegs - 1; i >= 0; i--) {
+			/* Descriptor address. */
+			sc->txring[sc->txring_hd_ptr + i].addr =
+			    segs[i].ds_addr;
+#ifdef CGEM64
+			sc->txring[sc->txring_hd_ptr + i].addrhi =
+			    segs[i].ds_addr >> 32;
+#endif
+			/* Descriptor control word. */
+			ctl = segs[i].ds_len;
+			if (i == nsegs - 1) {
+				ctl |= CGEM_TXDESC_LAST_BUF;
+				if (wrap)
+					ctl |= CGEM_TXDESC_WRAP;
+			}
+			sc->txring[sc->txring_hd_ptr + i].ctl = ctl;
+
+			if (i != 0)
+				sc->txring_m[sc->txring_hd_ptr + i] = NULL;
+		}
+
+		if (wrap)
+			sc->txring_hd_ptr = 0;
+		else
+			sc->txring_hd_ptr += nsegs;
+		sc->txring_queued += nsegs;
+
+		/* Kick the transmitter. */
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow |
+		    CGEM_NET_CTRL_START_TX);
+
+		/* If there is a BPF listener, bounce a copy to him. */
+		ETHER_BPF_MTAP(ifp, m);
+	}
+}
+
+static void
+cgem_start(if_t ifp)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+
+	CGEM_LOCK(sc);
+	cgem_start_locked(ifp);
+	CGEM_UNLOCK(sc);
+}
+
+static void
+cgem_poll_hw_stats(struct cgem_softc *sc)
+{
+	uint32_t n;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	sc->stats.tx_bytes += RD4(sc, CGEM_OCTETS_TX_BOT);
+	sc->stats.tx_bytes += (uint64_t)RD4(sc, CGEM_OCTETS_TX_TOP) << 32;
+
+	sc->stats.tx_frames += RD4(sc, CGEM_FRAMES_TX);
+	sc->stats.tx_frames_bcast += RD4(sc, CGEM_BCAST_FRAMES_TX);
+	sc->stats.tx_frames_multi += RD4(sc, CGEM_MULTI_FRAMES_TX);
+	sc->stats.tx_frames_pause += RD4(sc, CGEM_PAUSE_FRAMES_TX);
+	sc->stats.tx_frames_64b += RD4(sc, CGEM_FRAMES_64B_TX);
+	sc->stats.tx_frames_65to127b += RD4(sc, CGEM_FRAMES_65_127B_TX);
+	sc->stats.tx_frames_128to255b += RD4(sc, CGEM_FRAMES_128_255B_TX);
+	sc->stats.tx_frames_256to511b += RD4(sc, CGEM_FRAMES_256_511B_TX);
+	sc->stats.tx_frames_512to1023b += RD4(sc, CGEM_FRAMES_512_1023B_TX);
+	sc->stats.tx_frames_1024to1536b += RD4(sc, CGEM_FRAMES_1024_1518B_TX);
+	sc->stats.tx_under_runs += RD4(sc, CGEM_TX_UNDERRUNS);
+
+	n = RD4(sc, CGEM_SINGLE_COLL_FRAMES);
+	sc->stats.tx_single_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+	n = RD4(sc, CGEM_MULTI_COLL_FRAMES);
+	sc->stats.tx_multi_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+	n = RD4(sc, CGEM_EXCESSIVE_COLL_FRAMES);
+	sc->stats.tx_excsv_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+	n = RD4(sc, CGEM_LATE_COLL);
+	sc->stats.tx_late_collisn += n;
+	if_inc_counter(sc->ifp, IFCOUNTER_COLLISIONS, n);
+
+	sc->stats.tx_deferred_frames += RD4(sc, CGEM_DEFERRED_TX_FRAMES);
+	sc->stats.tx_carrier_sense_errs += RD4(sc, CGEM_CARRIER_SENSE_ERRS);
+
+	sc->stats.rx_bytes += RD4(sc, CGEM_OCTETS_RX_BOT);
+	sc->stats.rx_bytes += (uint64_t)RD4(sc, CGEM_OCTETS_RX_TOP) << 32;
+
+	sc->stats.rx_frames += RD4(sc, CGEM_FRAMES_RX);
+	sc->stats.rx_frames_bcast += RD4(sc, CGEM_BCAST_FRAMES_RX);
+	sc->stats.rx_frames_multi += RD4(sc, CGEM_MULTI_FRAMES_RX);
+	sc->stats.rx_frames_pause += RD4(sc, CGEM_PAUSE_FRAMES_RX);
+	sc->stats.rx_frames_64b += RD4(sc, CGEM_FRAMES_64B_RX);
+	sc->stats.rx_frames_65to127b += RD4(sc, CGEM_FRAMES_65_127B_RX);
+	sc->stats.rx_frames_128to255b += RD4(sc, CGEM_FRAMES_128_255B_RX);
+	sc->stats.rx_frames_256to511b += RD4(sc, CGEM_FRAMES_256_511B_RX);
+	sc->stats.rx_frames_512to1023b += RD4(sc, CGEM_FRAMES_512_1023B_RX);
+	sc->stats.rx_frames_1024to1536b += RD4(sc, CGEM_FRAMES_1024_1518B_RX);
+	sc->stats.rx_frames_undersize += RD4(sc, CGEM_UNDERSZ_RX);
+	sc->stats.rx_frames_oversize += RD4(sc, CGEM_OVERSZ_RX);
+	sc->stats.rx_frames_jabber += RD4(sc, CGEM_JABBERS_RX);
+	sc->stats.rx_frames_fcs_errs += RD4(sc, CGEM_FCS_ERRS);
+	sc->stats.rx_frames_length_errs += RD4(sc, CGEM_LENGTH_FIELD_ERRS);
+	sc->stats.rx_symbol_errs += RD4(sc, CGEM_RX_SYMBOL_ERRS);
+	sc->stats.rx_align_errs += RD4(sc, CGEM_ALIGN_ERRS);
+	sc->stats.rx_resource_errs += RD4(sc, CGEM_RX_RESOURCE_ERRS);
+	sc->stats.rx_overrun_errs += RD4(sc, CGEM_RX_OVERRUN_ERRS);
+	sc->stats.rx_ip_hdr_csum_errs += RD4(sc, CGEM_IP_HDR_CKSUM_ERRS);
+	sc->stats.rx_tcp_csum_errs += RD4(sc, CGEM_TCP_CKSUM_ERRS);
+	sc->stats.rx_udp_csum_errs += RD4(sc, CGEM_UDP_CKSUM_ERRS);
+}
+
+static void
+cgem_tick(void *arg)
+{
+	struct cgem_softc *sc = (struct cgem_softc *)arg;
+	struct mii_data *mii;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Poll the phy. */
+	if (sc->miibus != NULL) {
+		mii = device_get_softc(sc->miibus);
+		mii_tick(mii);
+	}
+
+	/* Poll statistics registers. */
+	cgem_poll_hw_stats(sc);
+
+	/* Check for receiver hang. */
+	if (sc->rxhangwar && sc->rx_frames_prev == sc->stats.rx_frames) {
+		/*
+		 * Reset receiver logic by toggling RX_EN bit.  1usec
+		 * delay is necessary especially when operating at 100mbps
+		 * and 10mbps speeds.
+		 */
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow &
+		    ~CGEM_NET_CTRL_RX_EN);
+		DELAY(1);
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow);
+	}
+	sc->rx_frames_prev = sc->stats.rx_frames;
+
+	/* Next callout in one second. */
+	callout_reset(&sc->tick_ch, hz, cgem_tick, sc);
+}
+
+/* Interrupt handler. */
+static void
+cgem_intr(void *arg)
+{
+	struct cgem_softc *sc = (struct cgem_softc *)arg;
+	if_t ifp = sc->ifp;
+	uint32_t istatus;
+
+	CGEM_LOCK(sc);
+
+	if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) == 0) {
+		CGEM_UNLOCK(sc);
+		return;
+	}
+
+	/* Read interrupt status and immediately clear the bits. */
+	istatus = RD4(sc, CGEM_INTR_STAT);
+	WR4(sc, CGEM_INTR_STAT, istatus);
+
+	/* Packets received. */
+	if ((istatus & CGEM_INTR_RX_COMPLETE) != 0)
+		cgem_recv(sc);
+
+	/* Free up any completed transmit buffers. */
+	cgem_clean_tx(sc);
+
+	/* Hresp not ok.  Something is very bad with DMA.  Try to clear. */
+	if ((istatus & CGEM_INTR_HRESP_NOT_OK) != 0) {
+		device_printf(sc->dev,
+		    "cgem_intr: hresp not okay! rx_status=0x%x\n",
+		    RD4(sc, CGEM_RX_STAT));
+		WR4(sc, CGEM_RX_STAT, CGEM_RX_STAT_HRESP_NOT_OK);
+	}
+
+	/* Receiver overrun. */
+	if ((istatus & CGEM_INTR_RX_OVERRUN) != 0) {
+		/* Clear status bit. */
+		WR4(sc, CGEM_RX_STAT, CGEM_RX_STAT_OVERRUN);
+		sc->rxoverruns++;
+	}
+
+	/* Receiver ran out of bufs. */
+	if ((istatus & CGEM_INTR_RX_USED_READ) != 0) {
+		WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow |
+		    CGEM_NET_CTRL_FLUSH_DPRAM_PKT);
+		cgem_fill_rqueue(sc);
+		sc->rxnobufs++;
+	}
+
+	/* Restart transmitter if needed. */
+	if (!if_sendq_empty(ifp))
+		cgem_start_locked(ifp);
+
+	CGEM_UNLOCK(sc);
+}
+
+/* Reset hardware. */
+static void
+cgem_reset(struct cgem_softc *sc)
+{
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Determine data bus width from design configuration register. */
+	switch (RD4(sc, CGEM_DESIGN_CFG1) &
+	    CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_MASK) {
+	case CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_64:
+		sc->net_cfg_shadow = CGEM_NET_CFG_DBUS_WIDTH_64;
+		break;
+	case CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_128:
+		sc->net_cfg_shadow = CGEM_NET_CFG_DBUS_WIDTH_128;
+		break;
+	default:
+		sc->net_cfg_shadow = CGEM_NET_CFG_DBUS_WIDTH_32;
+	}
+
+	WR4(sc, CGEM_NET_CTRL, 0);
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+	WR4(sc, CGEM_NET_CTRL, CGEM_NET_CTRL_CLR_STAT_REGS);
+	WR4(sc, CGEM_TX_STAT, CGEM_TX_STAT_ALL);
+	WR4(sc, CGEM_RX_STAT, CGEM_RX_STAT_ALL);
+	WR4(sc, CGEM_INTR_DIS, CGEM_INTR_ALL);
+	WR4(sc, CGEM_HASH_BOT, 0);
+	WR4(sc, CGEM_HASH_TOP, 0);
+	WR4(sc, CGEM_TX_QBAR, 0);	/* manual says do this. */
+	WR4(sc, CGEM_RX_QBAR, 0);
+
+	/* Get management port running even if interface is down. */
+	sc->net_cfg_shadow |= CGEM_NET_CFG_MDC_CLK_DIV_48;
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+
+	sc->net_ctl_shadow = CGEM_NET_CTRL_MGMT_PORT_EN;
+	WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow);
+}
+
+/* Bring up the hardware. */
+static void
+cgem_config(struct cgem_softc *sc)
+{
+	if_t ifp = sc->ifp;
+	uint32_t dma_cfg;
+	u_char *eaddr = if_getlladdr(ifp);
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Program Net Config Register. */
+	sc->net_cfg_shadow &= (CGEM_NET_CFG_MDC_CLK_DIV_MASK |
+	    CGEM_NET_CFG_DBUS_WIDTH_MASK);
+	sc->net_cfg_shadow |= (CGEM_NET_CFG_FCS_REMOVE |
+	    CGEM_NET_CFG_RX_BUF_OFFSET(ETHER_ALIGN) |
+	    CGEM_NET_CFG_GIGE_EN | CGEM_NET_CFG_1536RXEN |
+	    CGEM_NET_CFG_FULL_DUPLEX | CGEM_NET_CFG_SPEED100);
+
+	/* Enable receive checksum offloading? */
+	if ((if_getcapenable(ifp) & IFCAP_RXCSUM) != 0)
+		sc->net_cfg_shadow |=  CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN;
+
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+
+	/* Program DMA Config Register. */
+	dma_cfg = CGEM_DMA_CFG_RX_BUF_SIZE(MCLBYTES) |
+	    CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_8K |
+	    CGEM_DMA_CFG_TX_PKTBUF_MEMSZ_SEL |
+	    CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_16 |
+#ifdef CGEM64
+	    CGEM_DMA_CFG_ADDR_BUS_64 |
+#endif
+	    CGEM_DMA_CFG_DISC_WHEN_NO_AHB;
+
+	/* Enable transmit checksum offloading? */
+	if ((if_getcapenable(ifp) & IFCAP_TXCSUM) != 0)
+		dma_cfg |= CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN;
+
+	WR4(sc, CGEM_DMA_CFG, dma_cfg);
+
+	/* Write the rx and tx descriptor ring addresses to the QBAR regs. */
+	WR4(sc, CGEM_RX_QBAR, (uint32_t)sc->rxring_physaddr);
+	WR4(sc, CGEM_TX_QBAR, (uint32_t)sc->txring_physaddr);
+#ifdef CGEM64
+	WR4(sc, CGEM_RX_QBAR_HI, (uint32_t)(sc->rxring_physaddr >> 32));
+	WR4(sc, CGEM_TX_QBAR_HI, (uint32_t)(sc->txring_physaddr >> 32));
+#endif
+
+	/* Enable rx and tx. */
+	sc->net_ctl_shadow |= (CGEM_NET_CTRL_TX_EN | CGEM_NET_CTRL_RX_EN);
+	WR4(sc, CGEM_NET_CTRL, sc->net_ctl_shadow);
+
+	/* Set receive address in case it changed. */
+	WR4(sc, CGEM_SPEC_ADDR_LOW(0), (eaddr[3] << 24) |
+	    (eaddr[2] << 16) | (eaddr[1] << 8) | eaddr[0]);
+	WR4(sc, CGEM_SPEC_ADDR_HI(0), (eaddr[5] << 8) | eaddr[4]);
+
+	/* Set up interrupts. */
+	WR4(sc, CGEM_INTR_EN, CGEM_INTR_RX_COMPLETE | CGEM_INTR_RX_OVERRUN |
+	    CGEM_INTR_TX_USED_READ | CGEM_INTR_RX_USED_READ |
+	    CGEM_INTR_HRESP_NOT_OK);
+}
+
+/* Turn on interface and load up receive ring with buffers. */
+static void
+cgem_init_locked(struct cgem_softc *sc)
+{
+	struct mii_data *mii;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((if_getdrvflags(sc->ifp) & IFF_DRV_RUNNING) != 0)
+		return;
+
+	cgem_config(sc);
+	cgem_fill_rqueue(sc);
+
+	if_setdrvflagbits(sc->ifp, IFF_DRV_RUNNING, IFF_DRV_OACTIVE);
+
+	if (sc->miibus != NULL) {
+		mii = device_get_softc(sc->miibus);
+		mii_mediachg(mii);
+	}
+
+	callout_reset(&sc->tick_ch, hz, cgem_tick, sc);
+}
+
+static void
+cgem_init(void *arg)
+{
+	struct cgem_softc *sc = (struct cgem_softc *)arg;
+
+	CGEM_LOCK(sc);
+	cgem_init_locked(sc);
+	CGEM_UNLOCK(sc);
+}
+
+/* Turn off interface.  Free up any buffers in transmit or receive queues. */
+static void
+cgem_stop(struct cgem_softc *sc)
+{
+	int i;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	callout_stop(&sc->tick_ch);
+
+	/* Shut down hardware. */
+	cgem_reset(sc);
+
+	/* Clear out transmit queue. */
+	memset(sc->txring, 0, CGEM_NUM_TX_DESCS * sizeof(struct cgem_tx_desc));
+	for (i = 0; i < CGEM_NUM_TX_DESCS; i++) {
+		sc->txring[i].ctl = CGEM_TXDESC_USED;
+		if (sc->txring_m[i]) {
+			/* Unload and destroy dmamap. */
+			bus_dmamap_unload(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[i]);
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+			    sc->txring_m_dmamap[i]);
+			sc->txring_m_dmamap[i] = NULL;
+			m_freem(sc->txring_m[i]);
+			sc->txring_m[i] = NULL;
+		}
+	}
+	sc->txring[CGEM_NUM_TX_DESCS - 1].ctl |= CGEM_TXDESC_WRAP;
+
+	sc->txring_hd_ptr = 0;
+	sc->txring_tl_ptr = 0;
+	sc->txring_queued = 0;
+
+	/* Clear out receive queue. */
+	memset(sc->rxring, 0, CGEM_NUM_RX_DESCS * sizeof(struct cgem_rx_desc));
+	for (i = 0; i < CGEM_NUM_RX_DESCS; i++) {
+		sc->rxring[i].addr = CGEM_RXDESC_OWN;
+		if (sc->rxring_m[i]) {
+			/* Unload and destroy dmamap. */
+			bus_dmamap_unload(sc->mbuf_dma_tag,
+			    sc->rxring_m_dmamap[i]);
+			bus_dmamap_destroy(sc->mbuf_dma_tag,
+			    sc->rxring_m_dmamap[i]);
+			sc->rxring_m_dmamap[i] = NULL;
+
+			m_freem(sc->rxring_m[i]);
+			sc->rxring_m[i] = NULL;
+		}
+	}
+	sc->rxring[CGEM_NUM_RX_DESCS - 1].addr |= CGEM_RXDESC_WRAP;
+
+	sc->rxring_hd_ptr = 0;
+	sc->rxring_tl_ptr = 0;
+	sc->rxring_queued = 0;
+
+	/* Force next statchg or linkchg to program net config register. */
+	sc->mii_media_active = 0;
+}
+
+static int
+cgem_ioctl(if_t ifp, u_long cmd, caddr_t data)
+{
+	struct cgem_softc *sc = if_getsoftc(ifp);
+	struct ifreq *ifr = (struct ifreq *)data;
+	struct mii_data *mii;
+	int error = 0, mask;
+
+	switch (cmd) {
+	case SIOCSIFFLAGS:
+		CGEM_LOCK(sc);
+		if ((if_getflags(ifp) & IFF_UP) != 0) {
+			if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) != 0) {
+				if (((if_getflags(ifp) ^ sc->if_old_flags) &
+				    (IFF_PROMISC | IFF_ALLMULTI)) != 0) {
+					cgem_rx_filter(sc);
+				}
+			} else {
+				cgem_init_locked(sc);
+			}
+		} else if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) != 0) {
+			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);
+			cgem_stop(sc);
+		}
+		sc->if_old_flags = if_getflags(ifp);
+		CGEM_UNLOCK(sc);
+		break;
+
+	case SIOCADDMULTI:
+	case SIOCDELMULTI:
+		/* Set up multi-cast filters. */
+		if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) != 0) {
+			CGEM_LOCK(sc);
+			cgem_rx_filter(sc);
+			CGEM_UNLOCK(sc);
+		}
+		break;
+
+	case SIOCSIFMEDIA:
+	case SIOCGIFMEDIA:
+		if (sc->miibus == NULL)
+			return (ENXIO);
+		mii = device_get_softc(sc->miibus);
+		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
+		break;
+
+	case SIOCSIFCAP:
+		CGEM_LOCK(sc);
+		mask = if_getcapenable(ifp) ^ ifr->ifr_reqcap;
+
+		if ((mask & IFCAP_TXCSUM) != 0) {
+			if ((ifr->ifr_reqcap & IFCAP_TXCSUM) != 0) {
+				/* Turn on TX checksumming. */
+				if_setcapenablebit(ifp, IFCAP_TXCSUM |
+				    IFCAP_TXCSUM_IPV6, 0);
+				if_sethwassistbits(ifp, CGEM_CKSUM_ASSIST, 0);
+
+				WR4(sc, CGEM_DMA_CFG,
+				    RD4(sc, CGEM_DMA_CFG) |
+				    CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN);
+			} else {
+				/* Turn off TX checksumming. */
+				if_setcapenablebit(ifp, 0, IFCAP_TXCSUM |
+				    IFCAP_TXCSUM_IPV6);
+				if_sethwassistbits(ifp, 0, CGEM_CKSUM_ASSIST);
+
+				WR4(sc, CGEM_DMA_CFG,
+				    RD4(sc, CGEM_DMA_CFG) &
+				    ~CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN);
+			}
+		}
+		if ((mask & IFCAP_RXCSUM) != 0) {
+			if ((ifr->ifr_reqcap & IFCAP_RXCSUM) != 0) {
+				/* Turn on RX checksumming. */
+				if_setcapenablebit(ifp, IFCAP_RXCSUM |
+				    IFCAP_RXCSUM_IPV6, 0);
+				sc->net_cfg_shadow |=
+				    CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN;
+				WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+			} else {
+				/* Turn off RX checksumming. */
+				if_setcapenablebit(ifp, 0, IFCAP_RXCSUM |
+				    IFCAP_RXCSUM_IPV6);
+				sc->net_cfg_shadow &=
+				    ~CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN;
+				WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+			}
+		}
+		if ((if_getcapenable(ifp) & (IFCAP_RXCSUM | IFCAP_TXCSUM)) ==
+		    (IFCAP_RXCSUM | IFCAP_TXCSUM))
+			if_setcapenablebit(ifp, IFCAP_VLAN_HWCSUM, 0);
+		else
+			if_setcapenablebit(ifp, 0, IFCAP_VLAN_HWCSUM);
+
+		CGEM_UNLOCK(sc);
+		break;
+	default:
+		error = ether_ioctl(ifp, cmd, data);
+		break;
+	}
+
+	return (error);
+}
+
+/* MII bus support routines.
+ */
+static int
+cgem_ifmedia_upd(if_t ifp)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+	struct mii_data *mii;
+	struct mii_softc *miisc;
+	int error = 0;
+
+	mii = device_get_softc(sc->miibus);
+	CGEM_LOCK(sc);
+	if ((if_getflags(ifp) & IFF_UP) != 0) {
+		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
+			PHY_RESET(miisc);
+		error = mii_mediachg(mii);
+	}
+	CGEM_UNLOCK(sc);
+
+	return (error);
+}
+
+static void
+cgem_ifmedia_sts(if_t ifp, struct ifmediareq *ifmr)
+{
+	struct cgem_softc *sc = (struct cgem_softc *) if_getsoftc(ifp);
+	struct mii_data *mii;
+
+	mii = device_get_softc(sc->miibus);
+	CGEM_LOCK(sc);
+	mii_pollstat(mii);
+	ifmr->ifm_active = mii->mii_media_active;
+	ifmr->ifm_status = mii->mii_media_status;
+	CGEM_UNLOCK(sc);
+}
+
+static int
+cgem_miibus_readreg(device_t dev, int phy, int reg)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	int tries, val;
+
+	WR4(sc, CGEM_PHY_MAINT, CGEM_PHY_MAINT_CLAUSE_22 |
+	    CGEM_PHY_MAINT_MUST_10 | CGEM_PHY_MAINT_OP_READ |
+	    (phy << CGEM_PHY_MAINT_PHY_ADDR_SHIFT) |
+	    (reg << CGEM_PHY_MAINT_REG_ADDR_SHIFT));
+
+	/* Wait for completion. */
+	tries=0;
+	while ((RD4(sc, CGEM_NET_STAT) & CGEM_NET_STAT_PHY_MGMT_IDLE) == 0) {
+		DELAY(5);
+		if (++tries > 200) {
+			device_printf(dev, "phy read timeout: %d\n", reg);
+			return (-1);
+		}
+	}
+
+	val = RD4(sc, CGEM_PHY_MAINT) & CGEM_PHY_MAINT_DATA_MASK;
+
+	if (reg == MII_EXTSR)
+		/*
+		 * MAC does not support half-duplex at gig speeds.
+		 * Let mii(4) exclude the capability.
+		 */
+		val &= ~(EXTSR_1000XHDX | EXTSR_1000THDX);
+
+	return (val);
+}
+
+static int
+cgem_miibus_writereg(device_t dev, int phy, int reg, int data)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	int tries;
+
+	WR4(sc, CGEM_PHY_MAINT, CGEM_PHY_MAINT_CLAUSE_22 |
+	    CGEM_PHY_MAINT_MUST_10 | CGEM_PHY_MAINT_OP_WRITE |
+	    (phy << CGEM_PHY_MAINT_PHY_ADDR_SHIFT) |
+	    (reg << CGEM_PHY_MAINT_REG_ADDR_SHIFT) |
+	    (data & CGEM_PHY_MAINT_DATA_MASK));
+
+	/* Wait for completion. */
+	tries = 0;
+	while ((RD4(sc, CGEM_NET_STAT) & CGEM_NET_STAT_PHY_MGMT_IDLE) == 0) {
+		DELAY(5);
+		if (++tries > 200) {
+			device_printf(dev, "phy write timeout: %d\n", reg);
+			return (-1);
+		}
+	}
+
+	return (0);
+}
+
+static void
+cgem_miibus_statchg(device_t dev)
+{
+	struct cgem_softc *sc  = device_get_softc(dev);
+	struct mii_data *mii = device_get_softc(sc->miibus);
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
+	    (IFM_ACTIVE | IFM_AVALID) &&
+	    sc->mii_media_active != mii->mii_media_active)
+		cgem_mediachange(sc, mii);
+}
+
+static void
+cgem_miibus_linkchg(device_t dev)
+{
+	struct cgem_softc *sc  = device_get_softc(dev);
+	struct mii_data *mii = device_get_softc(sc->miibus);
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
+	    (IFM_ACTIVE | IFM_AVALID) &&
+	    sc->mii_media_active != mii->mii_media_active)
+		cgem_mediachange(sc, mii);
+}
+
+/*
+ * Overridable weak symbol cgem_set_ref_clk().  This allows platforms to
+ * provide a function to set the cgem's reference clock.
+ */
+static int __used
+cgem_default_set_ref_clk(int unit, int frequency)
+{
+
+	return 0;
+}
+__weak_reference(cgem_default_set_ref_clk, cgem_set_ref_clk);
+
+/* Call to set reference clock and network config bits according to media. */
+static void
+cgem_mediachange(struct cgem_softc *sc,	struct mii_data *mii)
+{
+	int ref_clk_freq;
+
+	CGEM_ASSERT_LOCKED(sc);
+
+	/* Update hardware to reflect media. */
+	sc->net_cfg_shadow &= ~(CGEM_NET_CFG_SPEED100 | CGEM_NET_CFG_GIGE_EN |
+	    CGEM_NET_CFG_FULL_DUPLEX);
+
+	switch (IFM_SUBTYPE(mii->mii_media_active)) {
+	case IFM_1000_T:
+		sc->net_cfg_shadow |= (CGEM_NET_CFG_SPEED100 |
+		    CGEM_NET_CFG_GIGE_EN);
+		ref_clk_freq = 125000000;
+		break;
+	case IFM_100_TX:
+		sc->net_cfg_shadow |= CGEM_NET_CFG_SPEED100;
+		ref_clk_freq = 25000000;
+		break;
+	default:
+		ref_clk_freq = 2500000;
+	}
+
+	if ((mii->mii_media_active & IFM_FDX) != 0)
+		sc->net_cfg_shadow |= CGEM_NET_CFG_FULL_DUPLEX;
+
+	WR4(sc, CGEM_NET_CFG, sc->net_cfg_shadow);
+
+#ifdef EXT_RESOURCES
+	if (sc->ref_clk != NULL) {
+		CGEM_UNLOCK(sc);
+		if (clk_set_freq(sc->ref_clk, ref_clk_freq, 0))
+			device_printf(sc->dev, "could not set ref clk to %d\n",
+			    ref_clk_freq);
+		CGEM_LOCK(sc);
+	}
+#else
+	/* Set the reference clock if necessary. */
+	if (cgem_set_ref_clk(sc->ref_clk_num, ref_clk_freq))
+		device_printf(sc->dev,
+		    "cgem_mediachange: could not set ref clk%d to %d.\n",
+		    sc->ref_clk_num, ref_clk_freq);
+#endif
+
+	sc->mii_media_active = mii->mii_media_active;
+}
+
+static void
+cgem_add_sysctls(device_t dev)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	struct sysctl_ctx_list *ctx;
+	struct sysctl_oid_list *child;
+	struct sysctl_oid *tree;
+
+	ctx = device_get_sysctl_ctx(dev);
+	child = SYSCTL_CHILDREN(device_get_sysctl_tree(dev));
+
+	SYSCTL_ADD_INT(ctx, child, OID_AUTO, "rxbufs", CTLFLAG_RW,
+	    &sc->rxbufs, 0, "Number receive buffers to provide");
+
+	SYSCTL_ADD_INT(ctx, child, OID_AUTO, "rxhangwar", CTLFLAG_RW,
+	    &sc->rxhangwar, 0, "Enable receive hang work-around");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_rxoverruns", CTLFLAG_RD,
+	    &sc->rxoverruns, 0, "Receive overrun events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_rxnobufs", CTLFLAG_RD,
+	    &sc->rxnobufs, 0, "Receive buf queue empty events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_rxdmamapfails", CTLFLAG_RD,
+	    &sc->rxdmamapfails, 0, "Receive DMA map failures");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txfull", CTLFLAG_RD,
+	    &sc->txfull, 0, "Transmit ring full events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txdmamapfails", CTLFLAG_RD,
+	    &sc->txdmamapfails, 0, "Transmit DMA map failures");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txdefrags", CTLFLAG_RD,
+	    &sc->txdefrags, 0, "Transmit m_defrag() calls");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "_txdefragfails", CTLFLAG_RD,
+	    &sc->txdefragfails, 0, "Transmit m_defrag() failures");
+
+	tree = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, "stats",
+	    CTLFLAG_RD | CTLFLAG_MPSAFE, NULL, "GEM statistics");
+	child = SYSCTL_CHILDREN(tree);
+
+	SYSCTL_ADD_UQUAD(ctx, child, OID_AUTO, "tx_bytes", CTLFLAG_RD,
+	    &sc->stats.tx_bytes, "Total bytes transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames", CTLFLAG_RD,
+	    &sc->stats.tx_frames, 0, "Total frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_bcast", CTLFLAG_RD,
+	    &sc->stats.tx_frames_bcast, 0,
+	    "Number broadcast frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_multi", CTLFLAG_RD,
+	    &sc->stats.tx_frames_multi, 0,
+	    "Number multicast frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_pause",
+	    CTLFLAG_RD, &sc->stats.tx_frames_pause, 0,
+	    "Number pause frames transmitted");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_64b", CTLFLAG_RD,
+	    &sc->stats.tx_frames_64b, 0,
+	    "Number frames transmitted of size 64 bytes or less");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_65to127b", CTLFLAG_RD,
+	    &sc->stats.tx_frames_65to127b, 0,
+	    "Number frames transmitted of size 65-127 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_128to255b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_128to255b, 0,
+	    "Number frames transmitted of size 128-255 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_256to511b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_256to511b, 0,
+	    "Number frames transmitted of size 256-511 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_512to1023b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_512to1023b, 0,
+	    "Number frames transmitted of size 512-1023 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_frames_1024to1536b",
+	    CTLFLAG_RD, &sc->stats.tx_frames_1024to1536b, 0,
+	    "Number frames transmitted of size 1024-1536 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_under_runs",
+	    CTLFLAG_RD, &sc->stats.tx_under_runs, 0,
+	    "Number transmit under-run events");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_single_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_single_collisn, 0,
+	    "Number single-collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_multi_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_multi_collisn, 0,
+	    "Number multi-collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_excsv_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_excsv_collisn, 0,
+	    "Number excessive collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_late_collisn",
+	    CTLFLAG_RD, &sc->stats.tx_late_collisn, 0,
+	    "Number late-collision transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_deferred_frames",
+	    CTLFLAG_RD, &sc->stats.tx_deferred_frames, 0,
+	    "Number deferred transmit frames");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "tx_carrier_sense_errs",
+	    CTLFLAG_RD, &sc->stats.tx_carrier_sense_errs, 0,
+	    "Number carrier sense errors on transmit");
+
+	SYSCTL_ADD_UQUAD(ctx, child, OID_AUTO, "rx_bytes", CTLFLAG_RD,
+	    &sc->stats.rx_bytes, "Total bytes received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames", CTLFLAG_RD,
+	    &sc->stats.rx_frames, 0, "Total frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_bcast",
+	    CTLFLAG_RD, &sc->stats.rx_frames_bcast, 0,
+	    "Number broadcast frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_multi",
+	    CTLFLAG_RD, &sc->stats.rx_frames_multi, 0,
+	    "Number multicast frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_pause",
+	    CTLFLAG_RD, &sc->stats.rx_frames_pause, 0,
+	    "Number pause frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_64b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_64b, 0,
+	    "Number frames received of size 64 bytes or less");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_65to127b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_65to127b, 0,
+	    "Number frames received of size 65-127 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_128to255b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_128to255b, 0,
+	    "Number frames received of size 128-255 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_256to511b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_256to511b, 0,
+	    "Number frames received of size 256-511 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_512to1023b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_512to1023b, 0,
+	    "Number frames received of size 512-1023 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_1024to1536b",
+	    CTLFLAG_RD, &sc->stats.rx_frames_1024to1536b, 0,
+	    "Number frames received of size 1024-1536 bytes");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_undersize",
+	    CTLFLAG_RD, &sc->stats.rx_frames_undersize, 0,
+	    "Number undersize frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_oversize",
+	    CTLFLAG_RD, &sc->stats.rx_frames_oversize, 0,
+	    "Number oversize frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_jabber",
+	    CTLFLAG_RD, &sc->stats.rx_frames_jabber, 0,
+	    "Number jabber frames received");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_fcs_errs",
+	    CTLFLAG_RD, &sc->stats.rx_frames_fcs_errs, 0,
+	    "Number frames received with FCS errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_length_errs",
+	    CTLFLAG_RD, &sc->stats.rx_frames_length_errs, 0,
+	    "Number frames received with length errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_symbol_errs",
+	    CTLFLAG_RD, &sc->stats.rx_symbol_errs, 0,
+	    "Number receive symbol errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_align_errs",
+	    CTLFLAG_RD, &sc->stats.rx_align_errs, 0,
+	    "Number receive alignment errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_resource_errs",
+	    CTLFLAG_RD, &sc->stats.rx_resource_errs, 0,
+	    "Number frames received when no rx buffer available");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_overrun_errs",
+	    CTLFLAG_RD, &sc->stats.rx_overrun_errs, 0,
+	    "Number frames received but not copied due to receive overrun");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_ip_hdr_csum_errs",
+	    CTLFLAG_RD, &sc->stats.rx_ip_hdr_csum_errs, 0,
+	    "Number frames received with IP header checksum errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_tcp_csum_errs",
+	    CTLFLAG_RD, &sc->stats.rx_tcp_csum_errs, 0,
+	    "Number frames received with TCP checksum errors");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "rx_frames_udp_csum_errs",
+	    CTLFLAG_RD, &sc->stats.rx_udp_csum_errs, 0,
+	    "Number frames received with UDP checksum errors");
+}
+
+static int
+cgem_probe(device_t dev)
+{
+
+	if (!ofw_bus_status_okay(dev))
+		return (ENXIO);
+
+	if (ofw_bus_search_compatible(dev, compat_data)->ocd_data == 0)
+		return (ENXIO);
+
+	device_set_desc(dev, "Cadence CGEM Gigabit Ethernet Interface");
+	return (0);
+}
+
+static int
+cgem_attach(device_t dev)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	if_t ifp = NULL;
+	int rid, err;
+	u_char eaddr[ETHER_ADDR_LEN];
+	int hwtype;
+#ifndef EXT_RESOURCES
+	phandle_t node;
+	pcell_t cell;
+#endif
+
+	sc->dev = dev;
+	CGEM_LOCK_INIT(sc);
+
+	/* Key off of compatible string and set hardware-specific options. */
+	hwtype = ofw_bus_search_compatible(dev, compat_data)->ocd_data;
+	if (hwtype == HWTYPE_ZYNQMP)
+		sc->neednullqs = 1;
+	if (hwtype == HWTYPE_ZYNQ)
+		sc->rxhangwar = 1;
+
+#ifdef EXT_RESOURCES
+	if (hwtype == HWTYPE_ZYNQ || hwtype == HWTYPE_ZYNQMP) {
+		if (clk_get_by_ofw_name(dev, 0, "tx_clk", &sc->ref_clk) != 0)
+			device_printf(dev,
+			    "could not retrieve reference clock.\n");
+		else if (clk_enable(sc->ref_clk) != 0)
+			device_printf(dev, "could not enable clock.\n");
+	} else if (hwtype == HWTYPE_SIFIVE) {
+		if (clk_get_by_ofw_name(dev, 0, "pclk", &sc->ref_clk) != 0)
+			device_printf(dev,
+			    "could not retrieve reference clock.\n");
+		else if (clk_enable(sc->ref_clk) != 0)
+			device_printf(dev, "could not enable clock.\n");
+	}
+#else
+	/* Get reference clock number and base divider from fdt. */
+	node = ofw_bus_get_node(dev);
+	sc->ref_clk_num = 0;
+	if (OF_getprop(node, "ref-clock-num", &cell, sizeof(cell)) > 0)
+		sc->ref_clk_num = fdt32_to_cpu(cell);
+#endif
+
+	/* Get memory resource. */
+	rid = 0;
+	sc->mem_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
+	    RF_ACTIVE);
+	if (sc->mem_res == NULL) {
+		device_printf(dev, "could not allocate memory resources.\n");
+		return (ENOMEM);
+	}
+
+	/* Get IRQ resource. */
+	rid = 0;
+	sc->irq_res = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid,
+	    RF_ACTIVE);
+	if (sc->irq_res == NULL) {
+		device_printf(dev, "could not allocate interrupt resource.\n");
+		cgem_detach(dev);
+		return (ENOMEM);
+	}
+
+	/* Set up ifnet structure. */
+	ifp = sc->ifp = if_alloc(IFT_ETHER);
+	if (ifp == NULL) {
+		device_printf(dev, "could not allocate ifnet structure\n");
+		cgem_detach(dev);
+		return (ENOMEM);
+	}
+	if_setsoftc(ifp, sc);
+	if_initname(ifp, IF_CGEM_NAME, device_get_unit(dev));
+	if_setflags(ifp, IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST);
+	if_setinitfn(ifp, cgem_init);
+	if_setioctlfn(ifp, cgem_ioctl);
+	if_setstartfn(ifp, cgem_start);
+	if_setcapabilitiesbit(ifp, IFCAP_HWCSUM | IFCAP_HWCSUM_IPV6 |
+	    IFCAP_VLAN_MTU | IFCAP_VLAN_HWCSUM, 0);
+	if_setsendqlen(ifp, CGEM_NUM_TX_DESCS);
+	if_setsendqready(ifp);
+
+	/* Disable hardware checksumming by default. */
+	if_sethwassist(ifp, 0);
+	if_setcapenable(ifp, if_getcapabilities(ifp) &
+	    ~(IFCAP_HWCSUM | IFCAP_HWCSUM_IPV6 | IFCAP_VLAN_HWCSUM));
+
+	sc->if_old_flags = if_getflags(ifp);
+	sc->rxbufs = DEFAULT_NUM_RX_BUFS;
+
+	/* Reset hardware. */
+	CGEM_LOCK(sc);
+	cgem_reset(sc);
+	CGEM_UNLOCK(sc);
+
+	/* Attach phy to mii bus. */
+	err = mii_attach(dev, &sc->miibus, ifp,
+	    cgem_ifmedia_upd, cgem_ifmedia_sts, BMSR_DEFCAPMASK,
+	    MII_PHY_ANY, MII_OFFSET_ANY, 0);
+	if (err)
+		device_printf(dev, "warning: attaching PHYs failed\n");
+
+	/* Set up TX and RX descriptor area. */
+	err = cgem_setup_descs(sc);
+	if (err) {
+		device_printf(dev, "could not set up dma mem for descs.\n");
+		cgem_detach(dev);
+		return (ENOMEM);
+	}
+
+	/* Get a MAC address. */
+	cgem_get_mac(sc, eaddr);
+
+	/* Start ticks. */
+	callout_init_mtx(&sc->tick_ch, &sc->sc_mtx, 0);
+
+	ether_ifattach(ifp, eaddr);
+
+	err = bus_setup_intr(dev, sc->irq_res, INTR_TYPE_NET | INTR_MPSAFE |
+	    INTR_EXCL, NULL, cgem_intr, sc, &sc->intrhand);
+	if (err) {
+		device_printf(dev, "could not set interrupt handler.\n");
+		ether_ifdetach(ifp);
+		cgem_detach(dev);
+		return (err);
+	}
+
+	cgem_add_sysctls(dev);
+
+	return (0);
+}
+
+static int
+cgem_detach(device_t dev)
+{
+	struct cgem_softc *sc = device_get_softc(dev);
+	int i;
+
+	if (sc == NULL)
+		return (ENODEV);
+
+	if (device_is_attached(dev)) {
+		CGEM_LOCK(sc);
+		cgem_stop(sc);
+		CGEM_UNLOCK(sc);
+		callout_drain(&sc->tick_ch);
+		if_setflagbits(sc->ifp, 0, IFF_UP);
+		ether_ifdetach(sc->ifp);
+	}
+
+	if (sc->miibus != NULL) {
+		device_delete_child(dev, sc->miibus);
+		sc->miibus = NULL;
+	}
+
+	/* Release resources. */
+	if (sc->mem_res != NULL) {
+		bus_release_resource(dev, SYS_RES_MEMORY,
+		    rman_get_rid(sc->mem_res), sc->mem_res);
+		sc->mem_res = NULL;
+	}
+	if (sc->irq_res != NULL) {
+		if (sc->intrhand)
+			bus_teardown_intr(dev, sc->irq_res, sc->intrhand);
+		bus_release_resource(dev, SYS_RES_IRQ,
+		    rman_get_rid(sc->irq_res), sc->irq_res);
+		sc->irq_res = NULL;
+	}
+
+	/* Release DMA resources. */
+	if (sc->rxring != NULL) {
+		if (sc->rxring_physaddr != 0) {
+			bus_dmamap_unload(sc->desc_dma_tag,
+			    sc->rxring_dma_map);
+			sc->rxring_physaddr = 0;
+			sc->txring_physaddr = 0;
+			sc->null_qs_physaddr = 0;
+		}
+		bus_dmamem_free(sc->desc_dma_tag, sc->rxring,
+				sc->rxring_dma_map);
+		sc->rxring = NULL;
+		sc->txring = NULL;
+		sc->null_qs = NULL;
+
+		for (i = 0; i < CGEM_NUM_RX_DESCS; i++)
+			if (sc->rxring_m_dmamap[i] != NULL) {
+				bus_dmamap_destroy(sc->mbuf_dma_tag,
+				    sc->rxring_m_dmamap[i]);
+				sc->rxring_m_dmamap[i] = NULL;
+			}
+		for (i = 0; i < CGEM_NUM_TX_DESCS; i++)
+			if (sc->txring_m_dmamap[i] != NULL) {
+				bus_dmamap_destroy(sc->mbuf_dma_tag,
+				    sc->txring_m_dmamap[i]);
+				sc->txring_m_dmamap[i] = NULL;
+			}
+	}
+	if (sc->desc_dma_tag != NULL) {
+		bus_dma_tag_destroy(sc->desc_dma_tag);
+		sc->desc_dma_tag = NULL;
+	}
+	if (sc->mbuf_dma_tag != NULL) {
+		bus_dma_tag_destroy(sc->mbuf_dma_tag);
+		sc->mbuf_dma_tag = NULL;
+	}
+
+#ifdef EXT_RESOURCES
+	if (sc->ref_clk != NULL) {
+		clk_release(sc->ref_clk);
+		sc->ref_clk = NULL;
+	}
+#endif
+
+	bus_generic_detach(dev);
+
+	CGEM_LOCK_DESTROY(sc);
+
+	return (0);
+}
+
+static device_method_t cgem_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		cgem_probe),
+	DEVMETHOD(device_attach,	cgem_attach),
+	DEVMETHOD(device_detach,	cgem_detach),
+
+	/* MII interface */
+	DEVMETHOD(miibus_readreg,	cgem_miibus_readreg),
+	DEVMETHOD(miibus_writereg,	cgem_miibus_writereg),
+	DEVMETHOD(miibus_statchg,	cgem_miibus_statchg),
+	DEVMETHOD(miibus_linkchg,	cgem_miibus_linkchg),
+
+	DEVMETHOD_END
+};
+
+static driver_t cgem_driver = {
+	"cgem",
+	cgem_methods,
+	sizeof(struct cgem_softc),
+};
+
+DRIVER_MODULE(cgem, simplebus, cgem_driver, cgem_devclass, NULL, NULL);
+DRIVER_MODULE(miibus, cgem, miibus_driver, miibus_devclass, NULL, NULL);
+MODULE_DEPEND(cgem, miibus, 1, 1, 1);
+MODULE_DEPEND(cgem, ether, 1, 1, 1);
+SIMPLEBUS_PNP_INFO(compat_data);
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem_hw.h b/src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem_hw.h
new file mode 100644
index 0000000000..784b131a88
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/dev/cadence/if_cgem_hw.h
@@ -0,0 +1,446 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2012-2013 Thomas Skibo
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * Hardware and register defines for Cadence GEM Gigabit Ethernet
+ * controller such as the one used in Zynq-7000 SoC.
+ *
+ * Reference: Zynq-7000 All Programmable SoC Technical Reference Manual.
+ * (v1.4) November 16, 2012.  Xilinx doc UG585.  GEM is covered in Ch. 16
+ * and register definitions are in appendix B.18.
+ *
+ * Additional Reference: Zynq UltraScale+ Device Register Reference
+ * (UG1087 v1.7 Feb 8,2019):
+ * https://www.xilinx.com/html_docs/registers/ug1087/ug1087-zynq-ultrascale-registers.html
+ */
+
+#ifndef _IF_CGEM_HW_H_
+#define _IF_CGEM_HW_H_
+
+/* Cadence GEM hardware register definitions. */
+#define CGEM_NET_CTRL			0x000	/* Network Control */
+#define   CGEM_NET_CTRL_FLUSH_DPRAM_PKT		(1 << 18)
+#define   CGEM_NET_CTRL_TX_PFC_PRI_PAUSE_FRAME	(1 << 17)
+#define   CGEM_NET_CTRL_EN_PFC_PRI_PAUSE_RX	(1 << 16)
+#define   CGEM_NET_CTRL_STORE_RX_TSTAMP		(1 << 15)
+#define   CGEM_NET_CTRL_TX_ZEROQ_PAUSE_FRAME	(1 << 12)
+#define   CGEM_NET_CTRL_TX_PAUSE_FRAME		(1 << 11)
+#define   CGEM_NET_CTRL_TX_HALT			(1 << 10)
+#define   CGEM_NET_CTRL_START_TX		(1 << 9)
+#define   CGEM_NET_CTRL_BACK_PRESSURE		(1 << 8)
+#define   CGEM_NET_CTRL_WREN_STAT_REGS		(1 << 7)
+#define   CGEM_NET_CTRL_INCR_STAT_REGS		(1 << 6)
+#define   CGEM_NET_CTRL_CLR_STAT_REGS		(1 << 5)
+#define   CGEM_NET_CTRL_MGMT_PORT_EN		(1 << 4)
+#define   CGEM_NET_CTRL_TX_EN			(1 << 3)
+#define   CGEM_NET_CTRL_RX_EN			(1 << 2)
+#define   CGEM_NET_CTRL_LOOP_LOCAL		(1 << 1)
+
+#define CGEM_NET_CFG			0x004	/* Netowrk Configuration */
+#define   CGEM_NET_CFG_UNIDIR_EN		(1U << 31)
+#define   CGEM_NET_CFG_IGNORE_IPG_RX_ER		(1 << 30)
+#define   CGEM_NET_CFG_RX_BAD_PREAMBLE		(1 << 29)
+#define   CGEM_NET_CFG_IPG_STRETCH_EN		(1 << 28)
+#define   CGEM_NET_CFG_SGMII_EN			(1 << 27)
+#define   CGEM_NET_CFG_IGNORE_RX_FCS		(1 << 26)
+#define   CGEM_NET_CFG_RX_HD_WHILE_TX		(1 << 25)
+#define   CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN	(1 << 24)
+#define   CGEM_NET_CFG_DIS_CP_PAUSE_FRAME	(1 << 23)
+#define   CGEM_NET_CFG_DBUS_WIDTH_32		(0 << 21)
+#define   CGEM_NET_CFG_DBUS_WIDTH_64		(1 << 21)
+#define   CGEM_NET_CFG_DBUS_WIDTH_128		(2 << 21)
+#define   CGEM_NET_CFG_DBUS_WIDTH_MASK		(3 << 21)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_8		(0 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_16		(1 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_32		(2 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_48		(3 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_64		(4 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_96		(5 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_128		(6 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_224		(7 << 18)
+#define   CGEM_NET_CFG_MDC_CLK_DIV_MASK		(7 << 18)
+#define   CGEM_NET_CFG_FCS_REMOVE		(1 << 17)
+#define   CGEM_NET_CFG_LEN_ERR_FRAME_DISC	(1 << 16)
+#define   CGEM_NET_CFG_RX_BUF_OFFSET_SHFT	14
+#define   CGEM_NET_CFG_RX_BUF_OFFSET_MASK	(3 << 14)
+#define   CGEM_NET_CFG_RX_BUF_OFFSET(n)		((n) << 14)
+#define   CGEM_NET_CFG_PAUSE_EN			(1 << 13)
+#define   CGEM_NET_CFG_RETRY_TEST		(1 << 12)
+#define   CGEM_NET_CFG_PCS_SEL			(1 << 11)
+#define   CGEM_NET_CFG_GIGE_EN			(1 << 10)
+#define   CGEM_NET_CFG_EXT_ADDR_MATCH_EN	(1 << 9)
+#define   CGEM_NET_CFG_1536RXEN			(1 << 8)
+#define   CGEM_NET_CFG_UNI_HASH_EN		(1 << 7)
+#define   CGEM_NET_CFG_MULTI_HASH_EN		(1 << 6)
+#define   CGEM_NET_CFG_NO_BCAST			(1 << 5)
+#define   CGEM_NET_CFG_COPY_ALL			(1 << 4)
+#define   CGEM_NET_CFG_DISC_NON_VLAN		(1 << 2)
+#define   CGEM_NET_CFG_FULL_DUPLEX		(1 << 1)
+#define   CGEM_NET_CFG_SPEED100			(1 << 0)
+
+#define CGEM_NET_STAT			0x008	/* Network Status */
+#define   CGEM_NET_STAT_PFC_PRI_PAUSE_NEG	(1 << 6)
+#define   CGEM_NET_STAT_PCS_AUTONEG_PAUSE_TX_RES (1 << 5)
+#define   CGEM_NET_STAT_PCS_AUTONEG_PAUSE_RX_RES (1 << 4)
+#define   CGEM_NET_STAT_PCS_AUTONEG_DUP_RES	(1 << 3)
+#define   CGEM_NET_STAT_PHY_MGMT_IDLE		(1 << 2)
+#define   CGEM_NET_STAT_MDIO_IN_PIN_STATUS	(1 << 1)
+#define   CGEM_NET_STAT_PCS_LINK_STATE		(1 << 0)
+
+#define CGEM_USER_IO			0x00C	/* User I/O */
+
+#define CGEM_DMA_CFG			0x010	/* DMA Config */
+#define   CGEM_DMA_CFG_ADDR_BUS_64		(1 << 30)
+#define   CGEM_DMA_CFG_DISC_WHEN_NO_AHB		(1 << 24)
+#define   CGEM_DMA_CFG_RX_BUF_SIZE_SHIFT	16
+#define   CGEM_DMA_CFG_RX_BUF_SIZE_MASK		(0xff << 16)
+#define   CGEM_DMA_CFG_RX_BUF_SIZE(sz)		((((sz) + 63) / 64)  <<  16)
+#define   CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN	(1 << 11)
+#define   CGEM_DMA_CFG_TX_PKTBUF_MEMSZ_SEL	(1 << 10)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_1K	(0 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_2K	(1 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_4K	(2 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_8K	(3 << 8)
+#define   CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_MASK	(3 << 8)
+#define   CGEM_DMA_CFG_AHB_ENDIAN_SWAP_PKT_EN	(1 << 7)
+#define   CGEM_DMA_CFG_AHB_ENDIAN_SWAP_MGMT_EN	(1 << 6)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_1	(1 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_4	(4 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_8	(8 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_16	(16 << 0)
+#define   CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_MASK	(0x1f << 0)
+
+#define CGEM_TX_STAT			0x014	/* Transmit Status */
+#define   CGEM_TX_STAT_HRESP_NOT_OK		(1 << 8)
+#define   CGEM_TX_STAT_LATE_COLL		(1 << 7)
+#define   CGEM_TX_STAT_UNDERRUN			(1 << 6)
+#define   CGEM_TX_STAT_COMPLETE			(1 << 5)
+#define   CGEM_TX_STAT_CORRUPT_AHB_ERR		(1 << 4)
+#define   CGEM_TX_STAT_GO			(1 << 3)
+#define   CGEM_TX_STAT_RETRY_LIMIT_EXC		(1 << 2)
+#define   CGEM_TX_STAT_COLLISION		(1 << 1)
+#define   CGEM_TX_STAT_USED_BIT_READ		(1 << 0)
+#define   CGEM_TX_STAT_ALL			0x1ff
+
+#define CGEM_RX_QBAR			0x018	/* Receive Buf Q Base Addr */
+#define CGEM_TX_QBAR			0x01C	/* Transmit Buf Q Base Addr */
+
+#define CGEM_RX_STAT			0x020	/* Receive Status */
+#define   CGEM_RX_STAT_HRESP_NOT_OK		(1 << 3)
+#define   CGEM_RX_STAT_OVERRUN			(1 << 2)
+#define   CGEM_RX_STAT_FRAME_RECD		(1 << 1)
+#define   CGEM_RX_STAT_BUF_NOT_AVAIL		(1 << 0)
+#define   CGEM_RX_STAT_ALL			0xf
+
+#define CGEM_INTR_STAT			0x024	/* Interrupt Status */
+#define CGEM_INTR_EN			0x028	/* Interrupt Enable */
+#define CGEM_INTR_DIS			0x02C	/* Interrupt Disable */
+#define CGEM_INTR_MASK			0x030	/* Interrupt Mask */
+#define   CGEM_INTR_TSU_SEC_INCR		(1 << 26)
+#define   CGEM_INTR_PDELAY_RESP_TX		(1 << 25)
+#define   CGEM_INTR_PDELAY_REQ_TX		(1 << 24)
+#define   CGEM_INTR_PDELAY_RESP_RX		(1 << 23)
+#define   CGEM_INTR_PDELAY_REQ_RX		(1 << 22)
+#define   CGEM_INTR_SYNX_TX			(1 << 21)
+#define   CGEM_INTR_DELAY_REQ_TX		(1 << 20)
+#define   CGEM_INTR_SYNC_RX			(1 << 19)
+#define   CGEM_INTR_DELAY_REQ_RX		(1 << 18)
+#define   CGEM_INTR_PARTNER_PG_RX		(1 << 17)
+#define   CGEM_INTR_AUTONEG_COMPL		(1 << 16)
+#define   CGEM_INTR_EXT_INTR			(1 << 15)
+#define   CGEM_INTR_PAUSE_TX			(1 << 14)
+#define   CGEM_INTR_PAUSE_ZERO			(1 << 13)
+#define   CGEM_INTR_PAUSE_NONZEROQ_RX		(1 << 12)
+#define   CGEM_INTR_HRESP_NOT_OK		(1 << 11)
+#define   CGEM_INTR_RX_OVERRUN			(1 << 10)
+#define   CGEM_INTR_LINK_CHNG			(1 << 9)
+#define   CGEM_INTR_TX_COMPLETE			(1 << 7)
+#define   CGEM_INTR_TX_CORRUPT_AHB_ERR		(1 << 6)
+#define   CGEM_INTR_RETRY_EX_LATE_COLLISION	(1 << 5)
+#define   CGEM_INTR_TX_USED_READ		(1 << 3)
+#define   CGEM_INTR_RX_USED_READ		(1 << 2)
+#define   CGEM_INTR_RX_COMPLETE			(1 << 1)
+#define   CGEM_INTR_MGMT_SENT			(1 << 0)
+#define   CGEM_INTR_ALL				0x7FFFEFF
+
+#define CGEM_PHY_MAINT			0x034	/* PHY Maintenenace */
+#define   CGEM_PHY_MAINT_CLAUSE_22		(1 << 30)
+#define   CGEM_PHY_MAINT_OP_SHIFT		28
+#define   CGEM_PHY_MAINT_OP_MASK		(3 << 28)
+#define   CGEM_PHY_MAINT_OP_READ		(2 << 28)
+#define   CGEM_PHY_MAINT_OP_WRITE		(1 << 28)
+#define   CGEM_PHY_MAINT_PHY_ADDR_SHIFT		23
+#define   CGEM_PHY_MAINT_PHY_ADDR_MASK		(0x1f << 23)
+#define   CGEM_PHY_MAINT_REG_ADDR_SHIFT		18
+#define   CGEM_PHY_MAINT_REG_ADDR_MASK		(0x1f << 18)
+#define   CGEM_PHY_MAINT_MUST_10		(2 << 16)
+#define   CGEM_PHY_MAINT_DATA_MASK		0xffff
+
+#define CGEM_RX_PAUSEQ			0x038	/* Received Pause Quantum */
+#define CGEM_TX_PAUSEQ			0x03C	/* Transmit Puase Quantum */
+
+#define CGEM_HASH_BOT			0x080	/* Hash Reg Bottom [31:0] */
+#define CGEM_HASH_TOP			0x084	/* Hash Reg Top [63:32] */
+#define CGEM_SPEC_ADDR_LOW(n)		(0x088 + (n) * 8)
+#define CGEM_SPEC_ADDR_HI(n)		(0x08C + (n) * 8)
+
+#define CGEM_TYPE_ID_MATCH1		0x0A8	/* Type ID Match 1 */
+#define   CGEM_TYPE_ID_MATCH_COPY_EN		(1U << 31)
+#define CGEM_TYPE_ID_MATCH2		0x0AC	/* Type ID Match 2 */
+#define CGEM_TYPE_ID_MATCH3		0x0B0	/* Type ID Match 3 */
+#define CGEM_TYPE_ID_MATCH4		0x0B4	/* Type ID Match 4 */
+
+#define CGEM_WAKE_ON_LAN		0x0B8	/* Wake on LAN Register */
+#define   CGEM_WOL_MULTI_HASH_EN		(1 << 19)
+#define   CGEM_WOL_SPEC_ADDR1_EN		(1 << 18)
+#define   CGEM_WOL_ARP_REQ_EN			(1 << 17)
+#define   CGEM_WOL_MAGIC_PKT_EN			(1 << 16)
+#define   CGEM_WOL_ARP_REQ_IP_ADDR_MASK		0xffff
+
+#define CGEM_IPG_STRETCH		/* IPG Stretch Register */
+
+#define CGEM_STACKED_VLAN		0x0C0	/* Stacked VLAN Register */
+#define   CGEM_STACKED_VLAN_EN			(1U << 31)
+
+#define CGEM_TX_PFC_PAUSE		0x0C4	/* Transmit PFC Pause Reg */
+#define   CGEM_TX_PFC_PAUSEQ_SEL_SHIFT		8
+#define   CGEM_TX_PFC_PAUSEQ_SEL_MASK		(0xff << 8)
+#define   CGEM_TX_PFC_PAUSE_PRI_EN_VEC_VAL_MASK 0xff
+
+#define CGEM_SPEC_ADDR1_MASK_BOT	0x0C8	/* Specific Addr Mask1 [31:0]*/
+#define CGEM_SPEC_ADDR1_MASK_TOP	0x0CC	/* Specific Addr Mask1[47:32]*/
+#define CGEM_MODULE_ID			0x0FC	/* Module ID */
+#define CGEM_OCTETS_TX_BOT		0x100	/* Octets xmitted [31:0] */
+#define CGEM_OCTETS_TX_TOP		0x104	/* Octets xmitted [47:32] */
+#define CGEM_FRAMES_TX			0x108	/* Frames xmitted */
+#define CGEM_BCAST_FRAMES_TX		0x10C	/* Broadcast Frames xmitted */
+#define CGEM_MULTI_FRAMES_TX		0x110	/* Multicast Frames xmitted */
+#define CGEM_PAUSE_FRAMES_TX		0x114	/* Pause Frames xmitted */
+#define CGEM_FRAMES_64B_TX		0x118	/* 64-Byte Frames xmitted */
+#define CGEM_FRAMES_65_127B_TX		0x11C	/* 65-127 Byte Frames xmitted*/
+#define CGEM_FRAMES_128_255B_TX		0x120	/* 128-255 Byte Frames xmit */
+#define CGEM_FRAMES_256_511B_TX		0x124	/* 256-511 Byte Frames xmit */
+#define CGEM_FRAMES_512_1023B_TX	0x128	/* 512-1023 Byte frames xmit */
+#define CGEM_FRAMES_1024_1518B_TX	0x12C	/* 1024-1518 Byte frames xmit*/
+#define CGEM_TX_UNDERRUNS		0x134	/* Transmit Under-runs */
+#define CGEM_SINGLE_COLL_FRAMES		0x138	/* Single-Collision Frames */
+#define CGEM_MULTI_COLL_FRAMES		0x13C	/* Multi-Collision Frames */
+#define CGEM_EXCESSIVE_COLL_FRAMES	0x140	/* Excessive Collision Frames*/
+#define CGEM_LATE_COLL			0x144	/* Late Collisions */
+#define CGEM_DEFERRED_TX_FRAMES		0x148	/* Deferred Transmit Frames */
+#define CGEM_CARRIER_SENSE_ERRS		0x14C	/* Carrier Sense Errors */
+#define CGEM_OCTETS_RX_BOT		0x150	/* Octets Received [31:0] */
+#define CGEM_OCTETS_RX_TOP		0x154	/* Octets Received [47:32] */
+#define CGEM_FRAMES_RX			0x158	/* Frames Received */
+#define CGEM_BCAST_FRAMES_RX		0x15C	/* Broadcast Frames Received */
+#define CGEM_MULTI_FRAMES_RX		0x160	/* Multicast Frames Received */
+#define CGEM_PAUSE_FRAMES_RX		0x164	/* Pause Frames Reeived */
+#define CGEM_FRAMES_64B_RX		0x168	/* 64-Byte Frames Received */
+#define CGEM_FRAMES_65_127B_RX		0x16C	/* 65-127 Byte Frames Rx'd */
+#define CGEM_FRAMES_128_255B_RX		0x170	/* 128-255 Byte Frames Rx'd */
+#define CGEM_FRAMES_256_511B_RX		0x174	/* 256-511 Byte Frames Rx'd */
+#define CGEM_FRAMES_512_1023B_RX	0x178	/* 512-1023 Byte Frames Rx'd */
+#define CGEM_FRAMES_1024_1518B_RX	0x17C	/* 1024-1518 Byte Frames Rx'd*/
+#define CGEM_UNDERSZ_RX			0x184	/* Undersize Frames Rx'd */
+#define CGEM_OVERSZ_RX			0x188	/* Oversize Frames Rx'd */
+#define CGEM_JABBERS_RX			0x18C	/* Jabbers received */
+#define CGEM_FCS_ERRS			0x190	/* Frame Check Sequence Errs */
+#define CGEM_LENGTH_FIELD_ERRS		0x194	/* Length Firled Frame Errs */
+#define CGEM_RX_SYMBOL_ERRS		0x198	/* Receive Symbol Errs */
+#define CGEM_ALIGN_ERRS			0x19C	/* Alignment Errors */
+#define CGEM_RX_RESOURCE_ERRS		0x1A0	/* Receive Resoure Errors */
+#define CGEM_RX_OVERRUN_ERRS		0x1A4	/* Receive Overrun Errors */
+#define CGEM_IP_HDR_CKSUM_ERRS		0x1A8	/* IP Hdr Checksum Errors */
+#define CGEM_TCP_CKSUM_ERRS		0x1AC	/* TCP Checksum Errors */
+#define CGEM_UDP_CKSUM_ERRS		0x1B0	/* UDP Checksum Errors */
+#define CGEM_TIMER_STROBE_S		0x1C8	/* 1588 timer sync strobe s */
+#define CGEM_TIMER_STROBE_NS		0x1CC	/* timer sync strobe ns */
+#define CGEM_TIMER_S			0x1D0	/* 1588 timer seconds */
+#define CGEM_TIMER_NS			0x1D4	/* 1588 timer ns */
+#define CGEM_ADJUST			0x1D8	/* 1588 timer adjust */
+#define CGEM_INCR			0x1DC	/* 1588 timer increment */
+#define CGEM_PTP_TX_S			0x1E0	/* PTP Event Frame xmit secs */
+#define CGEM_PTP_TX_NS			0x1E4	/* PTP Event Frame xmit ns */
+#define CGEM_PTP_RX_S			0x1E8	/* PTP Event Frame rcv'd s */
+#define CGEM_PTP_RX_NS			0x1EC	/* PTP Event Frame rcv'd ns */
+#define CGEM_PTP_PEER_TX_S		0x1F0	/* PTP Peer Event xmit s */
+#define CGEM_PTP_PEER_TX_NS		0x1F4	/* PTP Peer Event xmit ns */
+#define CGEM_PTP_PEER_RX_S		0x1F8	/* PTP Peer Event rcv'd s */
+#define CGEM_PTP_PEER_RX_NS		0x1FC	/* PTP Peer Event rcv'd ns */
+
+#define CGEM_DESIGN_CFG1		0x280	/* Design Configuration 1 */
+#define   CGEM_DESIGN_CFG1_AXI_CACHE_WIDTH_MASK	(0xfU << 28)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_MASK	(7 << 25)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_32	(1 << 25)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_64	(2 << 25)
+#define   CGEM_DESIGN_CFG1_DMA_BUS_WIDTH_128	(4 << 25)
+#define   CGEM_DESIGN_CFG1_IRQ_READ_CLR		(1 << 23)
+#define   CGEM_DESIGN_CFG1_NO_SNAPSHOT		(1 << 22)
+#define   CGEM_DESIGN_CFG1_NO_STATS		(1 << 21)
+#define   CGEM_DESIGN_CFG1_NO_SCAN_PINS		(1 << 20)
+#define   CGEM_DESIGN_CFG1_USER_IN_WIDTH_MASK	(0x1f << 15)
+#define   CGEM_DESIGN_CFG1_USER_OUT_WIDTH_MASK	(0x1f << 10)
+#define   CGEM_DESIGN_CFG1_USER_IO		(1 << 9)
+#define   CGEM_DESIGN_CFG1_APB_REV2		(1 << 8)
+#define   CGEM_DESIGN_CFG1_APB_REV1		(1 << 7)
+#define   CGEM_DESIGN_CFG1_EXT_FIFO_INTERFACE	(1 << 6)
+#define   CGEM_DESIGN_CFG1_NO_INT_LOOPBACK	(1 << 5)
+#define   CGEM_DESIGN_CFG1_INT_LOOPBACK		(1 << 4)
+#define   CGEM_DESIGN_CFG1_TDC_50		(1 << 3)
+#define   CGEM_DESIGN_CFG1_RDC_50		(1 << 2)
+#define   CGEM_DESIGN_CFG1_SERDES		(1 << 1)
+#define   CGEM_DESIGN_CFG1_NO_PCS		(1 << 0)
+
+#define CGEM_DESIGN_CFG2		0x284	/* Design Configuration 2 */
+#define   CGEM_DESIGN_CFG2_TX_PBUF_ADDR_SHIFT	26
+#define   CGEM_DESIGN_CFG2_TX_PBUF_ADDR_MASK	(0xf << 26)
+#define   CGEM_DESIGN_CFG2_RX_PBUF_ADDR_SHIFT	22
+#define   CGEM_DESIGN_CFG2_RX_PBUF_ADDR_MASK	(0xf << 22)
+#define   CGEM_DESIGN_CFG2_TX_PKT_BUF		(1 << 21)
+#define   CGEM_DESIGN_CFG2_RX_PKT_BUF		(1 << 20)
+#define   CGEM_DESIGN_CFG2_HPROT_VAL_SHIFT	16
+#define   CGEM_DESIGN_CFG2_HPROT_VAL_MASK	(0xf << 16)
+#define   CGEM_DESIGN_CFG2_JUMBO_MAX_LEN_MASK	0xffff
+
+#define CGEM_DESIGN_CFG3		0x288	/* Design Configuration 3 */
+#define   CGEM_DESIGN_CFG3_RX_BASE2_FIFO_SZ_MASK (0xffffU << 16)
+#define   CGEM_DESIGN_CFG3_RX_BASE2_FIFO_SZ_SHIFT 16
+#define   CGEM_DESIGN_CFG3_RX_FIFO_SIZE_MASK	0xffff
+
+#define CGEM_DESIGN_CFG4		0x28C	/* Design Configuration 4 */
+#define   CGEM_DESIGN_CFG4_TX_BASE2_FIFO_SZ_SHIFT 16
+#define   CGEM_DESIGN_CFG4_TX_BASE2_FIFO_SZ_MASK (0xffffU << 16)
+#define   CGEM_DESIGN_CFG4_TX_FIFO_SIZE_MASK	0xffff
+
+#define CGEM_DESIGN_CFG5		0x290	/* Design Configuration 5 */
+#define   CGEM_DESIGN_CFG5_TSU_CLK		(1 << 28)
+#define   CGEM_DESIGN_CFG5_RX_BUF_LEN_DEF_SHIFT 20
+#define   CGEM_DESIGN_CFG5_RX_BUF_LEN_DEF_MASK	(0xff << 20)
+#define   CGEM_DESIGN_CFG5_TX_PBUF_SIZE_DEF	(1 << 19)
+#define   CGEM_DESIGN_CFG5_RX_PBUF_SIZE_DEF_SHIFT 17
+#define   CGEM_DESIGN_CFG5_RX_PBUF_SIZE_DEF_MASK (3 << 17)
+#define   CGEM_DESIGN_CFG5_ENDIAN_SWAP_DEF_SHIFT 15
+#define   CGEM_DESIGN_CFG5_ENDIAN_SWAP_DEF_MASK (3 << 15)
+#define   CGEM_DESIGN_CFG5_MDC_CLOCK_DIV_SHIFT	12
+#define   CGEM_DESIGN_CFG5_MDC_CLOCK_DIV_MASK	(7 << 12)
+#define   CGEM_DESIGN_CFG5_DMA_BUS_WIDTH_SHIFT	10
+#define   CGEM_DESIGN_CFG5_DMA_BUS_WIDTH_MASK	(3 << 10)
+#define   CGEM_DESIGN_CFG5_PHY_IDENT		(1 << 9)
+#define   CGEM_DESIGN_CFG5_TSU			(1 << 8)
+#define   CGEM_DESIGN_CFG5_TX_FIFO_CNT_WIDTH_SHIFT 4
+#define   CGEM_DESIGN_CFG5_TX_FIFO_CNT_WIDTH_MASK (0xf << 4)
+#define   CGEM_DESIGN_CFG5_RX_FIFO_CNT_WIDTH_MASK 0xf
+
+#define CGEM_DESIGN_CFG6		0x294	/* Design Configuration 6 */
+#define   CGEM_DESIGN_CFG6_ADDR_64B		(1 << 23) /* 64-bit addr cap */
+#define   CGEM_DESIGN_CFG6_DMA_PRIO_Q_MASK	0xfffe
+#define   CGEM_DESIGN_CFG6_DMA_PRIO_Q(n)	(1 << (n))
+
+#define CGEM_TX_QN_BAR(n)		(0x440 + ((n) - 1) * 4)
+#define CGEM_RX_QN_BAR(n)		(0x480 + ((n) - 1) * 4)
+
+#define CGEM_TX_QBAR_HI			0x4C8
+#define CGEM_RX_QBAR_HI			0x4D4
+
+/*
+ * Transmit Descriptors:  two or four 32-bit words:
+ *	word0: address
+ *	word1: length and control
+ *	word2: address upper 32-bits (64-bit mode)
+ *	word3: unused (64-bit mode)
+ */
+
+struct cgem_tx_desc {
+	uint32_t	addr;
+	uint32_t	ctl;
+#define CGEM_TXDESC_USED			(1U << 31) /* done txmitting */
+#define CGEM_TXDESC_WRAP			(1 << 30)  /* end descr ring */
+#define CGEM_TXDESC_RETRY_ERR			(1 << 29)
+#define CGEM_TXDESC_AHB_ERR			(1 << 27)
+#define CGEM_TXDESC_LATE_COLL			(1 << 26)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_MASK		(7 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_VLAN_HDR_ERR (1 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_SNAP_HDR_ERR (2 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_IP_HDR_ERR	(3 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_UNKNOWN_TYPE (4 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_UNSUPP_FRAG	(5 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_NOT_TCPUDP	(6 << 20)
+#define CGEM_TXDESC_CKSUM_GEN_STAT_SHORT_PKT	(7 << 20)
+#define CGEM_TXDESC_NO_CRC_APPENDED		(1 << 16)
+#define CGEM_TXDESC_LAST_BUF			(1 << 15)  /* last in frame */
+#define CGEM_TXDESC_LENGTH_MASK		0x3fff
+#ifdef CGEM64
+	uint32_t	addrhi;
+	uint32_t	unused;
+#endif
+};
+
+/*
+ * Receive Descriptors: two or four 32-bit words:
+ *	word0: address | WRAP and OWN flags
+ *	word1: length and control
+ *	word2: address upper 32 bits (64-bit mode)
+ *	word3: unused
+ */
+
+struct cgem_rx_desc {
+	uint32_t	addr;
+#define CGEM_RXDESC_WRAP			(1 << 1)  /* goes in addr! */
+#define CGEM_RXDESC_OWN				(1 << 0)  /* buf filled */
+	uint32_t	ctl;
+#define CGEM_RXDESC_BCAST			(1U << 31)/* all 1's bcast */
+#define CGEM_RXDESC_MULTI_MATCH			(1 << 30) /* mutlicast match */
+#define CGEM_RXDESC_UNICAST_MATCH		(1 << 29)
+#define CGEM_RXDESC_EXTERNAL_MATCH		(1 << 28) /* ext addr match */
+#define CGEM_RXDESC_SPEC_MATCH_SHIFT		25
+#define CGEM_RXDESC_SPEC_MATCH_MASK		(3 << 25)
+#define CGEM_RXDESC_TYPE_ID_MATCH_SHIFT		22
+#define CGEM_RXDESC_TYPE_ID_MATCH_MASK		(3 << 22)
+#define CGEM_RXDESC_CKSUM_STAT_MASK		(3 << 22) /* same as above */
+#define CGEM_RXDESC_CKSUM_STAT_NONE		(0 << 22)
+#define CGEM_RXDESC_CKSUM_STAT_IP_GOOD		(1 << 22)
+#define CGEM_RXDESC_CKSUM_STAT_TCP_GOOD		(2 << 22) /* and ip good */
+#define CGEM_RXDESC_CKSUM_STAT_UDP_GOOD		(3 << 22) /* and ip good */
+#define CGEM_RXDESC_VLAN_DETECTED		(1 << 21)
+#define CGEM_RXDESC_PRIO_DETECTED		(1 << 20)
+#define CGEM_RXDESC_VLAN_PRIO_SHIFT		17
+#define CGEM_RXDESC_VLAN_PRIO_MASK		(7 << 17)
+#define CGEM_RXDESC_CFI				(1 << 16)
+#define CGEM_RXDESC_EOF				(1 << 15) /* end of frame */
+#define CGEM_RXDESC_SOF				(1 << 14) /* start of frame */
+#define CGEM_RXDESC_BAD_FCS			(1 << 13)
+#define CGEM_RXDESC_LENGTH_MASK			0x1fff
+#ifdef CGEM64
+	uint32_t	addrhi;
+	uint32_t	unused;
+#endif
+};
+
+#endif /* _IF_CGEM_HW_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/device.c b/src/add-ons/kernel/drivers/network/cadence_gem/device.c
new file mode 100644
index 0000000000..666dfae2d1
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/device.c
@@ -0,0 +1,651 @@
+/*
+ * Copyright 2007, Hugo Santos, hugosantos@gmail.com. All Rights Reserved.
+ * Copyright 2007, Axel Drfler, axeld@pinc-software.de. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ *
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include "device.h"
+
+#include <stdio.h>
+
+#include <KernelExport.h>
+#include <image.h>
+#include <kernel/heap.h>
+
+#include <compat/machine/resource.h>
+#include <compat/dev/mii/mii.h>
+#include <compat/sys/bus.h>
+#include <compat/net/if_media.h>
+
+#include <compat/dev/mii/miivar.h>
+
+
+spinlock __haiku_intr_spinlock;
+
+struct net_stack_module_info *gStack;
+
+static struct list sRootDevices;
+static int sNextUnit;
+
+//	#pragma mark - private functions
+
+
+static device_t
+init_device(device_t device, driver_t *driver)
+{
+	list_init_etc(&device->children, offsetof(struct device, link));
+	device->unit = sNextUnit++;
+
+	if (driver != NULL && device_set_driver(device, driver) < 0)
+		return NULL;
+
+	return device;
+}
+
+
+static device_t
+new_device(driver_t *driver)
+{
+	device_t dev = malloc(sizeof(struct device));
+	if (dev == NULL)
+		return NULL;
+
+	memset(dev, 0, sizeof(struct device));
+
+	if (init_device(dev, driver) == NULL) {
+		free(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+
+static image_id
+find_own_image()
+{
+	int32 cookie = 0;
+	image_info info;
+	while (get_next_image_info(B_SYSTEM_TEAM, &cookie, &info) == B_OK) {
+		if (((addr_t)info.text <= (addr_t)find_own_image
+			&& (addr_t)info.text + (addr_t)info.text_size
+				> (addr_t)find_own_image)) {
+			// found our own image
+			return info.id;
+		}
+	}
+
+	return B_ENTRY_NOT_FOUND;
+}
+
+
+static device_method_signature_t
+resolve_method(driver_t *driver, const char *name)
+{
+	device_method_signature_t method = NULL;
+	int i;
+
+	for (i = 0; method == NULL && driver->methods[i].name != NULL; i++) {
+		if (strcmp(driver->methods[i].name, name) == 0)
+			method = driver->methods[i].method;
+	}
+
+	if (method == NULL)
+		panic("resolve_method: method%s not found\n", name);
+
+	return method;
+}
+
+
+//	#pragma mark - Device
+
+
+void
+driver_printf(const char *format, ...)
+{
+	va_list vl;
+	va_start(vl, format);
+	driver_vprintf(format, vl);
+	va_end(vl);
+}
+
+
+static int
+driver_vprintf_etc(const char *extra, const char *format, va_list vl)
+{
+	char buf[256];
+	int ret = vsnprintf(buf, sizeof(buf), format, vl);
+
+	if (extra)
+		dprintf("[%s] (%s) %s", gDriverName, extra, buf);
+	else
+		dprintf("[%s] %s", gDriverName, buf);
+
+	return ret;
+}
+
+
+int
+driver_vprintf(const char *format, va_list vl)
+{
+	return driver_vprintf_etc(NULL, format, vl);
+}
+
+
+int
+device_printf(device_t dev, const char *format, ...)
+{
+	va_list vl;
+
+	va_start(vl, format);
+	driver_vprintf_etc(dev->device_name, format, vl);
+	va_end(vl);
+	return 0;
+}
+
+
+void
+device_set_desc(device_t dev, const char *desc)
+{
+	dev->description = desc;
+}
+
+
+void
+device_set_desc_copy(device_t dev, const char *desc)
+{
+	dev->description = strdup(desc);
+	dev->flags |= DEVICE_DESC_ALLOCED;
+}
+
+
+const char *
+device_get_desc(device_t dev)
+{
+	return dev->description;
+}
+
+
+device_t
+device_get_parent(device_t dev)
+{
+	return dev->parent;
+}
+
+
+devclass_t
+device_get_devclass(device_t dev)
+{
+	// TODO find out what to do
+	return 0;
+}
+
+
+int
+device_get_children(device_t dev, device_t **devlistp, int *devcountp)
+{
+	int count;
+	device_t child = NULL;
+	device_t *list;
+
+	count = 0;
+	while ((child = list_get_next_item(&dev->children, child)) != NULL) {
+		count++;
+	}
+
+	if (count == 0) {
+		*devlistp = NULL;
+		*devcountp = 0;
+		return (0);
+	}
+
+	list = malloc(count * sizeof(device_t));
+	if (!list)
+		return (ENOMEM);
+
+	count = 0;
+	while ((child = list_get_next_item(&dev->children, child)) != NULL) {
+		list[count] = child;
+		count++;
+	}
+
+	*devlistp = list;
+	*devcountp = count;
+
+	return (0);
+}
+
+
+void
+device_set_ivars(device_t dev, void *ivars)
+{
+	dev->ivars = ivars;
+}
+
+
+void *
+device_get_ivars(device_t dev)
+{
+	return dev->ivars;
+}
+
+
+const char *
+device_get_name(device_t dev)
+{
+	if (dev == NULL)
+		return NULL;
+
+	return dev->device_name;
+}
+
+
+int
+device_get_unit(device_t dev)
+{
+	return dev->unit;
+}
+
+
+const char *
+device_get_nameunit(device_t dev)
+{
+	return dev->nameunit;
+}
+
+
+void *
+device_get_softc(device_t dev)
+{
+	return dev->softc;
+}
+
+
+void
+device_set_softc(device_t dev, void *softc)
+{
+	if (dev->softc == softc)
+		return;
+
+	if ((dev->flags & DEVICE_SOFTC_SET) == 0) {
+		// Not externally allocated. We own it so we must clean it up.
+		free(dev->softc);
+	}
+
+	dev->softc = softc;
+	if (dev->softc != NULL)
+		dev->flags |= DEVICE_SOFTC_SET;
+	else
+		dev->flags &= ~DEVICE_SOFTC_SET;
+}
+
+
+u_int32_t
+device_get_flags(device_t dev)
+{
+	return dev->flags;
+}
+
+
+int
+device_set_driver(device_t dev, driver_t *driver)
+{
+	int i;
+
+	dev->softc = malloc(driver->size);
+	if (dev->softc == NULL)
+		return -1;
+
+	memset(dev->softc, 0, driver->size);
+	dev->driver = driver;
+
+	for (i = 0; driver->methods[i].name != NULL; i++) {
+		device_method_t *mth = &driver->methods[i];
+
+		if (strcmp(mth->name, "device_register") == 0)
+			dev->methods.device_register = (void *)mth->method;
+		else if (strcmp(mth->name, "device_probe") == 0)
+			dev->methods.probe = (void *)mth->method;
+		else if (strcmp(mth->name, "device_attach") == 0)
+			dev->methods.attach = (void *)mth->method;
+		else if (strcmp(mth->name, "device_detach") == 0)
+			dev->methods.detach = (void *)mth->method;
+		else if (strcmp(mth->name, "device_suspend") == 0)
+			dev->methods.suspend = (void *)mth->method;
+		else if (strcmp(mth->name, "device_resume") == 0)
+			dev->methods.resume = (void *)mth->method;
+		else if (strcmp(mth->name, "device_shutdown") == 0)
+			dev->methods.shutdown = (void *)mth->method;
+		else if (strcmp(mth->name, "miibus_readreg") == 0)
+			dev->methods.miibus_readreg = (void *)mth->method;
+		else if (strcmp(mth->name, "miibus_writereg") == 0)
+			dev->methods.miibus_writereg = (void *)mth->method;
+		else if (strcmp(mth->name, "miibus_statchg") == 0)
+			dev->methods.miibus_statchg = (void *)mth->method;
+		else if (!strcmp(mth->name, "miibus_linkchg"))
+			dev->methods.miibus_linkchg = (void *)mth->method;
+		else if (!strcmp(mth->name, "miibus_mediainit"))
+			dev->methods.miibus_mediainit = (void *)mth->method;
+		else if (!strcmp(mth->name, "bus_child_location_str"))
+			dev->methods.bus_child_location_str = (void *)mth->method;
+		else if (!strcmp(mth->name, "bus_child_pnpinfo_str"))
+			dev->methods.bus_child_pnpinfo_str = (void *)mth->method;
+		else if (!strcmp(mth->name, "bus_hinted_child"))
+			dev->methods.bus_hinted_child = (void *)mth->method;
+		else if (!strcmp(mth->name, "bus_print_child"))
+			dev->methods.bus_print_child = (void *)mth->method;
+		else if (!strcmp(mth->name, "bus_read_ivar"))
+			dev->methods.bus_read_ivar = (void *)mth->method;
+		else if (!strcmp(mth->name, "bus_get_dma_tag"))
+			dev->methods.bus_get_dma_tag = (void *)mth->method;
+		else
+			panic("device_set_driver: method %s not found\n", mth->name);
+
+	}
+
+	return 0;
+}
+
+
+int
+device_is_alive(device_t device)
+{
+	return (device->flags & DEVICE_ATTACHED) != 0;
+}
+
+
+device_t
+device_add_child_driver(device_t parent, const char* name, driver_t* _driver,
+	int unit)
+{
+	device_t child = NULL;
+
+	if (_driver == NULL && name != NULL) {
+		if (strcmp(name, "miibus") == 0)
+			child = new_device(&miibus_driver);
+		else {
+			// find matching driver structure
+			driver_t** driver;
+			char symbol[128];
+
+			snprintf(symbol, sizeof(symbol), "__fbsd_%s_%s", name,
+				parent->driver->name);
+			if (get_image_symbol(find_own_image(), symbol, B_SYMBOL_TYPE_DATA,
+					(void**)&driver) == B_OK) {
+				child = new_device(*driver);
+			} else
+				device_printf(parent, "couldn't find symbol %s\n", symbol);
+		}
+	} else if (_driver != NULL) {
+		child = new_device(_driver);
+	} else
+		child = new_device(NULL);
+
+	if (child == NULL)
+		return NULL;
+
+	if (name != NULL)
+		strlcpy(child->device_name, name, sizeof(child->device_name));
+
+	child->parent = parent;
+
+	if (parent != NULL) {
+		list_add_item(&parent->children, child);
+		child->root = parent->root;
+	} else {
+		if (sRootDevices.link.next == NULL)
+			list_init_etc(&sRootDevices, offsetof(struct device, link));
+		list_add_item(&sRootDevices, child);
+	}
+
+	return child;
+}
+
+
+device_t
+device_add_child(device_t parent, const char* name, int unit)
+{
+	return device_add_child_driver(parent, name, NULL, unit);
+}
+
+
+/*!	Delete the child and all of its children. Detach as necessary.
+*/
+int
+device_delete_child(device_t parent, device_t child)
+{
+	int status;
+
+	if (child == NULL)
+		return 0;
+
+	if (parent != NULL)
+		list_remove_item(&parent->children, child);
+	else
+		list_remove_item(&sRootDevices, child);
+
+	// We differentiate from the FreeBSD logic here - it will first delete
+	// the children, and will then detach the device.
+	// This has the problem that you cannot safely call device_delete_child()
+	// as you don't know if one of the children deletes its own children this
+	// way when it is detached.
+	// Therefore, we'll detach first, and then delete whatever is left.
+
+	parent = child;
+	child = NULL;
+
+	// detach children
+	while ((child = list_get_next_item(&parent->children, child)) != NULL) {
+		device_detach(child);
+	}
+
+	// detach device
+	status = device_detach(parent);
+	if (status != 0)
+		return status;
+
+	// delete children
+	while ((child = list_get_first_item(&parent->children)) != NULL) {
+		device_delete_child(parent, child);
+	}
+
+	// delete device
+	if (parent->flags & DEVICE_DESC_ALLOCED)
+		free((char *)parent->description);
+
+	// Delete softc if we were the ones to allocate it.
+	if ((parent->flags & DEVICE_SOFTC_SET) == 0)
+		free(parent->softc);
+
+	free(parent);
+	return 0;
+}
+
+
+int
+device_is_attached(device_t device)
+{
+	return (device->flags & DEVICE_ATTACHED) != 0;
+}
+
+
+int
+device_attach(device_t device)
+{
+	int result;
+
+	if (device->driver == NULL
+		|| device->methods.attach == NULL)
+		return B_ERROR;
+
+	result = device->methods.attach(device);
+
+	if (result == 0)
+		atomic_or(&device->flags, DEVICE_ATTACHED);
+/*
+	if (result == 0 && HAIKU_DRIVER_REQUIRES(FBSD_WLAN_FEATURE))
+		result = start_wlan(device);
+*/
+	return result;
+}
+
+
+int
+device_detach(device_t device)
+{
+	if (device->driver == NULL)
+		return B_ERROR;
+
+	if ((atomic_and(&device->flags, ~DEVICE_ATTACHED) & DEVICE_ATTACHED) != 0
+			&& device->methods.detach != NULL) {
+		int result = 0;
+/*
+		if (HAIKU_DRIVER_REQUIRES(FBSD_WLAN_FEATURE))
+			result = stop_wlan(device);
+*/
+		if (result != 0 && result != B_BAD_VALUE) {
+			atomic_or(&device->flags, DEVICE_ATTACHED);
+			return result;
+		}
+
+		result = device->methods.detach(device);
+		if (result != 0) {
+			atomic_or(&device->flags, DEVICE_ATTACHED);
+			return result;
+		}
+	}
+
+	return 0;
+}
+
+
+int
+bus_generic_attach(device_t dev)
+{
+	device_t child = NULL;
+
+	while ((child = list_get_next_item(&dev->children, child)) != NULL) {
+		if (child->driver == NULL) {
+			driver_t *driver = __haiku_select_miibus_driver(child);
+			if (driver == NULL) {
+				struct mii_attach_args *ma = device_get_ivars(child);
+
+				device_printf(dev, "No PHY module found (%x/%x)!\n",
+					MII_OUI(ma->mii_id1, ma->mii_id2), MII_MODEL(ma->mii_id2));
+			} else
+				device_set_driver(child, driver);
+		} else
+			child->methods.probe(child);
+
+		if (child->driver != NULL) {
+			int result = device_attach(child);
+			if (result != 0)
+				return result;
+		}
+	}
+
+	return 0;
+}
+
+
+int
+bus_generic_detach(device_t device)
+{
+	device_t child = NULL;
+
+	if ((device->flags & DEVICE_ATTACHED) == 0)
+		return B_ERROR;
+
+	while (true) {
+		child = list_get_next_item(&device->children, child);
+		if (child == NULL)
+			break;
+
+		device_detach(child);
+	}
+
+	return 0;
+}
+
+
+//	#pragma mark - Misc, Malloc
+
+
+device_t
+find_root_device(int unit)
+{
+	device_t device = NULL;
+
+	while ((device = list_get_next_item(&sRootDevices, device)) != NULL) {
+		if (device->unit <= unit)
+			return device;
+	}
+
+	return NULL;
+}
+
+
+driver_t *
+__haiku_probe_miibus(device_t dev, driver_t *drivers[])
+{
+	driver_t *selected = NULL;
+	int i, selectedResult = 0;
+
+	if (drivers == NULL)
+		return NULL;
+
+	for (i = 0; drivers[i]; i++) {
+		device_probe_t *probe = (device_probe_t *)
+			resolve_method(drivers[i], "device_probe");
+		if (probe) {
+			int result = probe(dev);
+			if (result >= 0) {
+				if (selected == NULL || result < selectedResult) {
+					selected = drivers[i];
+					selectedResult = result;
+					device_printf(dev, "Found MII: %s\n", selected->name);
+				}
+			}
+		}
+	}
+
+	return selected;
+}
+
+
+int
+printf(const char *format, ...)
+{
+	char buf[256];
+	va_list vl;
+	va_start(vl, format);
+	vsnprintf(buf, sizeof(buf), format, vl);
+	va_end(vl);
+	dprintf(buf);
+
+	return 0;
+}
+
+
+int
+resource_int_value(const char *name, int unit, const char *resname,
+	int *result)
+{
+	/* no support for hints */
+	return -1;
+}
+
+
+int
+resource_disabled(const char *name, int unit)
+{
+	int error, value;
+
+	error = resource_int_value(name, unit, "disabled", &value);
+	if (error)
+	       return (0);
+	return (value);
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/device.h b/src/add-ons/kernel/drivers/network/cadence_gem/device.h
new file mode 100644
index 0000000000..6aaf0a780d
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/device.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de. All Rights Reserved.
+ * Copyright 2007, Axel Drfler, axeld@pinc-software.de. All Rights Reserved.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef DEVICE_H
+#define DEVICE_H
+
+
+#include <stdint.h>
+#include <stdio.h>
+
+#include <KernelExport.h>
+
+#include <util/list.h>
+
+#include <net_stack.h>
+
+#include <compat/sys/kernel.h>
+#include <compat/net/if.h>
+
+#include "shared.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum {
+	DEVICE_OPEN		= 1 << 0,
+	DEVICE_CLOSED		= 1 << 1,
+	DEVICE_NON_BLOCK	= 1 << 2,
+	DEVICE_DESC_ALLOCED	= 1 << 3,
+	DEVICE_ATTACHED		= 1 << 4,
+	DEVICE_SOFTC_SET	= 1 << 5  // Set through device_set_softc().
+};
+
+
+extern struct net_stack_module_info *gStack;
+
+
+static inline void
+__unimplemented(const char *method)
+{
+	char msg[128];
+	snprintf(msg, sizeof(msg), "fbsd compat, unimplemented: %s", method);
+	panic(msg);
+}
+
+#define UNIMPLEMENTED() __unimplemented(__FUNCTION__)
+
+status_t init_mbufs(void);
+void uninit_mbufs(void);
+
+status_t init_mutexes(void);
+void uninit_mutexes(void);
+
+status_t init_taskqueues(void);
+void uninit_taskqueues(void);
+
+status_t init_hard_clock(void);
+void uninit_hard_clock(void);
+
+status_t init_callout(void);
+void uninit_callout(void);
+
+device_t find_root_device(int);
+
+void driver_printf(const char *format, ...)
+	__attribute__ ((format (__printf__, 1, 2)));
+int driver_vprintf(const char *format, va_list vl);
+
+void device_sprintf_name(device_t dev, const char *format, ...)
+	__attribute__ ((format (__printf__, 2, 3)));
+
+void ifq_init(struct ifqueue *, const char *);
+void ifq_uninit(struct ifqueue *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#if 0
+#include "device_pci.h"
+#else
+#include "device_fdt.h"
+#endif
+
+#endif	/* DEVICE_H */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/device_fdt.h b/src/add-ons/kernel/drivers/network/cadence_gem/device_fdt.h
new file mode 100644
index 0000000000..bc4c84f40f
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/device_fdt.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de. All Rights Reserved.
+ * Copyright 2007, Axel Drfler, axeld@pinc-software.de. All Rights Reserved.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef DEVICE_FDT_H
+#define DEVICE_FDT_H
+
+
+#include <drivers/bus/FDT.h>
+
+struct root_device_softc {
+	device_node* node;
+};
+
+
+#endif	/* DEVICE_FDT_H */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_if_media.c b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_if_media.c
new file mode 100644
index 0000000000..24be63b013
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_if_media.c
@@ -0,0 +1,532 @@
+/*	$NetBSD: if_media.c,v 1.1 1997/03/17 02:55:15 thorpej Exp $	*/
+/* $FreeBSD: src/sys/net/if_media.c,v 1.21.2.1 2006/03/17 20:17:43 glebius Exp $ */
+
+/*-
+ * Copyright (c) 1997
+ *	Jonathan Stone and Jason R. Thorpe.  All rights reserved.
+ *
+ * This software is derived from information provided by Matt Thomas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Jonathan Stone
+ *	and Jason R. Thorpe for the NetBSD Project.
+ * 4. The names of the authors may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * BSD/OS-compatible network interface media selection.
+ *
+ * Where it is safe to do so, this code strays slightly from the BSD/OS
+ * design.  Software which uses the API (device drivers, basically)
+ * shouldn't notice any difference.
+ *
+ * Many thanks to Matt Thomas for providing the information necessary
+ * to implement this interface.
+ */
+#include <string.h>
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/malloc.h>
+#include <sys/sysctl.h>
+
+#include <net/if.h>
+#include <net/if_media.h>
+
+/*
+ * Compile-time options:
+ * IFMEDIA_DEBUG:
+ *	turn on implementation-level debug printfs.
+ * 	Useful for debugging newly-ported  drivers.
+ */
+
+#define IFMEDIA_DEBUG
+#ifdef IFMEDIA_DEBUG
+#   define TRACE(x...) dprintf(x)
+#else
+#   define TRACE(x...) ;
+#endif
+
+static struct ifmedia_entry *ifmedia_match(struct ifmedia *ifm,
+	int flags, int mask);
+
+static	void ifmedia_printword(int);
+
+/*
+ * Initialize if_media struct for a specific interface instance.
+ */
+void
+ifmedia_init(ifm, dontcare_mask, change_callback, status_callback)
+	struct ifmedia *ifm;
+	int dontcare_mask;
+	ifm_change_cb_t change_callback;
+	ifm_stat_cb_t status_callback;
+{
+
+	LIST_INIT(&ifm->ifm_list);
+	ifm->ifm_cur = NULL;
+	ifm->ifm_media = 0;
+	ifm->ifm_mask = dontcare_mask;		/* IF don't-care bits */
+	ifm->ifm_change = change_callback;
+	ifm->ifm_status = status_callback;
+}
+
+void
+ifmedia_removeall(ifm)
+	struct ifmedia *ifm;
+{
+	struct ifmedia_entry *entry;
+
+	for (entry = LIST_FIRST(&ifm->ifm_list); entry;
+	     entry = LIST_FIRST(&ifm->ifm_list)) {
+		LIST_REMOVE(entry, ifm_list);
+		kernel_free(entry, M_IFADDR);
+	}
+}
+
+/*
+ * Add a media configuration to the list of supported media
+ * for a specific interface instance.
+ */
+void
+ifmedia_add(ifm, mword, data, aux)
+	struct ifmedia *ifm;
+	int mword;
+	int data;
+	void *aux;
+{
+	register struct ifmedia_entry *entry;
+
+#ifdef IFMEDIA_DEBUG
+	if (ifm == NULL) {
+		TRACE("ifmedia_add: null ifm\n");
+		return;
+	}
+	TRACE("ifmedia_add: Adding Entry...\n");
+	ifmedia_printword(mword);
+#endif
+
+	entry = kernel_malloc(sizeof(*entry), M_IFADDR, M_NOWAIT);
+	if (entry == NULL)
+		panic("ifmedia_add: can't malloc entry");
+
+	entry->ifm_media = mword;
+	entry->ifm_data = data;
+	entry->ifm_aux = aux;
+
+	LIST_INSERT_HEAD(&ifm->ifm_list, entry, ifm_list);
+}
+
+/*
+ * Add an array of media configurations to the list of
+ * supported media for a specific interface instance.
+ */
+void
+ifmedia_list_add(ifm, lp, count)
+	struct ifmedia *ifm;
+	struct ifmedia_entry *lp;
+	int count;
+{
+	int i;
+
+	for (i = 0; i < count; i++)
+		ifmedia_add(ifm, lp[i].ifm_media, lp[i].ifm_data,
+		    lp[i].ifm_aux);
+}
+
+/*
+ * Set the default active media.
+ *
+ * Called by device-specific code which is assumed to have already
+ * selected the default media in hardware.  We do _not_ call the
+ * media-change callback.
+ */
+void
+ifmedia_set(ifm, target)
+	struct ifmedia *ifm;
+	int target;
+
+{
+	struct ifmedia_entry *match;
+
+	match = ifmedia_match(ifm, target, ifm->ifm_mask);
+
+	if (match == NULL) {
+		TRACE("ifmedia_set: no match for 0x%x/0x%x\n",
+			target, ~ifm->ifm_mask);
+		panic("ifmedia_set");
+	}
+	ifm->ifm_cur = match;
+
+#ifdef IFMEDIA_DEBUG
+	TRACE("ifmedia_set: target ");
+	ifmedia_printword(target);
+	TRACE("ifmedia_set: setting to ");
+	ifmedia_printword(ifm->ifm_cur->ifm_media);
+#endif
+}
+
+/*
+ * Device-independent media ioctl support function.
+ */
+int
+ifmedia_ioctl(ifp, ifr, ifm, cmd)
+	struct ifnet *ifp;
+	struct ifreq *ifr;
+	struct ifmedia *ifm;
+	u_long cmd;
+{
+	struct ifmedia_entry *match;
+	struct ifmediareq *ifmr = (struct ifmediareq *) ifr;
+	int error = 0, sticky;
+
+	if (ifp == NULL || ifr == NULL || ifm == NULL)
+		return(EINVAL);
+
+	switch (cmd) {
+
+	/*
+	 * Set the current media.
+	 */
+	case  SIOCSIFMEDIA:
+	{
+		struct ifmedia_entry *oldentry;
+		int oldmedia;
+		int newmedia = ifr->ifr_media;
+
+		match = ifmedia_match(ifm, newmedia, ifm->ifm_mask);
+		if (match == NULL) {
+			TRACE("ifmedia_ioctl: no media found for 0x%x\n",
+				newmedia);
+			return (ENXIO);
+		}
+
+		/*
+		 * If no change, we're done.
+		 * XXX Automedia may invole software intervention.
+		 *     Keep going in case the the connected media changed.
+		 *     Similarly, if best match changed (kernel debugger?).
+		 */
+		if ((IFM_SUBTYPE(newmedia) != IFM_AUTO) &&
+		    (newmedia == ifm->ifm_media) &&
+		    (match == ifm->ifm_cur))
+			return 0;
+
+		/*
+		 * We found a match, now make the driver switch to it.
+		 * Make sure to preserve our old media type in case the
+		 * driver can't switch.
+		 */
+#ifdef IFMEDIA_DEBUG
+		TRACE("ifmedia_ioctl: switching %s to ",
+			ifp->if_xname);
+		ifmedia_printword(match->ifm_media);
+#endif
+		oldentry = ifm->ifm_cur;
+		oldmedia = ifm->ifm_media;
+		ifm->ifm_cur = match;
+		ifm->ifm_media = newmedia;
+		error = (*ifm->ifm_change)(ifp);
+		if (error) {
+			ifm->ifm_cur = oldentry;
+			ifm->ifm_media = oldmedia;
+		}
+		break;
+	}
+
+	/*
+	 * Get list of available media and current media on interface.
+	 */
+	case  SIOCGIFMEDIA:
+	{
+		struct ifmedia_entry *ep;
+		int *kptr, count;
+		int usermax;	/* user requested max */
+
+		kptr = NULL;		/* XXX gcc */
+
+		ifmr->ifm_active = ifmr->ifm_current = ifm->ifm_cur ?
+		    ifm->ifm_cur->ifm_media : IFM_NONE;
+		ifmr->ifm_mask = ifm->ifm_mask;
+		ifmr->ifm_status = 0;
+		(*ifm->ifm_status)(ifp, ifmr);
+
+		count = 0;
+		usermax = 0;
+
+		/*
+		 * If there are more interfaces on the list, count
+		 * them.  This allows the caller to set ifmr->ifm_count
+		 * to 0 on the first call to know how much space to
+		 * allocate.
+		 */
+		LIST_FOREACH(ep, &ifm->ifm_list, ifm_list)
+			usermax++;
+
+		/*
+		 * Don't allow the user to ask for too many
+		 * or a negative number.
+		 */
+		if (ifmr->ifm_count > usermax)
+			ifmr->ifm_count = usermax;
+		else if (ifmr->ifm_count < 0)
+			return (EINVAL);
+
+		if (ifmr->ifm_count != 0) {
+			kptr = (int *)kernel_malloc(ifmr->ifm_count * sizeof(int),
+			    M_TEMP, M_NOWAIT);
+
+			if (kptr == NULL)
+				return (ENOMEM);
+			/*
+			 * Get the media words from the interface's list.
+			 */
+			ep = LIST_FIRST(&ifm->ifm_list);
+			for (; ep != NULL && count < ifmr->ifm_count;
+			    ep = LIST_NEXT(ep, ifm_list), count++)
+				kptr[count] = ep->ifm_media;
+
+			if (ep != NULL)
+				error = E2BIG;	/* oops! */
+		} else {
+			count = usermax;
+		}
+
+		/*
+		 * We do the copyout on E2BIG, because that's
+		 * just our way of telling userland that there
+		 * are more.  This is the behavior I've observed
+		 * under BSD/OS 3.0
+		 */
+		sticky = error;
+		if ((error == 0 || error == E2BIG) && ifmr->ifm_count != 0) {
+#if 0
+			error = copyout((caddr_t)kptr,
+			    (caddr_t)ifmr->ifm_ulist,
+			    ifmr->ifm_count * sizeof(int));
+#endif
+			/* this ioctl() is only called from within the kernel -hugo */
+			memcpy(kptr, ifmr->ifm_ulist, ifmr->ifm_count * sizeof(int));
+		}
+
+		if (error == 0)
+			error = sticky;
+
+		if (ifmr->ifm_count != 0)
+			kernel_free(kptr, M_TEMP);
+
+		ifmr->ifm_count = count;
+		break;
+	}
+
+	default:
+		return (EINVAL);
+	}
+
+	return (error);
+}
+
+/*
+ * Find media entry matching a given ifm word.
+ *
+ */
+static struct ifmedia_entry *
+ifmedia_match(ifm, target, mask)
+	struct ifmedia *ifm;
+	int target;
+	int mask;
+{
+	struct ifmedia_entry *match, *next;
+
+	match = NULL;
+	mask = ~mask;
+
+	LIST_FOREACH(next, &ifm->ifm_list, ifm_list) {
+		if ((next->ifm_media & mask) == (target & mask)) {
+#ifdef IFMEDIA_DEBUG
+			if (match) {
+				TRACE("ifmedia_match: multiple match for "
+					"0x%x/0x%x\n", target, mask);
+			}
+#endif
+			match = next;
+		}
+	}
+
+	return match;
+}
+
+/*
+ * Compute the interface `baudrate' from the media, for the interface
+ * metrics (used by routing daemons).
+ */
+static const struct ifmedia_baudrate ifmedia_baudrate_descriptions[] =
+    IFM_BAUDRATE_DESCRIPTIONS;
+
+uint64_t
+ifmedia_baudrate(int mword)
+{
+	int i;
+
+	for (i = 0; ifmedia_baudrate_descriptions[i].ifmb_word != 0; i++) {
+		if ((mword & (IFM_NMASK|IFM_TMASK)) ==
+		    ifmedia_baudrate_descriptions[i].ifmb_word)
+			return (ifmedia_baudrate_descriptions[i].ifmb_baudrate);
+	}
+
+	/* Not known. */
+	return (0);
+}
+
+#ifdef IFMEDIA_DEBUG
+struct ifmedia_description ifm_type_descriptions[] =
+    IFM_TYPE_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_ethernet_descriptions[] =
+    IFM_SUBTYPE_ETHERNET_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_ethernet_option_descriptions[] =
+    IFM_SUBTYPE_ETHERNET_OPTION_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_ieee80211_descriptions[] =
+    IFM_SUBTYPE_IEEE80211_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_ieee80211_option_descriptions[] =
+    IFM_SUBTYPE_IEEE80211_OPTION_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_ieee80211_mode_descriptions[] =
+    IFM_SUBTYPE_IEEE80211_MODE_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_atm_descriptions[] =
+    IFM_SUBTYPE_ATM_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_atm_option_descriptions[] =
+    IFM_SUBTYPE_ATM_OPTION_DESCRIPTIONS;
+
+struct ifmedia_description ifm_subtype_shared_descriptions[] =
+    IFM_SUBTYPE_SHARED_DESCRIPTIONS;
+
+struct ifmedia_description ifm_shared_option_descriptions[] =
+    IFM_SHARED_OPTION_DESCRIPTIONS;
+
+struct ifmedia_type_to_subtype {
+	struct ifmedia_description *subtypes;
+	struct ifmedia_description *options;
+	struct ifmedia_description *modes;
+};
+
+/* must be in the same order as IFM_TYPE_DESCRIPTIONS */
+struct ifmedia_type_to_subtype ifmedia_types_to_subtypes[] = {
+	{
+	  &ifm_subtype_ethernet_descriptions[0],
+	  &ifm_subtype_ethernet_option_descriptions[0],
+	  NULL,
+	},
+	{
+	  &ifm_subtype_ieee80211_descriptions[0],
+	  &ifm_subtype_ieee80211_option_descriptions[0],
+	  &ifm_subtype_ieee80211_mode_descriptions[0]
+	},
+	{
+	  &ifm_subtype_atm_descriptions[0],
+	  &ifm_subtype_atm_option_descriptions[0],
+	  NULL,
+	},
+};
+
+/*
+ * print a media word.
+ */
+static void
+ifmedia_printword(ifmw)
+	int ifmw;
+{
+	struct ifmedia_description *desc;
+	struct ifmedia_type_to_subtype *ttos;
+	int seen_option = 0;
+
+	/* Find the top-level interface type. */
+	for (desc = ifm_type_descriptions, ttos = ifmedia_types_to_subtypes;
+	    desc->ifmt_string != NULL; desc++, ttos++)
+		if (IFM_TYPE(ifmw) == desc->ifmt_word)
+			break;
+	if (desc->ifmt_string == NULL) {
+		TRACE("  Type: <unknown type>\n");
+		return;
+	}
+	TRACE("  Type: %s\n", desc->ifmt_string);
+
+	/* Any mode. */
+	for (desc = ttos->modes; desc && desc->ifmt_string != NULL; desc++)
+		if (IFM_MODE(ifmw) == desc->ifmt_word) {
+			if (desc->ifmt_string != NULL)
+				TRACE("  Mode: %s\n", desc->ifmt_string);
+			break;
+		}
+
+	/*
+	 * Check for the shared subtype descriptions first, then the
+	 * type-specific ones.
+	 */
+	for (desc = ifm_subtype_shared_descriptions;
+	    desc->ifmt_string != NULL; desc++)
+		if (IFM_SUBTYPE(ifmw) == desc->ifmt_word)
+			goto got_subtype;
+
+	for (desc = ttos->subtypes; desc->ifmt_string != NULL; desc++)
+		if (IFM_SUBTYPE(ifmw) == desc->ifmt_word)
+			break;
+	if (desc->ifmt_string == NULL) {
+		TRACE("  SubType: <unknown>\n");
+		return;
+	}
+
+ got_subtype:
+	TRACE("  SubType: %s\n", desc->ifmt_string);
+
+	/*
+	 * Look for shared options.
+	 */
+	for (desc = ifm_shared_option_descriptions;
+	    desc->ifmt_string != NULL; desc++) {
+		if (ifmw & desc->ifmt_word) {
+			TRACE("  Shared Option[%d]: %s\n", seen_option++,
+				desc->ifmt_string);
+		}
+	}
+
+	/*
+	 * Look for subtype-specific options.
+	 */
+	for (desc = ttos->options; desc->ifmt_string != NULL; desc++) {
+		if (ifmw & desc->ifmt_word) {
+			TRACE("  SubType Option[%d]: %s\n", seen_option++,
+				desc->ifmt_string);
+		}
+	}
+}
+#endif /* IFMEDIA_DEBUG */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_kern_mbuf.c b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_kern_mbuf.c
new file mode 100644
index 0000000000..0960d250f2
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_kern_mbuf.c
@@ -0,0 +1,155 @@
+/*! NOTE: Most kern_mbuf functions are implemented by our mbuf.c; however,
+ *  a certain few non-allocation-related ones which we can copy wholesale
+ *  from FreeBSD live here. */
+/*-
+ * Copyright (c) 2004, 2005,
+ *	Bosko Milekic <bmilekic@FreeBSD.org>.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/mbuf.h>
+
+/*
+ * Allocate a given length worth of mbufs and/or clusters (whatever fits
+ * best) and return a pointer to the top of the allocated chain.  If an
+ * existing mbuf chain is provided, then we will append the new chain
+ * to the existing one but still return the top of the newly allocated
+ * chain.
+ */
+struct mbuf *
+m_getm2(struct mbuf *m, int len, int how, short type, int flags)
+{
+	struct mbuf *mb, *nm = NULL, *mtail = NULL;
+
+	KASSERT(len >= 0, ("%s: len is < 0", __func__));
+
+	/* Validate flags. */
+	flags &= (M_PKTHDR | M_EOR);
+
+	/* Packet header mbuf must be first in chain. */
+	if ((flags & M_PKTHDR) && m != NULL)
+		flags &= ~M_PKTHDR;
+
+	/* Loop and append maximum sized mbufs to the chain tail. */
+	while (len > 0) {
+		if (len > MCLBYTES)
+			mb = m_getjcl(how, type, (flags & M_PKTHDR),
+			    MJUMPAGESIZE);
+		else if (len >= MINCLSIZE)
+			mb = m_getcl(how, type, (flags & M_PKTHDR));
+		else if (flags & M_PKTHDR)
+			mb = m_gethdr(how, type);
+		else
+			mb = m_get(how, type);
+
+		/* Fail the whole operation if one mbuf can't be allocated. */
+		if (mb == NULL) {
+			if (nm != NULL)
+				m_freem(nm);
+			return (NULL);
+		}
+
+		/* Book keeping. */
+		len -= M_SIZE(mb);
+		if (mtail != NULL)
+			mtail->m_next = mb;
+		else
+			nm = mb;
+		mtail = mb;
+		flags &= ~M_PKTHDR;	/* Only valid on the first mbuf. */
+	}
+	if (flags & M_EOR)
+		mtail->m_flags |= M_EOR;  /* Only valid on the last mbuf. */
+
+	/* If mbuf was supplied, append new chain to the end of it. */
+	if (m != NULL) {
+		for (mtail = m; mtail->m_next != NULL; mtail = mtail->m_next)
+			;
+		mtail->m_next = nm;
+		mtail->m_flags &= ~M_EOR;
+	} else
+		m = nm;
+
+	return (m);
+}
+
+/*-
+ * Configure a provided mbuf to refer to the provided external storage
+ * buffer and setup a reference count for said buffer.
+ *
+ * Arguments:
+ *    mb     The existing mbuf to which to attach the provided buffer.
+ *    buf    The address of the provided external storage buffer.
+ *    size   The size of the provided buffer.
+ *    freef  A pointer to a routine that is responsible for freeing the
+ *           provided external storage buffer.
+ *    args   A pointer to an argument structure (of any type) to be passed
+ *           to the provided freef routine (may be NULL).
+ *    flags  Any other flags to be passed to the provided mbuf.
+ *    type   The type that the external storage buffer should be
+ *           labeled with.
+ *
+ * Returns:
+ *    Nothing.
+ */
+void
+m_extadd(struct mbuf *mb, caddr_t buf, u_int size,
+    void (*freef)(struct mbuf *, void *, void *), void *arg1, void *arg2,
+    int flags, int type)
+{
+
+	KASSERT(type != EXT_CLUSTER, ("%s: EXT_CLUSTER not allowed", __func__));
+
+	mb->m_flags |= (M_EXT | flags);
+	mb->m_ext.ext_buf = buf;
+	mb->m_data = mb->m_ext.ext_buf;
+	mb->m_ext.ext_size = size;
+#ifndef __HAIKU__
+	mb->m_ext.ext_free = freef;
+	mb->m_ext.ext_arg1 = arg1;
+	mb->m_ext.ext_arg2 = arg2;
+#else
+	if (freef != NULL)
+		panic("m_ext.ext_free not yet implemented");
+#endif
+	mb->m_ext.ext_type = type;
+
+	if (type != EXT_EXTREF) {
+		mb->m_ext.ext_count = 1;
+		mb->m_ext.ext_flags = EXT_FLAG_EMBREF;
+	} else
+		mb->m_ext.ext_flags = 0;
+}
+
+/*
+ * Free an entire chain of mbufs and associated external buffers, if
+ * applicable.
+ */
+void
+m_freem(struct mbuf *mb)
+{
+	while (mb != NULL)
+		mb = m_free(mb);
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_mii.c b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_mii.c
new file mode 100644
index 0000000000..a6aa36c7f9
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_mii.c
@@ -0,0 +1,671 @@
+/*	$NetBSD: mii.c,v 1.12 1999/08/03 19:41:49 drochner Exp $	*/
+
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifdef __HAIKU__
+#include "device.h"
+
+#define malloc(size, tag, flags) kernel_malloc(size, tag, flags)
+#define free(pointer, tag) kernel_free(pointer, tag)
+#endif
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * MII bus layer, glues MII-capable network interface drivers to sharable
+ * PHY drivers.  This exports an interface compatible with BSD/OS 3.0's,
+ * plus some NetBSD extensions.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/socket.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+
+#include <net/if.h>
+#include <net/if_var.h>
+#include <net/if_media.h>
+
+#include <dev/mii/mii.h>
+#include <dev/mii/miivar.h>
+
+MODULE_VERSION(miibus, 1);
+
+#include "miibus_if.h"
+
+static device_attach_t miibus_attach;
+static bus_child_location_str_t miibus_child_location_str;
+static bus_child_pnpinfo_str_t miibus_child_pnpinfo_str;
+static device_detach_t miibus_detach;
+static bus_hinted_child_t miibus_hinted_child;
+static bus_print_child_t miibus_print_child;
+static device_probe_t miibus_probe;
+static bus_read_ivar_t miibus_read_ivar;
+static miibus_readreg_t miibus_readreg;
+static miibus_statchg_t miibus_statchg;
+static miibus_writereg_t miibus_writereg;
+static miibus_linkchg_t miibus_linkchg;
+static miibus_mediainit_t miibus_mediainit;
+
+static unsigned char mii_bitreverse(unsigned char x);
+
+static device_method_t miibus_methods[] = {
+	/* device interface */
+	DEVMETHOD(device_probe,		miibus_probe),
+	DEVMETHOD(device_attach,	miibus_attach),
+	DEVMETHOD(device_detach,	miibus_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+
+	/* bus interface */
+	DEVMETHOD(bus_print_child,	miibus_print_child),
+	DEVMETHOD(bus_read_ivar,	miibus_read_ivar),
+	DEVMETHOD(bus_child_pnpinfo_str, miibus_child_pnpinfo_str),
+	DEVMETHOD(bus_child_location_str, miibus_child_location_str),
+	DEVMETHOD(bus_hinted_child,	miibus_hinted_child),
+
+	/* MII interface */
+	DEVMETHOD(miibus_readreg,	miibus_readreg),
+	DEVMETHOD(miibus_writereg,	miibus_writereg),
+	DEVMETHOD(miibus_statchg,	miibus_statchg),
+	DEVMETHOD(miibus_linkchg,	miibus_linkchg),
+	DEVMETHOD(miibus_mediainit,	miibus_mediainit),
+
+	DEVMETHOD_END
+};
+
+devclass_t miibus_devclass;
+
+driver_t miibus_driver = {
+	"miibus",
+	miibus_methods,
+	sizeof(struct mii_data)
+};
+
+struct miibus_ivars {
+	if_t		ifp;
+	ifm_change_cb_t	ifmedia_upd;
+	ifm_stat_cb_t	ifmedia_sts;
+	u_int		mii_flags;
+	u_int		mii_offset;
+};
+
+static int
+miibus_probe(device_t dev)
+{
+
+	device_set_desc(dev, "MII bus");
+
+	return (BUS_PROBE_SPECIFIC);
+}
+
+static int
+miibus_attach(device_t dev)
+{
+	struct miibus_ivars	*ivars;
+	struct mii_attach_args	*ma;
+	struct mii_data		*mii;
+	device_t		*children;
+	int			i, nchildren;
+
+	mii = device_get_softc(dev);
+	if (device_get_children(dev, &children, &nchildren) == 0) {
+		for (i = 0; i < nchildren; i++) {
+			ma = device_get_ivars(children[i]);
+			ma->mii_data = mii;
+		}
+		free(children, M_TEMP);
+	}
+	if (nchildren == 0) {
+		device_printf(dev, "cannot get children\n");
+		return (ENXIO);
+	}
+	ivars = device_get_ivars(dev);
+	ifmedia_init(&mii->mii_media, IFM_IMASK, ivars->ifmedia_upd,
+	    ivars->ifmedia_sts);
+	mii->mii_ifp = ivars->ifp;
+	if_setcapabilitiesbit(mii->mii_ifp, IFCAP_LINKSTATE, 0);
+	if_setcapenablebit(mii->mii_ifp, IFCAP_LINKSTATE, 0);
+	LIST_INIT(&mii->mii_phys);
+
+	return (bus_generic_attach(dev));
+}
+
+static int
+miibus_detach(device_t dev)
+{
+	struct mii_data		*mii;
+
+	bus_generic_detach(dev);
+	mii = device_get_softc(dev);
+	ifmedia_removeall(&mii->mii_media);
+	mii->mii_ifp = NULL;
+
+	return (0);
+}
+
+static int
+miibus_print_child(device_t dev, device_t child)
+{
+	struct mii_attach_args *ma;
+	int retval;
+
+	ma = device_get_ivars(child);
+	retval = bus_print_child_header(dev, child);
+	retval += printf(" PHY %d", ma->mii_phyno);
+	retval += bus_print_child_footer(dev, child);
+
+	return (retval);
+}
+
+static int
+miibus_read_ivar(device_t dev, device_t child __unused, int which,
+    uintptr_t *result)
+{
+	struct miibus_ivars *ivars;
+
+	/*
+	 * NB: this uses the instance variables of the miibus rather than
+	 * its PHY children.
+	 */
+	ivars = device_get_ivars(dev);
+	switch (which) {
+	case MIIBUS_IVAR_FLAGS:
+		*result = ivars->mii_flags;
+		break;
+	default:
+		return (ENOENT);
+	}
+	return (0);
+}
+
+static int
+miibus_child_pnpinfo_str(device_t dev __unused, device_t child, char *buf,
+    size_t buflen)
+{
+	struct mii_attach_args *ma;
+
+	ma = device_get_ivars(child);
+	snprintf(buf, buflen, "oui=0x%x model=0x%x rev=0x%x",
+	    MII_OUI(ma->mii_id1, ma->mii_id2),
+	    MII_MODEL(ma->mii_id2), MII_REV(ma->mii_id2));
+	return (0);
+}
+
+static int
+miibus_child_location_str(device_t dev __unused, device_t child, char *buf,
+    size_t buflen)
+{
+	struct mii_attach_args *ma;
+
+	ma = device_get_ivars(child);
+	snprintf(buf, buflen, "phyno=%d", ma->mii_phyno);
+	return (0);
+}
+
+static void
+miibus_hinted_child(device_t dev, const char *name, int unit)
+{
+	struct miibus_ivars *ivars;
+	struct mii_attach_args *args, *ma;
+	device_t *children, phy;
+	int i, nchildren;
+	u_int val;
+
+	if (resource_int_value(name, unit, "phyno", &val) != 0)
+		return;
+	if (device_get_children(dev, &children, &nchildren) != 0)
+		return;
+	ma = NULL;
+	for (i = 0; i < nchildren; i++) {
+		args = device_get_ivars(children[i]);
+		if (args->mii_phyno == val) {
+			ma = args;
+			break;
+		}
+	}
+	free(children, M_TEMP);
+
+	/*
+	 * Don't add a PHY that was automatically identified by having media
+	 * in its BMSR twice, only allow to alter its attach arguments.
+	 */
+	if (ma == NULL) {
+		ma = malloc(sizeof(struct mii_attach_args), M_DEVBUF,
+		    M_NOWAIT);
+		if (ma == NULL)
+			return;
+		phy = device_add_child(dev, name, unit);
+		if (phy == NULL) {
+			free(ma, M_DEVBUF);
+			return;
+		}
+		ivars = device_get_ivars(dev);
+		ma->mii_phyno = val;
+		ma->mii_offset = ivars->mii_offset++;
+		ma->mii_id1 = 0;
+		ma->mii_id2 = 0;
+		ma->mii_capmask = BMSR_DEFCAPMASK;
+		device_set_ivars(phy, ma);
+	}
+
+	if (resource_int_value(name, unit, "id1", &val) == 0)
+		ma->mii_id1 = val;
+	if (resource_int_value(name, unit, "id2", &val) == 0)
+		ma->mii_id2 = val;
+	if (resource_int_value(name, unit, "capmask", &val) == 0)
+		ma->mii_capmask = val;
+}
+
+static int
+miibus_readreg(device_t dev, int phy, int reg)
+{
+	device_t		parent;
+
+	parent = device_get_parent(dev);
+	return (MIIBUS_READREG(parent, phy, reg));
+}
+
+static int
+miibus_writereg(device_t dev, int phy, int reg, int data)
+{
+	device_t		parent;
+
+	parent = device_get_parent(dev);
+	return (MIIBUS_WRITEREG(parent, phy, reg, data));
+}
+
+static void
+miibus_statchg(device_t dev)
+{
+	device_t		parent;
+	struct mii_data		*mii;
+
+	parent = device_get_parent(dev);
+	MIIBUS_STATCHG(parent);
+
+	mii = device_get_softc(dev);
+	if_setbaudrate(mii->mii_ifp, ifmedia_baudrate(mii->mii_media_active));
+}
+
+static void
+miibus_linkchg(device_t dev)
+{
+	struct mii_data		*mii;
+	device_t		parent;
+	int			link_state;
+
+	parent = device_get_parent(dev);
+	MIIBUS_LINKCHG(parent);
+
+	mii = device_get_softc(dev);
+
+	if (mii->mii_media_status & IFM_AVALID) {
+		if (mii->mii_media_status & IFM_ACTIVE)
+			link_state = LINK_STATE_UP;
+		else
+			link_state = LINK_STATE_DOWN;
+	} else
+		link_state = LINK_STATE_UNKNOWN;
+	if_link_state_change(mii->mii_ifp, link_state);
+}
+
+static void
+miibus_mediainit(device_t dev)
+{
+	struct mii_data		*mii;
+	struct ifmedia_entry	*m;
+	int			media = 0;
+
+	/* Poke the parent in case it has any media of its own to add. */
+	MIIBUS_MEDIAINIT(device_get_parent(dev));
+
+	mii = device_get_softc(dev);
+	LIST_FOREACH(m, &mii->mii_media.ifm_list, ifm_list) {
+		media = m->ifm_media;
+		if (media == (IFM_ETHER | IFM_AUTO))
+			break;
+	}
+
+	ifmedia_set(&mii->mii_media, media);
+}
+
+/*
+ * Helper function used by network interface drivers, attaches the miibus and
+ * the PHYs to the network interface driver parent.
+ */
+int
+mii_attach(device_t dev, device_t *miibus, if_t ifp,
+    ifm_change_cb_t ifmedia_upd, ifm_stat_cb_t ifmedia_sts, int capmask,
+    int phyloc, int offloc, int flags)
+{
+	struct miibus_ivars *ivars;
+	struct mii_attach_args *args, ma;
+	device_t *children, phy;
+	int bmsr, first, i, nchildren, phymax, phymin, rv;
+	uint32_t phymask;
+
+	if (phyloc != MII_PHY_ANY && offloc != MII_OFFSET_ANY) {
+		printf("%s: phyloc and offloc specified\n", __func__);
+		return (EINVAL);
+	}
+
+	if (offloc != MII_OFFSET_ANY && (offloc < 0 || offloc >= MII_NPHY)) {
+		printf("%s: invalid offloc %d\n", __func__, offloc);
+		return (EINVAL);
+	}
+
+	if (phyloc == MII_PHY_ANY) {
+		phymin = 0;
+		phymax = MII_NPHY - 1;
+	} else {
+		if (phyloc < 0 || phyloc >= MII_NPHY) {
+			printf("%s: invalid phyloc %d\n", __func__, phyloc);
+			return (EINVAL);
+		}
+		phymin = phymax = phyloc;
+	}
+
+	first = 0;
+	if (*miibus == NULL) {
+		first = 1;
+		ivars = malloc(sizeof(*ivars), M_DEVBUF, M_NOWAIT);
+		if (ivars == NULL)
+			return (ENOMEM);
+		ivars->ifp = ifp;
+		ivars->ifmedia_upd = ifmedia_upd;
+		ivars->ifmedia_sts = ifmedia_sts;
+		ivars->mii_flags = flags;
+		*miibus = device_add_child(dev, "miibus", -1);
+		if (*miibus == NULL) {
+			rv = ENXIO;
+			goto fail;
+		}
+		device_set_ivars(*miibus, ivars);
+	} else {
+		ivars = device_get_ivars(*miibus);
+		if (ivars->ifp != ifp || ivars->ifmedia_upd != ifmedia_upd ||
+		    ivars->ifmedia_sts != ifmedia_sts ||
+		    ivars->mii_flags != flags) {
+			printf("%s: non-matching invariant\n", __func__);
+			return (EINVAL);
+		}
+		/*
+		 * Assignment of the attach arguments mii_data for the first
+		 * pass is done in miibus_attach(), i.e. once the miibus softc
+		 * has been allocated.
+		 */
+		ma.mii_data = device_get_softc(*miibus);
+	}
+
+	ma.mii_capmask = capmask;
+
+	if (resource_int_value(device_get_name(*miibus),
+	    device_get_unit(*miibus), "phymask", &phymask) != 0)
+		phymask = 0xffffffff;
+
+	if (device_get_children(*miibus, &children, &nchildren) != 0) {
+		children = NULL;
+		nchildren = 0;
+	}
+	ivars->mii_offset = 0;
+	for (ma.mii_phyno = phymin; ma.mii_phyno <= phymax; ma.mii_phyno++) {
+		/*
+		 * Make sure we haven't already configured a PHY at this
+		 * address.  This allows mii_attach() to be called
+		 * multiple times.
+		 */
+		for (i = 0; i < nchildren; i++) {
+			args = device_get_ivars(children[i]);
+			if (args->mii_phyno == ma.mii_phyno) {
+				/*
+				 * Yes, there is already something
+				 * configured at this address.
+				 */
+				goto skip;
+			}
+		}
+
+		/*
+		 * Check to see if there is a PHY at this address.  Note,
+		 * many braindead PHYs report 0/0 in their ID registers,
+		 * so we test for media in the BMSR.
+		 */
+		bmsr = MIIBUS_READREG(dev, ma.mii_phyno, MII_BMSR);
+		if (bmsr == 0 || bmsr == 0xffff ||
+		    (bmsr & (BMSR_EXTSTAT | BMSR_MEDIAMASK)) == 0) {
+			/* Assume no PHY at this address. */
+			continue;
+		}
+
+		/*
+		 * There is a PHY at this address.  If we were given an
+		 * `offset' locator, skip this PHY if it doesn't match.
+		 */
+		if (offloc != MII_OFFSET_ANY && offloc != ivars->mii_offset)
+			goto skip;
+
+		/*
+		 * Skip this PHY if it's not included in the phymask hint.
+		 */
+		if ((phymask & (1 << ma.mii_phyno)) == 0)
+			goto skip;
+
+		/*
+		 * Extract the IDs.  Braindead PHYs will be handled by
+		 * the `ukphy' driver, as we have no ID information to
+		 * match on.
+		 */
+		ma.mii_id1 = MIIBUS_READREG(dev, ma.mii_phyno, MII_PHYIDR1);
+		ma.mii_id2 = MIIBUS_READREG(dev, ma.mii_phyno, MII_PHYIDR2);
+
+		ma.mii_offset = ivars->mii_offset;
+		args = malloc(sizeof(struct mii_attach_args), M_DEVBUF,
+		    M_NOWAIT);
+		if (args == NULL)
+			goto skip;
+		bcopy((char *)&ma, (char *)args, sizeof(ma));
+		phy = device_add_child(*miibus, NULL, -1);
+		if (phy == NULL) {
+			free(args, M_DEVBUF);
+			goto skip;
+		}
+		device_set_ivars(phy, args);
+ skip:
+		ivars->mii_offset++;
+	}
+	free(children, M_TEMP);
+
+	if (first != 0) {
+		rv = device_set_driver(*miibus, &miibus_driver);
+		if (rv != 0)
+			goto fail;
+		bus_enumerate_hinted_children(*miibus);
+		rv = device_get_children(*miibus, &children, &nchildren);
+		if (rv != 0)
+			goto fail;
+		free(children, M_TEMP);
+		if (nchildren == 0) {
+			rv = ENXIO;
+			goto fail;
+		}
+		rv = bus_generic_attach(dev);
+		if (rv != 0)
+			goto fail;
+
+		/* Attaching of the PHY drivers is done in miibus_attach(). */
+		return (0);
+	}
+	rv = bus_generic_attach(*miibus);
+	if (rv != 0)
+		goto fail;
+
+	return (0);
+
+ fail:
+	if (*miibus != NULL)
+		device_delete_child(dev, *miibus);
+	free(ivars, M_DEVBUF);
+	if (first != 0)
+		*miibus = NULL;
+	return (rv);
+}
+
+/*
+ * Media changed; notify all PHYs.
+ */
+int
+mii_mediachg(struct mii_data *mii)
+{
+	struct mii_softc *child;
+	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
+	int rv;
+
+	mii->mii_media_status = 0;
+	mii->mii_media_active = IFM_NONE;
+
+	LIST_FOREACH(child, &mii->mii_phys, mii_list) {
+		/*
+		 * If the media indicates a different PHY instance,
+		 * isolate this one.
+		 */
+		if (IFM_INST(ife->ifm_media) != child->mii_inst) {
+			if ((child->mii_flags & MIIF_NOISOLATE) != 0) {
+				device_printf(child->mii_dev, "%s: "
+				    "can't handle non-zero PHY instance %d\n",
+				    __func__, child->mii_inst);
+				continue;
+			}
+			PHY_WRITE(child, MII_BMCR, PHY_READ(child, MII_BMCR) |
+			    BMCR_ISO);
+			continue;
+		}
+		rv = PHY_SERVICE(child, mii, MII_MEDIACHG);
+		if (rv)
+			return (rv);
+	}
+	return (0);
+}
+
+/*
+ * Call the PHY tick routines, used during autonegotiation.
+ */
+void
+mii_tick(struct mii_data *mii)
+{
+	struct mii_softc *child;
+	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
+
+	LIST_FOREACH(child, &mii->mii_phys, mii_list) {
+		/*
+		 * If this PHY instance isn't currently selected, just skip
+		 * it.
+		 */
+		if (IFM_INST(ife->ifm_media) != child->mii_inst)
+			continue;
+		(void)PHY_SERVICE(child, mii, MII_TICK);
+	}
+}
+
+/*
+ * Get media status from PHYs.
+ */
+void
+mii_pollstat(struct mii_data *mii)
+{
+	struct mii_softc *child;
+	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
+
+	mii->mii_media_status = 0;
+	mii->mii_media_active = IFM_NONE;
+
+	LIST_FOREACH(child, &mii->mii_phys, mii_list) {
+		/*
+		 * If we're not polling this PHY instance, just skip it.
+		 */
+		if (IFM_INST(ife->ifm_media) != child->mii_inst)
+			continue;
+		(void)PHY_SERVICE(child, mii, MII_POLLSTAT);
+	}
+}
+
+static unsigned char
+mii_bitreverse(unsigned char x)
+{
+	static unsigned const char nibbletab[16] = {
+		0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15
+	};
+
+	return ((nibbletab[x & 15] << 4) | nibbletab[x >> 4]);
+}
+
+u_int
+mii_oui(u_int id1, u_int id2)
+{
+	u_int h;
+
+	h = (id1 << 6) | (id2 >> 10);
+
+	return ((mii_bitreverse(h >> 16) << 16) |
+	    (mii_bitreverse((h >> 8) & 0xff) << 8) |
+	    mii_bitreverse(h & 0xff));
+}
+
+int
+mii_phy_mac_match(struct mii_softc *mii, const char *name)
+{
+
+	return (strcmp(device_get_name(device_get_parent(mii->mii_dev)),
+	    name) == 0);
+}
+
+int
+mii_dev_mac_match(device_t parent, const char *name)
+{
+
+	return (strcmp(device_get_name(device_get_parent(
+	    device_get_parent(parent))), name) == 0);
+}
+
+void *
+mii_phy_mac_softc(struct mii_softc *mii)
+{
+
+	return (device_get_softc(device_get_parent(mii->mii_dev)));
+}
+
+void *
+mii_dev_mac_softc(device_t parent)
+{
+
+	return (device_get_softc(device_get_parent(device_get_parent(parent))));
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf.c b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf.c
new file mode 100644
index 0000000000..a5060c8995
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf.c
@@ -0,0 +1,1866 @@
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)uipc_mbuf.c	8.2 (Berkeley) 1/4/94
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: stable/11/sys/kern/uipc_mbuf.c 331847 2018-03-31 17:28:30Z avos $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/limits.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/sysctl.h>
+#include <sys/protosw.h>
+#include <sys/uio.h>
+
+#if 0
+SDT_PROBE_DEFINE5_XLATE(sdt, , , m__init,
+    "struct mbuf *", "mbufinfo_t *",
+    "uint32_t", "uint32_t",
+    "uint16_t", "uint16_t",
+    "uint32_t", "uint32_t",
+    "uint32_t", "uint32_t");
+
+SDT_PROBE_DEFINE3_XLATE(sdt, , , m__gethdr,
+    "uint32_t", "uint32_t",
+    "uint16_t", "uint16_t",
+    "struct mbuf *", "mbufinfo_t *");
+
+SDT_PROBE_DEFINE3_XLATE(sdt, , , m__get,
+    "uint32_t", "uint32_t",
+    "uint16_t", "uint16_t",
+    "struct mbuf *", "mbufinfo_t *");
+
+SDT_PROBE_DEFINE4_XLATE(sdt, , , m__getcl,
+    "uint32_t", "uint32_t",
+    "uint16_t", "uint16_t",
+    "uint32_t", "uint32_t",
+    "struct mbuf *", "mbufinfo_t *");
+
+SDT_PROBE_DEFINE3_XLATE(sdt, , , m__clget,
+    "struct mbuf *", "mbufinfo_t *",
+    "uint32_t", "uint32_t",
+    "uint32_t", "uint32_t");
+
+SDT_PROBE_DEFINE4_XLATE(sdt, , , m__cljget,
+    "struct mbuf *", "mbufinfo_t *",
+    "uint32_t", "uint32_t",
+    "uint32_t", "uint32_t",
+    "void*", "void*");
+
+SDT_PROBE_DEFINE(sdt, , , m__cljset);
+
+SDT_PROBE_DEFINE1_XLATE(sdt, , , m__free,
+        "struct mbuf *", "mbufinfo_t *");
+
+SDT_PROBE_DEFINE1_XLATE(sdt, , , m__freem,
+    "struct mbuf *", "mbufinfo_t *");
+
+#include <security/mac/mac_framework.h>
+
+int	max_linkhdr;
+int	max_protohdr;
+int	max_hdr;
+int	max_datalen;
+#ifdef MBUF_STRESS_TEST
+int	m_defragpackets;
+int	m_defragbytes;
+int	m_defraguseless;
+int	m_defragfailure;
+int	m_defragrandomfailures;
+#endif
+
+/*
+ * sysctl(8) exported objects
+ */
+SYSCTL_INT(_kern_ipc, KIPC_MAX_LINKHDR, max_linkhdr, CTLFLAG_RD,
+	   &max_linkhdr, 0, "Size of largest link layer header");
+SYSCTL_INT(_kern_ipc, KIPC_MAX_PROTOHDR, max_protohdr, CTLFLAG_RD,
+	   &max_protohdr, 0, "Size of largest protocol layer header");
+SYSCTL_INT(_kern_ipc, KIPC_MAX_HDR, max_hdr, CTLFLAG_RD,
+	   &max_hdr, 0, "Size of largest link plus protocol header");
+SYSCTL_INT(_kern_ipc, KIPC_MAX_DATALEN, max_datalen, CTLFLAG_RD,
+	   &max_datalen, 0, "Minimum space left in mbuf after max_hdr");
+#ifdef MBUF_STRESS_TEST
+SYSCTL_INT(_kern_ipc, OID_AUTO, m_defragpackets, CTLFLAG_RD,
+	   &m_defragpackets, 0, "");
+SYSCTL_INT(_kern_ipc, OID_AUTO, m_defragbytes, CTLFLAG_RD,
+	   &m_defragbytes, 0, "");
+SYSCTL_INT(_kern_ipc, OID_AUTO, m_defraguseless, CTLFLAG_RD,
+	   &m_defraguseless, 0, "");
+SYSCTL_INT(_kern_ipc, OID_AUTO, m_defragfailure, CTLFLAG_RD,
+	   &m_defragfailure, 0, "");
+SYSCTL_INT(_kern_ipc, OID_AUTO, m_defragrandomfailures, CTLFLAG_RW,
+	   &m_defragrandomfailures, 0, "");
+#endif
+#endif
+
+/*
+ * Ensure the correct size of various mbuf parameters.  It could be off due
+ * to compiler-induced padding and alignment artifacts.
+ */
+CTASSERT(MSIZE - offsetof(struct mbuf, m_dat) == MLEN);
+CTASSERT(MSIZE - offsetof(struct mbuf, m_pktdat) == MHLEN);
+
+/*
+ * mbuf data storage should be 64-bit aligned regardless of architectural
+ * pointer size; check this is the case with and without a packet header.
+ */
+CTASSERT(offsetof(struct mbuf, m_dat) % 8 == 0);
+CTASSERT(offsetof(struct mbuf, m_pktdat) % 8 == 0);
+
+/*
+ * While the specific values here don't matter too much (i.e., +/- a few
+ * words), we do want to ensure that changes to these values are carefully
+ * reasoned about and properly documented.  This is especially the case as
+ * network-protocol and device-driver modules encode these layouts, and must
+ * be recompiled if the structures change.  Check these values at compile time
+ * against the ones documented in comments in mbuf.h.
+ *
+ * NB: Possibly they should be documented there via #define's and not just
+ * comments.
+ */
+#ifndef __HAIKU__
+#if defined(__LP64__)
+CTASSERT(offsetof(struct mbuf, m_dat) == 32);
+CTASSERT(sizeof(struct pkthdr) == 56);
+CTASSERT(sizeof(struct m_ext) == 48);
+#else
+CTASSERT(offsetof(struct mbuf, m_dat) == 24);
+CTASSERT(sizeof(struct pkthdr) == 48);
+CTASSERT(sizeof(struct m_ext) == 28);
+#endif
+#endif
+
+/*
+ * Assert that the queue(3) macros produce code of the same size as an old
+ * plain pointer does.
+ */
+#ifdef INVARIANTS
+static struct mbuf __used m_assertbuf;
+CTASSERT(sizeof(m_assertbuf.m_slist) == sizeof(m_assertbuf.m_next));
+CTASSERT(sizeof(m_assertbuf.m_stailq) == sizeof(m_assertbuf.m_next));
+CTASSERT(sizeof(m_assertbuf.m_slistpkt) == sizeof(m_assertbuf.m_nextpkt));
+CTASSERT(sizeof(m_assertbuf.m_stailqpkt) == sizeof(m_assertbuf.m_nextpkt));
+#endif
+
+/*
+ * Attach the cluster from *m to *n, set up m_ext in *n
+ * and bump the refcount of the cluster.
+ */
+void
+mb_dupcl(struct mbuf *n, struct mbuf *m)
+{
+	volatile u_int *refcnt;
+
+	KASSERT(m->m_flags & M_EXT, ("%s: M_EXT not set on %p", __func__, m));
+	KASSERT(!(n->m_flags & M_EXT), ("%s: M_EXT set on %p", __func__, n));
+
+	n->m_ext = m->m_ext;
+	n->m_flags |= M_EXT;
+	n->m_flags |= m->m_flags & M_RDONLY;
+
+	/* See if this is the mbuf that holds the embedded refcount. */
+	if (m->m_ext.ext_flags & EXT_FLAG_EMBREF) {
+		refcnt = n->m_ext.ext_cnt = &m->m_ext.ext_count;
+		n->m_ext.ext_flags &= ~EXT_FLAG_EMBREF;
+	} else {
+		KASSERT(m->m_ext.ext_cnt != NULL,
+		    ("%s: no refcounting pointer on %p", __func__, m));
+		refcnt = m->m_ext.ext_cnt;
+	}
+
+	if (*refcnt == 1)
+		*refcnt += 1;
+	else
+		atomic_add_int(refcnt, 1);
+}
+
+void
+m_demote_pkthdr(struct mbuf *m)
+{
+
+	M_ASSERTPKTHDR(m);
+
+	m_tag_delete_chain(m, NULL);
+	m->m_flags &= ~M_PKTHDR;
+	bzero(&m->m_pkthdr, sizeof(struct pkthdr));
+}
+
+/*
+ * Clean up mbuf (chain) from any tags and packet headers.
+ * If "all" is set then the first mbuf in the chain will be
+ * cleaned too.
+ */
+void
+m_demote(struct mbuf *m0, int all, int flags)
+{
+	struct mbuf *m;
+
+	for (m = all ? m0 : m0->m_next; m != NULL; m = m->m_next) {
+		KASSERT(m->m_nextpkt == NULL, ("%s: m_nextpkt in m %p, m0 %p",
+		    __func__, m, m0));
+		if (m->m_flags & M_PKTHDR)
+			m_demote_pkthdr(m);
+		m->m_flags = m->m_flags & (M_EXT | M_RDONLY | M_NOFREE | flags);
+	}
+}
+
+/*
+ * Sanity checks on mbuf (chain) for use in KASSERT() and general
+ * debugging.
+ * Returns 0 or panics when bad and 1 on all tests passed.
+ * Sanitize, 0 to run M_SANITY_ACTION, 1 to garble things so they
+ * blow up later.
+ */
+int
+m_sanity(struct mbuf *m0, int sanitize)
+{
+	struct mbuf *m;
+	caddr_t a, b;
+	int pktlen = 0;
+
+#ifdef INVARIANTS
+#define	M_SANITY_ACTION(s)	panic("mbuf %p: " s, m)
+#else
+#define	M_SANITY_ACTION(s)	printf("mbuf %p: " s, m)
+#endif
+
+	for (m = m0; m != NULL; m = m->m_next) {
+		/*
+		 * Basic pointer checks.  If any of these fails then some
+		 * unrelated kernel memory before or after us is trashed.
+		 * No way to recover from that.
+		 */
+		a = M_START(m);
+		b = a + M_SIZE(m);
+		if ((caddr_t)m->m_data < a)
+			M_SANITY_ACTION("m_data outside mbuf data range left");
+		if ((caddr_t)m->m_data > b)
+			M_SANITY_ACTION("m_data outside mbuf data range right");
+		if ((caddr_t)m->m_data + m->m_len > b)
+			M_SANITY_ACTION("m_data + m_len exeeds mbuf space");
+
+		/* m->m_nextpkt may only be set on first mbuf in chain. */
+		if (m != m0 && m->m_nextpkt != NULL) {
+			if (sanitize) {
+				m_freem(m->m_nextpkt);
+				m->m_nextpkt = (struct mbuf *)0xDEADC0DE;
+			} else
+				M_SANITY_ACTION("m->m_nextpkt on in-chain mbuf");
+		}
+
+		/* packet length (not mbuf length!) calculation */
+		if (m0->m_flags & M_PKTHDR)
+			pktlen += m->m_len;
+
+		/* m_tags may only be attached to first mbuf in chain. */
+		if (m != m0 && m->m_flags & M_PKTHDR &&
+		    !SLIST_EMPTY(&m->m_pkthdr.tags)) {
+			if (sanitize) {
+				m_tag_delete_chain(m, NULL);
+				/* put in 0xDEADC0DE perhaps? */
+			} else
+				M_SANITY_ACTION("m_tags on in-chain mbuf");
+		}
+
+		/* M_PKTHDR may only be set on first mbuf in chain */
+		if (m != m0 && m->m_flags & M_PKTHDR) {
+			if (sanitize) {
+				bzero(&m->m_pkthdr, sizeof(m->m_pkthdr));
+				m->m_flags &= ~M_PKTHDR;
+				/* put in 0xDEADCODE and leave hdr flag in */
+			} else
+				M_SANITY_ACTION("M_PKTHDR on in-chain mbuf");
+		}
+	}
+	m = m0;
+	if (pktlen && pktlen != m->m_pkthdr.len) {
+		if (sanitize)
+			m->m_pkthdr.len = 0;
+		else
+			M_SANITY_ACTION("m_pkthdr.len != mbuf chain length");
+	}
+	return 1;
+
+#undef	M_SANITY_ACTION
+}
+
+/*
+ * Non-inlined part of m_init().
+ */
+int
+m_pkthdr_init(struct mbuf *m, int how)
+{
+#ifdef MAC
+	int error;
+#endif
+	m->m_data = m->m_pktdat;
+	bzero(&m->m_pkthdr, sizeof(m->m_pkthdr));
+#ifdef MAC
+	/* If the label init fails, fail the alloc */
+	error = mac_mbuf_init(m, how);
+	if (error)
+		return (error);
+#endif
+
+	return (0);
+}
+
+/*
+ * "Move" mbuf pkthdr from "from" to "to".
+ * "from" must have M_PKTHDR set, and "to" must be empty.
+ */
+void
+m_move_pkthdr(struct mbuf *to, struct mbuf *from)
+{
+
+#if 0
+	/* see below for why these are not enabled */
+	M_ASSERTPKTHDR(to);
+	/* Note: with MAC, this may not be a good assertion. */
+	KASSERT(SLIST_EMPTY(&to->m_pkthdr.tags),
+	    ("m_move_pkthdr: to has tags"));
+#endif
+#ifdef MAC
+	/*
+	 * XXXMAC: It could be this should also occur for non-MAC?
+	 */
+	if (to->m_flags & M_PKTHDR)
+		m_tag_delete_chain(to, NULL);
+#endif
+	to->m_flags = (from->m_flags & M_COPYFLAGS) | (to->m_flags & M_EXT);
+	if ((to->m_flags & M_EXT) == 0)
+		to->m_data = to->m_pktdat;
+	to->m_pkthdr = from->m_pkthdr;		/* especially tags */
+	SLIST_INIT(&from->m_pkthdr.tags);	/* purge tags from src */
+	from->m_flags &= ~M_PKTHDR;
+}
+
+/*
+ * Duplicate "from"'s mbuf pkthdr in "to".
+ * "from" must have M_PKTHDR set, and "to" must be empty.
+ * In particular, this does a deep copy of the packet tags.
+ */
+int
+m_dup_pkthdr(struct mbuf *to, const struct mbuf *from, int how)
+{
+
+#if 0
+	/*
+	 * The mbuf allocator only initializes the pkthdr
+	 * when the mbuf is allocated with m_gethdr(). Many users
+	 * (e.g. m_copy*, m_prepend) use m_get() and then
+	 * smash the pkthdr as needed causing these
+	 * assertions to trip.  For now just disable them.
+	 */
+	M_ASSERTPKTHDR(to);
+	/* Note: with MAC, this may not be a good assertion. */
+	KASSERT(SLIST_EMPTY(&to->m_pkthdr.tags), ("m_dup_pkthdr: to has tags"));
+#endif
+	MBUF_CHECKSLEEP(how);
+#ifdef MAC
+	if (to->m_flags & M_PKTHDR)
+		m_tag_delete_chain(to, NULL);
+#endif
+	to->m_flags = (from->m_flags & M_COPYFLAGS) | (to->m_flags & M_EXT);
+	if ((to->m_flags & M_EXT) == 0)
+		to->m_data = to->m_pktdat;
+	to->m_pkthdr = from->m_pkthdr;
+	SLIST_INIT(&to->m_pkthdr.tags);
+	return (m_tag_copy_chain(to, from, how));
+}
+
+/*
+ * Lesser-used path for M_PREPEND:
+ * allocate new mbuf to prepend to chain,
+ * copy junk along.
+ */
+struct mbuf *
+m_prepend(struct mbuf *m, int len, int how)
+{
+	struct mbuf *mn;
+
+	if (m->m_flags & M_PKTHDR)
+		mn = m_gethdr(how, m->m_type);
+	else
+		mn = m_get(how, m->m_type);
+	if (mn == NULL) {
+		m_freem(m);
+		return (NULL);
+	}
+	if (m->m_flags & M_PKTHDR)
+		m_move_pkthdr(mn, m);
+	mn->m_next = m;
+	m = mn;
+	if (len < M_SIZE(m))
+		M_ALIGN(m, len);
+	m->m_len = len;
+	return (m);
+}
+
+/*
+ * Make a copy of an mbuf chain starting "off0" bytes from the beginning,
+ * continuing for "len" bytes.  If len is M_COPYALL, copy to end of mbuf.
+ * The wait parameter is a choice of M_WAITOK/M_NOWAIT from caller.
+ * Note that the copy is read-only, because clusters are not copied,
+ * only their reference counts are incremented.
+ */
+struct mbuf *
+m_copym(struct mbuf *m, int off0, int len, int wait)
+{
+	struct mbuf *n, **np;
+	int off = off0;
+	struct mbuf *top;
+	int copyhdr = 0;
+
+	KASSERT(off >= 0, ("m_copym, negative off %d", off));
+	KASSERT(len >= 0, ("m_copym, negative len %d", len));
+	MBUF_CHECKSLEEP(wait);
+	if (off == 0 && m->m_flags & M_PKTHDR)
+		copyhdr = 1;
+	while (off > 0) {
+		KASSERT(m != NULL, ("m_copym, offset > size of mbuf chain"));
+		if (off < m->m_len)
+			break;
+		off -= m->m_len;
+		m = m->m_next;
+	}
+	np = &top;
+	top = NULL;
+	while (len > 0) {
+		if (m == NULL) {
+			KASSERT(len == M_COPYALL,
+			    ("m_copym, length > size of mbuf chain"));
+			break;
+		}
+		if (copyhdr)
+			n = m_gethdr(wait, m->m_type);
+		else
+			n = m_get(wait, m->m_type);
+		*np = n;
+		if (n == NULL)
+			goto nospace;
+		if (copyhdr) {
+			if (!m_dup_pkthdr(n, m, wait))
+				goto nospace;
+			if (len == M_COPYALL)
+				n->m_pkthdr.len -= off0;
+			else
+				n->m_pkthdr.len = len;
+			copyhdr = 0;
+		}
+		n->m_len = min(len, m->m_len - off);
+		if (m->m_flags & M_EXT) {
+			n->m_data = m->m_data + off;
+			mb_dupcl(n, m);
+		} else
+			bcopy(mtod(m, caddr_t)+off, mtod(n, caddr_t),
+			    (u_int)n->m_len);
+		if (len != M_COPYALL)
+			len -= n->m_len;
+		off = 0;
+		m = m->m_next;
+		np = &n->m_next;
+	}
+
+	return (top);
+nospace:
+	m_freem(top);
+	return (NULL);
+}
+
+/*
+ * Copy an entire packet, including header (which must be present).
+ * An optimization of the common case `m_copym(m, 0, M_COPYALL, how)'.
+ * Note that the copy is read-only, because clusters are not copied,
+ * only their reference counts are incremented.
+ * Preserve alignment of the first mbuf so if the creator has left
+ * some room at the beginning (e.g. for inserting protocol headers)
+ * the copies still have the room available.
+ */
+struct mbuf *
+m_copypacket(struct mbuf *m, int how)
+{
+	struct mbuf *top, *n, *o;
+
+	MBUF_CHECKSLEEP(how);
+	n = m_get(how, m->m_type);
+	top = n;
+	if (n == NULL)
+		goto nospace;
+
+	if (!m_dup_pkthdr(n, m, how))
+		goto nospace;
+	n->m_len = m->m_len;
+	if (m->m_flags & M_EXT) {
+		n->m_data = m->m_data;
+		mb_dupcl(n, m);
+	} else {
+		n->m_data = n->m_pktdat + (m->m_data - m->m_pktdat );
+		bcopy(mtod(m, char *), mtod(n, char *), n->m_len);
+	}
+
+	m = m->m_next;
+	while (m) {
+		o = m_get(how, m->m_type);
+		if (o == NULL)
+			goto nospace;
+
+		n->m_next = o;
+		n = n->m_next;
+
+		n->m_len = m->m_len;
+		if (m->m_flags & M_EXT) {
+			n->m_data = m->m_data;
+			mb_dupcl(n, m);
+		} else {
+			bcopy(mtod(m, char *), mtod(n, char *), n->m_len);
+		}
+
+		m = m->m_next;
+	}
+	return top;
+nospace:
+	m_freem(top);
+	return (NULL);
+}
+
+/*
+ * Copy data from an mbuf chain starting "off" bytes from the beginning,
+ * continuing for "len" bytes, into the indicated buffer.
+ */
+void
+m_copydata(const struct mbuf *m, int off, int len, caddr_t cp)
+{
+	u_int count;
+
+	KASSERT(off >= 0, ("m_copydata, negative off %d", off));
+	KASSERT(len >= 0, ("m_copydata, negative len %d", len));
+	while (off > 0) {
+		KASSERT(m != NULL, ("m_copydata, offset > size of mbuf chain"));
+		if (off < m->m_len)
+			break;
+		off -= m->m_len;
+		m = m->m_next;
+	}
+	while (len > 0) {
+		KASSERT(m != NULL, ("m_copydata, length > size of mbuf chain"));
+		count = min(m->m_len - off, len);
+		bcopy(mtod(m, caddr_t) + off, cp, count);
+		len -= count;
+		cp += count;
+		off = 0;
+		m = m->m_next;
+	}
+}
+
+/*
+ * Copy a packet header mbuf chain into a completely new chain, including
+ * copying any mbuf clusters.  Use this instead of m_copypacket() when
+ * you need a writable copy of an mbuf chain.
+ */
+struct mbuf *
+m_dup(const struct mbuf *m, int how)
+{
+	struct mbuf **p, *top = NULL;
+	int remain, moff, nsize;
+
+	MBUF_CHECKSLEEP(how);
+	/* Sanity check */
+	if (m == NULL)
+		return (NULL);
+	M_ASSERTPKTHDR(m);
+
+	/* While there's more data, get a new mbuf, tack it on, and fill it */
+	remain = m->m_pkthdr.len;
+	moff = 0;
+	p = &top;
+	while (remain > 0 || top == NULL) {	/* allow m->m_pkthdr.len == 0 */
+		struct mbuf *n;
+
+		/* Get the next new mbuf */
+		if (remain >= MINCLSIZE) {
+			n = m_getcl(how, m->m_type, 0);
+			nsize = MCLBYTES;
+		} else {
+			n = m_get(how, m->m_type);
+			nsize = MLEN;
+		}
+		if (n == NULL)
+			goto nospace;
+
+		if (top == NULL) {		/* First one, must be PKTHDR */
+			if (!m_dup_pkthdr(n, m, how)) {
+				m_free(n);
+				goto nospace;
+			}
+			if ((n->m_flags & M_EXT) == 0)
+				nsize = MHLEN;
+			n->m_flags &= ~M_RDONLY;
+		}
+		n->m_len = 0;
+
+		/* Link it into the new chain */
+		*p = n;
+		p = &n->m_next;
+
+		/* Copy data from original mbuf(s) into new mbuf */
+		while (n->m_len < nsize && m != NULL) {
+			int chunk = min(nsize - n->m_len, m->m_len - moff);
+
+			bcopy(m->m_data + moff, n->m_data + n->m_len, chunk);
+			moff += chunk;
+			n->m_len += chunk;
+			remain -= chunk;
+			if (moff == m->m_len) {
+				m = m->m_next;
+				moff = 0;
+			}
+		}
+
+		/* Check correct total mbuf length */
+		KASSERT((remain > 0 && m != NULL) || (remain == 0 && m == NULL),
+		    	("%s: bogus m_pkthdr.len", __func__));
+	}
+	return (top);
+
+nospace:
+	m_freem(top);
+	return (NULL);
+}
+
+/*
+ * Concatenate mbuf chain n to m.
+ * Both chains must be of the same type (e.g. MT_DATA).
+ * Any m_pkthdr is not updated.
+ */
+void
+m_cat(struct mbuf *m, struct mbuf *n)
+{
+	while (m->m_next)
+		m = m->m_next;
+	while (n) {
+		if (!M_WRITABLE(m) ||
+		    M_TRAILINGSPACE(m) < n->m_len) {
+			/* just join the two chains */
+			m->m_next = n;
+			return;
+		}
+		/* splat the data from one into the other */
+		bcopy(mtod(n, caddr_t), mtod(m, caddr_t) + m->m_len,
+		    (u_int)n->m_len);
+		m->m_len += n->m_len;
+		n = m_free(n);
+	}
+}
+
+/*
+ * Concatenate two pkthdr mbuf chains.
+ */
+void
+m_catpkt(struct mbuf *m, struct mbuf *n)
+{
+
+	M_ASSERTPKTHDR(m);
+	M_ASSERTPKTHDR(n);
+
+	m->m_pkthdr.len += n->m_pkthdr.len;
+	m_demote(n, 1, 0);
+
+	m_cat(m, n);
+}
+
+void
+m_adj(struct mbuf *mp, int req_len)
+{
+	int len = req_len;
+	struct mbuf *m;
+	int count;
+
+	if ((m = mp) == NULL)
+		return;
+	if (len >= 0) {
+		/*
+		 * Trim from head.
+		 */
+		while (m != NULL && len > 0) {
+			if (m->m_len <= len) {
+				len -= m->m_len;
+				m->m_len = 0;
+				m = m->m_next;
+			} else {
+				m->m_len -= len;
+				m->m_data += len;
+				len = 0;
+			}
+		}
+		if (mp->m_flags & M_PKTHDR)
+			mp->m_pkthdr.len -= (req_len - len);
+	} else {
+		/*
+		 * Trim from tail.  Scan the mbuf chain,
+		 * calculating its length and finding the last mbuf.
+		 * If the adjustment only affects this mbuf, then just
+		 * adjust and return.  Otherwise, rescan and truncate
+		 * after the remaining size.
+		 */
+		len = -len;
+		count = 0;
+		for (;;) {
+			count += m->m_len;
+			if (m->m_next == (struct mbuf *)0)
+				break;
+			m = m->m_next;
+		}
+		if (m->m_len >= len) {
+			m->m_len -= len;
+			if (mp->m_flags & M_PKTHDR)
+				mp->m_pkthdr.len -= len;
+			return;
+		}
+		count -= len;
+		if (count < 0)
+			count = 0;
+		/*
+		 * Correct length for chain is "count".
+		 * Find the mbuf with last data, adjust its length,
+		 * and toss data from remaining mbufs on chain.
+		 */
+		m = mp;
+		if (m->m_flags & M_PKTHDR)
+			m->m_pkthdr.len = count;
+		for (; m; m = m->m_next) {
+			if (m->m_len >= count) {
+				m->m_len = count;
+				if (m->m_next != NULL) {
+					m_freem(m->m_next);
+					m->m_next = NULL;
+				}
+				break;
+			}
+			count -= m->m_len;
+		}
+	}
+}
+
+/*
+ * Rearange an mbuf chain so that len bytes are contiguous
+ * and in the data area of an mbuf (so that mtod will work
+ * for a structure of size len).  Returns the resulting
+ * mbuf chain on success, frees it and returns null on failure.
+ * If there is room, it will add up to max_protohdr-len extra bytes to the
+ * contiguous region in an attempt to avoid being called next time.
+ */
+struct mbuf *
+m_pullup(struct mbuf *n, int len)
+{
+	struct mbuf *m;
+	int count;
+	int space;
+
+	/*
+	 * If first mbuf has no cluster, and has room for len bytes
+	 * without shifting current data, pullup into it,
+	 * otherwise allocate a new mbuf to prepend to the chain.
+	 */
+	if ((n->m_flags & M_EXT) == 0 &&
+	    n->m_data + len < &n->m_dat[MLEN] && n->m_next) {
+		if (n->m_len >= len)
+			return (n);
+		m = n;
+		n = n->m_next;
+		len -= m->m_len;
+	} else {
+		if (len > MHLEN)
+			goto bad;
+		m = m_get(M_NOWAIT, n->m_type);
+		if (m == NULL)
+			goto bad;
+		if (n->m_flags & M_PKTHDR)
+			m_move_pkthdr(m, n);
+	}
+	space = &m->m_dat[MLEN] - (m->m_data + m->m_len);
+	do {
+		count = min(min(max(len, max_protohdr), space), n->m_len);
+		bcopy(mtod(n, caddr_t), mtod(m, caddr_t) + m->m_len,
+		  (u_int)count);
+		len -= count;
+		m->m_len += count;
+		n->m_len -= count;
+		space -= count;
+		if (n->m_len)
+			n->m_data += count;
+		else
+			n = m_free(n);
+	} while (len > 0 && n);
+	if (len > 0) {
+		(void) m_free(m);
+		goto bad;
+	}
+	m->m_next = n;
+	return (m);
+bad:
+	m_freem(n);
+	return (NULL);
+}
+
+/*
+ * Like m_pullup(), except a new mbuf is always allocated, and we allow
+ * the amount of empty space before the data in the new mbuf to be specified
+ * (in the event that the caller expects to prepend later).
+ */
+struct mbuf *
+m_copyup(struct mbuf *n, int len, int dstoff)
+{
+	struct mbuf *m;
+	int count, space;
+
+	if (len > (MHLEN - dstoff))
+		goto bad;
+	m = m_get(M_NOWAIT, n->m_type);
+	if (m == NULL)
+		goto bad;
+	if (n->m_flags & M_PKTHDR)
+		m_move_pkthdr(m, n);
+	m->m_data += dstoff;
+	space = &m->m_dat[MLEN] - (m->m_data + m->m_len);
+	do {
+		count = min(min(max(len, max_protohdr), space), n->m_len);
+		memcpy(mtod(m, caddr_t) + m->m_len, mtod(n, caddr_t),
+		    (unsigned)count);
+		len -= count;
+		m->m_len += count;
+		n->m_len -= count;
+		space -= count;
+		if (n->m_len)
+			n->m_data += count;
+		else
+			n = m_free(n);
+	} while (len > 0 && n);
+	if (len > 0) {
+		(void) m_free(m);
+		goto bad;
+	}
+	m->m_next = n;
+	return (m);
+ bad:
+	m_freem(n);
+	return (NULL);
+}
+
+/*
+ * Partition an mbuf chain in two pieces, returning the tail --
+ * all but the first len0 bytes.  In case of failure, it returns NULL and
+ * attempts to restore the chain to its original state.
+ *
+ * Note that the resulting mbufs might be read-only, because the new
+ * mbuf can end up sharing an mbuf cluster with the original mbuf if
+ * the "breaking point" happens to lie within a cluster mbuf. Use the
+ * M_WRITABLE() macro to check for this case.
+ */
+struct mbuf *
+m_split(struct mbuf *m0, int len0, int wait)
+{
+	struct mbuf *m, *n;
+	u_int len = len0, remain;
+
+	MBUF_CHECKSLEEP(wait);
+	for (m = m0; m && len > m->m_len; m = m->m_next)
+		len -= m->m_len;
+	if (m == NULL)
+		return (NULL);
+	remain = m->m_len - len;
+	if (m0->m_flags & M_PKTHDR && remain == 0) {
+		n = m_gethdr(wait, m0->m_type);
+		if (n == NULL)
+			return (NULL);
+		n->m_next = m->m_next;
+		m->m_next = NULL;
+		n->m_pkthdr.rcvif = m0->m_pkthdr.rcvif;
+		n->m_pkthdr.len = m0->m_pkthdr.len - len0;
+		m0->m_pkthdr.len = len0;
+		return (n);
+	} else if (m0->m_flags & M_PKTHDR) {
+		n = m_gethdr(wait, m0->m_type);
+		if (n == NULL)
+			return (NULL);
+		n->m_pkthdr.rcvif = m0->m_pkthdr.rcvif;
+		n->m_pkthdr.len = m0->m_pkthdr.len - len0;
+		m0->m_pkthdr.len = len0;
+		if (m->m_flags & M_EXT)
+			goto extpacket;
+		if (remain > MHLEN) {
+			/* m can't be the lead packet */
+			M_ALIGN(n, 0);
+			n->m_next = m_split(m, len, wait);
+			if (n->m_next == NULL) {
+				(void) m_free(n);
+				return (NULL);
+			} else {
+				n->m_len = 0;
+				return (n);
+			}
+		} else
+			M_ALIGN(n, remain);
+	} else if (remain == 0) {
+		n = m->m_next;
+		m->m_next = NULL;
+		return (n);
+	} else {
+		n = m_get(wait, m->m_type);
+		if (n == NULL)
+			return (NULL);
+		M_ALIGN(n, remain);
+	}
+extpacket:
+	if (m->m_flags & M_EXT) {
+		n->m_data = m->m_data + len;
+		mb_dupcl(n, m);
+	} else {
+		bcopy(mtod(m, caddr_t) + len, mtod(n, caddr_t), remain);
+	}
+	n->m_len = remain;
+	m->m_len = len;
+	n->m_next = m->m_next;
+	m->m_next = NULL;
+	return (n);
+}
+/*
+ * Routine to copy from device local memory into mbufs.
+ * Note that `off' argument is offset into first mbuf of target chain from
+ * which to begin copying the data to.
+ */
+struct mbuf *
+m_devget(char *buf, int totlen, int off, struct ifnet *ifp,
+    void (*copy)(char *from, caddr_t to, u_int len))
+{
+	struct mbuf *m;
+	struct mbuf *top = NULL, **mp = &top;
+	int len;
+
+	if (off < 0 || off > MHLEN)
+		return (NULL);
+
+	while (totlen > 0) {
+		if (top == NULL) {	/* First one, must be PKTHDR */
+			if (totlen + off >= MINCLSIZE) {
+				m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);
+				len = MCLBYTES;
+			} else {
+				m = m_gethdr(M_NOWAIT, MT_DATA);
+				len = MHLEN;
+
+				/* Place initial small packet/header at end of mbuf */
+				if (m && totlen + off + max_linkhdr <= MHLEN) {
+					m->m_data += max_linkhdr;
+					len -= max_linkhdr;
+				}
+			}
+			if (m == NULL)
+				return NULL;
+			m->m_pkthdr.rcvif = ifp;
+			m->m_pkthdr.len = totlen;
+		} else {
+			if (totlen + off >= MINCLSIZE) {
+				m = m_getcl(M_NOWAIT, MT_DATA, 0);
+				len = MCLBYTES;
+			} else {
+				m = m_get(M_NOWAIT, MT_DATA);
+				len = MLEN;
+			}
+			if (m == NULL) {
+				m_freem(top);
+				return NULL;
+			}
+		}
+		if (off) {
+			m->m_data += off;
+			len -= off;
+			off = 0;
+		}
+		m->m_len = len = min(totlen, len);
+		if (copy)
+			copy(buf, mtod(m, caddr_t), (u_int)len);
+		else
+			bcopy(buf, mtod(m, caddr_t), (u_int)len);
+		buf += len;
+		*mp = m;
+		mp = &m->m_next;
+		totlen -= len;
+	}
+	return (top);
+}
+
+/*
+ * Copy data from a buffer back into the indicated mbuf chain,
+ * starting "off" bytes from the beginning, extending the mbuf
+ * chain if necessary.
+ */
+void
+m_copyback(struct mbuf *m0, int off, int len, c_caddr_t cp)
+{
+	int mlen;
+	struct mbuf *m = m0, *n;
+	int totlen = 0;
+
+	if (m0 == NULL)
+		return;
+	while (off > (mlen = m->m_len)) {
+		off -= mlen;
+		totlen += mlen;
+		if (m->m_next == NULL) {
+			n = m_get(M_NOWAIT, m->m_type);
+			if (n == NULL)
+				goto out;
+			bzero(mtod(n, caddr_t), MLEN);
+			n->m_len = min(MLEN, len + off);
+			m->m_next = n;
+		}
+		m = m->m_next;
+	}
+	while (len > 0) {
+		if (m->m_next == NULL && (len > m->m_len - off)) {
+			m->m_len += min(len - (m->m_len - off),
+			    M_TRAILINGSPACE(m));
+		}
+		mlen = min (m->m_len - off, len);
+		bcopy(cp, off + mtod(m, caddr_t), (u_int)mlen);
+		cp += mlen;
+		len -= mlen;
+		mlen += off;
+		off = 0;
+		totlen += mlen;
+		if (len == 0)
+			break;
+		if (m->m_next == NULL) {
+			n = m_get(M_NOWAIT, m->m_type);
+			if (n == NULL)
+				break;
+			n->m_len = min(MLEN, len);
+			m->m_next = n;
+		}
+		m = m->m_next;
+	}
+out:	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
+		m->m_pkthdr.len = totlen;
+}
+
+/*
+ * Append the specified data to the indicated mbuf chain,
+ * Extend the mbuf chain if the new data does not fit in
+ * existing space.
+ *
+ * Return 1 if able to complete the job; otherwise 0.
+ */
+int
+m_append(struct mbuf *m0, int len, c_caddr_t cp)
+{
+	struct mbuf *m, *n;
+	int remainder, space;
+
+	for (m = m0; m->m_next != NULL; m = m->m_next)
+		;
+	remainder = len;
+	space = M_TRAILINGSPACE(m);
+	if (space > 0) {
+		/*
+		 * Copy into available space.
+		 */
+		if (space > remainder)
+			space = remainder;
+		bcopy(cp, mtod(m, caddr_t) + m->m_len, space);
+		m->m_len += space;
+		cp += space, remainder -= space;
+	}
+	while (remainder > 0) {
+		/*
+		 * Allocate a new mbuf; could check space
+		 * and allocate a cluster instead.
+		 */
+		n = m_get(M_NOWAIT, m->m_type);
+		if (n == NULL)
+			break;
+		n->m_len = min(MLEN, remainder);
+		bcopy(cp, mtod(n, caddr_t), n->m_len);
+		cp += n->m_len, remainder -= n->m_len;
+		m->m_next = n;
+		m = n;
+	}
+	if (m0->m_flags & M_PKTHDR)
+		m0->m_pkthdr.len += len - remainder;
+	return (remainder == 0);
+}
+
+/*
+ * Apply function f to the data in an mbuf chain starting "off" bytes from
+ * the beginning, continuing for "len" bytes.
+ */
+int
+m_apply(struct mbuf *m, int off, int len,
+    int (*f)(void *, void *, u_int), void *arg)
+{
+	u_int count;
+	int rval;
+
+	KASSERT(off >= 0, ("m_apply, negative off %d", off));
+	KASSERT(len >= 0, ("m_apply, negative len %d", len));
+	while (off > 0) {
+		KASSERT(m != NULL, ("m_apply, offset > size of mbuf chain"));
+		if (off < m->m_len)
+			break;
+		off -= m->m_len;
+		m = m->m_next;
+	}
+	while (len > 0) {
+		KASSERT(m != NULL, ("m_apply, offset > size of mbuf chain"));
+		count = min(m->m_len - off, len);
+		rval = (*f)(arg, mtod(m, caddr_t) + off, count);
+		if (rval)
+			return (rval);
+		len -= count;
+		off = 0;
+		m = m->m_next;
+	}
+	return (0);
+}
+
+/*
+ * Return a pointer to mbuf/offset of location in mbuf chain.
+ */
+struct mbuf *
+m_getptr(struct mbuf *m, int loc, int *off)
+{
+
+	while (loc >= 0) {
+		/* Normal end of search. */
+		if (m->m_len > loc) {
+			*off = loc;
+			return (m);
+		} else {
+			loc -= m->m_len;
+			if (m->m_next == NULL) {
+				if (loc == 0) {
+					/* Point at the end of valid data. */
+					*off = m->m_len;
+					return (m);
+				}
+				return (NULL);
+			}
+			m = m->m_next;
+		}
+	}
+	return (NULL);
+}
+
+void
+m_print(const struct mbuf *m, int maxlen)
+{
+	int len;
+	int pdata;
+	const struct mbuf *m2;
+
+	if (m == NULL) {
+		printf("mbuf: %p\n", m);
+		return;
+	}
+
+	if (m->m_flags & M_PKTHDR)
+		len = m->m_pkthdr.len;
+	else
+		len = -1;
+	m2 = m;
+	while (m2 != NULL && (len == -1 || len)) {
+		pdata = m2->m_len;
+		if (maxlen != -1 && pdata > maxlen)
+			pdata = maxlen;
+		printf("mbuf: %p len: %d, next: %p, %b%s", m2, m2->m_len,
+		    m2->m_next, m2->m_flags, "\20\20freelist\17skipfw"
+		    "\11proto5\10proto4\7proto3\6proto2\5proto1\4rdonly"
+		    "\3eor\2pkthdr\1ext", pdata ? "" : "\n");
+		if (pdata)
+			printf(", %*D\n", pdata, (u_char *)m2->m_data, "-");
+		if (len != -1)
+			len -= m2->m_len;
+		m2 = m2->m_next;
+	}
+	if (len > 0)
+		printf("%d bytes unaccounted for.\n", len);
+	return;
+}
+
+u_int
+m_fixhdr(struct mbuf *m0)
+{
+	u_int len;
+
+	len = m_length(m0, NULL);
+	m0->m_pkthdr.len = len;
+	return (len);
+}
+
+u_int
+m_length(struct mbuf *m0, struct mbuf **last)
+{
+	struct mbuf *m;
+	u_int len;
+
+	len = 0;
+	for (m = m0; m != NULL; m = m->m_next) {
+		len += m->m_len;
+		if (m->m_next == NULL)
+			break;
+	}
+	if (last != NULL)
+		*last = m;
+	return (len);
+}
+
+/*
+ * Defragment a mbuf chain, returning the shortest possible
+ * chain of mbufs and clusters.  If allocation fails and
+ * this cannot be completed, NULL will be returned, but
+ * the passed in chain will be unchanged.  Upon success,
+ * the original chain will be freed, and the new chain
+ * will be returned.
+ *
+ * If a non-packet header is passed in, the original
+ * mbuf (chain?) will be returned unharmed.
+ */
+struct mbuf *
+m_defrag(struct mbuf *m0, int how)
+{
+	struct mbuf *m_new = NULL, *m_final = NULL;
+	int progress = 0, length;
+
+	MBUF_CHECKSLEEP(how);
+	if (!(m0->m_flags & M_PKTHDR))
+		return (m0);
+
+	m_fixhdr(m0); /* Needed sanity check */
+
+#ifdef MBUF_STRESS_TEST
+	if (m_defragrandomfailures) {
+		int temp = arc4random() & 0xff;
+		if (temp == 0xba)
+			goto nospace;
+	}
+#endif
+
+	if (m0->m_pkthdr.len > MHLEN)
+		m_final = m_getcl(how, MT_DATA, M_PKTHDR);
+	else
+		m_final = m_gethdr(how, MT_DATA);
+
+	if (m_final == NULL)
+		goto nospace;
+
+	if (m_dup_pkthdr(m_final, m0, how) == 0)
+		goto nospace;
+
+	m_new = m_final;
+
+	while (progress < m0->m_pkthdr.len) {
+		length = m0->m_pkthdr.len - progress;
+		if (length > MCLBYTES)
+			length = MCLBYTES;
+
+		if (m_new == NULL) {
+			if (length > MLEN)
+				m_new = m_getcl(how, MT_DATA, 0);
+			else
+				m_new = m_get(how, MT_DATA);
+			if (m_new == NULL)
+				goto nospace;
+		}
+
+		m_copydata(m0, progress, length, mtod(m_new, caddr_t));
+		progress += length;
+		m_new->m_len = length;
+		if (m_new != m_final)
+			m_cat(m_final, m_new);
+		m_new = NULL;
+	}
+#ifdef MBUF_STRESS_TEST
+	if (m0->m_next == NULL)
+		m_defraguseless++;
+#endif
+	m_freem(m0);
+	m0 = m_final;
+#ifdef MBUF_STRESS_TEST
+	m_defragpackets++;
+	m_defragbytes += m0->m_pkthdr.len;
+#endif
+	return (m0);
+nospace:
+#ifdef MBUF_STRESS_TEST
+	m_defragfailure++;
+#endif
+	if (m_final)
+		m_freem(m_final);
+	return (NULL);
+}
+
+/*
+ * Defragment an mbuf chain, returning at most maxfrags separate
+ * mbufs+clusters.  If this is not possible NULL is returned and
+ * the original mbuf chain is left in it's present (potentially
+ * modified) state.  We use two techniques: collapsing consecutive
+ * mbufs and replacing consecutive mbufs by a cluster.
+ *
+ * NB: this should really be named m_defrag but that name is taken
+ */
+struct mbuf *
+m_collapse(struct mbuf *m0, int how, int maxfrags)
+{
+	struct mbuf *m, *n, *n2, **prev;
+	u_int curfrags;
+
+	/*
+	 * Calculate the current number of frags.
+	 */
+	curfrags = 0;
+	for (m = m0; m != NULL; m = m->m_next)
+		curfrags++;
+	/*
+	 * First, try to collapse mbufs.  Note that we always collapse
+	 * towards the front so we don't need to deal with moving the
+	 * pkthdr.  This may be suboptimal if the first mbuf has much
+	 * less data than the following.
+	 */
+	m = m0;
+again:
+	for (;;) {
+		n = m->m_next;
+		if (n == NULL)
+			break;
+		if (M_WRITABLE(m) &&
+		    n->m_len < M_TRAILINGSPACE(m)) {
+			bcopy(mtod(n, void *), mtod(m, char *) + m->m_len,
+				n->m_len);
+			m->m_len += n->m_len;
+			m->m_next = n->m_next;
+			m_free(n);
+			if (--curfrags <= maxfrags)
+				return m0;
+		} else
+			m = n;
+	}
+	KASSERT(maxfrags > 1,
+		("maxfrags %u, but normal collapse failed", maxfrags));
+	/*
+	 * Collapse consecutive mbufs to a cluster.
+	 */
+	prev = &m0->m_next;		/* NB: not the first mbuf */
+	while ((n = *prev) != NULL) {
+		if ((n2 = n->m_next) != NULL &&
+		    n->m_len + n2->m_len < MCLBYTES) {
+			m = m_getcl(how, MT_DATA, 0);
+			if (m == NULL)
+				goto bad;
+			bcopy(mtod(n, void *), mtod(m, void *), n->m_len);
+			bcopy(mtod(n2, void *), mtod(m, char *) + n->m_len,
+				n2->m_len);
+			m->m_len = n->m_len + n2->m_len;
+			m->m_next = n2->m_next;
+			*prev = m;
+			m_free(n);
+			m_free(n2);
+			if (--curfrags <= maxfrags)	/* +1 cl -2 mbufs */
+				return m0;
+			/*
+			 * Still not there, try the normal collapse
+			 * again before we allocate another cluster.
+			 */
+			goto again;
+		}
+		prev = &n->m_next;
+	}
+	/*
+	 * No place where we can collapse to a cluster; punt.
+	 * This can occur if, for example, you request 2 frags
+	 * but the packet requires that both be clusters (we
+	 * never reallocate the first mbuf to avoid moving the
+	 * packet header).
+	 */
+bad:
+	return NULL;
+}
+
+#ifdef MBUF_STRESS_TEST
+
+/*
+ * Fragment an mbuf chain.  There's no reason you'd ever want to do
+ * this in normal usage, but it's great for stress testing various
+ * mbuf consumers.
+ *
+ * If fragmentation is not possible, the original chain will be
+ * returned.
+ *
+ * Possible length values:
+ * 0	 no fragmentation will occur
+ * > 0	each fragment will be of the specified length
+ * -1	each fragment will be the same random value in length
+ * -2	each fragment's length will be entirely random
+ * (Random values range from 1 to 256)
+ */
+struct mbuf *
+m_fragment(struct mbuf *m0, int how, int length)
+{
+	struct mbuf *m_first, *m_last;
+	int divisor = 255, progress = 0, fraglen;
+
+	if (!(m0->m_flags & M_PKTHDR))
+		return (m0);
+
+	if (length == 0 || length < -2)
+		return (m0);
+	if (length > MCLBYTES)
+		length = MCLBYTES;
+	if (length < 0 && divisor > MCLBYTES)
+		divisor = MCLBYTES;
+	if (length == -1)
+		length = 1 + (arc4random() % divisor);
+	if (length > 0)
+		fraglen = length;
+
+	m_fixhdr(m0); /* Needed sanity check */
+
+	m_first = m_getcl(how, MT_DATA, M_PKTHDR);
+	if (m_first == NULL)
+		goto nospace;
+
+	if (m_dup_pkthdr(m_first, m0, how) == 0)
+		goto nospace;
+
+	m_last = m_first;
+
+	while (progress < m0->m_pkthdr.len) {
+		if (length == -2)
+			fraglen = 1 + (arc4random() % divisor);
+		if (fraglen > m0->m_pkthdr.len - progress)
+			fraglen = m0->m_pkthdr.len - progress;
+
+		if (progress != 0) {
+			struct mbuf *m_new = m_getcl(how, MT_DATA, 0);
+			if (m_new == NULL)
+				goto nospace;
+
+			m_last->m_next = m_new;
+			m_last = m_new;
+		}
+
+		m_copydata(m0, progress, fraglen, mtod(m_last, caddr_t));
+		progress += fraglen;
+		m_last->m_len = fraglen;
+	}
+	m_freem(m0);
+	m0 = m_first;
+	return (m0);
+nospace:
+	if (m_first)
+		m_freem(m_first);
+	/* Return the original chain on failure */
+	return (m0);
+}
+
+#endif
+
+#ifndef __HAIKU__
+/*
+ * Copy the contents of uio into a properly sized mbuf chain.
+ */
+struct mbuf *
+m_uiotombuf(struct uio *uio, int how, int len, int align, int flags)
+{
+	struct mbuf *m, *mb;
+	int error, length;
+	ssize_t total;
+	int progress = 0;
+
+	/*
+	 * len can be zero or an arbitrary large value bound by
+	 * the total data supplied by the uio.
+	 */
+	if (len > 0)
+		total = min(uio->uio_resid, len);
+	else
+		total = uio->uio_resid;
+
+	/*
+	 * The smallest unit returned by m_getm2() is a single mbuf
+	 * with pkthdr.  We can't align past it.
+	 */
+	if (align >= MHLEN)
+		return (NULL);
+
+	/*
+	 * Give us the full allocation or nothing.
+	 * If len is zero return the smallest empty mbuf.
+	 */
+	m = m_getm2(NULL, max(total + align, 1), how, MT_DATA, flags);
+	if (m == NULL)
+		return (NULL);
+	m->m_data += align;
+
+	/* Fill all mbufs with uio data and update header information. */
+	for (mb = m; mb != NULL; mb = mb->m_next) {
+		length = min(M_TRAILINGSPACE(mb), total - progress);
+
+		error = uiomove(mtod(mb, void *), length, uio);
+		if (error) {
+			m_freem(m);
+			return (NULL);
+		}
+
+		mb->m_len = length;
+		progress += length;
+		if (flags & M_PKTHDR)
+			m->m_pkthdr.len += length;
+	}
+	KASSERT(progress == total, ("%s: progress != total", __func__));
+
+	return (m);
+}
+
+/*
+ * Copy an mbuf chain into a uio limited by len if set.
+ */
+int
+m_mbuftouio(struct uio *uio, struct mbuf *m, int len)
+{
+	int error, length, total;
+	int progress = 0;
+
+	if (len > 0)
+		total = min(uio->uio_resid, len);
+	else
+		total = uio->uio_resid;
+
+	/* Fill the uio with data from the mbufs. */
+	for (; m != NULL; m = m->m_next) {
+		length = min(m->m_len, total - progress);
+
+		error = uiomove(mtod(m, void *), length, uio);
+		if (error)
+			return (error);
+
+		progress += length;
+	}
+
+	return (0);
+}
+#endif
+
+/*
+ * Create a writable copy of the mbuf chain.  While doing this
+ * we compact the chain with a goal of producing a chain with
+ * at most two mbufs.  The second mbuf in this chain is likely
+ * to be a cluster.  The primary purpose of this work is to create
+ * a writable packet for encryption, compression, etc.  The
+ * secondary goal is to linearize the data so the data can be
+ * passed to crypto hardware in the most efficient manner possible.
+ */
+struct mbuf *
+m_unshare(struct mbuf *m0, int how)
+{
+	struct mbuf *m, *mprev;
+	struct mbuf *n, *mfirst, *mlast;
+	int len, off;
+
+	mprev = NULL;
+	for (m = m0; m != NULL; m = mprev->m_next) {
+		/*
+		 * Regular mbufs are ignored unless there's a cluster
+		 * in front of it that we can use to coalesce.  We do
+		 * the latter mainly so later clusters can be coalesced
+		 * also w/o having to handle them specially (i.e. convert
+		 * mbuf+cluster -> cluster).  This optimization is heavily
+		 * influenced by the assumption that we're running over
+		 * Ethernet where MCLBYTES is large enough that the max
+		 * packet size will permit lots of coalescing into a
+		 * single cluster.  This in turn permits efficient
+		 * crypto operations, especially when using hardware.
+		 */
+		if ((m->m_flags & M_EXT) == 0) {
+			if (mprev && (mprev->m_flags & M_EXT) &&
+			    m->m_len <= M_TRAILINGSPACE(mprev)) {
+				/* XXX: this ignores mbuf types */
+				memcpy(mtod(mprev, caddr_t) + mprev->m_len,
+				    mtod(m, caddr_t), m->m_len);
+				mprev->m_len += m->m_len;
+				mprev->m_next = m->m_next;	/* unlink from chain */
+				m_free(m);			/* reclaim mbuf */
+#if 0
+				newipsecstat.ips_mbcoalesced++;
+#endif
+			} else {
+				mprev = m;
+			}
+			continue;
+		}
+		/*
+		 * Writable mbufs are left alone (for now).
+		 */
+		if (M_WRITABLE(m)) {
+			mprev = m;
+			continue;
+		}
+
+		/*
+		 * Not writable, replace with a copy or coalesce with
+		 * the previous mbuf if possible (since we have to copy
+		 * it anyway, we try to reduce the number of mbufs and
+		 * clusters so that future work is easier).
+		 */
+		KASSERT(m->m_flags & M_EXT, ("m_flags 0x%x", m->m_flags));
+		/* NB: we only coalesce into a cluster or larger */
+		if (mprev != NULL && (mprev->m_flags & M_EXT) &&
+		    m->m_len <= M_TRAILINGSPACE(mprev)) {
+			/* XXX: this ignores mbuf types */
+			memcpy(mtod(mprev, caddr_t) + mprev->m_len,
+			    mtod(m, caddr_t), m->m_len);
+			mprev->m_len += m->m_len;
+			mprev->m_next = m->m_next;	/* unlink from chain */
+			m_free(m);			/* reclaim mbuf */
+#if 0
+			newipsecstat.ips_clcoalesced++;
+#endif
+			continue;
+		}
+
+		/*
+		 * Allocate new space to hold the copy and copy the data.
+		 * We deal with jumbo mbufs (i.e. m_len > MCLBYTES) by
+		 * splitting them into clusters.  We could just malloc a
+		 * buffer and make it external but too many device drivers
+		 * don't know how to break up the non-contiguous memory when
+		 * doing DMA.
+		 */
+		n = m_getcl(how, m->m_type, m->m_flags & M_COPYFLAGS);
+		if (n == NULL) {
+			m_freem(m0);
+			return (NULL);
+		}
+		if (m->m_flags & M_PKTHDR) {
+			KASSERT(mprev == NULL, ("%s: m0 %p, m %p has M_PKTHDR",
+			    __func__, m0, m));
+			m_move_pkthdr(n, m);
+		}
+		len = m->m_len;
+		off = 0;
+		mfirst = n;
+		mlast = NULL;
+		for (;;) {
+			int cc = min(len, MCLBYTES);
+			memcpy(mtod(n, caddr_t), mtod(m, caddr_t) + off, cc);
+			n->m_len = cc;
+			if (mlast != NULL)
+				mlast->m_next = n;
+			mlast = n;
+#if 0
+			newipsecstat.ips_clcopied++;
+#endif
+
+			len -= cc;
+			if (len <= 0)
+				break;
+			off += cc;
+
+			n = m_getcl(how, m->m_type, m->m_flags & M_COPYFLAGS);
+			if (n == NULL) {
+				m_freem(mfirst);
+				m_freem(m0);
+				return (NULL);
+			}
+		}
+		n->m_next = m->m_next;
+		if (mprev == NULL)
+			m0 = mfirst;		/* new head of chain */
+		else
+			mprev->m_next = mfirst;	/* replace old mbuf */
+		m_free(m);			/* release old mbuf */
+		mprev = mfirst;
+	}
+	return (m0);
+}
+
+#ifdef MBUF_PROFILING
+
+#define MP_BUCKETS 32 /* don't just change this as things may overflow.*/
+struct mbufprofile {
+	uintmax_t wasted[MP_BUCKETS];
+	uintmax_t used[MP_BUCKETS];
+	uintmax_t segments[MP_BUCKETS];
+} mbprof;
+
+#define MP_MAXDIGITS 21	/* strlen("16,000,000,000,000,000,000") == 21 */
+#define MP_NUMLINES 6
+#define MP_NUMSPERLINE 16
+#define MP_EXTRABYTES 64	/* > strlen("used:\nwasted:\nsegments:\n") */
+/* work out max space needed and add a bit of spare space too */
+#define MP_MAXLINE ((MP_MAXDIGITS+1) * MP_NUMSPERLINE)
+#define MP_BUFSIZE ((MP_MAXLINE * MP_NUMLINES) + 1 + MP_EXTRABYTES)
+
+char mbprofbuf[MP_BUFSIZE];
+
+void
+m_profile(struct mbuf *m)
+{
+	int segments = 0;
+	int used = 0;
+	int wasted = 0;
+
+	while (m) {
+		segments++;
+		used += m->m_len;
+		if (m->m_flags & M_EXT) {
+			wasted += MHLEN - sizeof(m->m_ext) +
+			    m->m_ext.ext_size - m->m_len;
+		} else {
+			if (m->m_flags & M_PKTHDR)
+				wasted += MHLEN - m->m_len;
+			else
+				wasted += MLEN - m->m_len;
+		}
+		m = m->m_next;
+	}
+	/* be paranoid.. it helps */
+	if (segments > MP_BUCKETS - 1)
+		segments = MP_BUCKETS - 1;
+	if (used > 100000)
+		used = 100000;
+	if (wasted > 100000)
+		wasted = 100000;
+	/* store in the appropriate bucket */
+	/* don't bother locking. if it's slightly off, so what? */
+	mbprof.segments[segments]++;
+	mbprof.used[fls(used)]++;
+	mbprof.wasted[fls(wasted)]++;
+}
+
+static void
+mbprof_textify(void)
+{
+	int offset;
+	char *c;
+	uint64_t *p;
+
+	p = &mbprof.wasted[0];
+	c = mbprofbuf;
+	offset = snprintf(c, MP_MAXLINE + 10,
+	    "wasted:\n"
+	    "%ju %ju %ju %ju %ju %ju %ju %ju "
+	    "%ju %ju %ju %ju %ju %ju %ju %ju\n",
+	    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	    p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+#ifdef BIG_ARRAY
+	p = &mbprof.wasted[16];
+	c += offset;
+	offset = snprintf(c, MP_MAXLINE,
+	    "%ju %ju %ju %ju %ju %ju %ju %ju "
+	    "%ju %ju %ju %ju %ju %ju %ju %ju\n",
+	    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	    p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+#endif
+	p = &mbprof.used[0];
+	c += offset;
+	offset = snprintf(c, MP_MAXLINE + 10,
+	    "used:\n"
+	    "%ju %ju %ju %ju %ju %ju %ju %ju "
+	    "%ju %ju %ju %ju %ju %ju %ju %ju\n",
+	    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	    p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+#ifdef BIG_ARRAY
+	p = &mbprof.used[16];
+	c += offset;
+	offset = snprintf(c, MP_MAXLINE,
+	    "%ju %ju %ju %ju %ju %ju %ju %ju "
+	    "%ju %ju %ju %ju %ju %ju %ju %ju\n",
+	    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	    p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+#endif
+	p = &mbprof.segments[0];
+	c += offset;
+	offset = snprintf(c, MP_MAXLINE + 10,
+	    "segments:\n"
+	    "%ju %ju %ju %ju %ju %ju %ju %ju "
+	    "%ju %ju %ju %ju %ju %ju %ju %ju\n",
+	    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	    p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+#ifdef BIG_ARRAY
+	p = &mbprof.segments[16];
+	c += offset;
+	offset = snprintf(c, MP_MAXLINE,
+	    "%ju %ju %ju %ju %ju %ju %ju %ju "
+	    "%ju %ju %ju %ju %ju %ju %ju %jju",
+	    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	    p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+#endif
+}
+
+static int
+mbprof_handler(SYSCTL_HANDLER_ARGS)
+{
+	int error;
+
+	mbprof_textify();
+	error = SYSCTL_OUT(req, mbprofbuf, strlen(mbprofbuf) + 1);
+	return (error);
+}
+
+static int
+mbprof_clr_handler(SYSCTL_HANDLER_ARGS)
+{
+	int clear, error;
+
+	clear = 0;
+	error = sysctl_handle_int(oidp, &clear, 0, req);
+	if (error || !req->newptr)
+		return (error);
+
+	if (clear) {
+		bzero(&mbprof, sizeof(mbprof));
+	}
+
+	return (error);
+}
+
+
+SYSCTL_PROC(_kern_ipc, OID_AUTO, mbufprofile, CTLTYPE_STRING|CTLFLAG_RD,
+	    NULL, 0, mbprof_handler, "A", "mbuf profiling statistics");
+
+SYSCTL_PROC(_kern_ipc, OID_AUTO, mbufprofileclr, CTLTYPE_INT|CTLFLAG_RW,
+	    NULL, 0, mbprof_clr_handler, "I", "clear mbuf profiling statistics");
+#endif
+
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf2.c b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf2.c
new file mode 100644
index 0000000000..508243c0f1
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/fbsd_uipc_mbuf2.c
@@ -0,0 +1,455 @@
+/*	$KAME: uipc_mbuf2.c,v 1.31 2001/11/28 11:08:53 itojun Exp $	*/
+/*	$NetBSD: uipc_mbuf.c,v 1.40 1999/04/01 00:23:25 thorpej Exp $	*/
+
+/*-
+ * Copyright (C) 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)uipc_mbuf.c	8.4 (Berkeley) 2/14/95
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: stable/11/sys/kern/uipc_mbuf2.c 312441 2017-01-19 23:42:51Z rpokala $");
+
+/*#define PULLDOWN_DEBUG*/
+
+#ifdef __HAIKU__
+#define FBSD_DRIVER
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/mutex.h>
+
+#include <security/mac/mac_framework.h>
+
+static MALLOC_DEFINE(M_PACKET_TAGS, MBUF_TAG_MEM_NAME,
+    "packet-attached information");
+
+/* can't call it m_dup(), as freebsd[34] uses m_dup() with different arg */
+static struct mbuf *m_dup1(struct mbuf *, int, int, int);
+
+/*
+ * ensure that [off, off + len) is contiguous on the mbuf chain "m".
+ * packet chain before "off" is kept untouched.
+ * if offp == NULL, the target will start at <retval, 0> on resulting chain.
+ * if offp != NULL, the target will start at <retval, *offp> on resulting chain.
+ *
+ * on error return (NULL return value), original "m" will be freed.
+ *
+ * XXX: M_TRAILINGSPACE/M_LEADINGSPACE only permitted on writable ext_buf.
+ */
+struct mbuf *
+m_pulldown(struct mbuf *m, int off, int len, int *offp)
+{
+	struct mbuf *n, *o;
+	int hlen, tlen, olen;
+	int writable;
+
+	/* check invalid arguments. */
+	if (m == NULL)
+		panic("m == NULL in m_pulldown()");
+	if (len > MCLBYTES) {
+		m_freem(m);
+		return NULL;	/* impossible */
+	}
+
+#ifdef PULLDOWN_DEBUG
+    {
+	struct mbuf *t;
+	printf("before:");
+	for (t = m; t; t = t->m_next)
+		printf(" %d", t->m_len);
+	printf("\n");
+    }
+#endif
+	n = m;
+	while (n != NULL && off > 0) {
+		if (n->m_len > off)
+			break;
+		off -= n->m_len;
+		n = n->m_next;
+	}
+	/* be sure to point non-empty mbuf */
+	while (n != NULL && n->m_len == 0)
+		n = n->m_next;
+	if (!n) {
+		m_freem(m);
+		return NULL;	/* mbuf chain too short */
+	}
+
+	/*
+	 * The following comment is dated but still partially applies:
+	 *
+	 * XXX: This code is flawed because it considers a "writable" mbuf
+	 *      data region to require all of the following:
+	 *	  (i) mbuf _has_ to have M_EXT set; if it is just a regular
+	 *	      mbuf, it is still not considered "writable."
+	 *	  (ii) since mbuf has M_EXT, the ext_type _has_ to be
+	 *	       EXT_CLUSTER. Anything else makes it non-writable.
+	 *	  (iii) M_WRITABLE() must evaluate true.
+	 *      Ideally, the requirement should only be (iii).
+	 *
+	 * If we're writable, we're sure we're writable, because the ref. count
+	 * cannot increase from 1, as that would require possession of mbuf
+	 * n by someone else (which is impossible). However, if we're _not_
+	 * writable, we may eventually become writable )if the ref. count drops
+	 * to 1), but we'll fail to notice it unless we re-evaluate
+	 * M_WRITABLE(). For now, we only evaluate once at the beginning and
+	 * live with this.
+	 */
+	writable = 0;
+	if ((n->m_flags & M_EXT) == 0 ||
+	    (n->m_ext.ext_type == EXT_CLUSTER && M_WRITABLE(n)))
+		writable = 1;
+
+	/*
+	 * the target data is on <n, off>.
+	 * if we got enough data on the mbuf "n", we're done.
+	 */
+	if ((off == 0 || offp) && len <= n->m_len - off)
+		goto ok;
+
+	/*
+	 * when len <= n->m_len - off and off != 0, it is a special case.
+	 * len bytes from <n, off> sits in single mbuf, but the caller does
+	 * not like the starting position (off).
+	 * chop the current mbuf into two pieces, set off to 0.
+	 */
+	if (len <= n->m_len - off) {
+		o = m_dup1(n, off, n->m_len - off, M_NOWAIT);
+		if (o == NULL) {
+			m_freem(m);
+			return NULL;	/* ENOBUFS */
+		}
+		n->m_len = off;
+		o->m_next = n->m_next;
+		n->m_next = o;
+		n = n->m_next;
+		off = 0;
+		goto ok;
+	}
+
+	/*
+	 * we need to take hlen from <n, off> and tlen from <n->m_next, 0>,
+	 * and construct contiguous mbuf with m_len == len.
+	 * note that hlen + tlen == len, and tlen > 0.
+	 */
+	hlen = n->m_len - off;
+	tlen = len - hlen;
+
+	/*
+	 * ensure that we have enough trailing data on mbuf chain.
+	 * if not, we can do nothing about the chain.
+	 */
+	olen = 0;
+	for (o = n->m_next; o != NULL; o = o->m_next)
+		olen += o->m_len;
+	if (hlen + olen < len) {
+		m_freem(m);
+		return NULL;	/* mbuf chain too short */
+	}
+
+	/*
+	 * easy cases first.
+	 * we need to use m_copydata() to get data from <n->m_next, 0>.
+	 */
+	if ((off == 0 || offp) && M_TRAILINGSPACE(n) >= tlen
+	 && writable) {
+		m_copydata(n->m_next, 0, tlen, mtod(n, caddr_t) + n->m_len);
+		n->m_len += tlen;
+		m_adj(n->m_next, tlen);
+		goto ok;
+	}
+	if ((off == 0 || offp) && M_LEADINGSPACE(n->m_next) >= hlen
+	 && writable) {
+		n->m_next->m_data -= hlen;
+		n->m_next->m_len += hlen;
+		bcopy(mtod(n, caddr_t) + off, mtod(n->m_next, caddr_t), hlen);
+		n->m_len -= hlen;
+		n = n->m_next;
+		off = 0;
+		goto ok;
+	}
+
+	/*
+	 * now, we need to do the hard way.  don't m_copy as there's no room
+	 * on both end.
+	 */
+	if (len > MLEN)
+		o = m_getcl(M_NOWAIT, m->m_type, 0);
+	else
+		o = m_get(M_NOWAIT, m->m_type);
+	if (!o) {
+		m_freem(m);
+		return NULL;	/* ENOBUFS */
+	}
+	/* get hlen from <n, off> into <o, 0> */
+	o->m_len = hlen;
+	bcopy(mtod(n, caddr_t) + off, mtod(o, caddr_t), hlen);
+	n->m_len -= hlen;
+	/* get tlen from <n->m_next, 0> into <o, hlen> */
+	m_copydata(n->m_next, 0, tlen, mtod(o, caddr_t) + o->m_len);
+	o->m_len += tlen;
+	m_adj(n->m_next, tlen);
+	o->m_next = n->m_next;
+	n->m_next = o;
+	n = o;
+	off = 0;
+
+ok:
+#ifdef PULLDOWN_DEBUG
+    {
+	struct mbuf *t;
+	printf("after:");
+	for (t = m; t; t = t->m_next)
+		printf("%c%d", t == n ? '*' : ' ', t->m_len);
+	printf(" (off=%d)\n", off);
+    }
+#endif
+	if (offp)
+		*offp = off;
+	return n;
+}
+
+static struct mbuf *
+m_dup1(struct mbuf *m, int off, int len, int wait)
+{
+	struct mbuf *n;
+	int copyhdr;
+
+	if (len > MCLBYTES)
+		return NULL;
+	if (off == 0 && (m->m_flags & M_PKTHDR) != 0)
+		copyhdr = 1;
+	else
+		copyhdr = 0;
+	if (len >= MINCLSIZE) {
+		if (copyhdr == 1)
+			n = m_getcl(wait, m->m_type, M_PKTHDR);
+		else
+			n = m_getcl(wait, m->m_type, 0);
+	} else {
+		if (copyhdr == 1)
+			n = m_gethdr(wait, m->m_type);
+		else
+			n = m_get(wait, m->m_type);
+	}
+	if (!n)
+		return NULL; /* ENOBUFS */
+
+	if (copyhdr && !m_dup_pkthdr(n, m, wait)) {
+		m_free(n);
+		return NULL;
+	}
+	m_copydata(m, off, len, mtod(n, caddr_t));
+	n->m_len = len;
+	return n;
+}
+
+/* Free a packet tag. */
+void
+m_tag_free_default(struct m_tag *t)
+{
+#ifdef MAC
+	if (t->m_tag_id == PACKET_TAG_MACLABEL)
+		mac_mbuf_tag_destroy(t);
+#endif
+	free(t, M_PACKET_TAGS);
+}
+
+/* Get a packet tag structure along with specified data following. */
+struct m_tag *
+m_tag_alloc(uint32_t cookie, int type, int len, int wait)
+{
+	struct m_tag *t;
+
+	MBUF_CHECKSLEEP(wait);
+	if (len < 0)
+		return NULL;
+	t = malloc(len + sizeof(struct m_tag), M_PACKET_TAGS, wait);
+	if (t == NULL)
+		return NULL;
+	m_tag_setup(t, cookie, type, len);
+	t->m_tag_free = m_tag_free_default;
+	return t;
+}
+
+/* Unlink and free a packet tag. */
+void
+m_tag_delete(struct mbuf *m, struct m_tag *t)
+{
+
+	KASSERT(m && t, ("m_tag_delete: null argument, m %p t %p", m, t));
+	m_tag_unlink(m, t);
+	m_tag_free(t);
+}
+
+/* Unlink and free a packet tag chain, starting from given tag. */
+void
+m_tag_delete_chain(struct mbuf *m, struct m_tag *t)
+{
+	struct m_tag *p, *q;
+
+	KASSERT(m, ("m_tag_delete_chain: null mbuf"));
+	if (t != NULL)
+		p = t;
+	else
+		p = SLIST_FIRST(&m->m_pkthdr.tags);
+	if (p == NULL)
+		return;
+	while ((q = SLIST_NEXT(p, m_tag_link)) != NULL)
+		m_tag_delete(m, q);
+	m_tag_delete(m, p);
+}
+
+/*
+ * Strip off all tags that would normally vanish when
+ * passing through a network interface.  Only persistent
+ * tags will exist after this; these are expected to remain
+ * so long as the mbuf chain exists, regardless of the
+ * path the mbufs take.
+ */
+void
+m_tag_delete_nonpersistent(struct mbuf *m)
+{
+	struct m_tag *p, *q;
+
+	SLIST_FOREACH_SAFE(p, &m->m_pkthdr.tags, m_tag_link, q)
+		if ((p->m_tag_id & MTAG_PERSISTENT) == 0)
+			m_tag_delete(m, p);
+}
+
+/* Find a tag, starting from a given position. */
+struct m_tag *
+m_tag_locate(struct mbuf *m, uint32_t cookie, int type, struct m_tag *t)
+{
+	struct m_tag *p;
+
+	KASSERT(m, ("m_tag_locate: null mbuf"));
+	if (t == NULL)
+		p = SLIST_FIRST(&m->m_pkthdr.tags);
+	else
+		p = SLIST_NEXT(t, m_tag_link);
+	while (p != NULL) {
+		if (p->m_tag_cookie == cookie && p->m_tag_id == type)
+			return p;
+		p = SLIST_NEXT(p, m_tag_link);
+	}
+	return NULL;
+}
+
+/* Copy a single tag. */
+struct m_tag *
+m_tag_copy(struct m_tag *t, int how)
+{
+	struct m_tag *p;
+
+	MBUF_CHECKSLEEP(how);
+	KASSERT(t, ("m_tag_copy: null tag"));
+	p = m_tag_alloc(t->m_tag_cookie, t->m_tag_id, t->m_tag_len, how);
+	if (p == NULL)
+		return (NULL);
+#ifdef MAC
+	/*
+	 * XXXMAC: we should probably pass off the initialization, and
+	 * copying here?  can we hide that PACKET_TAG_MACLABEL is
+	 * special from the mbuf code?
+	 */
+	if (t->m_tag_id == PACKET_TAG_MACLABEL) {
+		if (mac_mbuf_tag_init(p, how) != 0) {
+			m_tag_free(p);
+			return (NULL);
+		}
+		mac_mbuf_tag_copy(t, p);
+	} else
+#endif
+		bcopy(t + 1, p + 1, t->m_tag_len); /* Copy the data */
+	return p;
+}
+
+/*
+ * Copy two tag chains. The destination mbuf (to) loses any attached
+ * tags even if the operation fails. This should not be a problem, as
+ * m_tag_copy_chain() is typically called with a newly-allocated
+ * destination mbuf.
+ */
+int
+m_tag_copy_chain(struct mbuf *to, const struct mbuf *from, int how)
+{
+	struct m_tag *p, *t, *tprev = NULL;
+
+	MBUF_CHECKSLEEP(how);
+	KASSERT(to && from,
+		("m_tag_copy_chain: null argument, to %p from %p", to, from));
+	m_tag_delete_chain(to, NULL);
+	SLIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
+		t = m_tag_copy(p, how);
+		if (t == NULL) {
+			m_tag_delete_chain(to, NULL);
+			return 0;
+		}
+		if (tprev == NULL)
+			SLIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
+		else
+			SLIST_INSERT_AFTER(tprev, t, m_tag_link);
+		tprev = t;
+	}
+	return 1;
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/glue.c b/src/add-ons/kernel/drivers/network/cadence_gem/glue.c
new file mode 100644
index 0000000000..77af2a6593
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/glue.c
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <sys/bus.h>
+
+
+HAIKU_FBSD_DRIVER_GLUE(cadence_cgem, cgem, simplebus);
+HAIKU_DRIVER_REQUIREMENTS(0);
+NO_HAIKU_FBSD_MII_DRIVER();
+NO_HAIKU_CHECK_DISABLE_INTERRUPTS();
+NO_HAIKU_REENABLE_INTERRUPTS();
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/if.c b/src/add-ons/kernel/drivers/network/cadence_gem/if.c
new file mode 100644
index 0000000000..28be2f6cf5
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/if.c
@@ -0,0 +1,1379 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007-2009, Axel Drfler, axeld@pinc-software.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ *
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include "device.h"
+
+#include <stdio.h>
+#include <net/if_types.h>
+#include <sys/sockio.h>
+
+#include <compat/sys/bus.h>
+#include <compat/sys/kernel.h>
+#include <compat/sys/taskqueue.h>
+
+#include <compat/net/bpf.h>
+#include <compat/net/ethernet.h>
+#include <compat/net/if.h>
+#include <compat/net/if_arp.h>
+#include <compat/net/if_media.h>
+#include <compat/net/if_var.h>
+#include <compat/net/if_vlan_var.h>
+#include <compat/sys/malloc.h>
+
+
+
+int ifqmaxlen = IFQ_MAXLEN;
+
+static void	if_input_default(struct ifnet *, struct mbuf *);
+static int	if_requestencap_default(struct ifnet *, struct if_encap_req *);
+
+
+
+#define IFNET_HOLD (void *)(uintptr_t)(-1)
+
+
+static void
+insert_into_device_name_list(struct ifnet * ifp)
+{
+	int i;
+	for (i = 0; i < MAX_DEVICES; i++) {
+		if (gDeviceNameList[i] == NULL) {
+			gDeviceNameList[i] = ifp->device_name;
+			return;
+		}
+	}
+
+	panic("too many devices");
+}
+
+
+static void
+remove_from_device_name_list(struct ifnet * ifp)
+{
+	int i;
+	for (i = 0; i < MAX_DEVICES; i++) {
+		if (ifp->device_name == gDeviceNameList[i]) {
+			int last;
+			for (last = i + 1; last < MAX_DEVICES; last++) {
+				if (gDeviceNameList[last] == NULL)
+					break;
+			}
+			last--;
+
+			if (i == last)
+				gDeviceNameList[i] = NULL;
+			else {
+				// switch positions with the last entry
+				gDeviceNameList[i] = gDeviceNameList[last];
+				gDeviceNameList[last] = NULL;
+			}
+			break;
+		}
+	}
+}
+
+
+struct ifnet *
+ifnet_byindex(u_short idx)
+{
+	struct ifnet *ifp;
+
+	IFNET_RLOCK_NOSLEEP();
+	ifp = ifnet_byindex_locked(idx);
+	IFNET_RUNLOCK_NOSLEEP();
+
+	return (ifp);
+}
+
+
+struct ifnet *
+ifnet_byindex_locked(u_short idx)
+{
+	struct ifnet *ifp;
+
+	ifp = gDevices[idx];
+
+	return (ifp);
+}
+
+
+static void
+ifnet_setbyindex_locked(u_short idx, struct ifnet *ifp)
+{
+	gDevices[idx] = ifp;
+}
+
+
+static void
+ifnet_setbyindex(u_short idx, struct ifnet *ifp)
+{
+	IFNET_WLOCK();
+	ifnet_setbyindex_locked(idx, ifp);
+	IFNET_WUNLOCK();
+}
+
+
+static int
+ifindex_alloc_locked(u_short *idxp)
+{
+	u_short index;
+
+	for (index = 0; index < MAX_DEVICES; index++) {
+		if (gDevices[index] == NULL) {
+			break;
+		}
+	}
+
+	if (index == MAX_DEVICES)
+		return ENOSPC;
+
+	gDeviceCount++;
+	*idxp = index;
+
+	return ENOERR;
+}
+
+
+static void
+ifindex_free_locked(u_short idx)
+{
+	gDevices[idx] = NULL;
+	gDeviceCount--;
+}
+
+
+struct ifnet *
+if_alloc(u_char type)
+{
+	char semName[64];
+	u_short index;
+
+	struct ifnet *ifp = _kernel_malloc(sizeof(struct ifnet), M_ZERO);
+	if (ifp == NULL)
+		return NULL;
+
+	snprintf(semName, sizeof(semName), "%s receive", gDriverName);
+
+	ifp->receive_sem = create_sem(0, semName);
+	if (ifp->receive_sem < B_OK)
+		goto err1;
+
+	switch (type) {
+		case IFT_ETHER:
+		{
+			ifp->if_l2com = _kernel_malloc(sizeof(struct arpcom), M_ZERO);
+			if (ifp->if_l2com == NULL)
+				goto err2;
+			IFP2AC(ifp)->ac_ifp = ifp;
+			break;
+		}
+	}
+
+	ifp->link_state_sem = -1;
+	ifp->open_count = 0;
+	ifp->flags = 0;
+	ifp->if_type = type;
+	ifq_init(&ifp->receive_queue, semName);
+
+	ifp->scan_done_sem = -1;
+		// WLAN specific, doesn't hurt when initilized for other devices
+
+	// Search for the first free device slot, and use that one
+	IFNET_WLOCK();
+	if (ifindex_alloc_locked(&index) != ENOERR) {
+		IFNET_WUNLOCK();
+		panic("too many devices");
+		goto err3;
+	}
+	ifnet_setbyindex_locked(index, IFNET_HOLD);
+	IFNET_WUNLOCK();
+
+	ifp->if_index = index;
+	ifnet_setbyindex(ifp->if_index, ifp);
+
+	IF_ADDR_LOCK_INIT(ifp);
+	return ifp;
+
+err3:
+	switch (type) {
+		case IFT_ETHER:
+			_kernel_free(ifp->if_l2com);
+			break;
+	}
+
+err2:
+	delete_sem(ifp->receive_sem);
+
+err1:
+	_kernel_free(ifp);
+	return NULL;
+}
+
+
+void
+if_free(struct ifnet *ifp)
+{
+	// IEEE80211 devices won't be in this list,
+	// so don't try to remove them.
+	if (ifp->if_type == IFT_ETHER)
+		remove_from_device_name_list(ifp);
+
+	IFNET_WLOCK();
+	ifindex_free_locked(ifp->if_index);
+	IFNET_WUNLOCK();
+
+	IF_ADDR_LOCK_DESTROY(ifp);
+	switch (ifp->if_type) {
+		case IFT_ETHER:
+			_kernel_free(ifp->if_l2com);
+			break;
+	}
+
+	delete_sem(ifp->receive_sem);
+	ifq_uninit(&ifp->receive_queue);
+
+	_kernel_free(ifp);
+}
+
+
+void
+if_initname(struct ifnet *ifp, const char *name, int unit)
+{
+	dprintf("if_initname(%p, %s, %d)\n", ifp, name, unit);
+
+	if (name == NULL || name[0] == '\0')
+		panic("interface goes unnamed");
+
+	ifp->if_dname = name;
+	ifp->if_dunit = unit;
+
+	strlcpy(ifp->if_xname, name, sizeof(ifp->if_xname));
+
+	snprintf(ifp->device_name, sizeof(ifp->device_name), "net/%s/%i",
+		gDriverName, ifp->if_index);
+
+	driver_printf("%s: /dev/%s\n", gDriverName, ifp->device_name);
+	insert_into_device_name_list(ifp);
+
+	ifp->root_device = find_root_device(unit);
+}
+
+
+void
+ifq_init(struct ifqueue *ifq, const char *name)
+{
+	ifq->ifq_head = NULL;
+	ifq->ifq_tail = NULL;
+	ifq->ifq_len = 0;
+	ifq->ifq_maxlen = IFQ_MAXLEN;
+	ifq->ifq_drops = 0;
+
+	mtx_init(&ifq->ifq_mtx, name, NULL, MTX_DEF);
+}
+
+
+void
+ifq_uninit(struct ifqueue *ifq)
+{
+	mtx_destroy(&ifq->ifq_mtx);
+}
+
+
+static int
+if_transmit(struct ifnet *ifp, struct mbuf *m)
+{
+	int error;
+
+	IFQ_HANDOFF(ifp, m, error);
+	return (error);
+}
+
+
+static void
+if_input_default(struct ifnet *ifp __unused, struct mbuf *m)
+{
+
+	m_freem(m);
+}
+
+
+/*
+ * Flush an interface queue.
+ */
+void
+if_qflush(struct ifnet *ifp)
+{
+	struct mbuf *m, *n;
+	struct ifaltq *ifq;
+
+	ifq = &ifp->if_snd;
+	IFQ_LOCK(ifq);
+#ifdef ALTQ
+	if (ALTQ_IS_ENABLED(ifq))
+		ALTQ_PURGE(ifq);
+#endif
+	n = ifq->ifq_head;
+	while ((m = n) != NULL) {
+		n = m->m_nextpkt;
+		m_freem(m);
+	}
+	ifq->ifq_head = 0;
+	ifq->ifq_tail = 0;
+	ifq->ifq_len = 0;
+	IFQ_UNLOCK(ifq);
+}
+
+
+void
+if_attach(struct ifnet *ifp)
+{
+	unsigned socksize, ifasize;
+	int namelen, masklen;
+	struct sockaddr_dl *sdl;
+	struct ifaddr *ifa;
+
+	TAILQ_INIT(&ifp->if_addrhead);
+	TAILQ_INIT(&ifp->if_prefixhead);
+	TAILQ_INIT(&ifp->if_multiaddrs);
+
+	IF_ADDR_LOCK_INIT(ifp);
+
+	ifp->if_lladdr.sdl_family = AF_LINK;
+
+	ifq_init((struct ifqueue *) &ifp->if_snd, ifp->if_xname);
+
+	if (ifp->if_transmit == NULL) {
+		ifp->if_transmit = if_transmit;
+		ifp->if_qflush = if_qflush;
+	}
+	if (ifp->if_input == NULL)
+		ifp->if_input = if_input_default;
+
+	if (ifp->if_requestencap == NULL)
+		ifp->if_requestencap = if_requestencap_default;
+
+	/*
+	 * Create a Link Level name for this device.
+	 */
+	namelen = strlen(ifp->if_xname);
+	/*
+	 * Always save enough space for any possiable name so we
+	 * can do a rename in place later.
+	 */
+	masklen = offsetof(struct sockaddr_dl, sdl_data[0]) + IFNAMSIZ;
+	socksize = masklen + ifp->if_addrlen;
+	if (socksize < sizeof(*sdl))
+		socksize = sizeof(*sdl);
+	socksize = roundup2(socksize, sizeof(long));
+	ifasize = sizeof(*ifa) + 2 * socksize;
+	ifa = ifa_alloc(ifasize, M_WAITOK);
+	sdl = (struct sockaddr_dl *)(ifa + 1);
+	sdl->sdl_len = socksize;
+	sdl->sdl_family = AF_LINK;
+	bcopy(ifp->if_xname, sdl->sdl_data, namelen);
+	sdl->sdl_nlen = namelen;
+	sdl->sdl_index = ifp->if_index;
+	sdl->sdl_type = ifp->if_type;
+	ifp->if_addr = ifa;
+	ifa->ifa_ifp = ifp;
+	//ifa->ifa_rtrequest = link_rtrequest;
+	ifa->ifa_addr = (struct sockaddr *)sdl;
+	sdl = (struct sockaddr_dl *)(socksize + (caddr_t)sdl);
+	ifa->ifa_netmask = (struct sockaddr *)sdl;
+	sdl->sdl_len = masklen;
+	while (namelen != 0)
+		sdl->sdl_data[--namelen] = 0xff;
+	dprintf("if_attach %p\n", ifa->ifa_addr);
+}
+
+
+void
+if_detach(struct ifnet *ifp)
+{
+	if (HAIKU_DRIVER_REQUIRES(FBSD_SWI_TASKQUEUE))
+		taskqueue_drain(taskqueue_swi, &ifp->if_linktask);
+
+	IF_ADDR_LOCK_DESTROY(ifp);
+	ifq_uninit((struct ifqueue *) &ifp->if_snd);
+}
+
+
+void
+if_start(struct ifnet *ifp)
+{
+#ifdef IFF_NEEDSGIANT
+	if (ifp->if_flags & IFF_NEEDSGIANT)
+	panic("freebsd compat.: unsupported giant requirement");
+#endif
+	ifp->if_start(ifp);
+}
+
+
+int
+if_printf(struct ifnet *ifp, const char *format, ...)
+{
+	char buf[256];
+	va_list vl;
+	va_start(vl, format);
+	vsnprintf(buf, sizeof(buf), format, vl);
+	va_end(vl);
+
+	dprintf("[%s] %s", ifp->device_name, buf);
+	return 0;
+}
+
+
+/*
+ * Compat function for handling basic encapsulation requests.
+ * Not converted stacks (FDDI, IB, ..) supports traditional
+ * output model: ARP (and other similar L2 protocols) are handled
+ * inside output routine, arpresolve/nd6_resolve() returns MAC
+ * address instead of full prepend.
+ *
+ * This function creates calculated header==MAC for IPv4/IPv6 and
+ * returns EAFNOSUPPORT (which is then handled in ARP code) for other
+ * address families.
+ */
+static int
+if_requestencap_default(struct ifnet *ifp, struct if_encap_req *req)
+{
+
+	if (req->rtype != IFENCAP_LL)
+		return (EOPNOTSUPP);
+
+	if (req->bufsize < req->lladdr_len)
+		return (ENOMEM);
+
+	switch (req->family) {
+	case AF_INET:
+	case AF_INET6:
+		break;
+	default:
+		return (EAFNOSUPPORT);
+	}
+
+	/* Copy lladdr to storage as is */
+	memmove(req->buf, req->lladdr, req->lladdr_len);
+	req->bufsize = req->lladdr_len;
+	req->lladdr_off = 0;
+
+	return (0);
+}
+
+
+void
+if_link_state_change(struct ifnet *ifp, int linkState)
+{
+	if (ifp->if_link_state == linkState)
+		return;
+
+	ifp->if_link_state = linkState;
+	release_sem_etc(ifp->link_state_sem, 1, B_DO_NOT_RESCHEDULE);
+}
+
+static struct ifmultiaddr *
+if_findmulti(struct ifnet *ifp, struct sockaddr *_address)
+{
+	struct sockaddr_dl *address = (struct sockaddr_dl *) _address;
+	struct ifmultiaddr *ifma;
+
+	TAILQ_FOREACH (ifma, &ifp->if_multiaddrs, ifma_link) {
+		if (memcmp(LLADDR(address),
+			LLADDR((struct sockaddr_dl *)ifma->ifma_addr), ETHER_ADDR_LEN) == 0)
+			return ifma;
+	}
+
+	return NULL;
+}
+
+
+/*
+ * if_freemulti: free ifmultiaddr structure and possibly attached related
+ * addresses.  The caller is responsible for implementing reference
+ * counting, notifying the driver, handling routing messages, and releasing
+ * any dependent link layer state.
+ */
+static void
+if_freemulti(struct ifmultiaddr *ifma)
+{
+
+	KASSERT(ifma->ifma_refcount == 0, ("if_freemulti: refcount %d",
+	    ifma->ifma_refcount));
+	KASSERT(ifma->ifma_protospec == NULL,
+	    ("if_freemulti: protospec not NULL"));
+
+	if (ifma->ifma_lladdr != NULL)
+		free(ifma->ifma_lladdr);
+
+	// Haiku note: We use a field in the ifmultiaddr struct (ifma_addr_storage)
+	// to store the address and let ifma_addr point to that. We therefore do not
+	// free it here, as it will be freed as part of freeing the if_multiaddr.
+	//free(ifma->ifma_addr);
+
+	free(ifma);
+}
+
+
+static struct ifmultiaddr *
+_if_addmulti(struct ifnet *ifp, struct sockaddr *address)
+{
+	struct ifmultiaddr *addr = if_findmulti(ifp, address);
+
+	if (addr != NULL) {
+		addr->ifma_refcount++;
+		return addr;
+	}
+
+	addr = (struct ifmultiaddr *) malloc(sizeof(struct ifmultiaddr));
+	if (addr == NULL)
+		return NULL;
+
+	addr->ifma_lladdr = NULL;
+	addr->ifma_ifp = ifp;
+	addr->ifma_protospec = NULL;
+
+	memcpy(&addr->ifma_addr_storage, address, sizeof(struct sockaddr_dl));
+	addr->ifma_addr = (struct sockaddr *) &addr->ifma_addr_storage;
+
+	addr->ifma_refcount = 1;
+
+	TAILQ_INSERT_HEAD(&ifp->if_multiaddrs, addr, ifma_link);
+
+	return addr;
+}
+
+
+int
+if_addmulti(struct ifnet *ifp, struct sockaddr *address,
+	struct ifmultiaddr **out)
+{
+	struct ifmultiaddr *result;
+	int refcount = 0;
+
+	IF_ADDR_LOCK(ifp);
+	result = _if_addmulti(ifp, address);
+	if (result)
+		refcount = result->ifma_refcount;
+	IF_ADDR_UNLOCK(ifp);
+
+	if (result == NULL)
+		return ENOBUFS;
+
+	if (refcount == 1 && ifp->if_ioctl != NULL)
+		ifp->if_ioctl(ifp, SIOCADDMULTI, NULL);
+
+	if (out)
+		(*out) = result;
+
+	return 0;
+}
+
+
+static int
+if_delmulti_locked(struct ifnet *ifp, struct ifmultiaddr *ifma, int detaching)
+{
+	struct ifmultiaddr *ll_ifma;
+
+	if (ifp != NULL && ifma->ifma_ifp != NULL) {
+		KASSERT(ifma->ifma_ifp == ifp,
+		    ("%s: inconsistent ifp %p", __func__, ifp));
+		IF_ADDR_LOCK_ASSERT(ifp);
+	}
+
+	ifp = ifma->ifma_ifp;
+
+	/*
+	 * If the ifnet is detaching, null out references to ifnet,
+	 * so that upper protocol layers will notice, and not attempt
+	 * to obtain locks for an ifnet which no longer exists. The
+	 * routing socket announcement must happen before the ifnet
+	 * instance is detached from the system.
+	 */
+	if (detaching) {
+#ifdef DIAGNOSTIC
+		printf("%s: detaching ifnet instance %p\n", __func__, ifp);
+#endif
+		/*
+		 * ifp may already be nulled out if we are being reentered
+		 * to delete the ll_ifma.
+		 */
+		if (ifp != NULL) {
+#ifndef __HAIKU__
+			rt_newmaddrmsg(RTM_DELMADDR, ifma);
+#endif
+			ifma->ifma_ifp = NULL;
+		}
+	}
+
+	if (--ifma->ifma_refcount > 0)
+		return 0;
+
+#ifndef __HAIKU__
+	/*
+	 * If this ifma is a network-layer ifma, a link-layer ifma may
+	 * have been associated with it. Release it first if so.
+	 */
+	ll_ifma = ifma->ifma_llifma;
+	if (ll_ifma != NULL) {
+		KASSERT(ifma->ifma_lladdr != NULL,
+		    ("%s: llifma w/o lladdr", __func__));
+		if (detaching)
+			ll_ifma->ifma_ifp = NULL;	/* XXX */
+		if (--ll_ifma->ifma_refcount == 0) {
+			if (ifp != NULL) {
+				TAILQ_REMOVE(&ifp->if_multiaddrs, ll_ifma,
+				    ifma_link);
+			}
+			if_freemulti(ll_ifma);
+		}
+	}
+#endif
+
+	if (ifp != NULL)
+		TAILQ_REMOVE(&ifp->if_multiaddrs, ifma, ifma_link);
+
+	if_freemulti(ifma);
+
+	/*
+	 * The last reference to this instance of struct ifmultiaddr
+	 * was released; the hardware should be notified of this change.
+	 */
+	return 1;
+}
+
+
+/*
+ * Delete all multicast group membership for an interface.
+ * Should be used to quickly flush all multicast filters.
+ */
+void
+if_delallmulti(struct ifnet *ifp)
+{
+	struct ifmultiaddr *ifma;
+	struct ifmultiaddr *next;
+
+	IF_ADDR_LOCK(ifp);
+	TAILQ_FOREACH_SAFE(ifma, &ifp->if_multiaddrs, ifma_link, next)
+		if_delmulti_locked(ifp, ifma, 0);
+	IF_ADDR_UNLOCK(ifp);
+}
+
+
+static void
+if_delete_multiaddr(struct ifnet *ifp, struct ifmultiaddr *ifma)
+{
+	TAILQ_REMOVE(&ifp->if_multiaddrs, ifma, ifma_link);
+	free(ifma);
+}
+
+
+int
+if_delmulti(struct ifnet *ifp, struct sockaddr *sa)
+{
+	struct ifmultiaddr *ifma;
+	int lastref;
+#if 0 /* def INVARIANTS */
+	struct ifnet *oifp;
+
+	IFNET_RLOCK_NOSLEEP();
+	TAILQ_FOREACH(oifp, &V_ifnet, if_link)
+		if (ifp == oifp)
+			break;
+	if (ifp != oifp)
+		ifp = NULL;
+	IFNET_RUNLOCK_NOSLEEP();
+
+	KASSERT(ifp != NULL, ("%s: ifnet went away", __func__));
+#endif
+	if (ifp == NULL)
+		return (ENOENT);
+
+	IF_ADDR_LOCK(ifp);
+	lastref = 0;
+	ifma = if_findmulti(ifp, sa);
+	if (ifma != NULL)
+		lastref = if_delmulti_locked(ifp, ifma, 0);
+	IF_ADDR_UNLOCK(ifp);
+
+	if (ifma == NULL)
+		return (ENOENT);
+
+	if (lastref && ifp->if_ioctl != NULL) {
+		(void)(*ifp->if_ioctl)(ifp, SIOCDELMULTI, 0);
+	}
+
+	return (0);
+}
+
+
+void
+if_purgemaddrs(struct ifnet *ifp)
+{
+	struct ifmultiaddr *ifma;
+	struct ifmultiaddr *next;
+
+	IF_ADDR_LOCK(ifp);
+	TAILQ_FOREACH_SAFE(ifma, &ifp->if_multiaddrs, ifma_link, next)
+		if_delmulti_locked(ifp, ifma, 1);
+	IF_ADDR_UNLOCK(ifp);
+}
+
+/*
+ * Return counter values from counter(9)s stored in ifnet.
+ */
+uint64_t
+if_get_counter_default(struct ifnet *ifp, ift_counter cnt)
+{
+
+	KASSERT(cnt < IFCOUNTERS, ("%s: invalid cnt %d", __func__, cnt));
+
+	switch (cnt) {
+		case IFCOUNTER_IPACKETS:
+			return atomic_get64((int64 *)&ifp->if_ipackets);
+		case IFCOUNTER_IERRORS:
+			return atomic_get64((int64 *)&ifp->if_ierrors);
+		case IFCOUNTER_OPACKETS:
+			return atomic_get64((int64 *)&ifp->if_opackets);
+		case IFCOUNTER_OERRORS:
+			return atomic_get64((int64 *)&ifp->if_oerrors);
+		case IFCOUNTER_COLLISIONS:
+			return atomic_get64((int64 *)&ifp->if_collisions);
+		case IFCOUNTER_IBYTES:
+			return atomic_get64((int64 *)&ifp->if_ibytes);
+		case IFCOUNTER_OBYTES:
+			return atomic_get64((int64 *)&ifp->if_obytes);
+		case IFCOUNTER_IMCASTS:
+			return atomic_get64((int64 *)&ifp->if_imcasts);
+		case IFCOUNTER_OMCASTS:
+			return atomic_get64((int64 *)&ifp->if_omcasts);
+		case IFCOUNTER_IQDROPS:
+			return atomic_get64((int64 *)&ifp->if_iqdrops);
+		case IFCOUNTER_OQDROPS:
+			return atomic_get64((int64 *)&ifp->if_oqdrops);
+		case IFCOUNTER_NOPROTO:
+			return atomic_get64((int64 *)&ifp->if_noproto);
+		case IFCOUNTERS:
+			KASSERT(cnt < IFCOUNTERS, ("%s: invalid cnt %d", __func__, cnt));
+	}
+	return 0;
+}
+
+void
+if_addr_rlock(struct ifnet *ifp)
+{
+	IF_ADDR_LOCK(ifp);
+}
+
+
+void
+if_addr_runlock(struct ifnet *ifp)
+{
+	IF_ADDR_UNLOCK(ifp);
+}
+
+
+void
+if_maddr_rlock(struct ifnet *ifp)
+{
+	IF_ADDR_LOCK(ifp);
+}
+
+
+void
+if_maddr_runlock(struct ifnet *ifp)
+{
+	IF_ADDR_UNLOCK(ifp);
+}
+
+
+int
+ether_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
+	struct route *ro)
+{
+	int error = 0;
+	IFQ_HANDOFF(ifp, m, error);
+	return error;
+}
+
+
+static void ether_input(struct ifnet *ifp, struct mbuf *m)
+{
+	IF_ENQUEUE(&ifp->receive_queue, m);
+	release_sem_etc(ifp->receive_sem, 1, B_DO_NOT_RESCHEDULE);
+}
+
+
+void
+ether_ifattach(struct ifnet *ifp, const uint8_t *lla)
+{
+	struct ifaddr *ifa;
+	struct sockaddr_dl *sdl;
+
+	ifp->if_addrlen = ETHER_ADDR_LEN;
+	ifp->if_hdrlen = ETHER_HDR_LEN;
+	if_attach(ifp);
+	ifp->if_mtu = ETHERMTU;
+	ifp->if_output = ether_output;
+	ifp->if_input = ether_input;
+	ifp->if_resolvemulti = NULL; // done in the stack
+	ifp->if_get_counter = NULL;
+	ifp->if_broadcastaddr = etherbroadcastaddr;
+
+	ifa = ifp->if_addr;
+	sdl = (struct sockaddr_dl *)ifa->ifa_addr;
+	sdl->sdl_type = IFT_ETHER;
+	sdl->sdl_alen = ifp->if_addrlen;
+	bcopy(lla, LLADDR(sdl), ifp->if_addrlen);
+}
+
+
+void
+ether_ifdetach(struct ifnet *ifp)
+{
+	if_detach(ifp);
+}
+
+
+int
+ether_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
+{
+	struct ifreq *ifr = (struct ifreq *) data;
+
+	switch (command) {
+		case SIOCSIFMTU:
+			if (ifr->ifr_mtu > ETHERMTU)
+				return EINVAL;
+			else
+				;
+			// need to fix our ifreq to work with C...
+			// ifp->ifr_mtu = ifr->ifr_mtu;
+			break;
+
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Initialization, destruction and refcounting functions for ifaddrs.
+ */
+struct ifaddr *
+ifa_alloc(size_t size, int flags)
+{
+	struct ifaddr *ifa;
+
+	KASSERT(size >= sizeof(struct ifaddr),
+	    ("%s: invalid size %zu", __func__, size));
+
+	ifa = _kernel_malloc(size, M_ZERO | flags);
+	if (ifa == NULL)
+		return (NULL);
+
+	//refcount_init(&ifa->ifa_refcnt, 1);
+
+	return (ifa);
+
+fail:
+	/* free(NULL) is okay */
+	free(ifa);
+
+	return (NULL);
+}
+
+void
+ifa_ref(struct ifaddr *ifa)
+{
+	//refcount_acquire(&ifa->ifa_refcnt);
+}
+
+void
+ifa_free(struct ifaddr *ifa)
+{
+
+	//if (refcount_release(&ifa->ifa_refcnt)) {
+	//	free(ifa);
+	//}
+}
+
+void
+if_inc_counter(struct ifnet *ifp, ift_counter cnt, int64_t inc)
+{
+	switch (cnt) {
+		case IFCOUNTER_IPACKETS:
+			atomic_add64((int64 *)&ifp->if_ipackets, inc);
+			break;
+		case IFCOUNTER_IERRORS:
+			atomic_add64((int64 *)&ifp->if_ierrors, inc);
+			break;
+		case IFCOUNTER_OPACKETS:
+			atomic_add64((int64 *)&ifp->if_opackets, inc);
+			break;
+		case IFCOUNTER_OERRORS:
+			atomic_add64((int64 *)&ifp->if_oerrors, inc);
+			break;
+		case IFCOUNTER_COLLISIONS:
+			atomic_add64((int64 *)&ifp->if_collisions, inc);
+			break;
+		case IFCOUNTER_IBYTES:
+			atomic_add64((int64 *)&ifp->if_ibytes, inc);
+			break;
+		case IFCOUNTER_OBYTES:
+			atomic_add64((int64 *)&ifp->if_obytes, inc);
+			break;
+		case IFCOUNTER_IMCASTS:
+			atomic_add64((int64 *)&ifp->if_imcasts, inc);
+			break;
+		case IFCOUNTER_OMCASTS:
+			atomic_add64((int64 *)&ifp->if_omcasts, inc);
+			break;
+		case IFCOUNTER_IQDROPS:
+			atomic_add64((int64 *)&ifp->if_iqdrops, inc);
+			break;
+		case IFCOUNTER_OQDROPS:
+			atomic_add64((int64 *)&ifp->if_oqdrops, inc);
+			break;
+		case IFCOUNTER_NOPROTO:
+			atomic_add64((int64 *)&ifp->if_noproto, inc);
+			break;
+		case IFCOUNTERS:
+			KASSERT(cnt < IFCOUNTERS, ("%s: invalid cnt %d", __func__, cnt));
+	}
+}
+
+
+/* API for driver access to network stack owned ifnet.*/
+uint64_t
+if_setbaudrate(struct ifnet *ifp, uint64_t baudrate)
+{
+	uint64_t oldbrate;
+
+	oldbrate = ifp->if_baudrate;
+	ifp->if_baudrate = baudrate;
+	return (oldbrate);
+}
+
+uint64_t
+if_getbaudrate(if_t ifp)
+{
+
+	return (((struct ifnet *)ifp)->if_baudrate);
+}
+
+int
+if_setcapabilities(if_t ifp, int capabilities)
+{
+	((struct ifnet *)ifp)->if_capabilities = capabilities;
+	return (0);
+}
+
+int
+if_setcapabilitiesbit(if_t ifp, int setbit, int clearbit)
+{
+	((struct ifnet *)ifp)->if_capabilities |= setbit;
+	((struct ifnet *)ifp)->if_capabilities &= ~clearbit;
+
+	return (0);
+}
+
+int
+if_getcapabilities(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_capabilities;
+}
+
+int
+if_setcapenable(if_t ifp, int capabilities)
+{
+	((struct ifnet *)ifp)->if_capenable = capabilities;
+	return (0);
+}
+
+int
+if_setcapenablebit(if_t ifp, int setcap, int clearcap)
+{
+	if(setcap)
+		((struct ifnet *)ifp)->if_capenable |= setcap;
+	if(clearcap)
+		((struct ifnet *)ifp)->if_capenable &= ~clearcap;
+
+	return (0);
+}
+
+const char *
+if_getdname(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_dname;
+}
+
+int
+if_togglecapenable(if_t ifp, int togglecap)
+{
+	((struct ifnet *)ifp)->if_capenable ^= togglecap;
+	return (0);
+}
+
+int
+if_getcapenable(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_capenable;
+}
+
+/*
+ * This is largely undesirable because it ties ifnet to a device, but does
+ * provide flexiblity for an embedded product vendor. Should be used with
+ * the understanding that it violates the interface boundaries, and should be
+ * a last resort only.
+ */
+int
+if_setdev(if_t ifp, void *dev)
+{
+	return (0);
+}
+
+int
+if_setdrvflagbits(if_t ifp, int set_flags, int clear_flags)
+{
+	((struct ifnet *)ifp)->if_drv_flags |= set_flags;
+	((struct ifnet *)ifp)->if_drv_flags &= ~clear_flags;
+
+	return (0);
+}
+
+int
+if_getdrvflags(if_t ifp)
+{
+	if ((struct ifnet *)ifp == NULL)
+		return 0;
+	return ((struct ifnet *)ifp)->if_drv_flags;
+}
+
+int
+if_setdrvflags(if_t ifp, int flags)
+{
+	((struct ifnet *)ifp)->if_drv_flags = flags;
+	return (0);
+}
+
+
+int
+if_setflags(if_t ifp, int flags)
+{
+	((struct ifnet *)ifp)->if_flags = flags;
+	return (0);
+}
+
+int
+if_setflagbits(if_t ifp, int set, int clear)
+{
+	((struct ifnet *)ifp)->if_flags |= set;
+	((struct ifnet *)ifp)->if_flags &= ~clear;
+
+	return (0);
+}
+
+int
+if_getflags(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_flags;
+}
+
+int
+if_clearhwassist(if_t ifp)
+{
+	((struct ifnet *)ifp)->if_hwassist = 0;
+	return (0);
+}
+
+int
+if_sethwassistbits(if_t ifp, int toset, int toclear)
+{
+	((struct ifnet *)ifp)->if_hwassist |= toset;
+	((struct ifnet *)ifp)->if_hwassist &= ~toclear;
+
+	return (0);
+}
+
+int
+if_sethwassist(if_t ifp, int hwassist_bit)
+{
+	((struct ifnet *)ifp)->if_hwassist = hwassist_bit;
+	return (0);
+}
+
+int
+if_gethwassist(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_hwassist;
+}
+
+int
+if_setmtu(if_t ifp, int mtu)
+{
+	((struct ifnet *)ifp)->if_mtu = mtu;
+	return (0);
+}
+
+int
+if_getmtu(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_mtu;
+}
+
+int
+if_setsoftc(if_t ifp, void *softc)
+{
+	((struct ifnet *)ifp)->if_softc = softc;
+	return (0);
+}
+
+void *
+if_getsoftc(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_softc;
+}
+
+void
+if_setrcvif(struct mbuf *m, if_t ifp)
+{
+	m->m_pkthdr.rcvif = (struct ifnet *)ifp;
+}
+
+void
+if_setvtag(struct mbuf *m, uint16_t tag)
+{
+	m->m_pkthdr.ether_vtag = tag;
+}
+
+uint16_t
+if_getvtag(struct mbuf *m)
+{
+
+	return (m->m_pkthdr.ether_vtag);
+}
+
+int
+if_sendq_empty(if_t ifp)
+{
+	return IFQ_DRV_IS_EMPTY(&((struct ifnet *)ifp)->if_snd);
+}
+
+int
+if_getamcount(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_amcount;
+}
+
+
+int
+if_setsendqready(if_t ifp)
+{
+	IFQ_SET_READY(&((struct ifnet *)ifp)->if_snd);
+	return (0);
+}
+
+int
+if_setsendqlen(if_t ifp, int tx_desc_count)
+{
+	IFQ_SET_MAXLEN(&((struct ifnet *)ifp)->if_snd, tx_desc_count);
+	((struct ifnet *)ifp)->if_snd.ifq_drv_maxlen = tx_desc_count;
+
+	return (0);
+}
+
+int
+if_vlantrunkinuse(if_t ifp)
+{
+	return ((struct ifnet *)ifp)->if_vlantrunk != NULL?1:0;
+}
+
+int
+if_input(if_t ifp, struct mbuf* sendmp)
+{
+	(*((struct ifnet *)ifp)->if_input)((struct ifnet *)ifp, sendmp);
+	return (0);
+
+}
+
+/* XXX */
+#ifndef ETH_ADDR_LEN
+#define ETH_ADDR_LEN 6
+#endif
+
+int
+if_setupmultiaddr(if_t ifp, void *mta, int *cnt, int max)
+{
+	struct ifmultiaddr *ifma;
+	uint8_t *lmta = (uint8_t *)mta;
+	int mcnt = 0;
+
+	TAILQ_FOREACH(ifma, &((struct ifnet *)ifp)->if_multiaddrs, ifma_link) {
+		if (ifma->ifma_addr->sa_family != AF_LINK)
+			continue;
+
+		if (mcnt == max)
+			break;
+
+		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
+		    &lmta[mcnt * ETH_ADDR_LEN], ETH_ADDR_LEN);
+		mcnt++;
+	}
+	*cnt = mcnt;
+
+	return (0);
+}
+
+int
+if_multiaddr_array(if_t ifp, void *mta, int *cnt, int max)
+{
+	int error;
+
+	if_maddr_rlock(ifp);
+	error = if_setupmultiaddr(ifp, mta, cnt, max);
+	if_maddr_runlock(ifp);
+	return (error);
+}
+
+int
+if_multiaddr_count(if_t ifp, int max)
+{
+	struct ifmultiaddr *ifma;
+	int count;
+
+	count = 0;
+	if_maddr_rlock(ifp);
+	TAILQ_FOREACH(ifma, &((struct ifnet *)ifp)->if_multiaddrs, ifma_link) {
+		if (ifma->ifma_addr->sa_family != AF_LINK)
+			continue;
+		count++;
+		if (count == max)
+			break;
+	}
+	if_maddr_runlock(ifp);
+	return (count);
+}
+
+struct mbuf *
+if_dequeue(if_t ifp)
+{
+	struct mbuf *m;
+	IFQ_DRV_DEQUEUE(&((struct ifnet *)ifp)->if_snd, m);
+
+	return (m);
+}
+
+int
+if_sendq_prepend(if_t ifp, struct mbuf *m)
+{
+	IFQ_DRV_PREPEND(&((struct ifnet *)ifp)->if_snd, m);
+	return (0);
+}
+
+int
+if_setifheaderlen(if_t ifp, int len)
+{
+	((struct ifnet *)ifp)->if_hdrlen = len;
+	return (0);
+}
+
+caddr_t
+if_getlladdr(if_t ifp)
+{
+	return (IF_LLADDR((struct ifnet *)ifp));
+}
+
+void *
+if_gethandle(u_char type)
+{
+	return (if_alloc(type));
+}
+
+void
+if_bpfmtap(if_t ifh, struct mbuf *m)
+{
+	struct ifnet *ifp = (struct ifnet *)ifh;
+
+	BPF_MTAP(ifp, m);
+}
+
+void
+if_etherbpfmtap(if_t ifh, struct mbuf *m)
+{
+	struct ifnet *ifp = (struct ifnet *)ifh;
+
+	ETHER_BPF_MTAP(ifp, m);
+}
+
+void
+if_vlancap(if_t ifh)
+{
+	struct ifnet *ifp = (struct ifnet *)ifh;
+	VLAN_CAPABILITIES(ifp);
+}
+
+void
+if_setinitfn(if_t ifp, void (*init_fn)(void *))
+{
+	((struct ifnet *)ifp)->if_init = init_fn;
+}
+
+void
+if_setioctlfn(if_t ifp, int (*ioctl_fn)(if_t, u_long, caddr_t))
+{
+	((struct ifnet *)ifp)->if_ioctl = (void *)ioctl_fn;
+}
+
+void
+if_setstartfn(if_t ifp, void (*start_fn)(if_t))
+{
+	((struct ifnet *)ifp)->if_start = (void *)start_fn;
+}
+
+void
+if_settransmitfn(if_t ifp, if_transmit_fn_t start_fn)
+{
+	((struct ifnet *)ifp)->if_transmit = start_fn;
+}
+
+void if_setqflushfn(if_t ifp, if_qflush_fn_t flush_fn)
+{
+	((struct ifnet *)ifp)->if_qflush = flush_fn;
+}
+
+void
+if_setgetcounterfn(if_t ifp, if_get_counter_t fn)
+{
+
+	ifp->if_get_counter = fn;
+}
+
+
+u_int
+if_foreach_llmaddr(if_t ifp, iflladdr_cb_t cb, void *cb_arg)
+{
+        struct ifmultiaddr *ifma;
+        u_int count;
+
+        MPASS(cb);
+ 
+        count = 0;
+        IF_ADDR_LOCK(ifp);
+        TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
+                if (ifma->ifma_addr->sa_family != AF_LINK)
+                        continue;
+                count += (*cb)(cb_arg, (struct sockaddr_dl *)ifma->ifma_addr,
+                    count);
+        }
+        IF_ADDR_UNLOCK(ifp);
+
+        return (count);
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/kobj.c b/src/add-ons/kernel/drivers/network/cadence_gem/kobj.c
new file mode 100644
index 0000000000..448628a7c3
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/kobj.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2018-2019, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/kobj.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+
+
+static kobj_method_t kobj_default_method = {
+	"kobj_default_method", 0, (kobjop_t)kobj_error_method
+};
+
+
+void
+kobj_init(kobj_t obj, kobj_class_t cls)
+{
+	obj->ops.cls = cls;
+}
+
+
+kobj_method_t*
+kobj_lookup_method(kobj_class_t class, kobj_method_t** cep,
+	kobjop_desc_t desc)
+{
+	int32 i, id;
+	kobj_method_t* ret = NULL;
+
+	id = desc->id;
+	if (id == 0)
+		id = desc->deflt.id;
+
+	for (i = 0; class->methods[i].name != NULL; i++) {
+		kobj_method_t* mth = &class->methods[i];
+		if (mth->id != id)
+			continue;
+
+		ret = mth;
+		break;
+	}
+	if (ret == NULL || ret->method == NULL)
+		ret = &desc->deflt;
+	if (ret == NULL || ret->method == NULL)
+		ret = &kobj_default_method;
+
+	if (cep != NULL)
+		*cep = ret;
+	return ret;
+}
+
+
+int
+kobj_error_method(void)
+{
+	return ENXIO;
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/libkern.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/libkern.cpp
new file mode 100644
index 0000000000..adeb122a05
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/libkern.cpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de. All rights reserved.
+ * Copyright 2018, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+extern "C" {
+#include <compat/sys/libkern.h>
+}
+
+#include <util/Random.h>
+
+
+u_int
+read_random(void* buf, u_int len)
+{
+	uint8* bufs = (uint8*)buf;
+	for (int i = 0; i < len; i++)
+		bufs[i] = secure_get_random<uint8>();
+	return len;
+}
+
+
+void
+arc4rand(void *ptr, u_int len, int reseed)
+{
+	read_random(ptr, len);
+}
+
+
+uint32_t
+arc4random(void)
+{
+	uint32_t ret;
+
+	arc4rand(&ret, sizeof ret, 0);
+	return ret;
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/malloc.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/malloc.cpp
new file mode 100644
index 0000000000..a06c42c4da
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/malloc.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010, Ingo Weinhold, ingo_weinhold@gmx.de.
+ * Copyright 2019, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+extern "C" {
+#include <compat/sys/malloc.h>
+}
+
+#include <stdio.h>
+#include <string.h>
+
+#include <util/BitUtils.h>
+
+#include <kernel/heap.h>
+#include <kernel/vm/vm.h>
+
+
+void*
+_kernel_malloc(size_t size, int flags)
+{
+	// According to the FreeBSD kernel malloc man page the allocator is expected
+	// to return power of two aligned addresses for allocations up to one page
+	// size. While it also states that this shouldn't be relied upon, at least
+	// bus_dmamem_alloc expects it and drivers may depend on it as well.
+	void *ptr
+		= memalign_etc(size >= PAGESIZE ? PAGESIZE : next_power_of_2(size), size,
+			(flags & M_NOWAIT) ? HEAP_DONT_WAIT_FOR_MEMORY : 0);
+	if (ptr == NULL)
+		return NULL;
+
+	if (flags & M_ZERO)
+		memset(ptr, 0, size);
+
+	return ptr;
+}
+
+
+void
+_kernel_free(void *ptr)
+{
+	free(ptr);
+}
+
+
+void *
+_kernel_contigmalloc(const char *file, int line, size_t size, int flags,
+	vm_paddr_t low, vm_paddr_t high, unsigned long alignment,
+	unsigned long boundary)
+{
+	const bool zero = (flags & M_ZERO) != 0, dontWait = (flags & M_NOWAIT) != 0;
+
+	size = ROUNDUP(size, B_PAGE_SIZE);
+
+	uint32 creationFlags = (zero ? 0 : CREATE_AREA_DONT_CLEAR)
+		| (dontWait ? CREATE_AREA_DONT_WAIT : 0);
+
+	char name[B_OS_NAME_LENGTH];
+	const char* baseName = strrchr(file, '/');
+	baseName = baseName != NULL ? baseName + 1 : file;
+	snprintf(name, sizeof(name), "contig:%s:%d", baseName, line);
+
+	virtual_address_restrictions virtualRestrictions = {};
+
+	physical_address_restrictions physicalRestrictions = {};
+	physicalRestrictions.low_address = low;
+	physicalRestrictions.high_address = high;
+	physicalRestrictions.alignment = alignment;
+	physicalRestrictions.boundary = boundary;
+
+	void* address;
+	area_id area = create_area_etc(B_SYSTEM_TEAM, name, size, B_CONTIGUOUS,
+		B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA, creationFlags, 0,
+		&virtualRestrictions, &physicalRestrictions, &address);
+	if (area < 0)
+		return NULL;
+
+	return address;
+}
+
+
+void
+_kernel_contigfree(void *addr, size_t size)
+{
+	delete_area(area_for(addr));
+}
+
+
+vm_paddr_t
+pmap_kextract(vm_offset_t virtualAddress)
+{
+	physical_entry entry;
+	status_t status = get_memory_map((void *)virtualAddress, 1, &entry, 1);
+	if (status < B_OK) {
+		panic("fbsd compat: get_memory_map failed for %p, error %08" B_PRIx32
+			"\n", (void *)virtualAddress, status);
+	}
+
+	return (vm_paddr_t)entry.address;
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/mbuf.c b/src/add-ons/kernel/drivers/network/cadence_gem/mbuf.c
new file mode 100644
index 0000000000..d9389341c8
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/mbuf.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include "device.h"
+
+#include <stdint.h>
+#include <string.h>
+#include <slab/Slab.h>
+
+#include <compat/sys/malloc.h>
+#include <compat/sys/mbuf.h>
+#include <compat/sys/kernel.h>
+
+
+static object_cache *sMBufCache;
+static object_cache *sChunkCache;
+static object_cache *sJumbo9ChunkCache;
+static object_cache *sJumboPageSizeCache;
+
+
+int max_linkhdr = 16;
+int max_protohdr = 40 + 20; /* ip6 + tcp */
+
+/* max_linkhdr + max_protohdr, but that's not allowed by gcc. */
+int max_hdr = 16 + 40 + 20;
+
+/* MHLEN - max_hdr */
+int max_datalen = MHLEN - (16 + 40 + 20);
+
+
+static int
+m_to_oc_flags(int how)
+{
+	if (how & M_NOWAIT)
+		return CACHE_DONT_WAIT_FOR_MEMORY;
+
+	return 0;
+}
+
+
+int
+m_init(struct mbuf *m, int how, short type, int flags)
+{
+	int error;
+
+	if (type == MT_NOINIT)
+		return 0;
+
+	m->m_next = NULL;
+	m->m_nextpkt = NULL;
+	m->m_data = m->m_dat;
+	m->m_len = 0;
+	m->m_flags = flags;
+	m->m_type = type;
+	if (flags & M_PKTHDR)
+		error = m_pkthdr_init(m, how);
+	else
+		error = 0;
+
+	return (error);
+}
+
+
+static void*
+allocate_ext_buf(int how, int size, int* ext_type)
+{
+	object_cache *cache;
+	int extType;
+	if (size != MCLBYTES && size != MJUM9BYTES && size != MJUMPAGESIZE)
+		panic("unsupported size");
+
+	if (size == MCLBYTES) {
+		cache = sChunkCache;
+		extType = EXT_CLUSTER;
+	} else if (size == MJUM9BYTES) {
+		cache = sJumbo9ChunkCache;
+		extType = EXT_JUMBO9;
+	} else {
+		cache = sJumboPageSizeCache;
+		extType = EXT_JUMBOP;
+	}
+
+	if (ext_type != NULL)
+		*ext_type = extType;
+	return object_cache_alloc(cache, m_to_oc_flags(how));
+}
+
+
+static int
+construct_ext_sized_mbuf(struct mbuf *memoryBuffer, int how, int size)
+{
+	int extType;
+
+	memoryBuffer->m_ext.ext_buf = allocate_ext_buf(how, size, &extType);
+	if (memoryBuffer->m_ext.ext_buf == NULL)
+		return B_NO_MEMORY;
+
+	memoryBuffer->m_data = memoryBuffer->m_ext.ext_buf;
+	memoryBuffer->m_flags |= M_EXT;
+	memoryBuffer->m_ext.ext_size = size;
+	memoryBuffer->m_ext.ext_type = extType;
+	memoryBuffer->m_ext.ext_flags = EXT_FLAG_EMBREF;
+	memoryBuffer->m_ext.ext_count = 1;
+
+	return 0;
+}
+
+
+static inline int
+construct_ext_mbuf(struct mbuf *memoryBuffer, int how)
+{
+	return construct_ext_sized_mbuf(memoryBuffer, how, MCLBYTES);
+}
+
+
+static int
+construct_pkt_mbuf(int how, struct mbuf *memoryBuffer, short type, int flags)
+{
+	if (m_init(memoryBuffer, how, type, flags) < 0)
+		return -1;
+	if (construct_ext_mbuf(memoryBuffer, how) < 0)
+		return -1;
+	memoryBuffer->m_ext.ext_type = EXT_CLUSTER;
+	return 0;
+}
+
+
+struct mbuf *
+m_getcl(int how, short type, int flags)
+{
+	struct mbuf *memoryBuffer =
+		(struct mbuf *)object_cache_alloc(sMBufCache, m_to_oc_flags(how));
+	if (memoryBuffer == NULL)
+		return NULL;
+
+	if (construct_pkt_mbuf(how, memoryBuffer, type, flags) < 0) {
+		object_cache_free(sMBufCache, memoryBuffer, 0);
+		return NULL;
+	}
+
+	return memoryBuffer;
+}
+
+
+static struct mbuf *
+_m_get(int how, short type, int flags)
+{
+	struct mbuf *memoryBuffer =
+		(struct mbuf *)object_cache_alloc(sMBufCache, m_to_oc_flags(how));
+	if (memoryBuffer == NULL)
+		return NULL;
+
+	m_init(memoryBuffer, how, type, flags);
+
+	return memoryBuffer;
+}
+
+
+struct mbuf *
+m_get(int how, short type)
+{
+	return _m_get(how, type, 0);
+}
+
+
+struct mbuf *
+m_get2(int size, int how, short type, int flags)
+{
+	if (size <= MHLEN || (size <= MLEN && (flags & M_PKTHDR) == 0)) {
+		size = MCLBYTES;
+	} else if (size <= MJUMPAGESIZE) {
+		size = MJUMPAGESIZE;
+	} else if (size <= MJUM9BYTES) {
+		size = MJUM9BYTES;
+	} else /* (size > MJUM9BYTES) */ {
+		return NULL;
+	}
+
+	return m_getjcl(how, type, flags, size);
+}
+
+
+struct mbuf *
+m_gethdr(int how, short type)
+{
+	return _m_get(how, type, M_PKTHDR);
+}
+
+
+struct mbuf *
+m_getjcl(int how, short type, int flags, int size)
+{
+	struct mbuf *memoryBuffer =
+		(struct mbuf *)object_cache_alloc(sMBufCache, m_to_oc_flags(how));
+	if (memoryBuffer == NULL)
+		return NULL;
+	if (m_init(memoryBuffer, how, type, flags) < 0) {
+		object_cache_free(sMBufCache, memoryBuffer, 0);
+		return NULL;
+	}
+	if (construct_ext_sized_mbuf(memoryBuffer, how, size) < 0) {
+		object_cache_free(sMBufCache, memoryBuffer, 0);
+		return NULL;
+	}
+	return memoryBuffer;
+}
+
+
+int
+m_clget(struct mbuf *memoryBuffer, int how)
+{
+	memoryBuffer->m_ext.ext_buf = NULL;
+	/* called checks for errors by looking for M_EXT */
+	construct_ext_mbuf(memoryBuffer, how);
+	return memoryBuffer->m_flags & M_EXT;
+}
+
+
+void*
+m_cljget(struct mbuf* memoryBuffer, int how, int size)
+{
+	if (memoryBuffer == NULL)
+		return allocate_ext_buf(how, size, NULL);
+
+	memoryBuffer->m_ext.ext_buf = NULL;
+	construct_ext_sized_mbuf(memoryBuffer, how, size);
+	return memoryBuffer->m_ext.ext_buf;
+}
+
+
+static void
+mb_free_ext(struct mbuf *memoryBuffer)
+{
+	volatile u_int *refcnt;
+	struct mbuf *mref;
+	int freembuf;
+
+	KASSERT(memoryBuffer->m_flags & M_EXT, ("%s: M_EXT not set on %p",
+		__func__, memoryBuffer));
+
+	/* See if this is the mbuf that holds the embedded refcount. */
+	if (memoryBuffer->m_ext.ext_flags & EXT_FLAG_EMBREF) {
+		refcnt = &memoryBuffer->m_ext.ext_count;
+		mref = memoryBuffer;
+	} else {
+		KASSERT(memoryBuffer->m_ext.ext_cnt != NULL,
+			("%s: no refcounting pointer on %p", __func__, memoryBuffer));
+		refcnt = memoryBuffer->m_ext.ext_cnt;
+		mref = __containerof(refcnt, struct mbuf, m_ext.ext_count);
+	}
+
+	/*
+	 * Check if the header is embedded in the cluster.  It is
+	 * important that we can't touch any of the mbuf fields
+	 * after we have freed the external storage, since mbuf
+	 * could have been embedded in it.  For now, the mbufs
+	 * embedded into the cluster are always of type EXT_EXTREF,
+	 * and for this type we won't free the mref.
+	 */
+	if (memoryBuffer->m_flags & M_NOFREE) {
+		freembuf = 0;
+		KASSERT(memoryBuffer->m_ext.ext_type == EXT_EXTREF,
+			("%s: no-free mbuf %p has wrong type", __func__, memoryBuffer));
+	} else
+		freembuf = 1;
+
+	/* Free attached storage only if this mbuf is the only reference to it. */
+	if (*refcnt == 1 || atomic_add((int32*)refcnt, -1) == 1) {
+		object_cache *cache = NULL;
+
+		if (memoryBuffer->m_ext.ext_type == EXT_CLUSTER)
+			cache = sChunkCache;
+		else if (memoryBuffer->m_ext.ext_type == EXT_JUMBO9)
+			cache = sJumbo9ChunkCache;
+		else if (memoryBuffer->m_ext.ext_type == EXT_JUMBOP)
+			cache = sJumboPageSizeCache;
+		else
+			panic("unknown mbuf ext_type %d", memoryBuffer->m_ext.ext_type);
+
+		object_cache_free(cache, memoryBuffer->m_ext.ext_buf, 0);
+		object_cache_free(sMBufCache, mref, 0);
+	}
+
+	if (freembuf && memoryBuffer != mref)
+		object_cache_free(sMBufCache, memoryBuffer, 0);
+}
+
+
+struct mbuf *
+m_free(struct mbuf* memoryBuffer)
+{
+	struct mbuf* next = memoryBuffer->m_next;
+
+	if ((memoryBuffer->m_flags & (M_PKTHDR|M_NOFREE)) == (M_PKTHDR|M_NOFREE))
+		m_tag_delete_chain(memoryBuffer, NULL);
+	if (memoryBuffer->m_flags & M_EXT)
+		mb_free_ext(memoryBuffer);
+	else if ((memoryBuffer->m_flags & M_NOFREE) == 0)
+		object_cache_free(sMBufCache, memoryBuffer, 0);
+
+	return next;
+}
+
+
+status_t
+init_mbufs()
+{
+	sMBufCache = create_object_cache("mbufs", MSIZE, 8, NULL, NULL, NULL);
+	if (sMBufCache == NULL)
+		goto clean;
+	sChunkCache = create_object_cache("mbuf chunks", MCLBYTES, 0, NULL, NULL,
+		NULL);
+	if (sChunkCache == NULL)
+		goto clean;
+	sJumbo9ChunkCache = create_object_cache("mbuf jumbo9 chunks", MJUM9BYTES, 0,
+		NULL, NULL, NULL);
+	if (sJumbo9ChunkCache == NULL)
+		goto clean;
+	sJumboPageSizeCache = create_object_cache("mbuf jumbo page size chunks",
+		MJUMPAGESIZE, 0, NULL, NULL, NULL);
+	if (sJumboPageSizeCache == NULL)
+		goto clean;
+	return B_OK;
+
+clean:
+	if (sJumbo9ChunkCache != NULL)
+		delete_object_cache(sJumbo9ChunkCache);
+	if (sChunkCache != NULL)
+		delete_object_cache(sChunkCache);
+	if (sMBufCache != NULL)
+		delete_object_cache(sMBufCache);
+	return B_NO_MEMORY;
+}
+
+
+void
+uninit_mbufs()
+{
+	delete_object_cache(sMBufCache);
+	delete_object_cache(sChunkCache);
+	delete_object_cache(sJumbo9ChunkCache);
+	delete_object_cache(sJumboPageSizeCache);
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/mii.c b/src/add-ons/kernel/drivers/network/cadence_gem/mii.c
new file mode 100644
index 0000000000..4721938e24
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/mii.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *      Hugo Santos, hugosantos@gmail.com
+ */
+
+
+#include "device.h"
+
+#include <compat/sys/bus.h>
+
+#include <compat/net/if_media.h>
+#include <compat/dev/mii/miivar.h>
+
+
+int
+__haiku_miibus_readreg(device_t device, int phy, int reg)
+{
+	if (device->methods.miibus_readreg == NULL)
+		panic("miibus_readreg, no support");
+
+	return device->methods.miibus_readreg(device, phy, reg);
+}
+
+
+int
+__haiku_miibus_writereg(device_t device, int phy, int reg, int data)
+{
+	if (device->methods.miibus_writereg == NULL)
+		panic("miibus_writereg, no support");
+
+	return device->methods.miibus_writereg(device, phy, reg, data);
+}
+
+
+void
+__haiku_miibus_statchg(device_t device)
+{
+	if (device->methods.miibus_statchg)
+		device->methods.miibus_statchg(device);
+}
+
+
+void
+__haiku_miibus_linkchg(device_t device)
+{
+	if (device->methods.miibus_linkchg)
+		device->methods.miibus_linkchg(device);
+}
+
+
+void
+__haiku_miibus_mediainit(device_t device)
+{
+	if (device->methods.miibus_mediainit)
+		device->methods.miibus_mediainit(device);
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/mutex.c b/src/add-ons/kernel/drivers/network/cadence_gem/mutex.c
new file mode 100644
index 0000000000..1084437f70
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/mutex.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include "device.h"
+
+#include <compat/sys/mutex.h>
+
+
+struct mtx Giant;
+struct rw_lock ifnet_rwlock;
+struct mtx gIdStoreLock;
+
+
+void
+mtx_init(struct mtx *mutex, const char *name, const char *type,
+	int options)
+{
+	if ((options & MTX_RECURSE) != 0) {
+		recursive_lock_init_etc(&mutex->u.recursive, name,
+			MUTEX_FLAG_CLONE_NAME);
+		mutex->type = MTX_RECURSE;
+	} else if ((options & MTX_SPIN) != 0) {
+		B_INITIALIZE_SPINLOCK(&mutex->u.spinlock.lock);
+		mutex->type = MTX_SPIN;
+	} else {
+		mutex_init_etc(&mutex->u.mutex.lock, name, MUTEX_FLAG_CLONE_NAME);
+		mutex->u.mutex.owner = -1;
+		mutex->type = MTX_DEF;
+	}
+}
+
+
+void
+mtx_sysinit(void *arg)
+{
+	struct mtx_args *margs = arg;
+
+	mtx_init((struct mtx *)margs->ma_mtx, margs->ma_desc, NULL,
+	    margs->ma_opts);
+}
+
+
+void
+mtx_destroy(struct mtx *mutex)
+{
+	if ((mutex->type & MTX_RECURSE) != 0) {
+		recursive_lock_destroy(&mutex->u.recursive);
+	} else if ((mutex->type & MTX_SPIN) != 0) {
+		KASSERT(!B_SPINLOCK_IS_LOCKED(&mutex->u.spinlock.lock), ("spin mutex is locked"));
+	} else {
+		mutex_destroy(&mutex->u.mutex.lock);
+	}
+}
+
+
+status_t
+init_mutexes()
+{
+	mtx_init(&Giant, "Banana Giant", NULL, MTX_DEF);
+	rw_lock_init(&ifnet_rwlock, "gDevices");
+	mtx_init(&gIdStoreLock, "Identity Store", NULL, MTX_DEF);
+
+	return B_OK;
+}
+
+
+void
+uninit_mutexes()
+{
+	mtx_destroy(&Giant);
+	rw_lock_destroy(&ifnet_rwlock);
+	mtx_destroy(&gIdStoreLock);
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/ofw.cpp b/src/add-ons/kernel/drivers/network/cadence_gem/ofw.cpp
new file mode 100644
index 0000000000..f04f544a06
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/ofw.cpp
@@ -0,0 +1,62 @@
+#include <bus/FDT.h>
+
+#include <malloc.h>
+
+extern "C" {
+#include <sys/haiku-module.h>
+#include <sys/kobj.h>
+#include <dev/ofw/ofw_bus_subr.h>
+#include "device.h"
+}
+
+int ofw_bus_status_okay(device_t dev)
+{
+	return 0;
+}
+
+const struct ofw_compat_data*
+	ofw_bus_search_compatible(device_t dev, const struct ofw_compat_data* compatData)
+{
+	return NULL;
+}
+
+extern "C" ssize_t
+OF_getprop(phandle_t node, const char *propname, void *buf, size_t len)
+{
+	return -1;
+}
+
+
+struct root_fdt_device_softc {
+	device_node* dev;
+};
+
+
+status_t
+init_root_fdt_device(device_t *_root)
+{
+	static driver_t sRootFdtDriver = {
+		"fdt",
+		NULL,
+		sizeof(struct root_fdt_device_softc)
+	};
+
+	device_t root = device_add_child(NULL, NULL, 0);
+	if (root == NULL)
+		return B_NO_MEMORY;
+
+	root->softc = malloc(sizeof(struct root_fdt_device_softc));
+	if (root->softc == NULL) {
+		device_delete_child(NULL, root);
+		return B_NO_MEMORY;
+	}
+
+	bzero(root->softc, sizeof(struct root_fdt_device_softc));
+	root->driver = &sRootFdtDriver;
+	root->root = root;
+
+	if (_root != NULL)
+		*_root = root;
+
+	return B_OK;
+}
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/ofw_bus_if.c b/src/add-ons/kernel/drivers/network/cadence_gem/ofw_bus_if.c
new file mode 100644
index 0000000000..538ce21688
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/ofw_bus_if.c
@@ -0,0 +1,111 @@
+/*
+ * This file is @generated automatically.
+ * Do not modify anything in here by hand.
+ *
+ * Created from source file
+ *   src/libs/compat/freebsd_network/compat/dev/ofw/ofw_bus_if.m
+ * with
+ *   makeobjops.awk
+ *
+ * See the source file for legal information
+ */
+
+#include <sys/param.h>
+#include <sys/queue.h>
+#include <sys/kernel.h>
+#include <sys/kobj.h>
+#include <sys/bus.h>
+#include <dev/ofw/openfirm.h>
+#include <dev/ofw/ofw_bus_if.h>
+
+
+static ofw_bus_get_devinfo_t ofw_bus_default_get_devinfo;
+static ofw_bus_get_compat_t ofw_bus_default_get_compat;
+static ofw_bus_get_model_t ofw_bus_default_get_model;
+static ofw_bus_get_name_t ofw_bus_default_get_name;
+static ofw_bus_get_node_t ofw_bus_default_get_node;
+static ofw_bus_get_type_t ofw_bus_default_get_type;
+static ofw_bus_map_intr_t ofw_bus_default_map_intr;
+
+static const struct ofw_bus_devinfo *
+ofw_bus_default_get_devinfo(device_t bus, device_t dev)
+{
+
+	return (NULL);
+}
+
+static const char *
+ofw_bus_default_get_compat(device_t bus, device_t dev)
+{
+
+	return (NULL);
+}
+
+static const char *
+ofw_bus_default_get_model(device_t bus, device_t dev)
+{
+
+	return (NULL);
+}
+
+static const char *
+ofw_bus_default_get_name(device_t bus, device_t dev)
+{
+
+	return (NULL);
+}
+
+static phandle_t
+ofw_bus_default_get_node(device_t bus, device_t dev)
+{
+
+	return (-1);
+}
+
+static const char *
+ofw_bus_default_get_type(device_t bus, device_t dev)
+{
+
+	return (NULL);
+}
+
+int
+ofw_bus_default_map_intr(device_t bus, device_t dev, phandle_t iparent,
+    int icells, pcell_t *interrupt)
+{
+	/* Propagate up the bus hierarchy until someone handles it. */	
+	if (device_get_parent(bus) != NULL)
+		return OFW_BUS_MAP_INTR(device_get_parent(bus), dev,
+		    iparent, icells, interrupt);
+
+	/* If that fails, then assume a one-domain system */
+	return (interrupt[0]);
+}
+
+struct kobjop_desc ofw_bus_get_devinfo_desc = {
+	0, { NULL, ID_ifdi_debug + 1, (kobjop_t)ofw_bus_default_get_devinfo }
+};
+
+struct kobjop_desc ofw_bus_get_compat_desc = {
+	0, { NULL, ID_ifdi_debug + 2, (kobjop_t)ofw_bus_default_get_compat }
+};
+
+struct kobjop_desc ofw_bus_get_model_desc = {
+	0, { NULL, ID_ifdi_debug + 3, (kobjop_t)ofw_bus_default_get_model }
+};
+
+struct kobjop_desc ofw_bus_get_name_desc = {
+	0, { NULL, ID_ifdi_debug + 4, (kobjop_t)ofw_bus_default_get_name }
+};
+
+struct kobjop_desc ofw_bus_get_node_desc = {
+	0, { NULL, ID_ifdi_debug + 5, (kobjop_t)ofw_bus_default_get_node }
+};
+
+struct kobjop_desc ofw_bus_get_type_desc = {
+	0, { NULL, ID_ifdi_debug + 6, (kobjop_t)ofw_bus_default_get_type }
+};
+
+struct kobjop_desc ofw_bus_map_intr_desc = {
+	0, { NULL, ID_ifdi_debug + 7, (kobjop_t)ofw_bus_default_map_intr }
+};
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/shared.h b/src/add-ons/kernel/drivers/network/cadence_gem/shared.h
new file mode 100644
index 0000000000..8544a8e7b7
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/shared.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de. All Rights Reserved.
+ * Copyright 2007, Axel Drfler, axeld@pinc-software.de. All Rights Reserved.
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2004, Marcus Overhagen. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef SHARED_H_
+#define SHARED_H_
+
+
+#include <sys/bus.h>
+
+
+#define MAX_DEVICES	8
+
+
+struct ifnet;
+
+struct device {
+	struct device	*parent;
+	struct device	*root;
+
+	driver_t		*driver;
+	struct list		children;
+
+	uint32			flags;
+
+	char			device_name[128];
+	int				unit;
+	char			nameunit[64];
+	const char		*description;
+	void			*softc;
+	void			*ivars;
+
+	struct {
+		void* (*device_register)(device_t dev);
+		int (*probe)(device_t dev);
+		int (*attach)(device_t dev);
+		int (*detach)(device_t dev);
+		int (*suspend)(device_t dev);
+		int (*resume)(device_t dev);
+		void (*shutdown)(device_t dev);
+
+		int (*miibus_readreg)(device_t, int, int);
+		int (*miibus_writereg)(device_t, int, int, int);
+		void (*miibus_statchg)(device_t);
+		void (*miibus_linkchg)(device_t);
+		void (*miibus_mediainit)(device_t);
+
+		int (*bus_child_location_str)(device_t dev __unused, device_t child,
+			char *buf, size_t buflen);
+		int (*bus_child_pnpinfo_str)(device_t dev __unused, device_t child,
+			char *buf, size_t buflen);
+		void (*bus_hinted_child)(device_t dev, const char *name, int unit);
+		int (*bus_print_child)(device_t dev, device_t child);
+		int (*bus_read_ivar)(device_t dev, device_t child __unused, int which,
+		    uintptr_t *result);
+		bus_dma_tag_t (*bus_get_dma_tag)(device_t dev);
+	} methods;
+
+	struct list_link link;
+};
+
+
+extern const char *gDeviceNameList[];
+extern struct ifnet *gDevices[];
+extern int32 gDeviceCount;
+
+#endif /* SHARED_H_ */
diff --git a/src/add-ons/kernel/drivers/network/cadence_gem/taskqueue.c b/src/add-ons/kernel/drivers/network/cadence_gem/taskqueue.c
new file mode 100644
index 0000000000..01dfdb918e
--- /dev/null
+++ b/src/add-ons/kernel/drivers/network/cadence_gem/taskqueue.c
@@ -0,0 +1,601 @@
+/*
+ * Copyright 2009, Colin Gnther, coling@gmx.de
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *      Hugo Santos, hugosantos@gmail.com
+ */
+
+
+#include "device.h"
+
+#include <stdio.h>
+
+#include <compat/sys/callout.h>
+#include <compat/sys/taskqueue.h>
+#include <compat/sys/haiku-module.h>
+
+
+#define TQ_FLAGS_ACTIVE		(1 << 0)
+#define TQ_FLAGS_BLOCKED	(1 << 1)
+#define TQ_FLAGS_PENDING	(1 << 2)
+
+#define	DT_CALLOUT_ARMED		(1 << 0)
+#define	DT_DRAIN_IN_PROGRESS	(1 << 1)
+
+struct taskqueue {
+	char tq_name[TASKQUEUE_NAMELEN];
+	struct mtx tq_mutex;
+	struct list tq_list;
+	taskqueue_enqueue_fn tq_enqueue;
+	void *tq_arg;
+	int tq_fast;
+	spinlock tq_spinlock;
+	sem_id tq_sem;
+	thread_id *tq_threads;
+	thread_id tq_thread_storage;
+	int tq_threadcount;
+	int tq_flags;
+	int tq_callouts;
+};
+
+struct taskqueue *taskqueue_fast = NULL;
+struct taskqueue *taskqueue_swi = NULL;
+struct taskqueue *taskqueue_thread = NULL;
+
+
+static struct taskqueue *
+_taskqueue_create(const char *name, int mflags, int fast,
+	taskqueue_enqueue_fn enqueueFunction, void *context)
+{
+	struct taskqueue *tq = malloc(sizeof(struct taskqueue));
+	if (tq == NULL)
+		return NULL;
+
+	tq->tq_fast = fast;
+
+	if (fast) {
+		B_INITIALIZE_SPINLOCK(&tq->tq_spinlock);
+	} else {
+		mtx_init(&tq->tq_mutex, name, NULL, MTX_DEF);
+	}
+
+	strlcpy(tq->tq_name, name, sizeof(tq->tq_name));
+	list_init_etc(&tq->tq_list, offsetof(struct task, ta_link));
+	tq->tq_enqueue = enqueueFunction;
+	tq->tq_arg = context;
+
+	tq->tq_sem = -1;
+	tq->tq_threads = NULL;
+	tq->tq_threadcount = 0;
+	tq->tq_flags = TQ_FLAGS_ACTIVE;
+	tq->tq_callouts = 0;
+
+	return tq;
+}
+
+
+static void
+tq_lock(struct taskqueue *taskQueue, cpu_status *status)
+{
+	if (taskQueue->tq_fast) {
+		*status = disable_interrupts();
+		acquire_spinlock(&taskQueue->tq_spinlock);
+	} else {
+		mtx_lock(&taskQueue->tq_mutex);
+	}
+}
+
+
+static void
+tq_unlock(struct taskqueue *taskQueue, cpu_status status)
+{
+	if (taskQueue->tq_fast) {
+		release_spinlock(&taskQueue->tq_spinlock);
+		restore_interrupts(status);
+	} else {
+		mtx_unlock(&taskQueue->tq_mutex);
+	}
+}
+
+
+struct taskqueue *
+taskqueue_create(const char *name, int mflags,
+	taskqueue_enqueue_fn enqueueFunction, void *context)
+{
+	return _taskqueue_create(name, mflags, 0, enqueueFunction, context);
+}
+
+
+static int32
+tq_handle_thread(void *data)
+{
+	struct taskqueue *tq = data;
+	cpu_status cpu_state;
+	struct task *t;
+	int pending;
+	sem_id sem;
+
+	/* just a synchronization point */
+	tq_lock(tq, &cpu_state);
+	sem = tq->tq_sem;
+	tq_unlock(tq, cpu_state);
+
+	while (acquire_sem(sem) == B_NO_ERROR) {
+		tq_lock(tq, &cpu_state);
+		t = list_remove_head_item(&tq->tq_list);
+		tq_unlock(tq, cpu_state);
+		if (t == NULL)
+			continue;
+		pending = t->ta_pending;
+		t->ta_pending = 0;
+
+		t->ta_handler(t->ta_argument, pending);
+	}
+
+	return 0;
+}
+
+
+static int
+_taskqueue_start_threads(struct taskqueue **taskQueue, int count, int priority,
+	const char *name)
+{
+	struct taskqueue *tq = (*taskQueue);
+	int i, j;
+
+	if (count == 0)
+		return -1;
+
+	if (tq->tq_threads != NULL)
+		return -1;
+
+	if (count == 1) {
+		tq->tq_threads = &tq->tq_thread_storage;
+	} else {
+		tq->tq_threads = malloc(sizeof(thread_id) * count);
+		if (tq->tq_threads == NULL)
+			return B_NO_MEMORY;
+	}
+
+	tq->tq_sem = create_sem(0, tq->tq_name);
+	if (tq->tq_sem < B_OK) {
+		if (count > 1)
+			free(tq->tq_threads);
+		tq->tq_threads = NULL;
+		return tq->tq_sem;
+	}
+
+	for (i = 0; i < count; i++) {
+		tq->tq_threads[i] = spawn_kernel_thread(tq_handle_thread, tq->tq_name,
+			priority, tq);
+		if (tq->tq_threads[i] < B_OK) {
+			status_t status = tq->tq_threads[i];
+			for (j = 0; j < i; j++)
+				kill_thread(tq->tq_threads[j]);
+			if (count > 1)
+				free(tq->tq_threads);
+			tq->tq_threads = NULL;
+			delete_sem(tq->tq_sem);
+			return status;
+		}
+	}
+
+	tq->tq_threadcount = count;
+
+	for (i = 0; i < count; i++)
+		resume_thread(tq->tq_threads[i]);
+
+	return 0;
+}
+
+
+int
+taskqueue_start_threads(struct taskqueue **taskQueue, int count, int priority,
+	const char *format, ...)
+{
+	/* we assume that start_threads is called in a sane place, and thus
+	 * don't need to be locked. This is mostly due to the fact that if
+	 * the TQ is 'fast', locking the TQ disables interrupts... and then
+	 * we can't create semaphores, threads and bananas. */
+
+	/* cpu_status state; */
+	char name[64];
+	int result;
+	va_list vl;
+
+	va_start(vl, format);
+	vsnprintf(name, sizeof(name), format, vl);
+	va_end(vl);
+
+	/*tq_lock(*tqp, &state);*/
+	result = _taskqueue_start_threads(taskQueue, count, priority, name);
+	/*tq_unlock(*tqp, state);*/
+
+	return result;
+}
+
+
+void
+taskqueue_free(struct taskqueue *taskQueue)
+{
+	if (taskQueue == NULL) {
+		printf("taskqueue_free called with NULL taskqueue\n");
+		return;
+	}
+
+	/* lock and  drain list? */
+	taskQueue->tq_flags &= ~TQ_FLAGS_ACTIVE;
+	if (!taskQueue->tq_fast)
+		mtx_destroy(&taskQueue->tq_mutex);
+	if (taskQueue->tq_sem != -1) {
+		int i;
+
+		delete_sem(taskQueue->tq_sem);
+
+		for (i = 0; i < taskQueue->tq_threadcount; i++) {
+			status_t status;
+			wait_for_thread(taskQueue->tq_threads[i], &status);
+		}
+
+		if (taskQueue->tq_threadcount > 1)
+			free(taskQueue->tq_threads);
+	}
+
+	free(taskQueue);
+}
+
+
+void
+taskqueue_drain(struct taskqueue *taskQueue, struct task *task)
+{
+	cpu_status status;
+
+	if (taskQueue == NULL) {
+		printf("taskqueue_drain called with NULL taskqueue\n");
+		return;
+	}
+
+	tq_lock(taskQueue, &status);
+	while (task->ta_pending != 0) {
+		tq_unlock(taskQueue, status);
+		snooze(0);
+		tq_lock(taskQueue, &status);
+	}
+	tq_unlock(taskQueue, status);
+}
+
+
+void
+taskqueue_drain_timeout(struct taskqueue *queue,
+	struct timeout_task *timeout_task)
+{
+	cpu_status status;
+	/*
+	 * Set flag to prevent timer from re-starting during drain:
+	 */
+	tq_lock(queue, &status);
+	KASSERT((timeout_task->f & DT_DRAIN_IN_PROGRESS) == 0,
+		("Drain already in progress"));
+	timeout_task->f |= DT_DRAIN_IN_PROGRESS;
+	tq_unlock(queue, status);
+
+	callout_drain(&timeout_task->c);
+	taskqueue_drain(queue, &timeout_task->t);
+
+	/*
+	 * Clear flag to allow timer to re-start:
+	 */
+	tq_lock(queue, &status);
+	timeout_task->f &= ~DT_DRAIN_IN_PROGRESS;
+	tq_unlock(queue, status);
+}
+
+
+static void
+taskqueue_task_nop_fn(void* context, int pending)
+{
+}
+
+
+void
+taskqueue_drain_all(struct taskqueue *taskQueue)
+{
+	struct task t_barrier;
+
+	if (taskQueue == NULL) {
+		printf("taskqueue_drain_all called with NULL taskqueue\n");
+		return;
+	}
+
+	TASK_INIT(&t_barrier, USHRT_MAX, taskqueue_task_nop_fn, &t_barrier);
+	taskqueue_enqueue(taskQueue, &t_barrier);
+	taskqueue_drain(taskQueue, &t_barrier);
+}
+
+
+static void
+taskqueue_enqueue_locked(struct taskqueue *taskQueue, struct task *task,
+	cpu_status status)
+{
+	/* we don't really support priorities */
+	if (task->ta_pending) {
+		task->ta_pending++;
+	} else {
+		list_add_item(&taskQueue->tq_list, task);
+		task->ta_pending = 1;
+		if ((taskQueue->tq_flags & TQ_FLAGS_BLOCKED) == 0)
+			taskQueue->tq_enqueue(taskQueue->tq_arg);
+		else
+			taskQueue->tq_flags |= TQ_FLAGS_PENDING;
+	}
+	tq_unlock(taskQueue, status);
+}
+
+
+int
+taskqueue_enqueue(struct taskqueue *taskQueue, struct task *task)
+{
+	cpu_status status;
+
+	tq_lock(taskQueue, &status);
+	taskqueue_enqueue_locked(taskQueue, task, status);
+	/* The lock is released inside. */
+
+	return 0;
+}
+
+
+static void
+taskqueue_timeout_func(void *arg)
+{
+	struct taskqueue *queue;
+	struct timeout_task *timeout_task;
+	cpu_status status;
+		// dummy, as we should never get here on a spin taskqueue
+
+	timeout_task = arg;
+	queue = timeout_task->q;
+	KASSERT((timeout_task->f & DT_CALLOUT_ARMED) != 0, ("Stray timeout"));
+	timeout_task->f &= ~DT_CALLOUT_ARMED;
+	queue->tq_callouts--;
+	taskqueue_enqueue_locked(timeout_task->q, &timeout_task->t, status);
+	/* The lock is released inside. */
+}
+
+
+int
+taskqueue_enqueue_timeout(struct taskqueue *queue,
+	struct timeout_task *ttask, int _ticks)
+{
+	int res;
+	cpu_status status;
+
+	tq_lock(queue, &status);
+	KASSERT(ttask->q == NULL || ttask->q == queue,
+		("Migrated queue"));
+	ttask->q = queue;
+	res = ttask->t.ta_pending;
+	if (ttask->f & DT_DRAIN_IN_PROGRESS) {
+		/* Do nothing */
+		tq_unlock(queue, status);
+		res = -1;
+	} else if (_ticks == 0) {
+		tq_unlock(queue, status);
+		taskqueue_enqueue(queue, &ttask->t);
+	} else {
+		if ((ttask->f & DT_CALLOUT_ARMED) != 0) {
+			res++;
+		} else {
+			queue->tq_callouts++;
+			ttask->f |= DT_CALLOUT_ARMED;
+			if (_ticks < 0)
+				_ticks = -_ticks; /* Ignore overflow. */
+		}
+		tq_unlock(queue, status);
+		if (_ticks > 0) {
+			callout_reset(&ttask->c, _ticks,
+				taskqueue_timeout_func, ttask);
+		}
+	}
+	return (res);
+}
+
+
+static int
+taskqueue_cancel_locked(struct taskqueue *queue, struct task *task,
+	u_int *pendp)
+{
+	if (task->ta_pending > 0)
+		list_remove_item(&queue->tq_list, task);
+	if (pendp != NULL)
+		*pendp = task->ta_pending;
+	task->ta_pending = 0;
+	return 0;
+}
+
+
+int
+taskqueue_cancel(struct taskqueue *queue, struct task *task, u_int *pendp)
+{
+	int error;
+	cpu_status status;
+
+	tq_lock(queue, &status);
+	error = taskqueue_cancel_locked(queue, task, pendp);
+	tq_unlock(queue, status);
+
+	return (error);
+}
+
+
+int
+taskqueue_cancel_timeout(struct taskqueue *queue,
+	struct timeout_task *timeout_task, u_int *pendp)
+{
+	u_int pending, pending1;
+	int error;
+	cpu_status status;
+
+	tq_lock(queue, &status);
+	pending = !!(callout_stop(&timeout_task->c) > 0);
+	error = taskqueue_cancel_locked(queue, &timeout_task->t, &pending1);
+	if ((timeout_task->f & DT_CALLOUT_ARMED) != 0) {
+		timeout_task->f &= ~DT_CALLOUT_ARMED;
+		queue->tq_callouts--;
+	}
+	tq_unlock(queue, status);
+
+	if (pendp != NULL)
+		*pendp = pending + pending1;
+	return (error);
+}
+
+
+void
+taskqueue_thread_enqueue(void *context)
+{
+	struct taskqueue **tqp = context;
+	release_sem_etc((*tqp)->tq_sem, 1, B_DO_NOT_RESCHEDULE);
+}
+
+
+int
+taskqueue_enqueue_fast(struct taskqueue *taskQueue, struct task *task)
+{
+	return taskqueue_enqueue(taskQueue, task);
+}
+
+
+struct taskqueue *
+taskqueue_create_fast(const char *name, int mflags,
+	taskqueue_enqueue_fn enqueueFunction, void *context)
+{
+	return _taskqueue_create(name, mflags, 1, enqueueFunction, context);
+}
+
+
+void
+task_init(struct task *task, int prio, task_fn_t handler, void *context)
+{
+	task->ta_priority = prio;
+	task->ta_handler = handler;
+	task->ta_argument = context;
+	task->ta_pending = 0;
+}
+
+
+void
+timeout_task_init(struct taskqueue *queue, struct timeout_task *timeout_task,
+	int priority, task_fn_t func, void *context)
+{
+	TASK_INIT(&timeout_task->t, priority, func, context);
+	callout_init_mtx(&timeout_task->c, &queue->tq_mutex,
+		CALLOUT_RETURNUNLOCKED);
+	timeout_task->q = queue;
+	timeout_task->f = 0;
+}
+
+
+status_t
+init_taskqueues()
+{
+	status_t status = B_NO_MEMORY;
+
+	if (HAIKU_DRIVER_REQUIRES(FBSD_FAST_TASKQUEUE)) {
+		taskqueue_fast = taskqueue_create_fast("fast taskq", 0,
+			taskqueue_thread_enqueue, &taskqueue_fast);
+		if (taskqueue_fast == NULL)
+			return B_NO_MEMORY;
+
+		status = taskqueue_start_threads(&taskqueue_fast, 1,
+			B_REAL_TIME_PRIORITY, "fast taskq thread");
+		if (status < B_OK)
+			goto err_1;
+	}
+
+	if (HAIKU_DRIVER_REQUIRES(FBSD_SWI_TASKQUEUE)) {
+		taskqueue_swi = taskqueue_create_fast("swi taskq", 0,
+			taskqueue_thread_enqueue, &taskqueue_swi);
+		if (taskqueue_swi == NULL) {
+			status = B_NO_MEMORY;
+			goto err_1;
+		}
+
+		status = taskqueue_start_threads(&taskqueue_swi, 1,
+			B_REAL_TIME_PRIORITY, "swi taskq");
+		if (status < B_OK)
+			goto err_2;
+	}
+
+	if (HAIKU_DRIVER_REQUIRES(FBSD_THREAD_TASKQUEUE)) {
+		taskqueue_thread = taskqueue_create_fast("thread taskq", 0,
+			taskqueue_thread_enqueue, &taskqueue_thread);
+		if (taskqueue_thread == NULL) {
+			status = B_NO_MEMORY;
+			goto err_2;
+		}
+
+		status = taskqueue_start_threads(&taskqueue_thread, 1,
+			B_REAL_TIME_PRIORITY, "swi taskq");
+		if (status < B_OK)
+			goto err_3;
+	}
+
+	return B_OK;
+
+err_3:
+	if (taskqueue_thread)
+		taskqueue_free(taskqueue_thread);
+
+err_2:
+	if (taskqueue_swi)
+		taskqueue_free(taskqueue_swi);
+
+err_1:
+	if (taskqueue_fast)
+		taskqueue_free(taskqueue_fast);
+
+	return status;
+}
+
+
+void
+uninit_taskqueues()
+{
+	if (HAIKU_DRIVER_REQUIRES(FBSD_THREAD_TASKQUEUE))
+		taskqueue_free(taskqueue_thread);
+
+	if (HAIKU_DRIVER_REQUIRES(FBSD_SWI_TASKQUEUE))
+		taskqueue_free(taskqueue_swi);
+
+	if (HAIKU_DRIVER_REQUIRES(FBSD_FAST_TASKQUEUE))
+		taskqueue_free(taskqueue_fast);
+}
+
+
+void
+taskqueue_block(struct taskqueue *taskQueue)
+{
+	cpu_status status;
+
+	tq_lock(taskQueue, &status);
+	taskQueue->tq_flags |= TQ_FLAGS_BLOCKED;
+	tq_unlock(taskQueue, status);
+}
+
+
+void
+taskqueue_unblock(struct taskqueue *taskQueue)
+{
+	cpu_status status;
+
+	tq_lock(taskQueue, &status);
+	taskQueue->tq_flags &= ~TQ_FLAGS_BLOCKED;
+	if (taskQueue->tq_flags & TQ_FLAGS_PENDING) {
+		taskQueue->tq_flags &= ~TQ_FLAGS_PENDING;
+		taskQueue->tq_enqueue(taskQueue->tq_arg);
+	}
+	tq_unlock(taskQueue, status);
+}
-- 
2.30.2

